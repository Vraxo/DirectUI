<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Alignment.cs">
// Alignment.cs
// Alignment.cs
using DirectUI.Core; // Added using directive

namespace DirectUI;

public enum HAlignment { Left, Center, Right }
public enum VAlignment { Top, Center, Bottom }

public struct Alignment(HAlignment horizontal, VAlignment vertical)
{
    public HAlignment Horizontal { get; set; } = horizontal;
    public VAlignment Vertical { get; set; } = vertical;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\AppEngine.cs">
// AppEngine.cs
using System;
using System.Diagnostics;
using System.Numerics;
using Vortice.Mathematics;
using DirectUI.Core; // For IRenderer, ITextService
using DirectUI.Drawing;
using DirectUI.Diagnostics;
using DirectUI.Input;
using Silk.NET.OpenAL;
using System.Reflection.Emit;
using System.Security.Cryptography;

namespace DirectUI;

/// <summary>
/// Manages the application's core UI engine lifecycle, input state aggregation,
/// and frame timing. It is decoupled from any specific windowing or graphics backend.
/// </summary>
public class AppEngine
{
    private readonly Action<UIContext> _drawCallback;
    private readonly FpsCounter _fpsCounter;
    private readonly InputManager _inputManager;
    private readonly Stopwatch _frameTimer = new();
    private long _lastFrameTicks;
    private readonly UIPersistentState _persistentState;

    public bool ShowFpsCounter { get; set; } = true;
    public InputManager Input => _inputManager;
    public Color4 BackgroundColor { get; }
    public float UIScale { get; set; } = 1.0f;

    public AppEngine(Action<UIContext> drawCallback, Color4 backgroundColor)
    {
        _drawCallback = drawCallback ?? throw new ArgumentNullException(nameof(drawCallback));
        BackgroundColor = backgroundColor;
        _fpsCounter = new FpsCounter();
        _inputManager = new InputManager();
        _persistentState = new UIPersistentState();

        _frameTimer.Start();
        _lastFrameTicks = _frameTimer.ElapsedTicks;
    }

    /// <summary>
    /// Initializes internal components like the FPS counter.
    /// This should be called once after the renderer and text service are ready.
    /// </summary>
    public void Initialize(ITextService textService, IRenderer renderer)
    {
        _fpsCounter.Initialize(textService, renderer);
    }

    /// <summary>
    /// Cleans up internal engine resources.
    /// </summary>
    public void Cleanup()
    {
        _fpsCounter.Cleanup();
    }

    /// <summary>
    /// Updates the engine state for a single frame and renders the UI.
    /// This method is called by the specific window host after it has prepared its drawing surface.
    /// </summary>
    /// <param name="renderer">The graphics renderer for this frame.</param>
    /// <param name="textService">The text service for this frame.</param>
    public void UpdateAndRender(IRenderer renderer, ITextService textService)
    {
        // Prevent re-entrant rendering calls.
        if (UI.IsRendering) return;

        // Calculate delta time for the frame
        long currentTicks = _frameTimer.ElapsedTicks;
        float deltaTime = (float)(currentTicks - _lastFrameTicks) / Stopwatch.Frequency;
        _lastFrameTicks = currentTicks;
        float totalTime = (float)_frameTimer.Elapsed.TotalSeconds;

        // Clamp delta time to avoid huge jumps (e.g., when debugging or window is moved)
        deltaTime = Math.Min(deltaTime, 1.0f / 15.0f); // Clamp to a minimum of 15 FPS

        _fpsCounter.Update(); // Update FPS counter once per render call.

        try
        {
            // Get the immutable, physical input state for this frame from the InputManager.
            // Mouse coordinates are in physical pixels. Hit-testing will be done in physical space.
            var inputState = _inputManager.GetCurrentState();

            var uiContext = new UIContext(renderer, textService, inputState, deltaTime, totalTime, UIScale);
            uiContext.State = _persistentState; // Assign instance-specific state to the context
            UI.BeginFrame(uiContext);

            _drawCallback(uiContext);

            if (ShowFpsCounter)
            {
                _fpsCounter.Draw();
            }

            UI.EndFrame();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred during UI drawing: {ex}");
        }
        finally
        {
            _inputManager.PrepareNextFrame();
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\AppRunner.cs">
using DirectUI.Backends.SDL3;
using DirectUI.Backends.SkiaSharp;
using DirectUI.Core; // Added for IWindowHost
using Raylib_cs;
using SDL3;
using GraphicsBackend = DirectUI.GraphicsBackend;

namespace DirectUI;

public static class ApplicationRunner
{
    private static bool _isSavedOnExit = false;

    public static void Run(GraphicsBackend backend, Func<IWindowHost, IAppLogic> appLogicFactory)
    {
        IWindowHost? host = null;
        IAppLogic? appLogic = null;

        // Load settings at the very beginning of the application run.
        var settings = SettingsManager.LoadSettings();

        // Define a guarded save action to prevent saving more than once on exit.
        Action? saveAction = null;

        try
        {
            host = backend switch
            {
                GraphicsBackend.Raylib => new RaylibWindowHost("My Raylib App", 1024, 768, new Vortice.Mathematics.Color4(45 / 255f, 45 / 255f, 45 / 255f, 1.0f)),
                GraphicsBackend.Direct2D => new Win32WindowHost("My D2D App", 1024, 768),
                GraphicsBackend.SDL3 => new SDL3WindowHost("My SDL3 App", 1024, 768, new Vortice.Mathematics.Color4(45 / 255f, 45 / 255f, 45 / 255f, 1.0f)),
                GraphicsBackend.SkiaSharp => new SilkNetWindowHost("My Skia App", 1024, 768, new Vortice.Mathematics.Color4(45 / 255f, 45 / 255f, 45 / 255f, 1.0f)),
                _ => throw new ArgumentOutOfRangeException(nameof(backend), backend, "Unsupported graphics backend.")
            };

            Console.WriteLine($"Using {backend} Backend.");

            appLogic = appLogicFactory(host);

            // Pass the loaded scale to the host during initialization.
            if (host.Initialize(appLogic.DrawUI, new Vortice.Mathematics.Color4(45 / 255f, 45 / 255f, 45 / 255f, 1.0f), settings.UIScale)) // #2D2D2D
            {
                // --- FIX: Define the save action AFTER the host and its AppEngine are initialized. ---
                saveAction = () =>
                {
                    if (_isSavedOnExit || appLogic is null) return;

                    Console.WriteLine("Exit detected. Saving application state...");
                    appLogic.SaveState();

                    // Save DirectUI settings on exit.
                    if (host?.AppEngine is not null)
                    {
                        settings.UIScale = host.AppEngine.UIScale;
                        SettingsManager.SaveSettings(settings);
                        Console.WriteLine($"Saved UI Scale: {settings.UIScale}");
                    }

                    _isSavedOnExit = true;
                };

                // Hook into the AppDomain.ProcessExit event AFTER initialization.
                AppDomain.CurrentDomain.ProcessExit += (sender, e) =>
                {
                    saveAction?.Invoke();
                };

                host.RunLoop();
            }
            else
            {
                Console.WriteLine($"Failed to initialize {backend} application.");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An unhandled exception occurred: {ex}");
        }
        finally
        {
            // The finally block is executed on a clean shutdown (e.g., closing the GUI window).
            // We call the same guarded save action here.
            saveAction?.Invoke();

            host?.Cleanup();
            host?.Dispose();
        }
    }

    // Removed specific RunRaylib, RunDirect2D, RunSDL3 methods
    // as their logic is now encapsulated within their respective IWindowHost implementations.
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\AppServices.cs">
using DirectUI.Core;

namespace DirectUI;

public sealed class AppServices
{
    public AppEngine AppEngine { get; }
    public DuiGraphicsDevice GraphicsDevice { get; }
    public IRenderer Renderer { get; }
    public ITextService TextService { get; }

    internal AppServices(AppEngine appEngine, DuiGraphicsDevice graphicsDevice, IRenderer renderer, ITextService textService)
    {
        AppEngine = appEngine;
        GraphicsDevice = graphicsDevice;
        Renderer = renderer;
        TextService = textService;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\DirectUISettings.cs">
namespace DirectUI;

/// <summary>
/// A model for storing global DirectUI settings that are persisted to a file.
/// </summary>
public class DirectUISettings
{
    /// <summary>
    /// The global zoom level for the entire user interface.
    /// </summary>
    public float UIScale { get; set; } = 1.0f;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\GlobalUsings.cs">
global using Color = DirectUI.Drawing.Color;
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\GraphicsBackend.cs">
namespace DirectUI;

public enum GraphicsBackend
{
    Direct2D,
    Raylib,
    SDL3,
    SkiaSharp
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\LayoutCalculator.cs">
using System.Numerics;
using DirectUI.Core;

namespace DirectUI;

public class LayoutCalculator
{
    public Vector2 Size => _vbox.GetAccumulatedSize();

    private readonly UIContext _context;
    private readonly VBoxContainerState _vbox;

    public LayoutCalculator(float gap = 0)
    {
        _context = UI.Context;
        _vbox = new VBoxContainerState(0) { Gap = gap };
    }

    public void Add(Vector2 logicalSize)
    {
        _vbox.Advance(logicalSize);
    }

    public void AddWrappedText(string text, float logicalMaxWidth, ButtonStyle? style = null)
    {
        if (string.IsNullOrEmpty(text))
        {
            return;
        }

        ButtonStyle finalStyle = style ?? new();

        ButtonStyle physicalStyle = new(finalStyle) 
        { 
            FontSize = finalStyle.FontSize * _context.UIScale 
        };

        ITextLayout layout = _context.TextService.GetTextLayout(
            text,
            physicalStyle,
            new(logicalMaxWidth * _context.UIScale, float.MaxValue),
            new(HAlignment.Left, VAlignment.Top)
        );

        Vector2 logicalSize = new(logicalMaxWidth, layout.Size.Y / _context.UIScale);
        
        _vbox.Advance(logicalSize);
    }

    public void AddSeparator(float logicalWidth, float thickness = 1f, float verticalPadding = 4f)
    {
        float logicalTotalHeight = thickness + (verticalPadding * 2);
        
        _vbox.Advance(new(logicalWidth, logicalTotalHeight));
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\ModalWindow.cs">
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI;

public class ModalWindow : Win32Window
{
    private readonly Win32Window owner;
    private readonly Action<UIContext> drawCallback;
    private AppServices? appServices;

    public ModalWindow(Win32Window owner, string title, int width, int height, Action<UIContext> drawCallback)
        : base(title, width, height)
    {
        this.owner = owner ?? throw new ArgumentNullException(nameof(owner));
        this.drawCallback = drawCallback ?? throw new ArgumentNullException(nameof(drawCallback));
    }

    protected override bool Initialize()
    {
        Console.WriteLine("ModalWindow initializing...");

        try
        {
            appServices = Win32AppServicesInitializer.Initialize(
                Handle,
                GetClientRectSize(),
                drawCallback,
                new(60 / 255f, 60 / 255f, 60 / 255f, 1.0f));

            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to initialize modal window services: {ex.Message}");
            return false;
        }
    }

    protected override void Cleanup()
    {
        Console.WriteLine("ModalWindow cleaning up its resources...");
        appServices?.AppEngine.Cleanup();
        appServices?.TextService.Cleanup();
        (appServices?.Renderer as Backends.Direct2DRenderer)?.Cleanup();
        appServices?.GraphicsDevice.Cleanup();

        appServices = null;
    }

    protected override void OnPaint()
    {
        if (appServices is null || !appServices.GraphicsDevice.IsInitialized)
        {
            Console.WriteLine("Modal window render services not initialized. Skipping paint.");
            return;
        }

        appServices.GraphicsDevice.BeginDraw();

        try
        {
            if (appServices.AppEngine is not null && appServices.GraphicsDevice.RenderTarget is not null)
            {
                appServices.GraphicsDevice.RenderTarget.Clear(appServices.AppEngine.BackgroundColor);
            }

            appServices?.AppEngine?.UpdateAndRender(appServices.Renderer, appServices.TextService);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred during modal window drawing: {ex}");
            appServices.GraphicsDevice.Cleanup();
        }
        finally
        {
            appServices.GraphicsDevice.EndDraw();
        }
    }

    public override void FrameUpdate()
    {
        Invalidate();
    }

    protected override void OnSize(int width, int height)
    {
        appServices?.GraphicsDevice.Resize(new SizeI(width, height));
    }

    protected override void OnMouseMove(int x, int y)
    {
        appServices?.AppEngine.Input.SetMousePosition(x, y);
        Invalidate();
    }

    protected override void OnMouseDown(MouseButton button, int x, int y)
    {
        appServices?.AppEngine.Input.SetMousePosition(x, y);
        appServices?.AppEngine.Input.SetMouseDown(button);
        Invalidate();
    }

    protected override void OnMouseUp(MouseButton button, int x, int y)
    {
        appServices?.AppEngine.Input.SetMousePosition(x, y);
        appServices?.AppEngine.Input.SetMouseUp(button);
        Invalidate();
    }

    protected override void OnMouseWheel(float delta)
    {
        appServices?.AppEngine.Input.AddMouseWheelDelta(delta);
        Invalidate();
    }

    protected override void OnKeyDown(Keys key)
    {
        appServices?.AppEngine.Input.AddKeyPressed(key);

        if (key == Keys.Escape)
        {
            Close();
        }

        Invalidate();
    }

    protected override void OnKeyUp(Keys key)
    {
        appServices?.AppEngine.Input.AddKeyReleased(key);
        Invalidate();
    }

    protected override void OnChar(char c)
    {
        appServices?.AppEngine.Input.AddCharacterInput(c);
        Invalidate();
    }

    protected override bool OnClose()
    {
        return true;
    }

    public bool CreateAsModal()
    {
        if (Handle != IntPtr.Zero)
        {
            return true;
        }

        uint style =
            NativeMethods.WS_POPUP |
            NativeMethods.WS_CAPTION |
            NativeMethods.WS_SYSMENU |
            NativeMethods.WS_VISIBLE |
            NativeMethods.WS_THICKFRAME;

        int? x = null;
        int? y = null;

        if (owner.Handle != IntPtr.Zero && owner.GetWindowRect(out NativeMethods.RECT ownerRect))
        {
            int ownerWidth = ownerRect.right - ownerRect.left;
            int ownerHeight = ownerRect.bottom - ownerRect.top;
            int modalWidth = Width;
            int modalHeight = Height;

            x = ownerRect.left + (ownerWidth - modalWidth) / 2;
            y = ownerRect.top + (ownerHeight - modalHeight) / 2;
        }

        if (!Create(owner.Handle, style, x, y))
        {
            return false;
        }

        if (Handle == IntPtr.Zero)
        {
            return false;
        }

        NativeMethods.EnableWindow(owner.Handle, false);

        return true;
    }

    protected override void OnDestroy()
    {
        // Explicitly notify the owner that the modal has closed.
        // This is a more robust pattern than the owner polling the handle.
        if (owner is Win32WindowHost host)
        {
            host.NotifyModalHasClosed();
        }

        if (owner.Handle != IntPtr.Zero)
        {
            NativeMethods.EnableWindow(owner.Handle, true);
        }

        base.OnDestroy();
    }

    protected SizeI GetClientRectSize()
    {
        if (Handle != nint.Zero && NativeMethods.GetClientRect(Handle, out NativeMethods.RECT r))
        {
            int width = int.Max(1, r.right - r.left);
            int height = int.Max(1, r.bottom - r.top);
            return new(width, height);
        }

        int baseWidth = int.Max(1, Width);
        int baseHeight = int.Max(1, Height);

        if (Handle != nint.Zero)
        {
            Console.WriteLine($"GetClientRect failed. Falling back to stored size: {baseWidth}x{baseHeight}");
        }

        return new(baseWidth, baseHeight);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\MouseButton.cs">
namespace DirectUI;

public enum MouseButton
{
    Left,
    Right,
    Middle,
    XButton1,
    XButton2
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\NativeMethods.cs">
// NativeMethods.cs
using System;
using System.Runtime.InteropServices;

// No changes needed here if it was correct from the previous step.
// Ensure these constants are defined:
// WM_NCCREATE, WM_CREATE, WM_NCDESTROY, WM_PAINT, WM_DESTROY, WM_SIZE,
// WM_CLOSE, WM_KEYDOWN, WM_LBUTTONDOWN, WM_LBUTTONUP, WM_MOUSEMOVE, WM_QUIT
// GWLP_USERDATA, VK_ESCAPE, etc.
// And the structs: WNDCLASSEX, MSG, POINT, RECT, CREATESTRUCT
// And the functions: RegisterClassEx, CreateWindowEx, GetMessage, etc.
// And the delegates: WndProc

namespace DirectUI;

public static class NativeMethods
{
    // --- Constants ---
    public const uint CS_HREDRAW = 0x0002;
    public const uint CS_VREDRAW = 0x0001;
    public const uint CS_OWNDC = 0x0020;

    public const uint WS_OVERLAPPED = 0x00000000;
    public const uint WS_CAPTION = 0x00C00000;
    public const uint WS_SYSMENU = 0x00080000;
    public const uint WS_THICKFRAME = 0x00040000;
    public const uint WS_MINIMIZEBOX = 0x00020000;
    public const uint WS_MAXIMIZEBOX = 0x00010000;
    public const uint WS_OVERLAPPEDWINDOW = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
    public const uint WS_VISIBLE = 0x10000000;
    public const uint WS_POPUP = 0x80000000;

    public const int WM_NCCREATE = 0x0081;
    public const int WM_CREATE = 0x0001;
    public const int WM_NCDESTROY = 0x0082;
    public const int WM_PAINT = 0x000F;
    public const int WM_DESTROY = 0x0002;
    public const int WM_SIZE = 0x0005;
    public const int WM_CLOSE = 0x0010;
    public const int WM_KEYDOWN = 0x0100;
    public const int WM_KEYUP = 0x0101;
    public const int WM_SYSKEYUP = 0x0105;
    public const int WM_LBUTTONDOWN = 0x0201;
    public const int WM_LBUTTONUP = 0x0202; // Ensure this exists
    public const int WM_RBUTTONDOWN = 0x0204;
    public const int WM_RBUTTONUP = 0x0205;
    public const int WM_MBUTTONDOWN = 0x0207;
    public const int WM_MBUTTONUP = 0x0208;
    public const int WM_XBUTTONDOWN = 0x020B;
    public const int WM_XBUTTONUP = 0x020C;
    public const int WM_MOUSEMOVE = 0x0200; // Ensure this exists
    public const int WM_MOUSEWHEEL = 0x020A;
    public const int WM_QUIT = 0x0012;
    public const int WM_CHAR = 0x0102;


    public const int CW_USEDEFAULT = unchecked((int)0x80000000);
    public const int SW_SHOWNORMAL = 1;
    public const int GWLP_USERDATA = -21;

    public const uint PM_REMOVE = 0x0001;

    // --- Structures ---
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
    public struct WNDCLASSEX
    { /* ... as before ... */
        public int cbSize;
        public uint style;
        public WndProc lpfnWndProc; // Use delegate type directly
        public int cbClsExtra;
        public int cbWndExtra;
        public IntPtr hInstance;
        public IntPtr hIcon;
        public IntPtr hCursor;
        public IntPtr hbrBackground;
        public string lpszMenuName;
        public string lpszClassName;
        public IntPtr hIconSm;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct MSG
    { /* ... as before ... */
        public IntPtr hwnd;
        public uint message;
        public IntPtr wParam;
        public IntPtr lParam;
        public uint time;
        public POINT pt;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct POINT
    { /* ... as before ... */
        public int X;
        public int Y;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct RECT
    { /* ... as before ... */
        public int left;
        public int top;
        public int right;
        public int bottom;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct CREATESTRUCT
    { /* ... as before ... */
        public IntPtr lpCreateParams;
        public IntPtr hInstance;
        public IntPtr hMenu;
        public IntPtr hwndParent;
        public int cy; // Height
        public int cx; // Width
        public int y;  // Top
        public int x;  // Left
        public int style;
        [MarshalAs(UnmanagedType.LPWStr)] // Assuming Unicode
        public string lpszName;
        [MarshalAs(UnmanagedType.LPWStr)] // Assuming Unicode
        public string lpszClass;
        public int dwExStyle;
    }

    // --- Delegates ---
    public delegate IntPtr WndProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam);

    // --- Functions ---
    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern ushort RegisterClassEx([In] ref WNDCLASSEX lpwcx);
    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern IntPtr CreateWindowEx(uint dwExStyle, string lpClassName, string lpWindowName, uint dwStyle, int x, int y, int nWidth, int nHeight, IntPtr hWndParent, IntPtr hMenu, IntPtr hInstance, IntPtr lpParam);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool UpdateWindow(IntPtr hWnd);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool DestroyWindow(IntPtr hWnd);
    [DllImport("user32.dll")]
    public static extern IntPtr DefWindowProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam);
    [DllImport("user32.dll")]
    public static extern void PostQuitMessage(int nExitCode);
    [DllImport("user32.dll")]
    public static extern bool GetMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax);
    [DllImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool PeekMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax, uint wRemoveMsg);
    [DllImport("user32.dll")]
    public static extern bool TranslateMessage([In] ref MSG lpMsg);
    [DllImport("user32.dll")]
    public static extern IntPtr DispatchMessage([In] ref MSG lpmsg);
    [DllImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)] // Add return type annotation
    public static extern bool PostMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam); // Added
    [DllImport("user32.dll")]
    public static extern bool GetClientRect(IntPtr hWnd, out RECT lpRect);
    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern IntPtr GetModuleHandle(string lpModuleName);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool InvalidateRect(IntPtr hWnd, IntPtr lpRect, bool bErase);
    [DllImport("user32.dll")]
    public static extern IntPtr LoadCursor(IntPtr hInstance, int lpCursorName);
    [DllImport("user32.dll")]
    public static extern IntPtr LoadIcon(IntPtr hInstance, IntPtr lpIconName);
    [DllImport("user32.dll", EntryPoint = "SetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr SetWindowLongPtr64(IntPtr hWnd, int nIndex, IntPtr dwNewLong);
    [DllImport("user32.dll", EntryPoint = "SetWindowLongW", SetLastError = true)]
    private static extern IntPtr SetWindowLong32(IntPtr hWnd, int nIndex, IntPtr dwNewLong);
    [DllImport("user32.dll", EntryPoint = "GetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr GetWindowLongPtr64(IntPtr hWnd, int nIndex);
    [DllImport("user32.dll", EntryPoint = "GetWindowLongW", SetLastError = true)]
    private static extern IntPtr GetWindowLong32(IntPtr hWnd, int nIndex);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr SetCapture(IntPtr hWnd);
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool ReleaseCapture();
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool EnableWindow(IntPtr hWnd, bool bEnable);
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool GetWindowRect(IntPtr hwnd, out RECT lpRect);


    public static IntPtr SetWindowLongPtr(IntPtr hWnd, int nIndex, IntPtr dwNewLong)
    {
        if (IntPtr.Size == 8) return SetWindowLongPtr64(hWnd, nIndex, dwNewLong);
        else return SetWindowLong32(hWnd, nIndex, dwNewLong);
    }
    public static IntPtr GetWindowLongPtr(IntPtr hWnd, int nIndex)
    {
        if (IntPtr.Size == 8) return GetWindowLongPtr64(hWnd, nIndex);
        else return GetWindowLong32(hWnd, nIndex);
    }

    // --- Helpers ---
    public static short LoWord(IntPtr val) => unchecked((short)(long)val);
    public static short HiWord(IntPtr val) => unchecked((short)((long)val >> 16));
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\SettingsManager.cs">
using System;
using System.IO;
using System.Text.Json;

namespace DirectUI;

/// <summary>
/// Manages loading and saving of global DirectUI settings.
/// </summary>
internal static class SettingsManager
{
    private static readonly string SettingsDirectory = Path.Combine(AppContext.BaseDirectory, "Data");
    private static readonly string SettingsFilePath = Path.Combine(SettingsDirectory, "settings.json");

    private static readonly JsonSerializerOptions SerializerOptions = new()
    {
        WriteIndented = true,
        PropertyNameCaseInsensitive = true
    };

    /// <summary>
    /// Saves the provided settings object to the default settings file.
    /// </summary>
    public static void SaveSettings(DirectUISettings settings)
    {
        try
        {
            Directory.CreateDirectory(SettingsDirectory);
            string json = JsonSerializer.Serialize(settings, SerializerOptions);
            File.WriteAllText(SettingsFilePath, json);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[DirectUI] Error saving settings to {SettingsFilePath}: {ex.Message}");
        }
    }

    /// <summary>
    /// Loads the settings object from the default settings file.
    /// If the file doesn't exist or fails to load, returns a new instance with default values.
    /// </summary>
    public static DirectUISettings LoadSettings()
    {
        if (!File.Exists(SettingsFilePath))
        {
            return new DirectUISettings(); // Return default settings
        }

        try
        {
            string json = File.ReadAllText(SettingsFilePath);
            return JsonSerializer.Deserialize<DirectUISettings>(json, SerializerOptions) ?? new DirectUISettings();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[DirectUI] Error loading settings from {SettingsFilePath}. Using defaults. Error: {ex.Message}");
            return new DirectUISettings(); // Return default settings on error
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\SharedGraphicsResources.cs">
// SharedGraphicsResources.cs
using System;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using SharpGen.Runtime;
using D2D = Vortice.Direct2D1;
using DW = Vortice.DirectWrite;

namespace DirectUI;

/// <summary>
/// Manages graphics resources that are shared across the entire application,
/// such as the main Direct2D and DirectWrite factories.
/// </summary>
internal static class SharedGraphicsResources
{
    public static ID2D1Factory1? D2DFactory { get; private set; }
    public static IDWriteFactory? DWriteFactory { get; private set; }

    private static bool s_isInitialized = false;

    /// <summary>
    /// Initializes the shared factories. Should be called once at application startup.
    /// </summary>
    public static void Initialize()
    {
        if (s_isInitialized) return;

        try
        {
            Result factoryResult = D2D1.D2D1CreateFactory(D2D.FactoryType.SingleThreaded, out ID2D1Factory1? d2dFactory);
            factoryResult.CheckError();
            D2DFactory = d2dFactory ?? throw new InvalidOperationException("Shared D2D Factory creation failed silently.");

            Result dwriteResult = DW.DWrite.DWriteCreateFactory(DW.FactoryType.Shared, out IDWriteFactory? dwriteFactory);
            dwriteResult.CheckError();
            DWriteFactory = dwriteFactory ?? throw new InvalidOperationException("Shared DWrite Factory creation failed silently.");

            Console.WriteLine("Shared Graphics Factories Initialized.");
            s_isInitialized = true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"FATAL: Could not initialize shared graphics resources: {ex.Message}");
            Cleanup();
            throw;
        }
    }

    /// <summary>
    /// Disposes of the shared factories. Should be called once when the application is closing.
    /// </summary>
    public static void Cleanup()
    {
        if (!s_isInitialized) return;
        Console.WriteLine("Cleaning up shared graphics factories...");
        DWriteFactory?.Dispose();
        DWriteFactory = null;
        D2DFactory?.Dispose();
        D2DFactory = null;
        s_isInitialized = false;
        Console.WriteLine("Shared graphics factories cleaned up.");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Containers\ComboboxState.cs">
namespace DirectUI;

internal class ComboboxState
{
    public bool IsOpen;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Containers\DataGridState.cs">
// DirectUI/Source/Containers/DataGridState.cs
using System.Collections.Generic;
using System.Numerics;

namespace DirectUI;

internal class DataGridState
{
    public int Id { get; set; }
    public List<float> ColumnWidths { get; set; } = new();
    public Vector2 ScrollOffset { get; set; } = Vector2.Zero;
    public int ResizingColumnIndex { get; set; } = -1;

    // New properties for sorting
    public int SortColumnIndex { get; set; } = -1;
    public bool SortAscending { get; set; } = true;

    // State for column resizing drag operation
    public float ColumnResizeStartWidth { get; set; }
    public float DragStartMouseX { get; set; }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Containers\GridContainerState.cs">
using System.Numerics;

namespace DirectUI;

public class GridContainerState : ILayoutContainer
{
    internal int Id { get; }
    public Vector2 StartPosition { get; } // Top-left corner of the grid area
    internal int NumColumns { get; }
    public Vector2 Gap { get; } // Gap between cells (X and Y)
    public Vector2 AvailableSize { get; } // Total area the grid can occupy

    // Calculated layout values
    public float CellWidth { get; }
    internal List<float> RowHeights { get; } = new(); // Store height of each completed row
    internal float CurrentRowMaxHeight { get; set; } = 0f; // Track max height of elements in the current row being built
    internal int CurrentCellIndex { get; set; } = 0; // 0-based index of the next cell to place an element in
    internal Vector2 CurrentDrawPosition { get; set; } // Calculated top-left for the next element

    // Tracking overall bounds occupied by elements
    internal float AccumulatedWidth { get; set; } = 0f;
    internal float AccumulatedHeight { get; set; } = 0f;


    public GridContainerState(int id, Vector2 startPosition, Vector2 availableSize, int numColumns, Vector2 gap)
    {
        Id = id;
        StartPosition = startPosition;
        AvailableSize = availableSize;
        NumColumns = Math.Max(1, numColumns); // Ensure at least one column
        Gap = gap;

        // Calculate fixed cell width based on available space and gaps
        float totalHorizontalGap = Math.Max(0, NumColumns - 1) * Gap.X;
        float widthForCells = AvailableSize.X - totalHorizontalGap;
        CellWidth = (NumColumns > 0) ? Math.Max(0, widthForCells / NumColumns) : 0;

        // Initial position is the start position
        CurrentDrawPosition = startPosition;
        RowHeights.Add(0); // Add initial height for the first row (will be updated)
    }

    internal void MoveToNextCell(Vector2 elementSize)
    {
        // Update max height for the current row
        CurrentRowMaxHeight = Math.Max(CurrentRowMaxHeight, elementSize.Y);

        // Update total occupied width (conservative estimate using cell width)
        int currentCol = CurrentCellIndex % NumColumns;
        float currentWidth = (currentCol + 1) * CellWidth + currentCol * Gap.X;
        AccumulatedWidth = Math.Max(AccumulatedWidth, currentWidth);


        CurrentCellIndex++;
        int nextCol = CurrentCellIndex % NumColumns;

        if (nextCol == 0) // Moved to the start of a new row
        {
            // Finalize the height of the completed row
            RowHeights[^1] = CurrentRowMaxHeight; // Update last row's height
            AccumulatedHeight += CurrentRowMaxHeight + (RowHeights.Count > 1 ? Gap.Y : 0); // Add height and gap (if not first row)

            // Reset for the new row
            CurrentRowMaxHeight = 0f;
            RowHeights.Add(0); // Add placeholder height for the new row

            // Calculate Y position for the new row
            float newY = StartPosition.Y;
            for (int i = 0; i < RowHeights.Count - 1; i++) // Sum heights and gaps of completed rows
            {
                newY += RowHeights[i] + Gap.Y;
            }

            // Set position for the first cell of the new row
            CurrentDrawPosition = new Vector2(StartPosition.X, newY);

        }
        else // Moving to the next column in the same row
        {
            // Calculate X position for the next cell
            float currentX = StartPosition.X + nextCol * (CellWidth + Gap.X);
            CurrentDrawPosition = new Vector2(currentX, CurrentDrawPosition.Y); // Y stays the same
        }
    }

    internal Vector2 GetTotalOccupiedSize()
    {
        // Calculate final height including the current row being built
        float finalHeight = AccumulatedHeight + CurrentRowMaxHeight;
        return new Vector2(AccumulatedWidth, finalHeight);
    }

    public Vector2 GetCurrentPosition() => CurrentDrawPosition;

    public void Advance(Vector2 elementSize) => MoveToNextCell(elementSize);
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Containers\HBoxContainerState.cs">
using System.Numerics;

namespace DirectUI;

public class HBoxContainerState : ILayoutContainer
{
    internal int Id { get; }
    internal Vector2 StartPosition { get; set; }
    internal Vector2 CurrentPosition { get; set; }
    internal float Gap { get; set; }
    internal float MaxElementHeight { get; set; } = 0f;
    internal float AccumulatedWidth { get; set; } = 0f;
    internal int ElementCount { get; set; } = 0;
    internal VAlignment VerticalAlignment { get; set; } = VAlignment.Top;
    internal float? FixedRowHeight { get; set; }

    internal HBoxContainerState(int id)
    {
        Id = id;
    }

    public Vector2 GetCurrentPosition() => CurrentPosition;

    public void Advance(Vector2 elementSize)
    {
        if (elementSize.Y > MaxElementHeight)
        {
            MaxElementHeight = elementSize.Y;
        }

        AccumulatedWidth += elementSize.X;
        if (ElementCount > 0)
        {
            AccumulatedWidth += Gap;
        }
        float advanceX = elementSize.X + Gap;
        CurrentPosition = new Vector2(CurrentPosition.X + advanceX, CurrentPosition.Y);
        ElementCount++;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Containers\ResizableHPanelState.cs">
using System.Numerics;

namespace DirectUI;

internal class ResizableHPanelState : ILayoutContainer
{
    internal int Id { get; }
    internal HBoxContainerState InnerHBox { get; }
    internal bool ClipRectWasPushed { get; }

    internal ResizableHPanelState(int id, HBoxContainerState innerHBox, bool clipPushed)
    {
        Id = id;
        InnerHBox = innerHBox;
        ClipRectWasPushed = clipPushed;
    }

    public Vector2 GetCurrentPosition() => InnerHBox.GetCurrentPosition();

    public void Advance(Vector2 elementSize) => InnerHBox.Advance(elementSize);
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Containers\ResizablePanelState.cs">
using System.Numerics;

namespace DirectUI;

internal class ResizablePanelState : ILayoutContainer
{
    internal int Id { get; }
    internal VBoxContainerState InnerVBox { get; }
    internal bool ClipRectWasPushed { get; }

    internal ResizablePanelState(int id, VBoxContainerState innerVBox, bool clipPushed)
    {
        Id = id;
        InnerVBox = innerVBox;
        ClipRectWasPushed = clipPushed;
    }

    public Vector2 GetCurrentPosition() => InnerVBox.GetCurrentPosition();

    public void Advance(Vector2 elementSize) => InnerVBox.Advance(elementSize);
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Containers\ScrollAreaState.cs">
using System.Numerics;

namespace DirectUI;

/// <summary>
/// A state object for the 2D ScrollArea container.
/// </summary>
public class ScrollAreaState : ILayoutContainer
{
    // --- State managed by the UI system ---
    internal Vector2 CurrentScrollOffset { get; set; } // Stored in logical units

    // --- Per-frame calculated/cached values ---
    internal int Id { get; set; }
    internal Vector2 Position { get; set; }      // Top-left of the entire control (logical)
    internal Vector2 VisibleSize { get; set; }   // The size of the viewport (logical)
    internal Vector2 ContentSize { get; set; }     // The full content size from the *previous* frame (logical)
    internal bool IsHovered { get; set; }

    // --- State for the current frame's layout pass ---
    internal Vector2 CalculatedContentSize { get; set; } // The content size measured *this* frame (logical)
    private Vector2 ContentStartPosition { get; set; }   // The top-left where content should begin drawing (logical)

    public ScrollAreaState() { }

    // This is called by the UILayoutManager to get the starting position for child elements.
    public Vector2 GetCurrentPosition() => ContentStartPosition;

    // This is called by a child container (like HBox) when it finishes laying out its elements.
    // The 'elementSize' is the total size of that child container.
    public void Advance(Vector2 elementSize)
    {
        // A scroll area should ideally only have one direct child container.
        // We take the max in case of weird usage, but it's the size of that single child.
        CalculatedContentSize = Vector2.Max(CalculatedContentSize, elementSize);
    }

    // Internal method for BeginScrollArea to set up the content's drawing position.
    internal void SetContentStartPosition(Vector2 position)
    {
        ContentStartPosition = position;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Containers\ScrollContainerState.cs">
using System.Numerics;

namespace DirectUI;

public class ScrollContainerState : ILayoutContainer
{
    // State managed by the UI system
    internal Vector2 CurrentScrollOffset { get; set; }

    // Per-frame calculated values
    internal int Id { get; set; }
    internal Vector2 Position { get; set; }
    internal Vector2 VisibleSize { get; set; }
    internal Vector2 ContentSize { get; set; }
    internal bool IsHovered { get; set; }
    internal VBoxContainerState ContentVBox { get; set; } = null!;

    // Public parameterless constructor required for GetOrCreateElement
    public ScrollContainerState() { }

    public Vector2 GetCurrentPosition() => ContentVBox.GetCurrentPosition();

    public void Advance(Vector2 elementSize) => ContentVBox.Advance(elementSize);
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Containers\TreeViewState.cs">
namespace DirectUI;

internal class TreeViewState
{
    internal int Id { get; }
    internal TreeStyle Style { get; }
    internal Stack<bool> IndentLineState { get; } = new();

    internal TreeViewState(int id, TreeStyle style)
    {
        Id = id;
        Style = style;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Containers\VBoxContainerState.cs">
using System.Numerics;

namespace DirectUI;

public class VBoxContainerState : ILayoutContainer
{
    internal int Id { get; }
    internal Vector2 StartPosition { get; set; }
    internal Vector2 CurrentPosition { get; set; } // Top-left for the next element
    internal float Gap { get; set; }
    internal float MaxElementWidth { get; set; } = 0f; // Track width for container bounds
    internal float AccumulatedHeight { get; set; } = 0f; // Track height for container bounds
    internal int ElementCount { get; set; } = 0;
    internal Vector2 MinSize { get; set; } = Vector2.Zero;

    internal VBoxContainerState(int id)
    {
        Id = id;
    }

    public Vector2 GetCurrentPosition() => CurrentPosition;

    public void Advance(Vector2 elementSize)
    {
        if (elementSize.X > MaxElementWidth)
        {
            MaxElementWidth = elementSize.X;
        }

        AccumulatedHeight += elementSize.Y;
        if (ElementCount > 0)
        {
            AccumulatedHeight += Gap;
        }
        float advanceY = elementSize.Y + Gap;
        CurrentPosition = new Vector2(CurrentPosition.X, CurrentPosition.Y + advanceY);
        ElementCount++;
    }

    public Vector2 GetAccumulatedSize() => new(Math.Max(MinSize.X, MaxElementWidth), Math.Max(MinSize.Y, AccumulatedHeight));
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\ClickCaptureRequest.cs">
namespace DirectUI;

public readonly struct ClickCaptureRequest
{
    public int Id { get; }
    public int Layer { get; }

    public ClickCaptureRequest(int id, int layer)
    {
        Id = id;
        Layer = layer;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\ClickCaptureServer.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using Raylib_cs;
using Silk.NET.Input;
using System.Text.RegularExpressions;

namespace DirectUI;

public class ClickCaptureServer
{
    private readonly List<ClickCaptureRequest> _requests = new();

    public void RequestCapture(int id, int layer)
    {
        _requests.Add(new ClickCaptureRequest(id, layer));
        Console.WriteLine($"[CAPTURE-REQUEST] ID: {id}, Layer: {layer}");
    }

    public int? GetWinner()
    {
        if (_requests.Count == 0)
        {
            return null;
        }

        var winner = _requests.OrderByDescending(r => r.Layer).First();

        // Always log the resolution process if there was at least one candidate.
        var candidates = string.Join(", ", _requests.Select(r => $"[ID: {r.Id}, L: {r.Layer}]"));
        Console.WriteLine($"[CAPTURE-RESOLVED] Candidates: {candidates} -> Winner: ID {winner.Id} (Layer {winner.Layer})");

        return winner.Id;
    }

    public void Clear()
    {
        _requests.Clear();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\TextMetrics.cs">
// DirectUI/Core/TextMetrics.cs
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI.Core;

/// <summary>
/// Describes the metrics of a character position within a text layout.
/// This is a backend-agnostic struct.
/// </summary>
public readonly record struct TextHitTestMetrics(
    /// <summary>
    /// The top-left corner of the character position, relative to the layout's origin.
    /// </summary>
    Vector2 Point,

    /// <summary>
    /// The measured size of the character position.
    /// </summary>
    Vector2 Size
);

/// <summary>
/// The result of a point-based hit-test on a text layout.
/// This is a backend-agnostic struct.
/// </summary>
public readonly record struct TextHitTestResult(
    /// <summary>
    /// The character position that was hit.
    /// </summary>
    int TextPosition,

    /// <summary>
    /// A value indicating whether the hit occurred on the leading or trailing edge of the character.
    /// </summary>
    bool IsTrailingHit,

    /// <summary>
    /// A value indicating whether the hit occurred inside the text string.
    /// </summary>
    bool IsInside,

    /// <summary>
    /// The detailed metrics of the hit character position.
    /// </summary>
    TextHitTestMetrics Metrics
);
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.Button.cs">
using System.Numerics;
using DirectUI.Animation;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1; // Still used for AntialiasMode enum

namespace DirectUI;

public static partial class UI
{
    public static bool Button(
        string id,
        string text,
        Vector2 size = default,
        ButtonStylePack? theme = null,
        bool disabled = false,
        bool autoWidth = false,
        Vector2? textMargin = null,
        Button.ActionMode clickMode = DirectUI.Button.ActionMode.Release,
        Button.ClickBehavior clickBehavior = DirectUI.Button.ClickBehavior.Left,
        Alignment? textAlignment = null,
        Vector2? textOffset = null,
        Vector2? origin = null, // This parameter is now unused but kept for compatibility to avoid breaking changes elsewhere. It will be removed in the future.
        object? userData = null,
        bool isActive = false,
        int layer = 1,
        AnimationInfo? animation = null)
    {
        if (!IsContextValid()) return false;
        var scale = Context.UIScale;

        int intId = id.GetHashCode();
        var finalTheme = theme ?? State.GetOrCreateElement<ButtonStylePack>(HashCode.Combine(intId, "theme"));
        State.SetUserData(intId, userData);

        Vector2 logicalSize = size == default ? new Vector2(84, 28) : size;

        // Auto-width calculation must happen before culling.
        if (autoWidth)
        {
            var styleForMeasuring = new ButtonStyle(finalTheme.Normal) { FontSize = finalTheme.Normal.FontSize * scale };
            Vector2 measuredSize = Context.TextService.MeasureText(text, styleForMeasuring) / scale; // Unscale to logical
            Vector2 margin = textMargin ?? new Vector2(10, 5);
            logicalSize.X = measuredSize.X + margin.X * 2;
        }

        Vector2 finalSize = logicalSize * scale;
        Vector2 drawPos = Context.Layout.ApplyLayout(origin ?? Vector2.Zero);


        // New: Automatically adjust vertical position for HBox alignment
        if (Context.Layout.IsInLayoutContainer() && Context.Layout.PeekContainer() is HBoxContainerState hbox)
        {
            if (hbox.VerticalAlignment != VAlignment.Top && hbox.FixedRowHeight.HasValue)
            {
                float yOffset = 0;
                switch (hbox.VerticalAlignment)
                {
                    case VAlignment.Center:
                        yOffset = (hbox.FixedRowHeight.Value - logicalSize.Y) / 2f;
                        break;
                    case VAlignment.Bottom:
                        yOffset = hbox.FixedRowHeight.Value - logicalSize.Y;
                        break;
                }
                drawPos.Y += yOffset * scale;
            }
        }

        Rect widgetBounds = new Rect(drawPos.X, drawPos.Y, finalSize.X, finalSize.Y);

        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(logicalSize);
            return false;
        }

        bool pushedClip = false;
        if (Context.Layout.IsInLayoutContainer() && Context.Layout.PeekContainer() is GridContainerState grid)
        {
            float clipStartY = grid.CurrentDrawPosition.Y;
            float gridBottomY = grid.StartPosition.Y + grid.AvailableSize.Y;
            float clipHeight = Math.Max(0f, gridBottomY - clipStartY);
            Rect cellClipRect = new Rect(grid.CurrentDrawPosition.X, clipStartY, Math.Max(0f, grid.CellWidth), clipHeight);
            if (cellClipRect.Width > 0 && cellClipRect.Height > 0)
            {
                Context.Renderer.PushClipRect(cellClipRect, D2D.AntialiasMode.Aliased);
                pushedClip = true;
            }
        }

        ClickResult clickResult = DrawButtonPrimitive(
            intId,
            widgetBounds,
            text,
            finalTheme,
            disabled,
            textAlignment ?? new Alignment(HAlignment.Center, VAlignment.Center),
            clickMode,
            clickBehavior,
            (textOffset ?? Vector2.Zero) * scale,
            isActive: isActive,
            layer: layer,
            animation: animation
        );

        if (pushedClip)
        {
            Context.Renderer.PopClipRect();
        }

        Context.Layout.AdvanceLayout(logicalSize);
        return clickResult != ClickResult.None;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.Checkbox.cs">
using System.Numerics;
using Vortice.Mathematics;
using Vortice.Direct2D1; // Still needed for AntialiasMode enum

namespace DirectUI;

public static partial class UI
{
    public static bool Checkbox(string id, string label, ref bool isChecked, bool disabled = false, Vector2? size = null)
    {
        if (!IsContextValid()) return false;

        int intId = id.GetHashCode();

        // --- Style and Sizing (UE5 Theme Adjustments) ---
        var boxSize = new Vector2(16, 16);
        var spacing = 5f;
        // Checkmark is now pure white.
        var checkmarkColor = DirectUI.Drawing.Colors.White;
        // Background is a specific dark grey.
        var normalFillColor = new Color4(43 / 255f, 45 / 255f, 47 / 255f, 1.0f); // #2B2D2F
        var textColor = disabled ? DefaultTheme.DisabledText : DefaultTheme.Text;
        var textStyle = new ButtonStyle { FontColor = textColor }; // Use ButtonStyle for font properties.

        var labelSize = string.IsNullOrEmpty(label) ? Vector2.Zero : Context.TextService.MeasureText(label, textStyle);

        var contentWidth = boxSize.X + (labelSize.X > 0 ? spacing + labelSize.X : 0);
        var contentHeight = Math.Max(boxSize.Y, labelSize.Y);

        var finalWidgetHeight = size?.Y > 0 ? size.Value.Y : contentHeight;
        var finalWidgetWidth = size?.X > 0 ? size.Value.X : contentWidth;
        var totalSize = new Vector2(finalWidgetWidth, finalWidgetHeight);

        var drawPos = Context.Layout.GetCurrentPosition();

        // New: Automatically adjust vertical position for HBox alignment
        if (Context.Layout.IsInLayoutContainer() && Context.Layout.PeekContainer() is HBoxContainerState hbox)
        {
            if (hbox.VerticalAlignment != VAlignment.Top && hbox.FixedRowHeight.HasValue)
            {
                float yOffset = 0;
                switch (hbox.VerticalAlignment)
                {
                    case VAlignment.Center:
                        yOffset = (hbox.FixedRowHeight.Value - totalSize.Y) / 2f;
                        break;
                    case VAlignment.Bottom:
                        yOffset = hbox.FixedRowHeight.Value - totalSize.Y;
                        break;
                }
                drawPos.Y += yOffset;
            }
        }

        var widgetBounds = new Rect(drawPos.X, drawPos.Y, totalSize.X, totalSize.Y);

        // --- Culling ---
        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(totalSize);
            return false;
        }

        // --- Interaction ---
        bool clicked = false;
        var input = Context.InputState;
        bool isHovering = !disabled && widgetBounds.Contains(input.MousePosition);

        if (isHovering)
        {
            State.SetPotentialInputTarget(intId);
        }

        if (!disabled && isHovering && input.WasLeftMousePressedThisFrame && State.PotentialInputTargetId == intId)
        {
            clicked = true;
            isChecked = !isChecked;
            State.SetFocus(intId);
        }

        // --- Drawing ---
        var renderer = Context.Renderer;
        // This calculation centers the box inside the widget's total height.
        // The small vertical adjustment has been removed to allow for proper alignment within parent containers.
        float boxY = drawPos.Y + (totalSize.Y - boxSize.Y) / 2;
        var boxRect = new Rect(drawPos.X, boxY, boxSize.X, boxSize.Y);

        // Draw the box frame
        var boxStyle = new BoxStyle();
        if (disabled)
        {
            boxStyle.FillColor = DefaultTheme.DisabledFill;
            boxStyle.BorderColor = DefaultTheme.DisabledBorder;
        }
        else if (isHovering)
        {
            boxStyle.FillColor = DefaultTheme.HoverFill;
            boxStyle.BorderColor = DefaultTheme.HoverBorder;
        }
        else
        {
            // Use the specified dark grey for the normal background.
            boxStyle.FillColor = normalFillColor;
            boxStyle.BorderColor = DefaultTheme.NormalBorder;
        }

        if (State.FocusedElementId == intId)
        {
            boxStyle.BorderColor = DefaultTheme.FocusBorder;
        }
        boxStyle.Roundness = 0.2f;
        boxStyle.BorderLength = 1f;

        renderer.DrawBox(boxRect, boxStyle);

        // Draw the checkmark if checked
        if (isChecked)
        {
            // The checkmarkColor variable was changed above to pure white.
            // A simple checkmark drawn as two lines
            float pad = boxSize.X * 0.25f;
            var p1 = new Vector2(boxRect.Left + pad, boxRect.Top + boxSize.Y * 0.5f);
            var p2 = new Vector2(boxRect.Left + boxSize.X * 0.45f, boxRect.Bottom - pad);
            var p3 = new Vector2(boxRect.Right - pad, boxRect.Top + pad);
            renderer.DrawLine(p1, p2, checkmarkColor, 2.0f);
            renderer.DrawLine(p2, p3, checkmarkColor, 2.0f);
        }

        // Draw the label
        if (!string.IsNullOrEmpty(label))
        {
            var labelPos = new Vector2(boxRect.Right + spacing, drawPos.Y);
            var labelBounds = new Rect(labelPos.X, labelPos.Y, labelSize.X, totalSize.Y);
            DrawTextPrimitive(labelBounds, label, textStyle, new Alignment(HAlignment.Left, VAlignment.Center), Vector2.Zero);
        }

        Context.Layout.AdvanceLayout(totalSize);
        return clicked;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.ColorSelector.cs">
using System;
using System.Collections.Generic;
using System.Numerics;
using DirectUI.Drawing;

namespace DirectUI;

public static partial class UI
{
    public static bool ColorSelector(
        string id,
        ref string selectedColorHex,
        IReadOnlyList<string> availableColors,
        Vector2 swatchSize,
        float gap = 10f)
    {
        if (!IsContextValid() || availableColors is null || availableColors.Count == 0)
        {
            return false;
        }

        bool selectionChanged = false;

        // This theme is created once per call and configured to use the Button's `isActive` state.
        var swatchTheme = new ButtonStylePack
        {
            Roundness = 0.5f,
            BorderLength = 3f,
        };
        // The 'Active' state (when isActive is true) has a white border.
        swatchTheme.Active.BorderColor = Colors.White;
        swatchTheme.ActiveHover.BorderColor = Colors.White; // Keep border on active hover

        // The 'Normal' state has a transparent border.
        swatchTheme.Normal.BorderColor = Colors.Transparent;
        swatchTheme.Hover.BorderColor = Colors.Transparent; // No border change on hover

        BeginHBoxContainer(id + "_hbox", Context.Layout.GetCurrentPosition(), gap);

        foreach (var colorHex in availableColors)
        {
            bool isSelected = colorHex == selectedColorHex;

            // Since the fill color is different for each button, we must modify the theme
            // inside the loop before passing it to the Button call.
            var fillColor = ParseColorHex(colorHex);
            swatchTheme.Normal.FillColor = fillColor;
            swatchTheme.Hover.FillColor = fillColor;
            swatchTheme.Active.FillColor = fillColor;
            swatchTheme.ActiveHover.FillColor = fillColor;

            // Use the `isActive` parameter to control the selection state visually.
            if (Button(id + "_swatch_" + colorHex, "", size: swatchSize, theme: swatchTheme, isActive: isSelected))
            {
                if (!isSelected)
                {
                    selectedColorHex = colorHex;
                    selectionChanged = true;
                }
            }
        }

        EndHBoxContainer();

        return selectionChanged;
    }

    private static Color ParseColorHex(string hex)
    {
        if (!string.IsNullOrEmpty(hex) && hex.StartsWith("#") && hex.Length == 7)
        {
            try
            {
                byte r = Convert.ToByte(hex.Substring(1, 2), 16);
                byte g = Convert.ToByte(hex.Substring(3, 2), 16);
                byte b = Convert.ToByte(hex.Substring(5, 2), 16);
                return new Color(r, g, b, 255);
            }
            catch
            {
                // Fallback on parsing error
                return DefaultTheme.Accent;
            }
        }
        // Fallback if format is wrong
        return DefaultTheme.Accent;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.ComboBox.cs">
using System.Numerics;

namespace DirectUI;

public static partial class UI
{
    public static bool Combobox(
        string id,
        ref int selectedIndex,
        string[] items,
        Vector2 size,
        Vector2 position = default,
        ButtonStylePack? theme = null,
        bool disabled = false)
    {
        if (!IsContextValid())
        {
            return false;
        }

        int intId = id.GetHashCode();
        Vector2 drawPos = Context.Layout.ApplyLayout(position);

        // Culling check
        if (!Context.Layout.IsRectVisible(new(drawPos.X, drawPos.Y, size.X, size.Y)))
        {
            Context.Layout.AdvanceLayout(size);
            return false;
        }

        var comboboxInstance = State.GetOrCreateElement<InternalComboboxLogic>(intId);
        int newIndex = comboboxInstance.UpdateAndDraw(intId, selectedIndex, items, drawPos, size, theme, disabled);

        bool valueChanged = newIndex != selectedIndex;
        if (valueChanged)
        {
            selectedIndex = newIndex;
        }

        Context.Layout.AdvanceLayout(size);
        return valueChanged;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.cs">
// Entire file content here
using System;
using System.Numerics;
using DirectUI.Core;
using DirectUI.Drawing;
using Vortice.Direct2D1;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    // --- Core Components ---
    public static UIContext Context { get; private set; } = null!;
    public static UIPersistentState State => Context.State;
    public static bool IsRendering
    {
        get; private set;
    } = false;

    /// <summary>
    /// A private, internal renderer that performs no-op drawing calls.
    /// Used by CalculateLayout to run UI logic for measurement purposes only,
    /// without generating any GPU commands.
    /// </summary>
    private class NullRenderer : IRenderer
    {
        public Vector2 RenderTargetSize { get; }

        public NullRenderer(Vector2 renderTargetSize)
        {
            RenderTargetSize = renderTargetSize;
        }

        public void DrawBox(Rect rect, BoxStyle style) { }
        public void DrawImage(byte[] imageData, string imageKey, Rect destination) { }
        public void DrawLine(Vector2 p1, Vector2 p2, Color color, float strokeWidth) { }
        public void DrawText(Vector2 origin, string text, ButtonStyle style, Alignment alignment, Vector2 maxSize, Color color) { }
        public void Flush() { }
        public void PopClipRect() { }
        public void PushClipRect(Rect rect, AntialiasMode antialiasMode = AntialiasMode.PerPrimitive) { }
    }

    /// <summary>
    /// Executes a block of UI logic in a calculation-only mode to determine its final size
    /// without performing any actual rendering. This is useful for sizing containers based on
    /// their dynamic content before drawing them.
    /// </summary>
    /// <param name="layoutCode">An action containing the UI calls to be measured.</param>
    /// <returns>The final logical size of the content within the provided action.</returns>
    public static Vector2 CalculateLayout(Action layoutCode)
    {
        if (!IsContextValid()) return Vector2.Zero;

        var originalLayout = Context.Layout;
        var originalRenderer = Context.Renderer;

        // Create a new layout manager for this calculation to keep it isolated.
        var calculationLayout = new UILayoutManager(Context.UIScale);
        // Put a root VBox in it to measure the total size of whatever the user does.
        calculationLayout.BeginVBox("calc_root".GetHashCode(), Vector2.Zero, 0);

        // Swap context properties for the calculation pass
        Context.Layout = calculationLayout;
        Context.Renderer = new NullRenderer(originalRenderer.RenderTargetSize);

        // Run user's UI code. It will only perform layout actions.
        layoutCode();

        // Pop the root container to get its final calculated state.
        if (calculationLayout.ContainerStackCount > 0)
        {
            var measuredVBox = (VBoxContainerState)calculationLayout.PopContainer();
            var size = measuredVBox.GetAccumulatedSize();

            // Restore original context state
            Context.Layout = originalLayout;
            Context.Renderer = originalRenderer;

            return size;
        }

        // Restore context state even if the container stack was mismatched.
        Context.Layout = originalLayout;
        Context.Renderer = originalRenderer;
        return Vector2.Zero;
    }

    // --- Frame Management ---
    public static void BeginFrame(UIContext context)
    {
        IsRendering = true;

        UI.Context = context;

        // Update animations with the current time before any UI logic runs.
        context.State.AnimationManager.Update(context.TotalTime);

        context.State.ResetFrameState(context.InputState);

        UI.Context.Layout.ClearStack();
        UI.Context.treeStateStack.Clear();
    }

    public static void EndFrame()
    {
        // At the end of the frame, resolve the winner from all click requests made this frame.
        // This winner's action (for Press mode) will be triggered in the next frame.
        var pressWinner = UI.State.ClickCaptureServer.GetWinner();
        if (pressWinner.HasValue)
        {
            UI.State.SetNextFramePressWinner(pressWinner.Value);
        }

        // If a click happened but no UI element captured it, and no popup was open, clear focus.
        if (UI.Context.InputState.WasLeftMousePressedThisFrame && UI.State.InputCaptorId == 0 && !UI.State.IsPopupOpen)
        {
            UI.State.SetFocus(0);
        }

        HandlePopupLogic();

        // After all widgets are processed, check for stale active press state.
        // If the mouse is up, but a widget is still marked as 'actively pressed',
        // it means that widget was not drawn this frame (e.g. it disappeared),
        // so we must clear the state globally to prevent it getting stuck.
        if (!UI.Context.InputState.IsLeftMouseDown && UI.State.ActivelyPressedElementId != 0)
        {
            UI.State.ClearAllActivePressState();
        }

        if (UI.Context.Layout.ContainerStackCount > 0)
        {
            Console.WriteLine($"Warning: Mismatch in Begin/End container calls. {UI.Context.Layout.ContainerStackCount} containers left open at EndFrame.");
            UI.Context.Layout.ClearStack();
        }
        if (UI.Context.treeStateStack.Count > 0)
        {
            Console.WriteLine($"Warning: Mismatch in Begin/End Tree calls. {UI.Context.treeStateStack.Count} trees left open at EndFrame.");
            UI.Context.treeStateStack.Clear();
        }

        // It's important that IsRendering is set to false AFTER the context is cleared.
        UI.Context = null!;
        IsRendering = false;
    }

    /// <summary>
    /// Handles popup logic at the end of a frame, ensuring they are drawn last and closed correctly.
    /// </summary>
    private static void HandlePopupLogic()
    {
        if (!UI.State.IsPopupOpen) return;

        // If a mouse press occurred outside the popup's bounds, close the popup.
        // This logic is skipped on the same frame the popup was opened to prevent it from closing immediately.
        if (!UI.State.PopupWasOpenedThisFrame && (UI.Context.InputState.WasLeftMousePressedThisFrame || UI.Context.InputState.WasRightMousePressedThisFrame))
        {
            if (!UI.State.PopupBounds.Contains(UI.Context.InputState.MousePosition))
            {
                UI.State.ClearActivePopup();
                return; // Don't draw the popup since we just closed it.
            }
        }

        // Execute the callback to draw the popup content.
        UI.State.PopupDrawCallback?.Invoke(UI.Context);
    }

    /// <summary>
    /// Checks if a context menu should be opened for a given widget ID.
    /// A context menu is typically triggered by a right-click.
    /// </summary>
    /// <param name="widgetId">The unique ID of the widget that can open the context menu.</param>
    /// <returns>True if the context menu should be opened this frame, false otherwise.</returns>
    public static bool BeginContextMenu(string widgetId)
    {
        if (!IsContextValid()) return false;

        int intId = widgetId.GetHashCode();
        var state = UI.State;
        var input = UI.Context.InputState;

        // A context menu is opened if the right mouse button was pressed this frame,
        // and the potential input target is the widget we're checking.
        if (input.WasRightMousePressedThisFrame && state.PotentialInputTargetId == intId)
        {
            state.ClearActivePopup(); // Close any other popups first.
            return true;
        }

        return false;
    }

    /// <summary>
    /// Draws a context menu popup at the current mouse position. This should be called after BeginContextMenu returns true.
    /// </summary>
    /// <param name="popupId">A unique ID for this specific context menu instance.</param>
    /// <param name="items">An array of strings representing the menu items.</param>
    /// <returns>The index of the clicked item, or -1 if no item was clicked.</returns>
    public static int ContextMenu(string popupId, string[] items)
    {
        if (!IsContextValid() || items is null || items.Length == 0) return -1;

        var context = UI.Context;
        var state = UI.State;
        int intId = popupId.GetHashCode();

        // If a result for this menu is already available from the previous frame, consume and return it.
        if (state.PopupResultAvailable && state.PopupResultOwnerId == intId)
        {
            return state.PopupResult;
        }

        // Only set up the popup on the first frame it's requested.
        // After that, the EndFrame logic will handle drawing it using the stored state.
        if (!state.IsPopupOpen || state.ActivePopupId != intId)
        {
            // Calculate popup properties ONCE
            float itemHeight = 25;
            float itemWidth = 150;
            float popupHeight = items.Length * itemHeight;
            var popupPosition = context.InputState.MousePosition;
            var popupBounds = new Vortice.Mathematics.Rect(popupPosition.X, popupPosition.Y, itemWidth, popupHeight);

            // Define the draw callback for the popup, which runs at EndFrame
            Action<UIContext> drawCallback = (ctx) =>
            {
                var popupStyle = new BoxStyle { FillColor = DefaultTheme.NormalFill, BorderColor = DefaultTheme.FocusBorder, BorderLength = 1f, Roundness = 0.1f };
                ctx.Renderer.DrawBox(popupBounds, popupStyle);

                for (int i = 0; i < items.Length; i++)
                {
                    var itemBounds = new Vortice.Mathematics.Rect(popupBounds.X, popupBounds.Y + i * itemHeight, popupBounds.Width, itemHeight);
                    var itemTheme = new ButtonStylePack { Roundness = 0f, BorderLength = 0f };
                    itemTheme.Normal.FillColor = DefaultTheme.Transparent;
                    itemTheme.Hover.FillColor = DefaultTheme.HoverFill;
                    itemTheme.Pressed.FillColor = DefaultTheme.Accent;

                    int itemId = HashCode.Combine(intId, "item", i);

                    if (DrawButtonPrimitive(itemId, itemBounds, items[i], itemTheme, false, new Alignment(HAlignment.Left, VAlignment.Center), DirectUI.Button.ActionMode.Release, DirectUI.Button.ClickBehavior.Left, new Vector2(5, 0), isActive: false, layer: 100) != ClickResult.None)
                    {
                        state.SetPopupResult(intId, i);
                        state.ClearActivePopup();
                    }
                }
            };

            state.SetActivePopup(intId, drawCallback, popupBounds);
        }

        return -1; // No item was clicked on *this* frame
    }


    // --- Helper Methods ---
    private static bool IsContextValid()
    {
        if (UI.Context?.Renderer is null || UI.Context?.TextService is null)
        {
            Console.WriteLine($"Error: UI method called outside BeginFrame/EndFrame or context is invalid.");
            return false;
        }
        return true;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.DataGrid.cs">
// DirectUI/Source/Core/UI.DataGrid.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Reflection;
using DirectUI.Drawing;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    private static readonly Dictionary<Type, Dictionary<string, PropertyInfo?>> _propertyInfoCache = new();

    /// <summary>
    /// Renders a grid to display tabular data.
    /// </summary>
    /// <typeparam name="T">The type of data items in the collection.</typeparam>
    /// <param name="id">A unique identifier for the data grid.</param>
    /// <param name="items">The collection of data items to display.</param>
    /// <param name="columns">The column definitions for the grid.</param>
    /// <param name="selectedIndex">A reference to the index of the currently selected item in the original 'items' list.</param>
    /// <param name="size">The total size of the data grid control.</param>
    /// <param name="rowDoubleClicked">An output parameter that is true if a row was double-clicked this frame.</param>
    /// <param name="position">An optional absolute position for the grid. If not provided, it uses the current layout position.</param>
    /// <param name="autoSizeColumns">If true, columns are proportionally resized to fit the available width, disabling horizontal scrolling and user resizing.</param>
    /// <param name="trimCellText">If true, text that overflows a cell's width will be truncated and appended with an ellipsis (...).</param>
    public static void DataGrid<T>(
        string id,
        IReadOnlyList<T> items,
        IReadOnlyList<DataGridColumn> columns,
        ref int selectedIndex,
        Vector2 size,
        out bool rowDoubleClicked,
        Vector2 position = default,
        bool autoSizeColumns = false,
        bool trimCellText = false)
    {
        if (!IsContextValid())
        {
            rowDoubleClicked = false;
            return;
        }

        int intId = id.GetHashCode();
        var state = State.GetOrCreateElement<DataGridState>(intId);
        Vector2 drawPos = Context.Layout.ApplyLayout(position);
        rowDoubleClicked = false;

        // Culling
        var gridBounds = new Rect(drawPos.X, drawPos.Y, size.X, size.Y);
        if (!Context.Layout.IsRectVisible(gridBounds))
        {
            Context.Layout.AdvanceLayout(size);
            return;
        }

        InitializeDataGridState(state, intId, columns);

        // Store the currently selected item before we sort, so we can find it again.
        T? currentSelectedItem = default;
        if (selectedIndex >= 0 && selectedIndex < items.Count)
        {
            currentSelectedItem = items[selectedIndex];
        }

        // Create a mutable, sorted copy of the items for display.
        List<T> sortedItems = new List<T>(items);
        if (state.SortColumnIndex >= 0 && state.SortColumnIndex < columns.Count)
        {
            var sortColumn = columns[state.SortColumnIndex];
            try
            {
                sortedItems.Sort((a, b) =>
                {
                    var valA = GetPropertyValue(a, sortColumn.DataPropertyName);
                    var valB = GetPropertyValue(b, sortColumn.DataPropertyName);

                    int compareResult;
                    if (valA is null && valB is null) compareResult = 0;
                    else if (valA is null) compareResult = -1;
                    else if (valB is null) compareResult = 1;
                    else if (valA is IComparable comparableA) compareResult = comparableA.CompareTo(valB);
                    else compareResult = string.Compare(valA.ToString(), valB.ToString(), StringComparison.Ordinal);

                    return state.SortAscending ? compareResult : -compareResult;
                });
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error during DataGrid sort: {ex.Message}");
                state.SortColumnIndex = -1; // Disable sorting if it fails
            }
        }


        // --- Style Definitions ---
        float headerHeight = 28f;
        float rowHeight = 24f;
        const float scrollbarThickness = 12f;

        var gridStyle = new BoxStyle { FillColor = new(0.1f, 0.1f, 0.1f, 1.0f), BorderLength = 0f, Roundness = 0f };
        var headerStyle = new ButtonStyle { FillColor = new(0.2f, 0.2f, 0.2f, 1.0f), Roundness = 0, BorderLength = 0, BorderColor = DirectUI.Drawing.Colors.Transparent, FontColor = DefaultTheme.Text };
        var rowStyle = new ButtonStylePack { Roundness = 0f, BorderLength = 0f };
        rowStyle.Normal.FillColor = DefaultTheme.Transparent;
        rowStyle.Hover.FillColor = new Color4(0.25f, 0.25f, 0.25f, 1.0f);
        rowStyle.Active.FillColor = DefaultTheme.Accent;
        rowStyle.ActiveHover.FillColor = DefaultTheme.Accent;

        // --- Layout Calculation ---
        var headerBounds = new Rect(drawPos.X, drawPos.Y, size.X, headerHeight);
        var contentBounds = new Rect(drawPos.X, drawPos.Y + headerHeight, size.X, size.Y - headerHeight);
        float totalContentHeight = items.Count * rowHeight;

        // Determine scrollbar visibility and available content view size
        bool vScrollVisible = totalContentHeight > contentBounds.Height;
        float viewWidth = contentBounds.Width - (vScrollVisible ? scrollbarThickness : 0);

        // Auto-size columns if requested
        if (autoSizeColumns)
        {
            float totalInitialWidth = columns.Sum(c => c.InitialWidth);
            if (totalInitialWidth > 0 && viewWidth > 0)
            {
                float scaleFactor = viewWidth / totalInitialWidth;
                state.ColumnWidths.Clear();
                float accumulatedWidth = 0;
                for (int i = 0; i < columns.Count; i++)
                {
                    // For all but the last column, calculate and round.
                    if (i < columns.Count - 1)
                    {
                        float newWidth = (float)Math.Round(columns[i].InitialWidth * scaleFactor);
                        state.ColumnWidths.Add(newWidth);
                        accumulatedWidth += newWidth;
                    }
                    else // For the last column, use the remaining space to avoid rounding errors.
                    {
                        state.ColumnWidths.Add(Math.Max(20, viewWidth - accumulatedWidth)); // Ensure a minimum width
                    }
                }
            }
        }

        float totalContentWidth = state.ColumnWidths.Sum();
        bool hScrollVisible = !autoSizeColumns && totalContentWidth > contentBounds.Width;
        float viewHeight = contentBounds.Height - (hScrollVisible ? scrollbarThickness : 0);


        // --- Draw Main Background ---
        Context.Renderer.DrawBox(gridBounds, gridStyle);

        // --- Draw Header ---
        DrawDataGridHeader(intId, state, columns, headerBounds, headerStyle, !autoSizeColumns);

        // --- Handle Scrolling and Draw Rows ---
        var scrollOffset = state.ScrollOffset;

        // Handle Mouse Wheel Scrolling
        bool isHoveringContent = contentBounds.Contains(Context.InputState.MousePosition);
        if (isHoveringContent && Context.InputState.ScrollDelta != 0)
        {
            // Scroll delta is inverted: up is positive, but content moves down (offset increases)
            // A standard mouse wheel tick is 120, and the delta is usually +/- 1.0f in the input system.
            // Scrolling by 3 rows feels natural.
            scrollOffset.Y -= Context.InputState.ScrollDelta * rowHeight * 3;
        }

        // Clamp scroll offsets
        scrollOffset.X = Math.Clamp(scrollOffset.X, 0, Math.Max(0, totalContentWidth - viewWidth));
        scrollOffset.Y = Math.Clamp(scrollOffset.Y, 0, Math.Max(0, totalContentHeight - viewHeight));
        state.ScrollOffset = scrollOffset; // Assign back before drawing rows

        // Find the index of the selected item within the newly sorted list for display.
        int displayIndex = (currentSelectedItem is not null) ? sortedItems.IndexOf(currentSelectedItem) : -1;
        int displayIndexBeforeDraw = displayIndex;

        // Define and push clip rect for content area
        var contentClipRect = new Rect(contentBounds.X, contentBounds.Y, viewWidth, viewHeight);
        Context.Layout.PushClipRect(contentClipRect);
        Context.Renderer.PushClipRect(contentClipRect);

        DrawDataGridRows(intId, sortedItems, columns, state, contentBounds, new Vector2(viewWidth, viewHeight), rowHeight, ref displayIndex, rowStyle, trimCellText, out rowDoubleClicked);

        // Pop clip rects
        Context.Renderer.PopClipRect();
        Context.Layout.PopClipRect();

        // After drawing, if the user clicked a different row, the displayIndex will have changed.
        // We need to find the new item in the original list and update the caller's selectedIndex.
        if (displayIndex != displayIndexBeforeDraw)
        {
            if (displayIndex >= 0 && displayIndex < sortedItems.Count)
            {
                T newSelectedItem = sortedItems[displayIndex];
                // Find this item in the original list to update the external index.
                // This is a linear scan, which is acceptable for moderately sized lists.
                int newOriginalIndex = -1;
                for (int i = 0; i < items.Count; i++)
                {
                    // Using object.Equals for robust comparison, especially with value types.
                    if (object.Equals(items[i], newSelectedItem))
                    {
                        newOriginalIndex = i;
                        break;
                    }
                }
                selectedIndex = newOriginalIndex;
            }
            else
            {
                selectedIndex = -1; // Selection was cleared.
            }
        }


        // --- Draw Scrollbars ---
        // Re-read from state in case it was modified, then modify and write back.
        scrollOffset = state.ScrollOffset;
        if (vScrollVisible)
        {
            scrollOffset.Y = VScrollBar(
                id + "_vscroll",
                scrollOffset.Y,
                new Vector2(contentBounds.Right - scrollbarThickness, contentBounds.Y),
                contentBounds.Height - (hScrollVisible ? scrollbarThickness : 0), // Adjust track height if HScroll is visible
                totalContentHeight,
                viewHeight,
                scrollbarThickness
            );
        }
        if (hScrollVisible)
        {
            scrollOffset.X = HScrollBar(
                id + "_hscroll",
                scrollOffset.X,
                new Vector2(contentBounds.X, contentBounds.Bottom - scrollbarThickness),
                contentBounds.Width - (vScrollVisible ? scrollbarThickness : 0),
                totalContentWidth,
                viewWidth,
                scrollbarThickness
            );
        }
        state.ScrollOffset = scrollOffset; // Assign the final value back

        Context.Layout.AdvanceLayout(size);
    }

    private static void InitializeDataGridState(DataGridState state, int id, IReadOnlyList<DataGridColumn> columns)
    {
        if (state.Id == id && state.ColumnWidths.Count == columns.Count) return;
        state.Id = id;
        state.ColumnWidths.Clear();
        state.ColumnWidths.AddRange(columns.Select(c => c.InitialWidth));
    }

    private static void DrawDataGridHeader(int id, DataGridState state, IReadOnlyList<DataGridColumn> columns, Rect headerBounds, ButtonStyle style, bool allowColumnResize)
    {
        var input = Context.InputState;
        float currentX = headerBounds.X - state.ScrollOffset.X;

        Context.Renderer.PushClipRect(headerBounds);

        // Create a temporary ButtonStylePack for the header for hover feedback
        var headerTheme = new ButtonStylePack { Roundness = 0, BorderLength = 0 };
        headerTheme.Normal = new ButtonStyle(style);
        headerTheme.Pressed = new ButtonStyle(style);
        headerTheme.Hover = new ButtonStyle(style);
        // Make hover slightly brighter for feedback
        var hoverColor = headerTheme.Hover.FillColor;
        hoverColor.R = (byte)Math.Min(255, (int)(hoverColor.R * 1.1f));
        hoverColor.G = (byte)Math.Min(255, (int)(hoverColor.G * 1.1f));
        hoverColor.B = (byte)Math.Min(255, (int)(hoverColor.B * 1.1f));
        headerTheme.Hover.FillColor = hoverColor;

        for (int i = 0; i < columns.Count; i++)
        {
            float colWidth = state.ColumnWidths[i];
            var colHeaderBounds = new Rect(currentX, headerBounds.Y, colWidth, headerBounds.Height);

            // Header click for sorting using a proper button primitive
            int headerId = HashCode.Combine(id, "header", i);
            string headerText = columns[i].HeaderText;
            if (state.SortColumnIndex == i)
            {
                headerText += state.SortAscending ? " ▲" : " ▼";
            }

            // Use DrawButtonPrimitive with a high layer to prevent click-through
            bool wasHeaderClicked = DrawButtonPrimitive(
                id: headerId,
                bounds: colHeaderBounds,
                text: headerText,
                theme: headerTheme,
                disabled: false,
                textAlignment: new Alignment(HAlignment.Left, VAlignment.Center),
                clickMode: DirectUI.Button.ActionMode.Press, // Use Press mode for fair arbitration
                clickBehavior: DirectUI.Button.ClickBehavior.Left,
                textOffset: new Vector2(5, 0),
                isActive: false,
                layer: 5 // High layer to win against grid rows
            ) != ClickResult.None;

            if (wasHeaderClicked)
            {
                if (state.SortColumnIndex == i)
                {
                    state.SortAscending = !state.SortAscending;
                }
                else
                {
                    state.SortColumnIndex = i;
                    state.SortAscending = true;
                }
            }

            if (allowColumnResize)
            {
                // Column Resizer Handle
                var handleId = HashCode.Combine(id, "resize", i);
                var handleBounds = new Rect(currentX + colWidth - 2, headerBounds.Y, 4, headerBounds.Height);

                bool isHoveringHandle = handleBounds.Contains(input.MousePosition);
                if (isHoveringHandle) State.SetPotentialInputTarget(handleId);

                if (State.ActivelyPressedElementId == handleId && input.IsLeftMouseDown)
                {
                    float deltaX = input.MousePosition.X - state.DragStartMouseX;
                    state.ColumnWidths[i] = Math.Max(20, state.ColumnResizeStartWidth + deltaX);
                }
                else if (State.ActivelyPressedElementId == handleId && !input.IsLeftMouseDown)
                {
                    State.ClearActivePress(handleId);
                }

                if (isHoveringHandle && input.WasLeftMousePressedThisFrame && State.PotentialInputTargetId == handleId)
                {
                    // Use a higher layer for the resize handle than the header button itself
                    if (State.TrySetActivePress(handleId, 10))
                    {
                        state.ResizingColumnIndex = i;
                        state.DragStartMouseX = input.MousePosition.X;
                        state.ColumnResizeStartWidth = state.ColumnWidths[i];
                    }
                }
            }
            currentX += colWidth;
        }

        Context.Renderer.PopClipRect();
    }

    private static string TrimTextWithEllipsis(string text, float maxWidth, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(text) || maxWidth <= 0) return string.Empty;

        var textService = UI.Context.TextService;
        const string ellipsis = "...";

        var fullSize = textService.MeasureText(text, style);
        if (fullSize.X <= maxWidth) return text;

        var ellipsisSize = textService.MeasureText(ellipsis, style);
        if (ellipsisSize.X > maxWidth) return string.Empty; // Not even ellipsis fits

        // Use a copy of the string to trim
        string trimmed = text;
        while (trimmed.Length > 0)
        {
            var tempText = trimmed + ellipsis;
            if (textService.MeasureText(tempText, style).X <= maxWidth)
            {
                return tempText;
            }
            trimmed = trimmed.Substring(0, trimmed.Length - 1);
        }

        return ellipsis; // If nothing else fits
    }

    private static void DrawDataGridRows<T>(int id, IReadOnlyList<T> items, IReadOnlyList<DataGridColumn> columns, DataGridState state, Rect contentBounds, Vector2 viewSize, float rowHeight, ref int selectedIndex, ButtonStylePack rowStyle, bool trimCellText, out bool rowDoubleClicked)
    {
        var input = Context.InputState;
        rowDoubleClicked = false;

        int firstVisibleRow = (int)Math.Floor(state.ScrollOffset.Y / rowHeight);
        int visibleRowCount = (int)Math.Ceiling(viewSize.Y / rowHeight) + 1;
        int lastVisibleRow = Math.Min(items.Count - 1, firstVisibleRow + visibleRowCount);

        for (int i = firstVisibleRow; i <= lastVisibleRow; i++)
        {
            var item = items[i];
            float rowY = contentBounds.Y + (i * rowHeight) - state.ScrollOffset.Y;
            var rowBounds = new Rect(contentBounds.X, rowY, viewSize.X, rowHeight); // Use view width for selection
            bool isSelected = i == selectedIndex;

            int rowId = HashCode.Combine(id, "row", i);
            var clickResult = DrawButtonPrimitive(rowId, rowBounds, "", rowStyle, false, default, DirectUI.Button.ActionMode.Press, DirectUI.Button.ClickBehavior.Left, Vector2.Zero, isSelected);

            if (clickResult != ClickResult.None)
            {
                selectedIndex = i;
                if (clickResult == ClickResult.DoubleClick)
                {
                    rowDoubleClicked = true;
                }
            }

            float currentX = contentBounds.X - state.ScrollOffset.X;
            for (int j = 0; j < columns.Count; j++)
            {
                var column = columns[j];
                float colWidth = state.ColumnWidths[j];
                var cellBounds = new Rect(currentX, rowY, colWidth, rowHeight);

                var value = GetPropertyValue(item, column.DataPropertyName);
                string cellText = value?.ToString() ?? string.Empty;

                if (value is TimeSpan ts)
                {
                    cellText = $"{(int)ts.TotalMinutes:00}:{ts.Seconds:00}";
                }

                string textToDraw = cellText;
                var textMargin = new Vector2(5, 0);

                if (trimCellText)
                {
                    float availableWidth = cellBounds.Width - (textMargin.X * 2);
                    if (availableWidth > 0)
                    {
                        var measuredSize = Context.TextService.MeasureText(cellText, rowStyle.Current);
                        if (measuredSize.X > availableWidth)
                        {
                            textToDraw = TrimTextWithEllipsis(cellText, availableWidth, rowStyle.Current);
                        }
                    }
                }

                Context.Renderer.PushClipRect(cellBounds); // Clip text to cell
                DrawTextPrimitive(cellBounds, textToDraw, rowStyle.Current, new Alignment(HAlignment.Left, VAlignment.Center), textMargin);
                Context.Renderer.PopClipRect();

                currentX += colWidth;
            }
        }
    }

    private static object? GetPropertyValue<T>(T item, string propertyName)
    {
        if (item is null || string.IsNullOrEmpty(propertyName)) return null;
        var type = typeof(T);

        if (!_propertyInfoCache.TryGetValue(type, out var propertyMap))
        {
            propertyMap = new Dictionary<string, PropertyInfo?>();
            _propertyInfoCache[type] = propertyMap;
        }

        if (!propertyMap.TryGetValue(propertyName, out var propInfo))
        {
            propInfo = type.GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance);
            propertyMap[propertyName] = propInfo;
        }

        return propInfo?.GetValue(item);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.GridContainer.cs">
using System.Numerics;

namespace DirectUI;

public static partial class UI
{
    public static void BeginGridContainer(string id, Vector2 position, Vector2 availableSize, int numColumns, Vector2 gap)
    {
        Context.Layout.PushContainer(new GridContainerState(id.GetHashCode(), position, availableSize, numColumns, gap));
    }

    public static void EndGridContainer()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not GridContainerState state)
        {
            Console.WriteLine("Error: EndGridContainer called without a matching BeginGridContainer.");
            return;
        }

        Context.Layout.PopContainer();
        
        if (!Context.Layout.IsInLayoutContainer())
        {
            return;
        }

        Vector2 containerSize = state.GetTotalOccupiedSize();
        Context.Layout.AdvanceContainerLayout(containerSize);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.HBoxContainer.cs">
using System.Numerics;

namespace DirectUI;

public static partial class UI
{
    public static void BeginHBoxContainer(string id, Vector2 position, float gap = 5.0f, VAlignment verticalAlignment = VAlignment.Top, float? fixedRowHeight = null)
    {
        HBoxContainerState hboxState = Context.Layout.GetOrCreateHBoxState(id.GetHashCode());
        hboxState.VerticalAlignment = verticalAlignment;
        hboxState.FixedRowHeight = fixedRowHeight;

        Context.Layout.BeginHBox(id.GetHashCode(), position, gap);
    }

    public static void EndHBoxContainer()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not HBoxContainerState state)
        {
            Console.WriteLine("Error: EndHBoxContainer called without a matching BeginHBoxContainer.");
            return;
        }

        Context.Layout.PopContainer();

        if (!Context.Layout.IsInLayoutContainer())
        {
            return;
        }

        Context.Layout.AdvanceContainerLayout(new(state.AccumulatedWidth, state.MaxElementHeight));
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.InputText.cs">
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static bool InputText(
        string id,
        ref string text,
        Vector2 size,
        Vector2 position = default,
        ButtonStylePack? theme = null,
        string placeholderText = "",
        bool isPassword = false,
        char passwordChar = '*',
        int maxLength = 1024,
        bool disabled = false,
        Vector2? textMargin = null)
    {
        if (!IsContextValid())
        {
            return false;
        }

        int intId = id.GetHashCode();
        Vector2 finalPosition = Context.Layout.ApplyLayout(position);
        Vector2 finalMargin = textMargin ?? new(4, 2);
        Rect widgetBounds = new(finalPosition.X, finalPosition.Y, size.X, size.Y);

        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(size);
            return false;
        }

        InputText lineEditInstance = State.GetOrCreateElement<InputText>(intId);
        var lineEditState = State.GetOrCreateElement<InputTextState>(HashCode.Combine(intId, "state"));

        bool textChanged = lineEditInstance.UpdateAndDraw(
            intId,
            ref text,
            lineEditState,
            finalPosition,
            size,
            theme,
            placeholderText,
            isPassword,
            passwordChar,
            maxLength,
            disabled,
            finalMargin);

        Context.Layout.AdvanceLayout(size);
        return textChanged;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.Knob.cs">
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    /// <summary>
    /// Draws a circular knob control. Value is changed by clicking and dragging vertically.
    /// </summary>
    /// <param name="id">A unique identifier for the knob.</param>
    /// <param name="currentValue">The current value, passed by ref to be modified.</param>
    /// <param name="minValue">The minimum value of the knob.</param>
    /// <param name="maxValue">The maximum value of the knob.</param>
    /// <param name="radius">The radius of the knob.</param>
    /// <param name="theme">The style of the knob.</param>
    /// <param name="disabled">Whether the knob is disabled.</param>
    /// <param name="sensitivity">Controls how much the value changes per pixel of vertical mouse movement.</param>
    /// <returns>True if the value was changed this frame, otherwise false.</returns>
    public static bool Knob(
        string id,
        ref float currentValue,
        float minValue,
        float maxValue,
        float radius = 24f,
        KnobStyle? theme = null,
        bool disabled = false,
        float sensitivity = 0.005f)
    {
        if (!IsContextValid()) return false;

        int intId = id.GetHashCode();
        var knobInstance = State.GetOrCreateElement<InternalKnobLogic>(intId);

        Vector2 size = new(radius * 2, radius * 2);
        Vector2 drawPos = Context.Layout.GetCurrentPosition();

        // New: Automatically adjust vertical position for HBox alignment
        if (Context.Layout.IsInLayoutContainer() && Context.Layout.PeekContainer() is HBoxContainerState hbox)
        {
            if (hbox.VerticalAlignment != VAlignment.Top && hbox.FixedRowHeight.HasValue)
            {
                float yOffset = 0;
                switch (hbox.VerticalAlignment)
                {
                    case VAlignment.Center:
                        yOffset = (hbox.FixedRowHeight.Value - size.Y) / 2f;
                        break;
                    case VAlignment.Bottom:
                        yOffset = hbox.FixedRowHeight.Value - size.Y;
                        break;
                }
                drawPos.Y += yOffset;
            }
        }

        Rect widgetBounds = new(drawPos.X, drawPos.Y, size.X, size.Y);

        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(size);
            return false;
        }

        bool valueChanged = knobInstance.UpdateAndDraw(
            intId,
            ref currentValue,
            minValue,
            maxValue,
            radius,
            drawPos,
            theme,
            disabled,
            sensitivity);

        Context.Layout.AdvanceLayout(size);
        return valueChanged;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.Label.cs">
using System.Net.NetworkInformation;
using System;
using System.Numerics;
using SkiaSharp;
using Vortice.Mathematics;
using Vulkan.Xlib;

namespace DirectUI;

public static partial class UI
{
    public static void Text(string id, string text, Vector2? size = null, ButtonStyle? style = null, Alignment? textAlignment = null)
    {
        if (!IsContextValid() || string.IsNullOrEmpty(text))
        {
            return;
        }
        var scale = Context.UIScale;
        var logicalSize = size ?? Vector2.Zero;

        ButtonStyle finalStyle = style ?? new();
        finalStyle.FontColor = GetStyleColor(StyleColor.Text, finalStyle.FontColor);

        Alignment finalAlignment = textAlignment
            ?? new(HAlignment.Left, VAlignment.Center);

        var measurementStyle = new ButtonStyle(finalStyle) { FontSize = finalStyle.FontSize * scale };
        Vector2 measuredSize = Context.TextService.MeasureText(text, measurementStyle) / scale; // unscale to get logical size

        Vector2 finalLogicalSize;
        if (size.HasValue)
        {
            finalLogicalSize = new Vector2(
                logicalSize.X > 0 ? logicalSize.X : measuredSize.X,
                logicalSize.Y > 0 ? logicalSize.Y : measuredSize.Y
            );
        }
        else
        {
            finalLogicalSize = measuredSize;
        }

        Vector2 finalPhysicalSize = finalLogicalSize * scale;
        Vector2 drawPos = Context.Layout.ApplyLayout(Vector2.Zero);

        // New: Automatically adjust vertical position for HBox alignment
        if (Context.Layout.IsInLayoutContainer() && Context.Layout.PeekContainer() is HBoxContainerState hbox)
        {
            if (hbox.VerticalAlignment != VAlignment.Top && hbox.FixedRowHeight.HasValue)
            {
                float yOffset = 0;
                switch (hbox.VerticalAlignment)
                {
                    case VAlignment.Center:
                        yOffset = (hbox.FixedRowHeight.Value - finalLogicalSize.Y) / 2f;
                        break;
                    case VAlignment.Bottom:
                        yOffset = hbox.FixedRowHeight.Value - finalLogicalSize.Y;
                        break;
                }
                drawPos.Y += yOffset * scale;
            }
        }

        Rect widgetBounds = new(drawPos.X, drawPos.Y, finalPhysicalSize.X, finalPhysicalSize.Y);

        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(finalLogicalSize);
            return;
        }

        var renderStyle = new ButtonStyle(finalStyle) { FontSize = finalStyle.FontSize * scale };

        DrawTextPrimitive(
            widgetBounds,
            text,
            renderStyle,
            finalAlignment,
            Vector2.Zero);

        Context.Layout.AdvanceLayout(finalLogicalSize);
    }

    /// <summary>
    /// Displays text that wraps automatically based on the specified width.
    /// The layout height is determined by the content.
    /// </summary>
    public static void WrappedText(string id, string text, Vector2 size, ButtonStyle? style = null, Alignment? textAlignment = null)
    {
        if (!IsContextValid())
        {
            // Still advance layout if a fixed height was given
            if (size.Y > 0) Context.Layout.AdvanceLayout(size);
            return;
        }

        if (string.IsNullOrEmpty(text))
        {
            Context.Layout.AdvanceLayout(new Vector2(size.X, 0));
            return;
        }

        var scale = Context.UIScale;
        var logicalSize = size;

        ButtonStyle finalStyle = style ?? new ButtonStyle();
        finalStyle.FontColor = GetStyleColor(StyleColor.Text, finalStyle.FontColor);

        // Wrapped text should default to top alignment for natural reading flow
        Alignment finalAlignment = textAlignment ?? new(HAlignment.Left, VAlignment.Top);

        var renderStyle = new ButtonStyle(finalStyle) { FontSize = finalStyle.FontSize * scale };

        // Get a text layout that is constrained by the available width.
        // The height constraint is set to max to allow it to grow and wrap naturally.
        var textLayout = Context.TextService.GetTextLayout(text, renderStyle, new Vector2(logicalSize.X * scale, float.MaxValue), finalAlignment);

        if (textLayout is null)
        {
            if (logicalSize.Y > 0) Context.Layout.AdvanceLayout(logicalSize);
            return;
        }

        // The actual content size is determined by the layout's metrics.
        Vector2 actualPhysicalContentSize = textLayout.Size;
        Vector2 actualLogicalContentSize = actualPhysicalContentSize / scale;

        // The final size for layout advancement is the constrained width and the actual measured height.
        Vector2 finalLogicalSize = new Vector2(logicalSize.X, actualLogicalContentSize.Y);
        Vector2 finalPhysicalSize = finalLogicalSize * scale;

        Vector2 drawPos = Context.Layout.ApplyLayout(Vector2.Zero);
        Rect widgetBounds = new(drawPos.X, drawPos.Y, finalPhysicalSize.X, finalPhysicalSize.Y);

        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(finalLogicalSize);
            return;
        }

        DrawTextPrimitive(
            widgetBounds,
            text,
            renderStyle,
            finalAlignment,
            Vector2.Zero);

        Context.Layout.AdvanceLayout(finalLogicalSize);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.RadioButton.cs">
using System.Numerics;

namespace DirectUI;

public static partial class UI
{
    public static bool RadioButtons(
        string id,
        string[] labels,
        ref int activeIndex,
        ButtonStylePack? theme = null,
        Vector2 size = default,
        bool autoWidth = false,
        float gap = 10f)
    {
        if (!IsContextValid() || labels is null || labels.Length == 0)
        {
            return false;
        }

        bool valueChanged = false;

        BeginHBoxContainer(id + "_hbox", Context.Layout.GetCurrentPosition(), gap);

        for (int i = 0; i < labels.Length; i++)
        {
            // Use isActive parameter of the Button to control visual state.
            if (Button(
                    id: id + "_btn_" + i,
                    text: labels[i],
                    isActive: i == activeIndex,
                    theme: theme,
                    size: size,
                    autoWidth: autoWidth
                    ))
            {
                if (activeIndex != i)
                {
                    activeIndex = i;
                    valueChanged = true;
                }
            }
        }

        EndHBoxContainer();

        return valueChanged;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.ResizableHPanel.cs">
// Core/UI.Containers.cs
using System;
using System.Numerics;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

public static partial class UI
{
    public static void BeginResizableHPanel(
        string id,
        ref float currentHeight,
        float reservedLeftSpace,
        float reservedRightSpace,
        float topOffset = 0f,
        float minHeight = 50f,
        float maxHeight = 300f,
        float resizeHandleHeight = 5f,
        BoxStyle? panelStyle = null,
        Vector2 padding = default,
        float gap = 5f,
        bool disabled = false)
    {
        if (!IsContextValid()) return;
        var intId = id.GetHashCode();
        var state = State; // Define local state variable

        Vector2 finalPadding = (padding == default) ? new Vector2(5, 5) : padding;

        var input = Context.InputState;
        var renderer = Context.Renderer;
        var windowWidth = renderer.RenderTargetSize.X;
        var windowHeight = renderer.RenderTargetSize.Y;
        var availableWidth = Math.Max(0, windowWidth - reservedLeftSpace - reservedRightSpace);
        var maxAllowedHeight = windowHeight - topOffset;
        var effectiveMaxHeight = Math.Min(maxHeight, maxAllowedHeight);
        float clampMax = Math.Max(minHeight, effectiveMaxHeight);

        if (!disabled)
        {
            currentHeight = Math.Clamp(currentHeight, minHeight, clampMax);
            float panelY = windowHeight - currentHeight;
            float handleHeight = Math.Min(resizeHandleHeight, currentHeight);
            Rect handleRect = new Rect(reservedLeftSpace, panelY, availableWidth, handleHeight);

            bool isHoveringHandle = handleRect.Contains(input.MousePosition.X, input.MousePosition.Y);
            if (isHoveringHandle) state.SetPotentialInputTarget(intId);

            if (input.WasLeftMousePressedThisFrame && isHoveringHandle && state.PotentialInputTargetId == intId && !state.DragInProgressFromPreviousFrame)
            {
                state.TrySetActivePress(intId, 10);
            }

            if (state.ActivelyPressedElementId == intId && !input.IsLeftMouseDown) state.ClearActivePress(intId);

            if (state.ActivelyPressedElementId == intId && input.IsLeftMouseDown)
            {
                float clampedMouseY = Math.Max(input.MousePosition.Y, topOffset);
                currentHeight = Math.Clamp(windowHeight - clampedMouseY, minHeight, clampMax);
            }
        }

        var finalPanelStyle = panelStyle ?? new BoxStyle { FillColor = new(0.15f, 0.15f, 0.2f, 1.0f), BorderColor = DefaultTheme.NormalBorder, BorderLength = 1 };
        currentHeight = Math.Clamp(currentHeight, minHeight, clampMax);
        float finalPanelY = windowHeight - currentHeight;
        Rect panelRect = new Rect(reservedLeftSpace, finalPanelY, availableWidth, currentHeight);
        if (panelRect.Width > 0 && panelRect.Height > 0)
        {
            renderer.DrawBox(new Rect(panelRect.X, panelRect.Y, panelRect.Width, panelRect.Height), finalPanelStyle);
        }

        Vector2 contentStartPosition = new Vector2(reservedLeftSpace + finalPadding.X, finalPanelY + finalPadding.Y);
        Rect contentClipRect = new Rect(contentStartPosition.X, contentStartPosition.Y, Math.Max(0, availableWidth - (finalPadding.X * 2)), Math.Max(0, currentHeight - (finalPadding.Y * 2)));
        bool clipPushed = false;
        if (contentClipRect.Width > 0 && contentClipRect.Height > 0)
        {
            renderer.PushClipRect(contentClipRect, D2D.AntialiasMode.Aliased);
            Context.Layout.PushClipRect(contentClipRect); // For culling
            clipPushed = true;
        }

        var hboxId = HashCode.Combine(intId, "_hbox");
        var hboxState = Context.Layout.GetOrCreateHBoxState(hboxId);
        hboxState.StartPosition = contentStartPosition;
        hboxState.CurrentPosition = contentStartPosition;
        hboxState.Gap = gap;
        hboxState.MaxElementHeight = 0f;
        hboxState.AccumulatedWidth = 0f;
        hboxState.ElementCount = 0;

        var panelState = new ResizableHPanelState(intId, hboxState, clipPushed);
        Context.Layout.PushContainer(panelState);
    }

    public static void EndResizableHPanel()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not ResizableHPanelState state)
        { Console.WriteLine("Error: EndResizableHPanel called without a matching BeginResizableHPanel."); return; }
        if (state.ClipRectWasPushed)
        {
            Context.Layout.PopClipRect(); // For culling
            Context.Renderer.PopClipRect();
        }
        Context.Layout.PopContainer();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.ResizableVPanel.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

public static partial class UI
{
    public static void BeginResizableVPanel(
        string id,
        ref float currentWidth,
        HAlignment alignment = HAlignment.Left,
        float topOffset = 0f,
        float minWidth = 50f,
        float maxWidth = 500f,
        float resizeHandleWidth = 5f,
        BoxStyle? panelStyle = null,
        Vector2 padding = default,
        float gap = 5f,
        bool disabled = false)
    {
        if (!IsContextValid()) return;
        var intId = id.GetHashCode();
        var state = State; // Define local state variable

        Vector2 finalPadding = (padding == default) ? new Vector2(5, 5) : padding;

        var input = Context.InputState;
        var renderer = Context.Renderer;
        var windowWidth = renderer.RenderTargetSize.X;
        var windowHeight = renderer.RenderTargetSize.Y;
        var availableHeight = windowHeight - topOffset;

        if (!disabled)
        {
            float handleWidth = Math.Min(resizeHandleWidth, currentWidth);
            float panelX = (alignment == HAlignment.Right) ? windowWidth - currentWidth : 0;
            float handleX = (alignment == HAlignment.Right) ? panelX : panelX + currentWidth - handleWidth;
            Rect handleRect = new Rect(handleX, topOffset, handleWidth, availableHeight);

            bool isHoveringHandle = handleRect.Contains(input.MousePosition.X, input.MousePosition.Y);
            if (isHoveringHandle) state.SetPotentialInputTarget(intId);

            if (input.WasLeftMousePressedThisFrame && isHoveringHandle && state.PotentialInputTargetId == intId && !state.DragInProgressFromPreviousFrame)
            {
                state.TrySetActivePress(intId, 10);
            }

            if (state.ActivelyPressedElementId == intId && !input.IsLeftMouseDown) state.ClearActivePress(intId);

            if (state.ActivelyPressedElementId == intId && input.IsLeftMouseDown)
            {
                if (alignment == HAlignment.Left) currentWidth = Math.Clamp(input.MousePosition.X, minWidth, maxWidth);
                else currentWidth = Math.Clamp(windowWidth - input.MousePosition.X, minWidth, maxWidth);
            }
        }

        var finalPanelStyle = panelStyle ?? new BoxStyle { FillColor = new(0.15f, 0.15f, 0.2f, 1.0f), BorderColor = DefaultTheme.NormalBorder, BorderLength = 1 };
        currentWidth = Math.Max(0, currentWidth);
        float finalPanelX = (alignment == HAlignment.Right) ? windowWidth - currentWidth : 0;
        Rect panelRect = new Rect(finalPanelX, topOffset, currentWidth, availableHeight);
        if (panelRect.Width > 0 && panelRect.Height > 0)
        {
            renderer.DrawBox(new Rect(panelRect.X, panelRect.Y, panelRect.Width, panelRect.Height), finalPanelStyle);
        }

        Vector2 contentStartPosition = new Vector2(finalPanelX + finalPadding.X, topOffset + finalPadding.Y);
        Rect contentClipRect = new Rect(contentStartPosition.X, contentStartPosition.Y, Math.Max(0, currentWidth - (finalPadding.X * 2)), Math.Max(0, availableHeight - (finalPadding.Y * 2)));
        bool clipPushed = false;
        if (contentClipRect.Width > 0 && contentClipRect.Height > 0)
        {
            renderer.PushClipRect(contentClipRect, D2D.AntialiasMode.Aliased);
            Context.Layout.PushClipRect(contentClipRect); // For culling
            clipPushed = true;
        }

        var vboxId = HashCode.Combine(intId, "_vbox");
        var vboxState = Context.Layout.GetOrCreateVBoxState(vboxId);
        vboxState.StartPosition = contentStartPosition;
        vboxState.CurrentPosition = contentStartPosition;
        vboxState.Gap = gap;
        vboxState.MaxElementWidth = 0f;
        vboxState.AccumulatedHeight = 0f;
        vboxState.ElementCount = 0;

        var panelState = new ResizablePanelState(intId, vboxState, clipPushed);
        Context.Layout.PushContainer(panelState);
    }

    public static void EndResizableVPanel()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not ResizablePanelState state)
        { Console.WriteLine("Error: EndResizableVPanel called without a matching BeginResizableVPanel."); return; }
        if (state.ClipRectWasPushed)
        {
            Context.Layout.PopClipRect(); // For culling
            Context.Renderer.PopClipRect();
        }
        Context.Layout.PopContainer();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.ScrollableRegion.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

public static partial class UI
{
    public static void BeginScrollableRegion(string id, Vector2 size, out float availableInnerWidth)
    {
        if (!IsContextValid())
        {
            availableInnerWidth = size.X;
            return;
        }

        int intId = id.GetHashCode();
        Vector2 position = Context.Layout.GetCurrentPosition();
        Rect regionBounds = new Rect(position.X, position.Y, size.X, size.Y);

        var scrollState = State.GetOrCreateElement<ScrollContainerState>(intId);
        scrollState.Id = intId;
        scrollState.Position = position;
        scrollState.VisibleSize = size;
        scrollState.IsHovered = regionBounds.Contains(Context.InputState.MousePosition);

        // Predict if a scrollbar will be needed based on the previous frame's content size.
        // This is a common and effective pattern in immediate-mode UIs.
        const float scrollbarThickness = 12f; // Must match the value in EndScrollableRegion
        const float scrollbarGap = 4f; // Add a small gap between content and scrollbar
        bool scrollbarWillBeVisible = scrollState.ContentSize.Y > scrollState.VisibleSize.Y;
        // If scrollbar is visible, reduce the available width by its thickness and a small gap.
        availableInnerWidth = scrollbarWillBeVisible ? size.X - scrollbarThickness - scrollbarGap : size.X;


        // Handle scroll input
        if (scrollState.IsHovered && Context.InputState.ScrollDelta != 0)
        {
            var offset = scrollState.CurrentScrollOffset;
            offset.Y -= Context.InputState.ScrollDelta * 20; // Apply scroll wheel input
            scrollState.CurrentScrollOffset = offset;
        }

        // Clamp the offset *before* using it for layout. Use the content size from the *previous* frame for this.
        float maxScrollY = Math.Max(0, scrollState.ContentSize.Y - scrollState.VisibleSize.Y);
        var clampedOffset = scrollState.CurrentScrollOffset;
        clampedOffset.Y = Math.Clamp(clampedOffset.Y, 0, maxScrollY);
        scrollState.CurrentScrollOffset = clampedOffset;

        // Begin the inner container for content layout, offset by the now-clamped scroll position
        var contentVBoxId = HashCode.Combine(intId, "scroll_vbox");
        var contentVBox = Context.Layout.GetOrCreateVBoxState(contentVBoxId);
        contentVBox.StartPosition = position - scrollState.CurrentScrollOffset;
        contentVBox.CurrentPosition = position - scrollState.CurrentScrollOffset;
        contentVBox.Gap = 0; // The user can nest another VBox inside for gaps
        contentVBox.MaxElementWidth = 0f;
        contentVBox.AccumulatedHeight = 0f;
        contentVBox.ElementCount = 0;
        scrollState.ContentVBox = contentVBox;

        Context.Layout.PushClipRect(regionBounds);
        Context.Renderer.PushClipRect(regionBounds, D2D.AntialiasMode.Aliased);

        Context.Layout.PushContainer(scrollState);
    }

    public static void EndScrollableRegion()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not ScrollContainerState scrollState)
        { Console.WriteLine("Error: EndScrollableRegion called without a matching Begin."); return; }

        // Finalize content size based on what was rendered inside the container.
        // This new size will be used for clamping in the *next* frame.
        scrollState.ContentSize = new Vector2(scrollState.ContentVBox.MaxElementWidth, scrollState.ContentVBox.AccumulatedHeight);

        // Pop the container and clip rect so the scrollbar can be drawn outside the content's clipped area.
        Context.Layout.PopContainer();
        Context.Renderer.PopClipRect();
        Context.Layout.PopClipRect();

        // Draw scrollbar if needed. This will return a new, validated scroll offset.
        if (scrollState.ContentSize.Y > scrollState.VisibleSize.Y)
        {
            string scrollBarIdString = scrollState.Id + "_scrollbar";
            float scrollbarThickness = 12f;
            var scrollBarPos = new Vector2(scrollState.Position.X + scrollState.VisibleSize.X - scrollbarThickness, scrollState.Position.Y);

            // The VScrollBar handles all its own logic, including clamping the value against the new content size.
            float newScrollY = VScrollBar(
                id: scrollBarIdString,
                currentScrollOffset: scrollState.CurrentScrollOffset.Y,
                position: scrollBarPos,
                trackHeight: scrollState.VisibleSize.Y,
                contentHeight: scrollState.ContentSize.Y,
                visibleHeight: scrollState.VisibleSize.Y,
                thickness: scrollbarThickness);

            // Update the state with the value from the scrollbar for the next frame.
            scrollState.CurrentScrollOffset = new Vector2(scrollState.CurrentScrollOffset.X, newScrollY);
        }
        else
        {
            // If no scrollbar is needed, ensure the offset is zero.
            scrollState.CurrentScrollOffset = new Vector2(scrollState.CurrentScrollOffset.X, 0);
        }

        // After everything, advance the main layout cursor by the size of the scroll region itself.
        Context.Layout.AdvanceLayout(scrollState.VisibleSize);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.ScrollArea.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

public static partial class UI
{
    public static void BeginScrollArea(string id, Vector2 size)
    {
        if (!IsContextValid())
        {
            return;
        }

        int intId = id.GetHashCode();
        var state = State.GetOrCreateElement<ScrollAreaState>(intId);
        var scale = Context.UIScale;

        // --- Step 1: Initialize per-frame state (all units are logical) ---
        state.Id = intId;
        state.Position = Context.Layout.GetCurrentPosition();
        state.VisibleSize = size;
        state.CalculatedContentSize = Vector2.Zero; // Reset for this frame's measurement.

        var viewRect = new Rect(state.Position.X * scale, state.Position.Y * scale, size.X * scale, size.Y * scale);
        state.IsHovered = viewRect.Contains(Context.InputState.MousePosition);

        // --- Step 2: Predict scrollbar visibility and calculate available space ---
        // This uses ContentSize from the PREVIOUS frame to avoid layout jitter.
        const float scrollbarThickness = 12f;
        bool vScrollWillBeVisible = state.ContentSize.Y > state.VisibleSize.Y;
        bool hScrollWillBeVisible = state.ContentSize.X > state.VisibleSize.X;

        float availableWidth = state.VisibleSize.X - (vScrollWillBeVisible ? scrollbarThickness : 0);
        float availableHeight = state.VisibleSize.Y - (hScrollWillBeVisible ? scrollbarThickness : 0);

        // --- Step 3: Handle scroll input and clamp offset ---
        // This also uses ContentSize from the PREVIOUS frame for clamping. Offset is LOGICAL.
        if (state.IsHovered)
        {
            var offset = state.CurrentScrollOffset;
            offset.Y -= Context.InputState.ScrollDelta * 40; // Apply vertical scroll wheel
            state.CurrentScrollOffset = offset;
        }

        float maxScrollX = Math.Max(0, state.ContentSize.X - availableWidth);
        float maxScrollY = Math.Max(0, state.ContentSize.Y - availableHeight);
        var clampedOffset = state.CurrentScrollOffset;
        clampedOffset.X = Math.Clamp(clampedOffset.X, 0, maxScrollX);
        clampedOffset.Y = Math.Clamp(clampedOffset.Y, 0, maxScrollY);
        state.CurrentScrollOffset = clampedOffset;

        // --- Step 4: Calculate content start position (with centering) ---
        float startX = state.Position.X;
        if (state.ContentSize.X < availableWidth) // Center horizontally if content is smaller
        {
            startX += (availableWidth - state.ContentSize.X) / 2f;
        }
        else // Otherwise, apply scroll offset
        {
            startX -= state.CurrentScrollOffset.X;
        }
        float startY = state.Position.Y - state.CurrentScrollOffset.Y;

        state.SetContentStartPosition(new Vector2(startX, startY));

        // --- Step 5: Push clipping and container state ---
        var contentClipRect = new Rect(state.Position.X * scale, state.Position.Y * scale, availableWidth * scale, availableHeight * scale);
        Context.Layout.PushClipRect(contentClipRect);
        Context.Renderer.PushClipRect(contentClipRect, D2D.AntialiasMode.Aliased);
        Context.Layout.PushContainer(state);
    }

    public static void EndScrollArea()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not ScrollAreaState state)
        {
            Console.WriteLine("Error: EndScrollArea called without a matching BeginScrollArea.");
            return;
        }

        var scale = Context.UIScale;

        // --- Step 6: Pop container and clips ---
        Context.Layout.PopContainer();
        Context.Renderer.PopClipRect();
        Context.Layout.PopClipRect();

        // --- Step 7: Draw scrollbars based on THIS frame's content size ---
        // The child container has called Advance(), so state.CalculatedContentSize is now populated.
        var currentContentSize = state.CalculatedContentSize;
        const float scrollbarThickness = 12f;

        bool vScrollIsVisible = currentContentSize.Y > state.VisibleSize.Y;
        bool hScrollIsVisible = currentContentSize.X > state.VisibleSize.X;

        float availableWidth = state.VisibleSize.X - (vScrollIsVisible ? scrollbarThickness : 0);
        float availableHeight = state.VisibleSize.Y - (hScrollIsVisible ? scrollbarThickness : 0);

        var finalLogicalOffset = state.CurrentScrollOffset;

        if (vScrollIsVisible)
        {
            var scrollBarPos = new Vector2((state.Position.X + state.VisibleSize.X - scrollbarThickness) * scale, state.Position.Y * scale);
            float newPhysicalOffsetY = VScrollBar(
               id: state.Id + "_vscroll",
               currentScrollOffset: finalLogicalOffset.Y * scale,
               position: scrollBarPos,
               trackHeight: availableHeight * scale,
               contentHeight: currentContentSize.Y * scale,
               visibleHeight: availableHeight * scale,
               thickness: scrollbarThickness * scale);
            finalLogicalOffset.Y = newPhysicalOffsetY / scale;
        }
        else
        {
            finalLogicalOffset.Y = 0;
        }

        if (hScrollIsVisible)
        {
            var scrollBarPos = new Vector2(state.Position.X * scale, (state.Position.Y + state.VisibleSize.Y - scrollbarThickness) * scale);
            float newPhysicalOffsetX = HScrollBar(
               id: state.Id + "_hscroll",
               currentScrollOffset: finalLogicalOffset.X * scale,
               position: scrollBarPos,
               trackWidth: availableWidth * scale,
               contentWidth: currentContentSize.X * scale,
               visibleWidth: availableWidth * scale,
               thickness: scrollbarThickness * scale);
            finalLogicalOffset.X = newPhysicalOffsetX / scale;
        }
        else
        {
            finalLogicalOffset.X = 0;
        }

        // Update state with the final offset from scrollbar interactions for next frame.
        state.CurrentScrollOffset = finalLogicalOffset;

        // --- Step 8: Store this frame's content size for next frame's prediction ---
        state.ContentSize = currentContentSize;

        // --- Step 9: Advance parent layout ---
        Context.Layout.AdvanceLayout(state.VisibleSize);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.ScrollBar.cs">
// Core/UI.ScrollBar.cs
using System;
using System.Numerics;

namespace DirectUI;

public static partial class UI
{
    /// <summary>
    /// Draws a vertical scrollbar and handles its interaction.
    /// </summary>
    /// <param name="id">A unique identifier for the scrollbar.</param>
    /// <param name="currentScrollOffset">The current vertical scroll offset, which this control will modify.</param>
    /// <param name="position">The top-left position where the scrollbar will be drawn.</param>
    /// <param name="trackHeight">The total height of the scrollbar track.</param>
    /// <param name="contentHeight">The total height of the content being scrolled.</param>
    /// <param name="visibleHeight">The height of the visible portion of the content.</param>
    /// <param name="thickness">The width of the scrollbar.</param>
    /// <param name="theme">The style for the scrollbar's track.</param>
    /// <param name="thumbTheme">The style for the scrollbar's draggable thumb.</param>
    /// <returns>The new vertical scroll offset after user interaction.</returns>
    public static float VScrollBar(
        string id,
        float currentScrollOffset,
        Vector2 position,
        float trackHeight,
        float contentHeight,
        float visibleHeight,
        float thickness = 12f,
        SliderStyle? theme = null,
        ButtonStylePack? thumbTheme = null)
    {
        if (!IsContextValid()) return currentScrollOffset;

        int intId = id.GetHashCode();
        InternalScrollBarLogic scrollBarInstance = State.GetOrCreateElement<InternalScrollBarLogic>(intId);

        // Configure instance
        scrollBarInstance.Position = position;
        scrollBarInstance.TrackLength = trackHeight;
        scrollBarInstance.TrackThickness = thickness;
        scrollBarInstance.IsVertical = true;
        scrollBarInstance.ContentSize = contentHeight;
        scrollBarInstance.VisibleSize = visibleHeight;
        scrollBarInstance.Theme = theme ?? scrollBarInstance.Theme ?? new SliderStyle();
        scrollBarInstance.ThumbTheme = thumbTheme ?? scrollBarInstance.ThumbTheme ?? new ButtonStylePack();

        float newScrollOffset = scrollBarInstance.UpdateAndDraw(intId, currentScrollOffset);

        // A scrollbar, being an overlay, does not advance the main layout cursor.

        return newScrollOffset;
    }

    /// <summary>
    /// Draws a horizontal scrollbar and handles its interaction.
    /// </summary>
    /// <param name="id">A unique identifier for the scrollbar.</param>
    /// <param name="currentScrollOffset">The current horizontal scroll offset, which this control will modify.</param>
    /// <param name="position">The top-left position where the scrollbar will be drawn.</param>
    /// <param name="trackWidth">The total width of the scrollbar track.</param>
    /// <param name="contentWidth">The total width of the content being scrolled.</param>
    /// <param name="visibleWidth">The width of the visible portion of the content.</param>
    /// <param name="thickness">The height of the scrollbar.</param>
    /// <param name="theme">The style for the scrollbar's track.</param>
    /// <param name="thumbTheme">The style for the scrollbar's draggable thumb.</param>
    /// <returns>The new horizontal scroll offset after user interaction.</returns>
    public static float HScrollBar(
        string id,
        float currentScrollOffset,
        Vector2 position,
        float trackWidth,
        float contentWidth,
        float visibleWidth,
        float thickness = 12f,
        SliderStyle? theme = null,
        ButtonStylePack? thumbTheme = null)
    {
        if (!IsContextValid()) return currentScrollOffset;

        int intId = id.GetHashCode();
        InternalScrollBarLogic scrollBarInstance = State.GetOrCreateElement<InternalScrollBarLogic>(intId);

        // Configure instance
        scrollBarInstance.Position = position;
        scrollBarInstance.TrackLength = trackWidth;
        scrollBarInstance.TrackThickness = thickness;
        scrollBarInstance.IsVertical = false;
        scrollBarInstance.ContentSize = contentWidth;
        scrollBarInstance.VisibleSize = visibleWidth;
        scrollBarInstance.Theme = theme ?? scrollBarInstance.Theme ?? new SliderStyle();
        scrollBarInstance.ThumbTheme = thumbTheme ?? scrollBarInstance.ThumbTheme ?? new ButtonStylePack();

        float newScrollOffset = scrollBarInstance.UpdateAndDraw(intId, currentScrollOffset);

        return newScrollOffset;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.Separator.cs">
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static void Separator(float width, float thickness = 1f, float verticalPadding = 4f, Color4? color = null)
    {
        if (!IsContextValid())
        {
            return;
        }

        var scale = Context.UIScale;

        // All input parameters are logical
        float logicalWidth = width;
        float logicalThickness = thickness;
        float logicalPadding = verticalPadding;

        Color4 finalColor = color ?? DefaultTheme.NormalBorder;
        float logicalTotalHeight = logicalThickness + (logicalPadding * 2);
        Vector2 logicalSize = new(logicalWidth, logicalTotalHeight);

        // Get the physical top-left position for drawing
        Vector2 physicalDrawPos = Context.Layout.ApplyLayout(Vector2.Zero);
        Vector2 physicalSize = logicalSize * scale;

        Rect physicalWidgetBounds = new(physicalDrawPos.X, physicalDrawPos.Y, physicalSize.X, physicalSize.Y);

        if (!Context.Layout.IsRectVisible(physicalWidgetBounds))
        {
            Context.Layout.AdvanceLayout(logicalSize);
            return;
        }

        // Calculate physical line properties for rendering
        float physicalThickness = logicalThickness * scale;
        float physicalPadding = logicalPadding * scale;

        float lineY = physicalDrawPos.Y + physicalPadding + (physicalThickness * 0.5f);
        Vector2 lineStart = new(physicalDrawPos.X, lineY);
        Vector2 lineEnd = new(physicalDrawPos.X + physicalSize.X, lineY);

        // Use the renderer to draw the line with physical values
        Context.Renderer.DrawLine(lineStart, lineEnd, finalColor, physicalThickness);

        // Advance the layout using the logical size
        Context.Layout.AdvanceLayout(logicalSize);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.Slider.cs">
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static float HSlider(
        string id,
        float currentValue,
        float minValue,
        float maxValue,
        Vector2 size,
        Vector2 position = default,
        float step = 0.01f,
        SliderStyle? theme = null,
        ButtonStylePack? grabberTheme = null,
        Vector2? grabberSize = null,
        HSliderDirection direction = HSliderDirection.LeftToRight,
        bool disabled = false,
        object? userData = null,
        Vector2? origin = null)
    {
        if (!IsContextValid()) return currentValue;

        int intId = id.GetHashCode();
        Vector2 drawPos = Context.Layout.ApplyLayout(position);

        // Culling Check
        Rect widgetBounds = new Rect(drawPos.X, drawPos.Y, size.X, size.Y);
        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(size);
            return currentValue;
        }

        InternalHSliderLogic sliderInstance = State.GetOrCreateElement<InternalHSliderLogic>(intId);
        sliderInstance.Position = drawPos;

        // Configure instance
        sliderInstance.Size = size;
        sliderInstance.MinValue = minValue;
        sliderInstance.MaxValue = maxValue;
        sliderInstance.Step = step;
        sliderInstance.Theme = theme ?? sliderInstance.Theme ?? new SliderStyle();
        sliderInstance.GrabberTheme = grabberTheme ?? sliderInstance.GrabberTheme ?? new ButtonStylePack();
        sliderInstance.GrabberSize = grabberSize ?? new Vector2(16, 16);
        sliderInstance.Origin = origin ?? Vector2.Zero;
        sliderInstance.Disabled = disabled;
        sliderInstance.UserData = userData;
        sliderInstance.Direction = direction;


        float newValue = sliderInstance.UpdateAndDraw(intId, currentValue);
        Context.Layout.AdvanceLayout(sliderInstance.Size);
        return newValue;
    }

    public static float VSlider(
        string id,
        float currentValue,
        float minValue,
        float maxValue,
        Vector2 size,
        Vector2 position = default,
        float step = 0.01f,
        SliderStyle? theme = null,
        ButtonStylePack? grabberTheme = null,
        Vector2? grabberSize = null,
        VSliderDirection direction = VSliderDirection.TopToBottom,
        bool disabled = false,
        object? userData = null,
        Vector2? origin = null)
    {
        if (!IsContextValid()) return currentValue;

        int intId = id.GetHashCode();
        Vector2 drawPos = Context.Layout.ApplyLayout(position);

        // Culling Check
        Rect widgetBounds = new Rect(drawPos.X, drawPos.Y, size.X, size.Y);
        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(size);
            return currentValue;
        }

        InternalVSliderLogic sliderInstance = State.GetOrCreateElement<InternalVSliderLogic>(intId);
        sliderInstance.Position = drawPos;

        // Configure instance
        sliderInstance.Size = size;
        sliderInstance.MinValue = minValue;
        sliderInstance.MaxValue = maxValue;
        sliderInstance.Step = step;
        sliderInstance.Theme = theme ?? sliderInstance.Theme ?? new SliderStyle();
        sliderInstance.GrabberTheme = grabberTheme ?? sliderInstance.GrabberTheme ?? new ButtonStylePack();
        sliderInstance.GrabberSize = grabberSize ?? new Vector2(16, 16);
        sliderInstance.Origin = origin ?? Vector2.Zero;
        sliderInstance.Disabled = disabled;
        sliderInstance.UserData = userData;
        sliderInstance.Direction = direction;

        float newValue = sliderInstance.UpdateAndDraw(intId, currentValue);
        Context.Layout.AdvanceLayout(sliderInstance.Size);
        return newValue;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.StatelessWidgets.cs">
// Entire file content here
using System;
using System.Numerics;
using DirectUI.Animation;
using DirectUI.Drawing;
using Vortice.Direct2D1; // Still used for AntialiasMode enum
using Vortice.Mathematics;

namespace DirectUI;

public enum ClickResult { None, Click, DoubleClick }

public static partial class UI
{
    /// <summary>
    /// The core, stateless primitive for drawing and interacting with a button.
    /// This is the single source of truth for all button-like controls.
    /// </summary>
    internal static ClickResult DrawButtonPrimitive(
        int id,
        Vortice.Mathematics.Rect bounds,
        string text,
        ButtonStylePack theme,
        bool disabled,
        Alignment textAlignment,
        DirectUI.Button.ActionMode clickMode,
        DirectUI.Button.ClickBehavior clickBehavior,
        Vector2 textOffset,
        bool isActive = false,
        int layer = 1,
        AnimationInfo? animation = null)
    {
        var context = UI.Context;
        var scale = context.UIScale;
        var state = UI.State;
        var renderer = context.Renderer;
        var textService = context.TextService;
        var input = context.InputState;

        ClickResult clickResult = ClickResult.None;

        // --- State Calculation ---
        bool isFocused = !disabled && state.FocusedElementId == id;
        bool isHovering = !disabled && bounds.Width > 0 && bounds.Height > 0 && bounds.Contains(input.MousePosition.X, input.MousePosition.Y);
        if (isHovering)
        {
            // A widget is only truly hovered if the mouse is within its bounds
            // AND within the current layout clip rect. This prevents interaction
            // with elements that are drawn outside their container's clipped area.
            var currentClip = context.Layout.GetCurrentClipRect();
            if (!currentClip.Contains(input.MousePosition.X, input.MousePosition.Y))
            {
                isHovering = false;
            }
        }
        if (isHovering)
        {
            state.SetPotentialInputTarget(id);
        }

        // --- Click Detection ---
        bool isPressed = state.ActivelyPressedElementId == id;

        bool primaryActionPressedThisFrame = (clickBehavior is DirectUI.Button.ClickBehavior.Left or DirectUI.Button.ClickBehavior.Both) && input.WasLeftMousePressedThisFrame;
        bool secondaryActionPressedThisFrame = (clickBehavior is DirectUI.Button.ClickBehavior.Right or DirectUI.Button.ClickBehavior.Both) && input.WasRightMousePressedThisFrame;
        bool anyActionPressedThisFrame = primaryActionPressedThisFrame || secondaryActionPressedThisFrame;

        bool primaryActionHeld = (clickBehavior is DirectUI.Button.ClickBehavior.Left or DirectUI.Button.ClickBehavior.Both) && input.IsLeftMouseDown;
        bool secondaryActionHeld = (clickBehavior is DirectUI.Button.ClickBehavior.Right or DirectUI.Button.ClickBehavior.Both) && input.IsRightMouseDown;
        bool anyActionHeld = primaryActionHeld || secondaryActionHeld;


        // Handle MOUSE UP
        if (!anyActionHeld && isPressed)
        {
            if (isHovering && clickMode == DirectUI.Button.ActionMode.Release)
            {
                // A click happens on release IF this button was the one that initially captured the input.
                if (state.InputCaptorId == id)
                {
                    clickResult = state.RegisterClick(id);
                }
            }
            state.ClearActivePress(id);
            isPressed = false;
        }

        // Handle MOUSE DOWN
        if (anyActionPressedThisFrame && isHovering && state.PotentialInputTargetId == id && !state.DragInProgressFromPreviousFrame)
        {
            // Any button, regardless of mode, registers its intent to be clicked.
            state.ClickCaptureServer.RequestCapture(id, layer);
            // It also tries to become the "active" element for immediate visual feedback.
            if (state.TrySetActivePress(id, layer))
            {
                state.SetFocus(id);
            }
        }

        // For 'Press' mode, the click is triggered if this button was the winner from the *previous* frame's resolution,
        // AND it is still the element that has captured input (i.e., no higher layer element has stolen the press).
        if (clickMode == DirectUI.Button.ActionMode.Press && state.PressActionWinnerId == id && state.InputCaptorId == id)
        {
            clickResult = state.RegisterClick(id);
        }

        // --- Style Resolution ---
        // Re-check `isPressed` for correct visual state, as it might have changed above.
        isPressed = state.ActivelyPressedElementId == id;
        ButtonStyle targetStyle = ResolveButtonStylePrimitive(theme, isHovering, isPressed, disabled, isFocused, isActive);
        ButtonStyle animatedStyle;
        Vector2 animatedScale = targetStyle.Scale;

        // --- Animation Resolution ---
        // Hierarchy of animation preference:
        // 1. Explicitly passed 'animation' parameter.
        // 2. Animation defined on the target style state (e.g., Hover style).
        // 3. Animation defined on the parent ButtonStylePack.
        AnimationInfo? finalAnimation = animation ?? targetStyle.Animation ?? theme.Animation;


        if (finalAnimation is not null && !disabled)
        {
            var animManager = state.AnimationManager;
            var currentTime = context.TotalTime;

            var fillColor = animManager.GetOrAnimate(HashCode.Combine(id, "FillColor"), targetStyle.FillColor, currentTime, finalAnimation.Duration, finalAnimation.Easing);
            var borderColor = animManager.GetOrAnimate(HashCode.Combine(id, "BorderColor"), targetStyle.BorderColor, currentTime, finalAnimation.Duration, finalAnimation.Easing);
            var borderLength = animManager.GetOrAnimate(HashCode.Combine(id, "BorderLength"), targetStyle.BorderLength, currentTime, finalAnimation.Duration, finalAnimation.Easing);
            animatedScale = animManager.GetOrAnimate(HashCode.Combine(id, "Scale"), targetStyle.Scale, currentTime, finalAnimation.Duration, finalAnimation.Easing);

            animatedStyle = new ButtonStyle(targetStyle)
            {
                FillColor = fillColor,
                BorderColor = borderColor,
                BorderLength = borderLength,
                Scale = animatedScale
            };
        }
        else
        {
            animatedStyle = targetStyle;
        }


        // Create a physical style for rendering with scaled properties.
        var renderStyle = new ButtonStyle(animatedStyle)
        {
            FontSize = animatedStyle.FontSize * scale,
            BorderLengthTop = animatedStyle.BorderLengthTop * scale,
            BorderLengthRight = animatedStyle.BorderLengthRight * scale,
            BorderLengthBottom = animatedStyle.BorderLengthBottom * scale,
            BorderLengthLeft = animatedStyle.BorderLengthLeft * scale
        };

        // --- Drawing ---
        if (bounds.Width > 0 && bounds.Height > 0)
        {
            // Calculate visual bounds based on animated scale, centered within the layout bounds.
            Vector2 center = new Vector2(bounds.X + bounds.Width / 2f, bounds.Y + bounds.Height / 2f);
            float renderWidth = bounds.Width * animatedScale.X;
            float renderHeight = bounds.Height * animatedScale.Y;
            Rect renderBounds = new Rect(
                center.X - renderWidth / 2f,
                center.Y - renderHeight / 2f,
                renderWidth,
                renderHeight
            );

            // Draw Background using the style with scaled border lengths and the animated render bounds.
            renderer.DrawBox(renderBounds, renderStyle);

            // Draw Text using the style with scaled font size and the animated render bounds.
            DrawTextPrimitive(renderBounds, text, renderStyle, textAlignment, textOffset);
        }

        return clickResult;
    }

    /// <summary>
    /// Resolves the final ButtonStyle for the current frame by applying interaction state and style stack overrides.
    /// </summary>
    internal static ButtonStyle ResolveButtonStylePrimitive(ButtonStylePack theme, bool isHovering, bool isPressed, bool isDisabled, bool isFocused, bool isActive)
    {
        // Determine base style from interaction state
        theme.UpdateCurrentStyle(isHovering, isPressed, isDisabled, isFocused, isActive);
        ButtonStyle baseStyle = theme.Current;

        // Create a temporary, modifiable copy for this frame to apply style stack overrides
        var finalStyle = new ButtonStyle
        {
            FillColor = baseStyle.FillColor,
            BorderColor = baseStyle.BorderColor,
            FontColor = baseStyle.FontColor,
            BorderLengthTop = baseStyle.BorderLengthTop,
            BorderLengthRight = baseStyle.BorderLengthRight,
            BorderLengthBottom = baseStyle.BorderLengthBottom,
            BorderLengthLeft = baseStyle.BorderLengthLeft,
            Roundness = baseStyle.Roundness,
            FontName = baseStyle.FontName,
            FontSize = baseStyle.FontSize,
            FontWeight = baseStyle.FontWeight,
            FontStyle = baseStyle.FontStyle,
            FontStretch = baseStyle.FontStretch,
            Scale = baseStyle.Scale,
            Animation = baseStyle.Animation // Copy animation info
        };

        // Override with values from the style stack if they exist
        if (isDisabled)
        {
            finalStyle.FillColor = GetStyleColor(StyleColor.ButtonDisabled, finalStyle.FillColor);
            finalStyle.BorderColor = GetStyleColor(StyleColor.BorderDisabled, finalStyle.BorderColor);
            finalStyle.FontColor = GetStyleColor(StyleColor.TextDisabled, finalStyle.FontColor);
        }
        else if (isPressed)
        {
            finalStyle.FillColor = GetStyleColor(StyleColor.ButtonPressed, finalStyle.FillColor);
            finalStyle.BorderColor = GetStyleColor(StyleColor.BorderPressed, finalStyle.BorderColor);
        }
        else if (isHovering && !isActive) // Don't apply button hover if it's an active tab/button
        {
            finalStyle.FillColor = GetStyleColor(StyleColor.ButtonHovered, finalStyle.FillColor);
            finalStyle.BorderColor = GetStyleColor(StyleColor.BorderHovered, finalStyle.BorderColor);
        }
        else if (isFocused && !isActive) // Don't apply focus border if it's an active tab/button
        {
            finalStyle.BorderColor = GetStyleColor(StyleColor.BorderFocused, finalStyle.BorderColor);
        }
        else if (!isActive) // Normal
        {
            finalStyle.FillColor = GetStyleColor(StyleColor.Button, finalStyle.FillColor);
            finalStyle.BorderColor = GetStyleColor(StyleColor.Border, finalStyle.BorderColor);
        }

        if (!isDisabled)
        {
            finalStyle.FontColor = GetStyleColor(StyleColor.Text, finalStyle.FontColor);
        }

        finalStyle.Roundness = GetStyleVar(StyleVar.FrameRounding, finalStyle.Roundness);
        finalStyle.BorderLength = GetStyleVar(StyleVar.FrameBorderSize, finalStyle.BorderLength);

        return finalStyle;
    }

    /// <summary>
    /// The single, unified primitive for drawing cached text within a bounding box.
    /// </summary>
    public static void DrawTextPrimitive(
        Vortice.Mathematics.Rect bounds,
        string text,
        ButtonStyle style,
        Alignment textAlignment,
        Vector2 textOffset)
    {
        if (string.IsNullOrEmpty(text)) return;

        var renderer = UI.Context.Renderer;

        // Calculate a clean drawing origin without backend-specific corrections.
        Vector2 drawOrigin = new Vector2(bounds.X + textOffset.X, bounds.Y + textOffset.Y);

        // Call the backend-agnostic DrawText method on the renderer.
        // The renderer is now responsible for any specific positional adjustments.
        renderer.DrawText(drawOrigin, text, style, textAlignment, new Vector2(bounds.Width, bounds.Height), style.FontColor);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.Style.cs">
using System;
using System.Collections.Generic;
using System.Numerics;
using DirectUI.Drawing;

namespace DirectUI;

public enum StyleVar
{
    FrameRounding,
    FrameBorderSize,
    // Future additions could include:
    // ItemSpacing,
    // FramePadding,
    // ButtonTextAlign,
}

public enum StyleColor
{
    Text,
    TextDisabled,
    Button,
    ButtonHovered,
    ButtonPressed,
    ButtonDisabled,
    Border,
    BorderHovered,
    BorderPressed,
    BorderDisabled,
    BorderFocused,
}

public static partial class UI
{
    // --- Style Stack API ---

    public static void PushStyleVar(StyleVar styleVar, float value)
    {
        Context.styleVarStack.Push((styleVar, value));
    }

    public static void PushStyleVar(StyleVar styleVar, Vector2 value)
    {
        Context.styleVarStack.Push((styleVar, value));
    }

    public static void PopStyleVar(int count = 1)
    {
        for (int i = 0; i < count; i++)
        {
            if (Context.styleVarStack.Count > 0)
            {
                Context.styleVarStack.Pop();
            }
        }
    }

    public static void PushStyleColor(StyleColor styleColor, Color color)
    {
        Context.styleColorStack.Push((styleColor, color));
    }

    public static void PopStyleColor(int count = 1)
    {
        for (int i = 0; i < count; i++)
        {
            if (Context.styleColorStack.Count > 0)
            {
                Context.styleColorStack.Pop();
            }
        }
    }

    // --- Style Accessors (for internal widget use) ---

    internal static T GetStyleVar<T>(StyleVar styleVar, T defaultValue)
    {
        foreach (var (key, value) in Context.styleVarStack)
        {
            if (key == styleVar && value is T typedValue)
            {
                return typedValue;
            }
        }
        return defaultValue;
    }

    internal static Color GetStyleColor(StyleColor styleColor, Color defaultValue)
    {
        foreach (var (key, value) in Context.styleColorStack)
        {
            if (key == styleColor)
            {
                return value;
            }
        }
        return defaultValue;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.TabBar.cs">
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static void TabBar(string id, string[] tabLabels, ref int activeIndex, ButtonStylePack? theme = null)
    {
        if (!IsContextValid() || tabLabels is null || tabLabels.Length == 0) return;

        int intId = id.GetHashCode();
        var themeId = HashCode.Combine(intId, "theme_default");
        var tabTheme = theme ?? State.GetOrCreateElement<ButtonStylePack>(themeId);
        var state = State.GetOrCreateElement<TabBarState>(intId);

        const float textMarginX = 15f;
        const float tabHeight = 30f;
        float uniformTabWidth;

        if (state.CachedUniformWidth < 0) // Not calculated yet, or invalidated.
        {
            float maxWidth = 0;
            var styleForMeasuring = tabTheme.Normal;
            foreach (var label in tabLabels)
            {
                // Use ITextService to measure text
                Vector2 measuredSize = Context.TextService.MeasureText(label, styleForMeasuring);
                if (measuredSize.X > maxWidth)
                {
                    maxWidth = measuredSize.X;
                }
            }
            uniformTabWidth = maxWidth + textMarginX * 2;
            state.CachedUniformWidth = uniformTabWidth;
        }
        else
        {
            uniformTabWidth = state.CachedUniformWidth;
        }

        var tabSize = new Vector2(uniformTabWidth, tabHeight);

        var hboxIdString = id + "_hbox";
        BeginHBoxContainer(hboxIdString, Context.Layout.GetCurrentPosition(), 0);
        for (int i = 0; i < tabLabels.Length; i++)
        {
            var buttonId = HashCode.Combine(intId, i);
            var position = Context.Layout.GetCurrentPosition();
            var bounds = new Rect(position.X, position.Y, tabSize.X, tabSize.Y);

            var clickResult = DrawButtonPrimitive(
                buttonId,
                bounds,
                tabLabels[i],
                tabTheme,
                disabled: false,
                textAlignment: new Alignment(HAlignment.Center, VAlignment.Center),
                clickMode: DirectUI.Button.ActionMode.Release,
                clickBehavior: DirectUI.Button.ClickBehavior.Left,
                textOffset: Vector2.Zero,
                isActive: i == activeIndex
            );

            if (clickResult != ClickResult.None)
            {
                activeIndex = i;
            }
            Context.Layout.AdvanceLayout(tabSize);
        }
        EndHBoxContainer();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.Tree.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static void Tree<T>(string id, TreeNode<T> root, out TreeNode<T>? clickedNode, TreeStyle? style = null)
    {
        if (!IsContextValid() || root is null) { clickedNode = null; return; }

        clickedNode = null;
        int intId = id.GetHashCode();
        var styleId = HashCode.Combine(intId, "style");
        var treeStyle = style ?? State.GetOrCreateElement<TreeStyle>(styleId);

        var treeState = new TreeViewState(intId, treeStyle);
        Context.treeStateStack.Push(treeState);
        ProcessTreeNodeRecursive(intId, 0, root, ref clickedNode);
        Context.treeStateStack.Pop();
    }

    private static void ProcessTreeNodeRecursive<T>(int parentIdHash, int index, TreeNode<T> node, ref TreeNode<T>? clickedNode)
    {
        if (Context.treeStateStack.Count == 0) return;
        var treeState = Context.treeStateStack.Peek();
        var style = treeState.Style;
        var renderer = Context.Renderer;

        var startLayoutPos = Context.Layout.GetCurrentPosition();

        // Draw indent lines
        int i = 0;
        foreach (var shouldDrawLine in treeState.IndentLineState)
        {
            if (shouldDrawLine)
            {
                float x = startLayoutPos.X + (i * style.Indent) + (style.Indent * 0.5f);
                renderer.DrawLine(new Vector2(x, startLayoutPos.Y), new Vector2(x, startLayoutPos.Y + style.RowHeight), style.LineColor, 1.0f);
            }
            i++;
        }
        if (treeState.IndentLineState.Count > 0)
        {
            float hLineXStart = startLayoutPos.X + ((treeState.IndentLineState.Count - 1) * style.Indent) + (style.Indent * 0.5f);
            float hLineY = startLayoutPos.Y + style.RowHeight * 0.5f;
            renderer.DrawLine(new Vector2(hLineXStart, hLineY), new Vector2(hLineXStart + style.Indent * 0.5f, hLineY), style.LineColor, 1.0f);
        }

        float indentSize = treeState.IndentLineState.Count * style.Indent;
        var nodeRowStartPos = startLayoutPos + new Vector2(indentSize, 0);
        float currentX = nodeRowStartPos.X;
        float gap = 5;

        int nodeHash = node.GetHashCode();
        int toggleId = HashCode.Combine(parentIdHash, index, nodeHash, 0);
        int labelId = HashCode.Combine(parentIdHash, index, nodeHash, 1);

        float toggleWidth = style.RowHeight - 4;
        if (node.Children.Count > 0)
        {
            var bounds = new Vortice.Mathematics.Rect(currentX, nodeRowStartPos.Y, toggleWidth, style.RowHeight);
            if (DrawButtonPrimitive(toggleId, bounds, node.IsExpanded ? "-" : "+", style.ToggleStyle, false, new Alignment(HAlignment.Center, VAlignment.Center), DirectUI.Button.ActionMode.Release, DirectUI.Button.ClickBehavior.Left, Vector2.Zero, false) != ClickResult.None)
            {
                node.IsExpanded = !node.IsExpanded;
            }
        }
        currentX += toggleWidth;

        currentX += gap;
        var labelStyle = style.NodeLabelStyle;
        var labelTextAlignment = new Alignment(HAlignment.Left, VAlignment.Center);
        float labelMargin = 4;
        // Use ITextService to measure text
        var labelSize = Context.TextService.MeasureText(node.Text, labelStyle.Normal);
        float labelWidth = labelSize.X + labelMargin * 2;
        var labelOffset = new Vector2(labelMargin, 0);
        var labelBounds = new Vortice.Mathematics.Rect(currentX, nodeRowStartPos.Y, labelWidth, style.RowHeight);
        if (DrawButtonPrimitive(labelId, labelBounds, node.Text, labelStyle, false, labelTextAlignment, DirectUI.Button.ActionMode.Press, DirectUI.Button.ClickBehavior.Left, labelOffset, false) != ClickResult.None)
        {
            clickedNode = node;
        }
        currentX += labelWidth;

        Context.Layout.AdvanceLayout(new Vector2((currentX - nodeRowStartPos.X), style.RowHeight));

        if (node.IsExpanded && node.Children.Count > 0)
        {
            for (int childIdx = 0; childIdx < node.Children.Count; childIdx++)
            {
                bool isLastChild = childIdx == node.Children.Count - 1;
                treeState.IndentLineState.Push(!isLastChild);
                ProcessTreeNodeRecursive(toggleId, childIdx, node.Children[childIdx], ref clickedNode);
                treeState.IndentLineState.Pop();
            }
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.VBoxContainer.cs">
using System.Numerics;
using DirectUI.Core;

namespace DirectUI;

public static partial class UI
{
    public static void BeginVBoxContainer(string id, Vector2 position, float gap = 5.0f, Vector2 minSize = default)
    {
        Context.Layout.BeginVBox(id.GetHashCode(), position, gap, minSize);
    }

    public static void EndVBoxContainer(bool advanceParentLayout = true)
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not VBoxContainerState state)
        {
            Console.WriteLine("Error: EndVBoxContainer called without a matching BeginVBoxContainer.");
            return;
        }

        Context.Layout.PopContainer();

        if (advanceParentLayout && Context.Layout.IsInLayoutContainer())
        {
            Context.Layout.AdvanceContainerLayout(state.GetAccumulatedSize());
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UIContext.cs">
using DirectUI.Core;

namespace DirectUI;

public class UIContext
{
    public IRenderer Renderer { get; internal set; }
    public ITextService TextService { get; }
    public InputState InputState { get; }
    public float DeltaTime { get; }
    public float TotalTime { get; }
    public float UIScale { get; }
    public UIPersistentState State { get; internal set; } = null!;

    public UILayoutManager Layout { get; internal set; }
    internal readonly Stack<TreeViewState> treeStateStack = new();
    internal readonly Stack<(StyleVar, object)> styleVarStack = new();
    internal readonly Stack<(StyleColor, Color)> styleColorStack = new();

    public UIContext(IRenderer renderer, ITextService textService, InputState inputState, float deltaTime, float totalTime, float uiScale)
    {
        Renderer = renderer;
        TextService = textService;
        InputState = inputState;
        DeltaTime = deltaTime;
        TotalTime = totalTime;
        UIScale = uiScale;
        Layout = new(uiScale);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UILayoutManager.cs">
using System.Numerics;
using Vortice.Mathematics;
using System;

namespace DirectUI;

public class UILayoutManager
{
    private readonly Stack<ILayoutContainer> _containerStack = new();
    private readonly Dictionary<int, object> _containerStateCache = new();
    private readonly Stack<Rect> _clipRectStack = new();
    private readonly float _uiScale;

    public int ContainerStackCount => _containerStack.Count;
    public bool IsInLayoutContainer() => _containerStack.Count > 0;

    public UILayoutManager(float uiScale)
    {
        _uiScale = uiScale;
    }

    public void PushContainer(ILayoutContainer containerState) => _containerStack.Push(containerState);
    public ILayoutContainer PopContainer() => _containerStack.Pop();
    public ILayoutContainer PeekContainer() => _containerStack.Peek();
    public void ClearStack()
    {
        _containerStack.Clear();
        _clipRectStack.Clear();
    }

    public void PushClipRect(Rect rect) => _clipRectStack.Push(rect);
    public void PopClipRect()
    {
        if (_clipRectStack.Count > 0)
        {
            _clipRectStack.Pop();
        }
    }

    public Rect GetCurrentClipRect()
    {
        if (_clipRectStack.Count > 0)
        {
            return _clipRectStack.Peek();
        }
        // Return a very large rectangle representing no clipping
        return new Rect(float.MinValue / 2, float.MinValue / 2, float.MaxValue, float.MaxValue);
    }

    public bool IsRectVisible(Rect rect)
    {
        if (_clipRectStack.Count == 0) return true;

        var currentClip = GetCurrentClipRect();

        // Basic intersection test
        return rect.X < currentClip.X + currentClip.Width &&
               rect.X + rect.Width > currentClip.X &&
               rect.Y < currentClip.Y + currentClip.Height &&
               rect.Y + rect.Height > currentClip.Y;
    }

    public HBoxContainerState GetOrCreateHBoxState(int id)
    {
        if (!_containerStateCache.TryGetValue(id, out var state) || state is not HBoxContainerState hboxState)
        {
            hboxState = new HBoxContainerState(id);
            _containerStateCache[id] = hboxState;
        }
        return hboxState;
    }

    public VBoxContainerState GetOrCreateVBoxState(int id)
    {
        if (!_containerStateCache.TryGetValue(id, out var state) || state is not VBoxContainerState vboxState)
        {
            vboxState = new VBoxContainerState(id);
            _containerStateCache[id] = vboxState;
        }
        return vboxState;
    }

    public void BeginHBox(int id, Vector2 startPosition, float gap)
    {
        var hboxState = GetOrCreateHBoxState(id);

        // Reset per-frame properties
        hboxState.StartPosition = startPosition;
        hboxState.CurrentPosition = startPosition;
        hboxState.Gap = gap;
        hboxState.MaxElementHeight = 0f;
        hboxState.AccumulatedWidth = 0f;
        hboxState.ElementCount = 0;

        PushContainer(hboxState);
    }

    public void BeginVBox(int id, Vector2 startPosition, float gap, Vector2 minSize = default)
    {
        VBoxContainerState vboxState = GetOrCreateVBoxState(id);

        // Reset per-frame properties
        vboxState.StartPosition = startPosition;
        vboxState.CurrentPosition = startPosition;
        vboxState.Gap = gap;
        vboxState.MaxElementWidth = 0f;
        vboxState.AccumulatedHeight = 0f;
        vboxState.ElementCount = 0;
        vboxState.MinSize = minSize;

        PushContainer(vboxState);
    }

    public Vector2 ApplyLayout(Vector2 positionOffset)
    {
        // Calculate the final logical position.
        var logicalPosition = IsInLayoutContainer() ? GetCurrentPosition() + positionOffset : positionOffset;
        // Return the physical, scaled position for rendering.
        return logicalPosition * _uiScale;
    }

    public void AdvanceLayout(Vector2 elementSize)
    {
        // This method receives a logical size and advances the internal logical layout.
        if (IsInLayoutContainer())
        {
            AdvanceContainerLayout(new Vector2(Math.Max(0, elementSize.X), Math.Max(0, elementSize.Y)));
        }
    }

    public Vector2 GetCurrentPosition()
    {
        if (_containerStack.Count == 0)
        {
            return Vector2.Zero;
        }
        // Polymorphic call to the container at the top of the stack. Returns a logical position.
        return _containerStack.Peek().GetCurrentPosition();
    }

    public void AdvanceContainerLayout(Vector2 elementSize)
    {
        if (_containerStack.Count == 0) return;

        // Polymorphic call to the container at the top of the stack with a logical size.
        _containerStack.Peek().Advance(elementSize);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UIPersistentState.cs">
// Entire file content here
using System;
using System.Collections.Generic;
using DirectUI.Animation;
using Vortice.Mathematics;

namespace DirectUI;

/// <summary>
/// Manages state that persists across frames, such as UI element instances
/// and input capture state (e.g., which element is currently being pressed).
/// </summary>
public class UIPersistentState
{
    // --- Persistent Element State ---
    private readonly Dictionary<int, object> uiElements = new();
    private readonly Dictionary<int, object?> _userData = new();

    // --- Popup/Overlay State ---
    private int _activePopupId;
    private Action<UIContext>? _popupDrawCallback;
    private Rect _popupBounds;
    public bool PopupWasOpenedThisFrame { get; private set; }


    // Staging area for results from the previous frame to be read in the current one.
    private int _nextFramePopupResult;
    private bool _nextFramePopupResultAvailable;
    private int _nextFramePopupResultOwnerId;

    public int PopupResult { get; private set; }
    public bool PopupResultAvailable { get; private set; }
    public int PopupResultOwnerId { get; private set; }


    public T GetOrCreateElement<T>(int id) where T : new()
    {
        if (uiElements.TryGetValue(id, out object? element) && element is T existingElement)
        {
            return existingElement;
        }

        T newElement = new();
        uiElements[id] = newElement;
        return newElement;
    }

    public void SetUserData(int id, object? data)
    {
        if (data is not null)
        {
            _userData[id] = data;
        }
        else
        {
            _userData.Remove(id);
        }
    }

    public object? GetUserData(int id)
    {
        return _userData.TryGetValue(id, out var data) ? data : null;
    }


    // --- Input State (persists across frames until interaction ends) ---
    public int ActivelyPressedElementId { get; private set; } = 0;
    public bool DragInProgressFromPreviousFrame { get; private set; } = false;
    public int FocusedElementId { get; private set; } = 0;

    // --- Double Click State ---
    public int LastClickedElementId { get; private set; } = 0;
    public float LastClickTime { get; private set; } = -1.0f;
    public const float DoubleClickThreshold = 0.4f; // 400ms

    // --- Input State (reset each frame) ---
    public int PotentialInputTargetId { get; private set; } = 0;
    public int InputCaptorId { get; private set; } = 0; // The element that captured the press for RELEASE mode.
    private int _inputCaptorLayer = -1; // The layer of the currently active press.
    public ClickCaptureServer ClickCaptureServer { get; } = new();

    // The winner of a 'Press' action, resolved at the end of the previous frame.
    public int PressActionWinnerId { get; private set; }
    private int _nextFramePressWinnerId;

    // --- Animation State ---
    public AnimationManager AnimationManager { get; } = new();


    /// <summary>
    /// Resets the per-frame state variables. Called once at the beginning of each frame.
    /// </summary>
    public void ResetFrameState(InputState input)
    {
        ClickCaptureServer.Clear();
        DragInProgressFromPreviousFrame = input.IsLeftMouseDown && ActivelyPressedElementId != 0;
        PotentialInputTargetId = 0;

        // The logic for clearing active press state was moved to UI.EndFrame
        // and the control's own mouse-up handler to fix a bug where the state
        // was cleared before the control could process the mouse-up event.

        // At the start of the frame, the winner from the *last* frame becomes the active winner for this frame.
        PressActionWinnerId = _nextFramePressWinnerId;
        _nextFramePressWinnerId = 0; // Clear the staging variable.

        // At the start of the frame, transfer the popup result from the previous frame
        // to the current frame's readable state.
        PopupResult = _nextFramePopupResult;
        PopupResultAvailable = _nextFramePopupResultAvailable;
        PopupResultOwnerId = _nextFramePopupResultOwnerId;

        // Clear the "next frame" state, making it ready for this frame's popups to write to.
        _nextFramePopupResult = 0;
        _nextFramePopupResultAvailable = false;
        _nextFramePopupResultOwnerId = 0;

        // Reset the popup-opened-this-frame flag.
        PopupWasOpenedThisFrame = false;
    }

    // --- Popup Management ---
    public bool IsPopupOpen => _activePopupId != 0;
    public int ActivePopupId => _activePopupId;
    public Rect PopupBounds => _popupBounds;
    public Action<UIContext>? PopupDrawCallback => _popupDrawCallback;

    public void SetActivePopup(int ownerId, Action<UIContext> drawCallback, Rect bounds)
    {
        _activePopupId = ownerId;
        _popupDrawCallback = drawCallback;
        _popupBounds = bounds;
        PopupWasOpenedThisFrame = true;
    }

    public void SetPopupResult(int ownerId, int result)
    {
        // This sets the data that will become available at the start of the *next* frame.
        _nextFramePopupResultOwnerId = ownerId;
        _nextFramePopupResult = result;
        _nextFramePopupResultAvailable = true;
    }

    public void ClearActivePopup()
    {
        _activePopupId = 0;
        _popupDrawCallback = null;
        _popupBounds = default;
    }


    // --- Input Capture && Targeting ---
    public bool IsElementActive()
    {
        return ActivelyPressedElementId != 0;
    }

    public void SetPotentialInputTarget(int id)
    {
        // Don't allow elements to become potential targets if a popup is open and the cursor is outside it.
        if (IsPopupOpen && !_popupBounds.Contains(UI.Context.InputState.MousePosition))
        {
            return;
        }

        // The last widget drawn under the mouse is the topmost one, so it should always
        // be allowed to set itself as the potential target, overwriting any widget drawn beneath it.
        PotentialInputTargetId = id;
    }

    // Used for immediate visual feedback (which element is currently held down)
    public bool TrySetActivePress(int id, int layer)
    {
        if (layer >= _inputCaptorLayer)
        {
            _inputCaptorLayer = layer;
            InputCaptorId = id; // This element is the captor for release checks
            ActivelyPressedElementId = id; // This element is visually pressed
            return true;
        }
        return false;
    }

    // Called at the end of the frame to set the winner for the next frame's Press actions
    public void SetNextFramePressWinner(int id)
    {
        _nextFramePressWinnerId = id;
    }

    /// <summary>
    /// Resets all state related to an active mouse press.
    /// </summary>
    public void ClearAllActivePressState()
    {
        ActivelyPressedElementId = 0;
        InputCaptorId = 0;
        _inputCaptorLayer = -1;
    }

    public void ClearActivePress(int id)
    {
        // When a control that initiated a press is done with it (e.g., on mouse up),
        // it clears the global state.
        if (ActivelyPressedElementId == id)
        {
            ClearAllActivePressState();
        }
    }

    // --- Focus Management ---
    public void SetFocus(int id)
    {
        FocusedElementId = id;
    }

    // --- Click Management ---
    public ClickResult RegisterClick(int id)
    {
        float currentTime = UI.Context.TotalTime;
        if (LastClickedElementId == id && (currentTime - LastClickTime) < DoubleClickThreshold)
        {
            // Double click detected, reset state
            LastClickedElementId = 0;
            LastClickTime = -1.0f;
            return ClickResult.DoubleClick;
        }
        else
        {
            // Single click, update state
            LastClickedElementId = id;
            LastClickTime = currentTime;
            return ClickResult.Click;
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Diagnostics\FpsCounter.cs">
// DirectUI/Diagnostics/FpsCounter.cs
using System;
using System.Diagnostics;
using DirectUI.Core;
using Vortice.Mathematics;
using Vortice.DirectWrite;
using System.Numerics; // Still used for TextAlignment and ParagraphAlignment enums

namespace DirectUI.Diagnostics;

public class FpsCounter
{
    // Configuration
    private readonly Color4 _textColor = DefaultTheme.Text;
    private readonly string _fontName = "Consolas";
    private readonly float _fontSize = 14.0f;
    private const int UpdatesPerSecond = 2; // Update twice a second

    // State
    private readonly Stopwatch _timer = new();
    private long _lastUpdateTimeTicks = 0;
    private int _frameCountSinceUpdate = 0;
    private float _currentFps = 0.0f;
    private long _updateIntervalInStopwatchTicks;

    // DirectUI Service references
    private ITextService? _textService;
    private IRenderer? _renderer;
    // Removed ITextLayout? _fpsTextLayout; // No longer cached here for drawing

    public void Initialize(ITextService textService, IRenderer renderer)
    {
        _textService = textService ?? throw new ArgumentNullException(nameof(textService));
        _renderer = renderer ?? throw new ArgumentNullException(nameof(renderer));

        Cleanup(); // Ensure any old resources are released

        try
        {
            // Calculate the update interval based on the Stopwatch's actual frequency.
            if (Stopwatch.IsHighResolution)
            {
                _updateIntervalInStopwatchTicks = Stopwatch.Frequency / UpdatesPerSecond;
            }
            else
            {
                // Fallback for low-resolution timer
                _updateIntervalInStopwatchTicks = TimeSpan.TicksPerSecond / UpdatesPerSecond;
            }

            _frameCountSinceUpdate = 0;
            _currentFps = 0;
            _lastUpdateTimeTicks = 0;
            _timer.Restart();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Warning: Failed to initialize FPS counter: {ex.Message}");
            Cleanup(); // Clean up partial resources on failure
        }
    }

    public void Cleanup()
    {
        _timer.Stop();
        // Removed _fpsTextLayout?.Dispose();
        // Removed _fpsTextLayout = null;
    }

    /// <summary>
    /// Updates the frame count and recalculates the FPS value if the update interval has passed.
    /// This should be called once per rendered frame.
    /// </summary>
    public void Update()
    {
        if (!_timer.IsRunning) _timer.Start();

        _frameCountSinceUpdate++;
        long elapsedTicks = _timer.ElapsedTicks;
        long timeSinceLastUpdate = elapsedTicks - _lastUpdateTimeTicks;

        if (timeSinceLastUpdate >= _updateIntervalInStopwatchTicks)
        {
            long frequency = Stopwatch.IsHighResolution ? Stopwatch.Frequency : TimeSpan.TicksPerSecond;
            float secondsElapsed = (float)timeSinceLastUpdate / frequency;

            _currentFps = (secondsElapsed > 0.001f) ? (_frameCountSinceUpdate / secondsElapsed) : 0.0f;
            _frameCountSinceUpdate = 0;
            _lastUpdateTimeTicks = elapsedTicks;

            // No longer invalidate the cached text layout here, as renderer handles its own caching.
        }
    }

    public void Draw()
    {
        if (_textService is null || _renderer is null)
        {
            return;
        }

        string fpsText = $"FPS: {_currentFps:F1}";

        // The FpsCounter no longer needs to create/cache an ITextLayout for drawing.
        // It simply provides the text and style, and the renderer draws it.
        var style = new ButtonStyle
        {
            FontName = _fontName,
            FontSize = _fontSize,
            FontWeight = FontWeight.Normal,
            FontStyle = FontStyle.Normal,
            FontStretch = FontStretch.Normal,
            FontColor = _textColor
        };
        // Use a large max size as FPS counter typically won't wrap
        // The IRenderer.DrawText method requires a maxSize and alignment for its internal layout logic.
        _renderer.DrawText(new Vector2(5f, 5f), fpsText, style, new Alignment(HAlignment.Left, VAlignment.Top), new Vector2(150f, 30f), _textColor);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Drawing\Color.cs">
using System.Runtime.InteropServices;

namespace DirectUI.Drawing;

[StructLayout(LayoutKind.Sequential)]
public struct Color
{
    public byte R;
    public byte G;
    public byte B;
    public byte A;

    public Color(byte r, byte g, byte b, byte a)
    {
        R = r;
        G = g;
        B = b;
        A = a;
    }

    public Color(float r, float g, float b, float a)
    {
        R = (byte)(r * 255.0f);
        G = (byte)(g * 255.0f);
        B = (byte)(b * 255.0f);
        A = (byte)(a * 255.0f);
    }

    public static implicit operator Raylib_cs.Color(Color color)
    {
        return new Raylib_cs.Color(color.R, color.G, color.B, color.A);
    }

    public static implicit operator Vortice.Mathematics.Color4(Color color)
    {
        return new Vortice.Mathematics.Color4(color.R / 255.0f, color.G / 255.0f, color.B / 255.0f, color.A / 255.0f);
    }

    public static implicit operator Color(Vortice.Mathematics.Color4 color)
    {
        return new Color((byte)(color.R * 255), (byte)(color.G * 255), (byte)(color.B * 255), (byte)(color.A * 255));
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Drawing\Colors.cs">
namespace DirectUI.Drawing;

public static class Colors
{
    public static readonly Color Transparent = new(0, 0, 0, 0);
    public static readonly Color Black = new(0, 0, 0, 255);
    public static readonly Color White = new(255, 255, 255, 255);
    public static readonly Color WhiteSmoke = new(245, 245, 245, 255);
    public static readonly Color Red = new(255, 0, 0, 255);
    public static readonly Color Green = new(0, 255, 0, 255);
    public static readonly Color Blue = new(0, 0, 255, 255);
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Drawing\FontManager.cs">
// DirectUI/Drawing/FontManager.cs
using Raylib_cs;
using System;
using System.Collections.Generic;
using Vortice.DirectWrite;

namespace DirectUI.Drawing
{
    /// <summary>
    /// Manages loading and caching of fonts for the Raylib backend.
    /// Fonts are registered by family and loaded on-demand at specific sizes and weights.
    /// </summary>
    public static class FontManager
    {
        // Caches the actual loaded Raylib Font objects. Key is (family name, font size, font weight).
        private static readonly Dictionary<(string, int, FontWeight), Font> s_loadedFontsCache = new();

        // Stores registered font families. Key is family name (e.g., "Segoe UI").
        // Value is a dictionary mapping a FontWeight to its file path.
        private static readonly Dictionary<string, Dictionary<FontWeight, string>> s_fontFamilies = new();
        private static bool s_isInitialized = false;

        /// <summary>
        /// Initializes the FontManager.
        /// </summary>
        public static void Initialize()
        {
            if (s_isInitialized) return;
            s_isInitialized = true;
        }

        /// <summary>
        /// Registers a specific font variant (a file path for a given weight) to a font family.
        /// </summary>
        /// <param name="familyName">The logical name for the font family (e.g., "Segoe UI").</param>
        /// <param name="weight">The weight of this font variant.</param>
        /// <param name="filePath">The path to the font file for this variant.</param>
        public static void RegisterFontVariant(string familyName, FontWeight weight, string filePath)
        {
            if (!s_isInitialized)
            {
                Console.WriteLine("FontManager not initialized. Call FontManager.Initialize() first.");
                return;
            }
            if (!s_fontFamilies.TryGetValue(familyName, out var variants))
            {
                variants = new Dictionary<FontWeight, string>();
                s_fontFamilies[familyName] = variants;
            }
            variants[weight] = filePath;
        }

        /// <summary>
        /// Attempts to retrieve the file path for a registered font variant.
        /// </summary>
        /// <param name="familyName">The logical name for the font family.</param>
        /// <param name="weight">The desired weight of the font.</param>
        /// <param name="filePath">When this method returns, contains the file path if found; otherwise, null.</param>
        /// <returns>True if the font file path was found, false otherwise.</returns>
        public static bool TryGetFontFilePath(string familyName, FontWeight weight, out string? filePath)
        {
            filePath = null;
            if (!s_isInitialized) return false;

            if (s_fontFamilies.TryGetValue(familyName, out var variants))
            {
                return variants.TryGetValue(weight, out filePath);
            }
            return false;
        }

        /// <summary>
        /// Retrieves a font at a specific size and weight. If not cached, it's loaded from its registered path.
        /// </summary>
        /// <param name="familyName">The name of the registered font family.</param>
        /// <param name="fontSize">The desired size of the font.</param>
        /// <param name="weight">The desired weight of the font.</param>
        /// <returns>The Raylib Font object. Returns the default font if the requested font cannot be loaded.</returns>
        public static Font GetFont(string familyName, int fontSize, FontWeight weight)
        {
            if (!s_isInitialized)
            {
                return Raylib.GetFontDefault();
            }
            if (fontSize <= 0)
            {
                fontSize = 10; // Use a default small size for safety.
            }

            var cacheKey = (familyName, fontSize, weight);
            if (s_loadedFontsCache.TryGetValue(cacheKey, out var font))
            {
                return font;
            }

            if (!TryGetFontFilePath(familyName, weight, out string? filePath) && !TryGetFontFilePath(familyName, FontWeight.Normal, out filePath))
            {
                Console.WriteLine($"Font family '{familyName}' does not have a variant for weight {weight} or a Normal fallback. Returning default font.");
                return Raylib.GetFontDefault();
            }

            try
            {
                // Load the font at the exact size requested for the atlas.
                Font newFont = Raylib.LoadFontEx(filePath, fontSize, null, 0);

                // Use Point filtering for sharp, 1:1 pixel rendering from the atlas.
                // This avoids the blurriness/shagginess of Bilinear filtering when not oversampling.
                // MSAA should handle smoothing the final glyph edges.
                Raylib.SetTextureFilter(newFont.Texture, TextureFilter.Point);

                s_loadedFontsCache[cacheKey] = newFont;
                return newFont;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to load font '{familyName}' (weight {weight}) at size {fontSize} from '{filePath}'. Reason: {ex.Message}. Returning default font.");
                return Raylib.GetFontDefault();
            }
        }

        /// <summary>
        /// Unloads all loaded fonts and clears all caches.
        /// </summary>
        public static void UnloadAll()
        {
            var defaultFont = Raylib.GetFontDefault();
            foreach (var font in s_loadedFontsCache.Values)
            {
                // Do not unload the default font, Raylib manages it.
                if (font.Texture.Id != defaultFont.Texture.Id)
                {
                    Raylib.UnloadFont(font);
                }
            }
            s_loadedFontsCache.Clear();
            s_fontFamilies.Clear();
            s_isInitialized = false;
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Input\InputManager.cs">
using System.Numerics;
using System.Runtime.InteropServices; // Added for Marshal
using Raylib_cs; // Added for Raylib backend
using SDL3;
using static SDL3.SDL; // Added for SDL3 backend

namespace DirectUI.Input;

public class InputManager
{
    // Persistent state (held across frames)
    private Vector2 _currentMousePos = new(-1, -1);
    private Vector2 _previousMousePos = new(-1, -1);
    private bool _isLeftMouseButtonDown;
    private bool _isRightMouseButtonDown;
    private bool _isMiddleMouseButtonDown;
    private readonly HashSet<Keys> _heldKeys = new();

    // Per-frame state (reset every frame)
    private bool _wasLeftMouseClickedThisFrame;
    private bool _wasRightMouseClickedThisFrame;
    private bool _wasMiddleMouseClickedThisFrame;
    private float _scrollDeltaThisFrame;
    private readonly Queue<char> _typedCharsThisFrame = new();
    private readonly List<Keys> _pressedKeysThisFrame = new();
    private readonly List<Keys> _releasedKeysThisFrame = new();
    private readonly List<MouseButton> _pressedMouseButtonsThisFrame = new();

    public InputState GetCurrentState()
    {
        return new(
            _currentMousePos,
            _previousMousePos,
            _wasLeftMouseClickedThisFrame,
            _isLeftMouseButtonDown,
            _wasRightMouseClickedThisFrame,
            _isRightMouseButtonDown,
            _wasMiddleMouseClickedThisFrame,
            _isMiddleMouseButtonDown,
            _scrollDeltaThisFrame,
            [.. _typedCharsThisFrame], // Create a copy for the readonly list
            _pressedKeysThisFrame,
            _releasedKeysThisFrame,
            _heldKeys,
            [.. _pressedMouseButtonsThisFrame] // Create a copy for the readonly list
        );
    }

    public void PrepareNextFrame()
    {
        _previousMousePos = _currentMousePos;
        _wasLeftMouseClickedThisFrame = false;
        _wasRightMouseClickedThisFrame = false;
        _wasMiddleMouseClickedThisFrame = false;
        _scrollDeltaThisFrame = 0f;
        _typedCharsThisFrame.Clear();
        _pressedKeysThisFrame.Clear();
        _releasedKeysThisFrame.Clear();
        _pressedMouseButtonsThisFrame.Clear();
    }

    public void SetMousePosition(int x, int y)
    {
        _currentMousePos = new Vector2(x, y);
    }

    public void AddMouseWheelDelta(float delta)
    {
        _scrollDeltaThisFrame += delta;
    }

    public void SetMouseDown(MouseButton button)
    {
        _pressedMouseButtonsThisFrame.Add(button);

        if (button == MouseButton.Left)
        {
            _isLeftMouseButtonDown = true;
            _wasLeftMouseClickedThisFrame = true;
        }
        else if (button == MouseButton.Right)
        {
            _isRightMouseButtonDown = true;
            _wasRightMouseClickedThisFrame = true;
        }
        else if (button == MouseButton.Middle)
        {
            _isMiddleMouseButtonDown = true;
            _wasMiddleMouseClickedThisFrame = true;
        }
    }

    public void SetMouseUp(MouseButton button)
    {
        if (button == MouseButton.Left)
        {
            _isLeftMouseButtonDown = false;
        }
        else if (button == MouseButton.Right)
        {
            _isRightMouseButtonDown = false;
        }
        else if (button == MouseButton.Middle)
        {
            _isMiddleMouseButtonDown = false;
        }
    }

    public void AddCharacterInput(char c)
    {
        // Filter out control characters except for tab and newline which might be useful in text boxes.
        if (!char.IsControl(c) || c == '\t' || c == '\n')
        {
            _typedCharsThisFrame.Enqueue(c);
        }
    }

    public void AddKeyPressed(Keys key)
    {
        if (!_heldKeys.Contains(key))
        {
            _pressedKeysThisFrame.Add(key);
            _heldKeys.Add(key);
        }
    }

    public void AddKeyReleased(Keys key)
    {
        if (_heldKeys.Contains(key))
        {
            _releasedKeysThisFrame.Add(key);
            _heldKeys.Remove(key);
        }
    }

    public void HardReset()
    {
        // Resets persistent state that might be invalid after losing focus,
        // e.g. after a modal window closes.
        _isLeftMouseButtonDown = false;
        _isRightMouseButtonDown = false;
        _isMiddleMouseButtonDown = false;
        _heldKeys.Clear();
        // Also clear per-frame state for good measure.
        PrepareNextFrame();
    }

    public void ProcessVeldridInput(Veldrid.InputSnapshot snapshot)
    {
        SetMousePosition((int)snapshot.MousePosition.X, (int)snapshot.MousePosition.Y);
        AddMouseWheelDelta(snapshot.WheelDelta);

        foreach (Veldrid.KeyEvent keyEvent in snapshot.KeyEvents)
        {
            Keys mappedKey = MapVeldridKeyToDirectUIKey(keyEvent.Key);
            if (mappedKey == Keys.Unknown) continue;

            if (keyEvent.Down)
            {
                AddKeyPressed(mappedKey);
            }
            else
            {
                AddKeyReleased(mappedKey);
            }
        }

        foreach (var mouseEvent in snapshot.MouseEvents)
        {
            MouseButton mappedButton = MapVeldridMouseButtonToDirectUIButton(mouseEvent.MouseButton);
            if (mouseEvent.Down)
            {
                SetMouseDown(mappedButton);
            }
            else
            {
                SetMouseUp(mappedButton);
            }
        }

        foreach (char c in snapshot.KeyCharPresses)
        {
            AddCharacterInput(c);
        }
    }

    private Keys MapVeldridKeyToDirectUIKey(Veldrid.Key key)
    {
        throw new NotImplementedException();
    }

    public void ProcessRaylibInput()
    {
        // Mouse position
        Vector2 mousePos = Raylib.GetMousePosition();
        SetMousePosition((int)mousePos.X, (int)mousePos.Y);

        // Mouse buttons
        if (Raylib.IsMouseButtonPressed(Raylib_cs.MouseButton.Left)) SetMouseDown(MouseButton.Left);
        if (Raylib.IsMouseButtonReleased(Raylib_cs.MouseButton.Left)) SetMouseUp(MouseButton.Left);
        if (Raylib.IsMouseButtonPressed(Raylib_cs.MouseButton.Right)) SetMouseDown(MouseButton.Right);
        if (Raylib.IsMouseButtonReleased(Raylib_cs.MouseButton.Right)) SetMouseUp(MouseButton.Right);
        if (Raylib.IsMouseButtonPressed(Raylib_cs.MouseButton.Middle)) SetMouseDown(MouseButton.Middle);
        if (Raylib.IsMouseButtonReleased(Raylib_cs.MouseButton.Middle)) SetMouseUp(MouseButton.Middle);

        // Mouse wheel
        float wheelMove = Raylib.GetMouseWheelMove();
        if (wheelMove != 0) AddMouseWheelDelta(wheelMove);

        // Keyboard keys
        foreach (KeyboardKey rlKey in Enum.GetValues(typeof(KeyboardKey)))
        {
            if (rlKey == KeyboardKey.Null) continue; // Skip NULL key

            Keys mappedKey = MapRaylibKeyToDirectUIKey(rlKey);
            if (mappedKey == Keys.Unknown) continue;

            if (Raylib.IsKeyPressed(rlKey)) AddKeyPressed(mappedKey);
            if (Raylib.IsKeyReleased(rlKey)) AddKeyReleased(mappedKey);
        }

        // Character input
        int charValue = Raylib.GetCharPressed();
        while (charValue > 0)
        {
            AddCharacterInput((char)charValue);
            charValue = Raylib.GetCharPressed();
        }
    }
    public unsafe void ProcessSDL3Event(Event sdlEvent)
    {
        switch ((EventType)sdlEvent.Type)
        {
            case EventType.MouseButtonDown:
                SetMousePosition((int)sdlEvent.Button.X, (int)sdlEvent.Button.Y); // Update position on click
                SetMouseDown(MapSDL3MouseButtonToDirectUIButton(sdlEvent.Button.Button)); // Pass byte directly
                break;
            case EventType.MouseButtonUp:
                SetMousePosition((int)sdlEvent.Button.X, (int)sdlEvent.Button.Y); // Update position on release
                SetMouseUp(MapSDL3MouseButtonToDirectUIButton(sdlEvent.Button.Button)); // Pass byte directly
                break;
            case EventType.MouseMotion: // ADDED: Handle mouse motion to update position
                SetMousePosition((int)sdlEvent.Motion.X, (int)sdlEvent.Motion.Y);
                break;
            case EventType.MouseWheel:
                // SDL wheel delta is usually in integers (e.g., 1 or -1)
                // Normalize it similar to Win32/Veldrid
                float deltaY = sdlEvent.Wheel.Y;
                AddMouseWheelDelta(deltaY);
                break;
            case EventType.KeyDown:
                Keys mappedKeyDown = MapSDL3ScanCodeToDirectUIKey(sdlEvent.Key.Scancode);
                if (mappedKeyDown != Keys.Unknown) AddKeyPressed(mappedKeyDown);
                break;
            case EventType.KeyUp:
                Keys mappedKeyUp = MapSDL3ScanCodeToDirectUIKey(sdlEvent.Key.Scancode);
                if (mappedKeyUp != Keys.Unknown) AddKeyReleased(mappedKeyUp);
                break;
            case EventType.TextInput:
                // Correct way to get character input from SDL3 when `text` is exposed as `nint`
                // `sdlEvent.Text.text` is already an unmanaged pointer (`nint`).
                string typedText = Marshal.PtrToStringUTF8(sdlEvent.Text.Text);
                if (!string.IsNullOrEmpty(typedText))
                {
                    foreach (char c in typedText)
                    {
                        AddCharacterInput(c);
                    }
                }
                break;
        }
    }

    private static MouseButton MapVeldridMouseButtonToDirectUIButton(Veldrid.MouseButton vdButton)
    {
        return vdButton switch
        {
            Veldrid.MouseButton.Left => MouseButton.Left,
            Veldrid.MouseButton.Right => MouseButton.Right,
            Veldrid.MouseButton.Middle => MouseButton.Middle,
            Veldrid.MouseButton.Button1 => MouseButton.XButton1, // Assuming Button1 is XButton1
            Veldrid.MouseButton.Button2 => MouseButton.XButton2, // Assuming Button2 is XButton2
            _ => MouseButton.Left, // Default case
        };
    }

    private static Keys MapRaylibKeyToDirectUIKey(KeyboardKey rlKey)
    {
        // Updated to use PascalCase enum members without the KEY_ prefix
        return rlKey switch
        {
            KeyboardKey.Backspace => Keys.Backspace,
            KeyboardKey.Tab => Keys.Tab,
            KeyboardKey.Enter => Keys.Enter,
            KeyboardKey.LeftShift => Keys.Shift,
            KeyboardKey.RightShift => Keys.Shift,
            KeyboardKey.LeftControl => Keys.Control,
            KeyboardKey.RightControl => Keys.Control,
            KeyboardKey.LeftAlt => Keys.Alt,
            KeyboardKey.RightAlt => Keys.Alt,
            KeyboardKey.Pause => Keys.Pause,
            KeyboardKey.CapsLock => Keys.CapsLock,
            KeyboardKey.Escape => Keys.Escape,
            KeyboardKey.Space => Keys.Space,
            KeyboardKey.PageUp => Keys.PageUp,
            KeyboardKey.PageDown => Keys.PageDown,
            KeyboardKey.End => Keys.End,
            KeyboardKey.Home => Keys.Home,
            KeyboardKey.Left => Keys.LeftArrow,
            KeyboardKey.Up => Keys.UpArrow,
            KeyboardKey.Right => Keys.RightArrow,
            KeyboardKey.Down => Keys.DownArrow,
            KeyboardKey.Insert => Keys.Insert,
            KeyboardKey.Delete => Keys.Delete,
            KeyboardKey.Zero => Keys.D0,
            KeyboardKey.One => Keys.D1,
            KeyboardKey.Two => Keys.D2,
            KeyboardKey.Three => Keys.D3,
            KeyboardKey.Four => Keys.D4,
            KeyboardKey.Five => Keys.D5,
            KeyboardKey.Six => Keys.D6,
            KeyboardKey.Seven => Keys.D7,
            KeyboardKey.Eight => Keys.D8,
            KeyboardKey.Nine => Keys.D9,
            KeyboardKey.A => Keys.A,
            KeyboardKey.B => Keys.B,
            KeyboardKey.C => Keys.C,
            KeyboardKey.D => Keys.D,
            KeyboardKey.E => Keys.E,
            KeyboardKey.F => Keys.F,
            KeyboardKey.G => Keys.G,
            KeyboardKey.H => Keys.H,
            KeyboardKey.I => Keys.I,
            KeyboardKey.J => Keys.J,
            KeyboardKey.K => Keys.K,
            KeyboardKey.L => Keys.L,
            KeyboardKey.M => Keys.M,
            KeyboardKey.N => Keys.N,
            KeyboardKey.O => Keys.O,
            KeyboardKey.P => Keys.P,
            KeyboardKey.Q => Keys.Q,
            KeyboardKey.R => Keys.R,
            KeyboardKey.S => Keys.S,
            KeyboardKey.T => Keys.T,
            KeyboardKey.U => Keys.U,
            KeyboardKey.V => Keys.V,
            KeyboardKey.W => Keys.W,
            KeyboardKey.X => Keys.X,
            KeyboardKey.Y => Keys.Y,
            KeyboardKey.Z => Keys.Z,
            KeyboardKey.F1 => Keys.F1,
            KeyboardKey.F2 => Keys.F2,
            KeyboardKey.F3 => Keys.F3,
            KeyboardKey.F4 => Keys.F4,
            KeyboardKey.F5 => Keys.F5,
            KeyboardKey.F6 => Keys.F6,
            KeyboardKey.F7 => Keys.F7,
            KeyboardKey.F8 => Keys.F8,
            KeyboardKey.F9 => Keys.F9,
            KeyboardKey.F10 => Keys.F10,
            KeyboardKey.F11 => Keys.F11,
            KeyboardKey.F12 => Keys.F12,
            _ => Keys.Unknown,
        };
    }

    private static MouseButton MapSDL3MouseButtonToDirectUIButton(byte sdlButton) // Changed parameter type to byte
    {
        return sdlButton switch
        {
            SDL.ButtonLeft => MouseButton.Left,
            SDL.ButtonMiddle => MouseButton.Middle,
            SDL.ButtonRight => MouseButton.Right,
            SDL.ButtonX1 => MouseButton.XButton1,
            SDL.ButtonX2 => MouseButton.XButton2,
            _ => MouseButton.Left, // Fallback, though ideally all used buttons are mapped.
        };
    }
    private static Keys MapSDL3ScanCodeToDirectUIKey(Scancode sdlScancode)
    {
        return sdlScancode switch
        {
            Scancode.Backspace => Keys.Backspace,
            Scancode.Tab => Keys.Tab,
            Scancode.Return => Keys.Enter, // RETURN is Enter
            Scancode.LShift => Keys.Shift,
            Scancode.RShift => Keys.Shift,
            Scancode.LCtrl => Keys.Control,
            Scancode.RCtrl => Keys.Control,
            Scancode.LAlt => Keys.Alt,
            Scancode.RAlt => Keys.Alt,
            Scancode.Pause => Keys.Pause,
            Scancode.Capslock => Keys.CapsLock,
            Scancode.Escape => Keys.Escape,
            Scancode.Space => Keys.Space,
            Scancode.Pageup => Keys.PageUp,
            Scancode.Pagedown => Keys.PageDown,
            Scancode.End => Keys.End,
            Scancode.Home => Keys.Home,
            Scancode.Left => Keys.LeftArrow,
            Scancode.Up => Keys.UpArrow,
            Scancode.Right => Keys.RightArrow,
            Scancode.Down => Keys.DownArrow,
            Scancode.Insert => Keys.Insert,
            Scancode.Delete => Keys.Delete,
            //Scancode.Num0 => Keys.D0,
            //Scancode.Num1 => Keys.D1,
            //Scancode.Num2 => Keys.D2,
            //Scancode.Num3 => Keys.D3,
            //Scancode.Num4 => Keys.D4,
            //Scancode.Num5 => Keys.D5,
            //Scancode.Num6 => Keys.D6,
            //Scancode.Num7 => Keys.D7,
            //Scancode.Num8 => Keys.D8,
            //Scancode.Num9 => Keys.D9,
            Scancode.A => Keys.A,
            Scancode.B => Keys.B,
            Scancode.C => Keys.C,
            Scancode.D => Keys.D,
            Scancode.E => Keys.E,
            Scancode.F => Keys.F,
            Scancode.G => Keys.G,
            Scancode.H => Keys.H,
            Scancode.I => Keys.I,
            Scancode.J => Keys.J,
            Scancode.K => Keys.K,
            Scancode.L => Keys.L,
            Scancode.M => Keys.M,
            Scancode.N => Keys.N,
            Scancode.O => Keys.O,
            Scancode.P => Keys.P,
            Scancode.Q => Keys.Q,
            Scancode.R => Keys.R,
            Scancode.S => Keys.S,
            Scancode.T => Keys.T,
            Scancode.U => Keys.U,
            Scancode.V => Keys.V,
            Scancode.W => Keys.W,
            Scancode.X => Keys.X,
            Scancode.Y => Keys.Y,
            Scancode.Z => Keys.Z,
            Scancode.F1 => Keys.F1,
            Scancode.F2 => Keys.F2,
            Scancode.F3 => Keys.F3,
            Scancode.F4 => Keys.F4,
            Scancode.F5 => Keys.F5,
            Scancode.F6 => Keys.F6,
            Scancode.F7 => Keys.F7,
            Scancode.F8 => Keys.F8,
            Scancode.F9 => Keys.F9,
            Scancode.F10 => Keys.F10,
            Scancode.F11 => Keys.F11,
            Scancode.F12 => Keys.F12,
            Scancode.LGUI => Keys.LeftWindows, // Left GUI key (Windows, Command, etc.)
            Scancode.RGUI => Keys.RightWindows, // Right GUI key
            Scancode.Application => Keys.Menu, // Application key (right-click menu)
            _ => Keys.Unknown,
        };
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Input\InputState.cs">
// InputState.cs
using System.Collections.Generic;
using System.Numerics;

namespace DirectUI;

// Holds input state needed for UI processing in a single frame
public readonly struct InputState
{
    public readonly Vector2 MousePosition;
    public readonly Vector2 PreviousMousePosition;
    public readonly bool WasLeftMousePressedThisFrame; // True if the left button went down this frame
    public readonly bool IsLeftMouseDown; // True if the left button is currently held down
    public readonly bool WasRightMousePressedThisFrame; // True if the right button went down this frame
    public readonly bool IsRightMouseDown; // True if the right button is currently held down
    public readonly bool WasMiddleMousePressedThisFrame;
    public readonly bool IsMiddleMouseDown;
    public readonly float ScrollDelta; // Mouse wheel scroll amount this frame
    public readonly IReadOnlyList<char> TypedCharacters; // Characters typed this frame
    public readonly IReadOnlyList<Keys> PressedKeys; // Keys pressed down this frame
    public readonly IReadOnlyList<Keys> ReleasedKeys; // Keys released this frame
    public readonly IReadOnlyCollection<Keys> HeldKeys; // Keys currently held down
    public readonly IReadOnlyList<MouseButton> PressedMouseButtons; // Mouse buttons pressed down this frame

    public InputState(
        Vector2 mousePosition,
        Vector2 previousMousePosition,
        bool wasLeftMousePressedThisFrame,
        bool isLeftMouseDown,
        bool wasRightMousePressedThisFrame,
        bool isRightMouseDown,
        bool wasMiddleMousePressedThisFrame,
        bool isMiddleMouseDown,
        float scrollDelta,
        IReadOnlyList<char> typedCharacters,
        IReadOnlyList<Keys> pressedKeys,
        IReadOnlyList<Keys> releasedKeys,
        IReadOnlyCollection<Keys> heldKeys,
        IReadOnlyList<MouseButton> pressedMouseButtons)
    {
        MousePosition = mousePosition;
        PreviousMousePosition = previousMousePosition;
        WasLeftMousePressedThisFrame = wasLeftMousePressedThisFrame;
        IsLeftMouseDown = isLeftMouseDown;
        WasRightMousePressedThisFrame = wasRightMousePressedThisFrame;
        IsRightMouseDown = isRightMouseDown;
        WasMiddleMousePressedThisFrame = wasMiddleMousePressedThisFrame;
        IsMiddleMouseDown = isMiddleMouseDown;
        ScrollDelta = scrollDelta;
        TypedCharacters = typedCharacters;
        PressedKeys = pressedKeys;
        ReleasedKeys = releasedKeys;
        HeldKeys = heldKeys;
        PressedMouseButtons = pressedMouseButtons;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Input\Keys.cs">
namespace DirectUI;

/// <summary>
/// Defines keyboard keys for use in application-level input handling.
/// The values correspond to Win32 Virtual-Key Codes.
/// </summary>
public enum Keys
{
    /// <summary>
    /// The key is not recognized.
    /// </summary>
    Unknown = 0,

    // Action Keys
    /// <summary>The BACKSPACE key.</summary>
    Backspace = 0x08,
    /// <summary>The TAB key.</summary>
    Tab = 0x09,
    /// <summary>The ENTER key.</summary>
    Enter = 0x0D,
    /// <summary>The SHIFT key.</summary>
    Shift = 0x10,
    /// <summary>The CTRL key.</summary>
    Control = 0x11,
    /// <summary>The ALT key.</summary>
    Alt = 0x12,
    /// <summary>The PAUSE key.</summary>
    Pause = 0x13,
    /// <summary>The CAPS LOCK key.</summary>
    CapsLock = 0x14,
    /// <summary>The ESC key.</summary>
    Escape = 0x1B,
    /// <summary>The SPACEBAR key.</summary>
    Space = 0x20,
    /// <summary>The PAGE UP key.</summary>
    PageUp = 0x21,
    /// <summary>The PAGE DOWN key.</summary>
    PageDown = 0x22,
    /// <summary>The END key.</summary>
    End = 0x23,
    /// <summary>The HOME key.</summary>
    Home = 0x24,
    /// <summary>The LEFT ARROW key.</summary>
    LeftArrow = 0x25,
    /// <summary>The UP ARROW key.</summary>
    UpArrow = 0x26,
    /// <summary>The RIGHT ARROW key.</summary>
    RightArrow = 0x27,
    /// <summary>The DOWN ARROW key.</summary>
    DownArrow = 0x28,
    /// <summary>The INSERT key.</summary>
    Insert = 0x2D,
    /// <summary>The DELETE key.</summary>
    Delete = 0x2E,

    // Digit Keys
    /// <summary>The 0 key.</summary>
    D0 = 0x30,
    /// <summary>The 1 key.</summary>
    D1 = 0x31,
    /// <summary>The 2 key.</summary>
    D2 = 0x32,
    /// <summary>The 3 key.</summary>
    D3 = 0x33,
    /// <summary>The 4 key.</summary>
    D4 = 0x34,
    /// <summary>The 5 key.</summary>
    D5 = 0x35,
    /// <summary>The 6 key.</summary>
    D6 = 0x36,
    /// <summary>The 7 key.</summary>
    D7 = 0x37,
    /// <summary>The 8 key.</summary>
    D8 = 0x38,
    /// <summary>The 9 key.</summary>
    D9 = 0x39,

    // Letter Keys
    /// <summary>The A key.</summary>
    A = 0x41,
    /// <summary>The B key.</summary>
    B = 0x42,
    /// <summary>The C key.</summary>
    C = 0x43,
    /// <summary>The D key.</summary>
    D = 0x44,
    /// <summary>The E key.</summary>
    E = 0x45,
    /// <summary>The F key.</summary>
    F = 0x46,
    /// <summary>The G key.</summary>
    G = 0x47,
    /// <summary>The H key.</summary>
    H = 0x48,
    /// <summary>The I key.</summary>
    I = 0x49,
    /// <summary>The J key.</summary>
    J = 0x4A,
    /// <summary>The K key.</summary>
    K = 0x4B,
    /// <summary>The L key.</summary>
    L = 0x4C,
    /// <summary>The M key.</summary>
    M = 0x4D,
    /// <summary>The N key.</summary>
    N = 0x4E,
    /// <summary>The O key.</summary>
    O = 0x4F,
    /// <summary>The P key.</summary>
    P = 0x50,
    /// <summary>The Q key.</summary>
    Q = 0x51,
    /// <summary>The R key.</summary>
    R = 0x52,
    /// <summary>The S key.</summary>
    S = 0x53,
    /// <summary>The T key.</summary>
    T = 0x54,
    /// <summary>The U key.</summary>
    U = 0x55,
    /// <summary>The V key.</summary>
    V = 0x56,
    /// <summary>The W key.</summary>
    W = 0x57,
    /// <summary>The X key.</summary>
    X = 0x58,
    /// <summary>The Y key.</summary>
    Y = 0x59,
    /// <summary>The Z key.</summary>
    Z = 0x5A,

    // Function Keys
    /// <summary>The F1 key.</summary>
    F1 = 0x70,
    /// <summary>The F2 key.</summary>
    F2 = 0x71,
    /// <summary>The F3 key.</summary>
    F3 = 0x72,
    /// <summary>The F4 key.</summary>
    F4 = 0x73,
    /// <summary>The F5 key.</summary>
    F5 = 0x74,
    /// <summary>The F6 key.</summary>
    F6 = 0x75,
    /// <summary>The F7 key.</summary>
    F7 = 0x76,
    /// <summary>The F8 key.</summary>
    F8 = 0x77,
    /// <summary>The F9 key.</summary>
    F9 = 0x78,
    /// <summary>The F10 key.</summary>
    F10 = 0x79,
    /// <summary>The F11 key.</summary>
    F11 = 0x7A,
    /// <summary>The F12 key.</summary>
    F12 = 0x7B,

    // Special Keys
    /// <summary>The left Windows logo key (Microsoft Natural Keyboard).</summary>
    LeftWindows = 0x5B,
    /// <summary>The right Windows logo key (Microsoft Natural Keyboard).</summary>
    RightWindows = 0x5C,
    /// <summary>The Application key (Microsoft Natural Keyboard).</summary>
    Menu = 0x5D,
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\BoxStyle.cs">
using DirectUI.Drawing;

namespace DirectUI;

public class BoxStyle
{
    public float Roundness { get; set; } = 0.2f;
    public Color FillColor { get; set; } = DefaultTheme.NormalFill;
    public Color BorderColor { get; set; } = DefaultTheme.NormalBorder;

    public float BorderLengthTop { get; set; } = 1.0f;
    public float BorderLengthRight { get; set; } = 1.0f;
    public float BorderLengthBottom { get; set; } = 1.0f;
    public float BorderLengthLeft { get; set; } = 1.0f;

    public float BorderLength
    {
        get => BorderLengthTop; // Return a representative value
        set
        {
            BorderLengthTop = value;
            BorderLengthRight = value;
            BorderLengthBottom = value;
            BorderLengthLeft = value;
        }
    }

    public BoxStyle() { }

    protected BoxStyle(BoxStyle other)
    {
        this.Roundness = other.Roundness;
        this.FillColor = other.FillColor;
        this.BorderColor = other.BorderColor;
        this.BorderLengthTop = other.BorderLengthTop;
        this.BorderLengthRight = other.BorderLengthRight;
        this.BorderLengthBottom = other.BorderLengthBottom;
        this.BorderLengthLeft = other.BorderLengthLeft;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\ButtonStyle.cs">
// ButtonStyle.cs
using System.Numerics;
using DirectUI.Animation;
using DirectUI.Drawing;
using Vortice.DirectWrite; // For Font related enums eventually

namespace DirectUI;

public class ButtonStyle : BoxStyle
{
    // DirectWrite Font properties will be managed elsewhere (e.g., IDWriteTextFormat)
    // public float FontSpacing { get; set; } = 0; // Handled by TextFormat
    // public float FontSize { get; set; } = 16; // Handled by TextFormat
    // public Font? Font { get; set; } = null; // Represented by TextFormat
    public Color FontColor { get; set; } = DefaultTheme.Text;

    // Properties needed for creating IDWriteTextFormat
    public string FontName { get; set; } = "Segoe UI";
    public float FontSize { get; set; } = 14.0f;
    public FontWeight FontWeight { get; set; } = FontWeight.Normal;
    public FontStyle FontStyle { get; set; } = FontStyle.Normal;
    public FontStretch FontStretch { get; set; } = FontStretch.Normal;
    public Vector2 Scale { get; set; } = Vector2.One;

    /// <summary>
    /// Optional animation info for transitioning *to* this specific state.
    /// </summary>
    public AnimationInfo? Animation { get; set; }

    public ButtonStyle() { }

    public ButtonStyle(ButtonStyle other) : base(other)
    {
        this.FontColor = other.FontColor;
        this.FontName = other.FontName;
        this.FontSize = other.FontSize;
        this.FontWeight = other.FontWeight;
        this.FontStyle = other.FontStyle;
        this.FontStretch = other.FontStretch;
        this.Scale = other.Scale;
        this.Animation = other.Animation;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\ButtonStylePack.cs">
using System.Collections.Generic;
using System;
using Vortice.Mathematics;
using Vortice.DirectWrite;
using DirectUI.Animation;

namespace DirectUI;

public sealed class ButtonStylePack
{
    public ButtonStyle Current { get; internal set; }
    public ButtonStyle Normal { get; set; } = new();
    public ButtonStyle Hover { get; set; } = new();
    public ButtonStyle Pressed { get; set; } = new();
    public ButtonStyle Disabled { get; set; } = new();
    public ButtonStyle Focused { get; set; } = new();
    public ButtonStyle Active { get; set; } = new();
    public ButtonStyle ActiveHover { get; set; } = new();
    public AnimationInfo? Animation { get; set; }

    public ButtonStylePack()
    {
        Hover.FillColor = DefaultTheme.HoverFill;
        Hover.BorderColor = DefaultTheme.HoverBorder;

        Pressed.FillColor = DefaultTheme.Accent;
        Pressed.BorderColor = DefaultTheme.AccentBorder;

        Disabled.FillColor = DefaultTheme.DisabledFill;
        Disabled.BorderColor = DefaultTheme.DisabledBorder;
        Disabled.FontColor = DefaultTheme.DisabledText;

        Focused.FillColor = DefaultTheme.NormalFill;
        Focused.BorderColor = DefaultTheme.FocusBorder;
        Focused.BorderLength = 1;

        // Styles for 'Active' state, taken from the old TabStylePack
        var panelBg = new Color4(37 / 255f, 37 / 255f, 38 / 255f, 1.0f);
        Active.FillColor = panelBg;
        Active.BorderColor = DefaultTheme.HoverBorder;
        Active.BorderLengthTop = 1f; Active.BorderLengthLeft = 1f; Active.BorderLengthRight = 1f; Active.BorderLengthBottom = 0f;
        Active.Roundness = 0f;

        ActiveHover.FillColor = panelBg;
        ActiveHover.BorderColor = DefaultTheme.AccentBorder;
        ActiveHover.BorderLengthTop = 1f; ActiveHover.BorderLengthLeft = 1f; ActiveHover.BorderLengthRight = 1f; ActiveHover.BorderLengthBottom = 0f;
        ActiveHover.Roundness = 0f;

        Current = Normal;
    }

    public ButtonStylePack(ButtonStylePack other)
    {
        Normal = new ButtonStyle(other.Normal);
        Hover = new ButtonStyle(other.Hover);
        Pressed = new ButtonStyle(other.Pressed);
        Disabled = new ButtonStyle(other.Disabled);
        Focused = new ButtonStyle(other.Focused);
        Active = new ButtonStyle(other.Active);
        ActiveHover = new ButtonStyle(other.ActiveHover);
        Animation = other.Animation; // Copy animation info
        Current = Normal; // Reset current to normal
    }


    public void UpdateCurrentStyle(bool isHovering, bool isPressed, bool isDisabled, bool isFocused, bool isActive = false)
    {
        if (isDisabled)
        {
            Current = Disabled;
        }
        else if (isPressed)
        {
            Current = Pressed;
        }
        else if (isActive)
        {
            Current = isHovering ? ActiveHover : Active;
        }
        else if (isHovering)
        {
            Current = Hover;
        }
        else if (isFocused)
        {
            Current = Focused;
        }
        else
        {
            Current = Normal;
        }
    }

    private IEnumerable<ButtonStyle> AllStyles => [Normal, Hover, Pressed, Disabled, Focused, Active, ActiveHover];

    public string FontName
    {
        set => SetAll(s => s.FontName = value);
    }

    public float FontSize
    {
        set => SetAll(s => s.FontSize = value);
    }

    public FontWeight FontWeight
    {
        set => SetAll(s => s.FontWeight = value);
    }

    public FontStyle FontStyle
    {
        set => SetAll(s => s.FontStyle = value);
    }

    public FontStretch FontStretch
    {
        set => SetAll(s => s.FontStretch = value);
    }

    public Color4 FontColor
    {
        set => SetAll(s => s.FontColor = value);
    }

    public float Roundness
    {
        set => SetAll(s => s.Roundness = value);
    }

    public float BorderLength
    {
        set => SetAll(s => s.BorderLength = value);
    }

    public Color4 FillColor
    {
        set => SetAll(s => s.FillColor = value);
    }

    public Color4 BorderColor
    {
        set => SetAll(s => s.BorderColor = value);
    }

    private void SetAll(Action<ButtonStyle> setter)
    {
        foreach (ButtonStyle style in AllStyles)
        {
            setter(style);
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\DefaultTheme.cs">
// DefaultTheme.cs
using DirectUI.Drawing;

namespace DirectUI;

// Defines default colors for the UI theme
public static class DefaultTheme
{
    // --- Theme Color Definitions ---

    private static class DAWThemeColors
    {
        // Palette inspired by modern DAWs like Ableton Live
        public static readonly Color Control = new Color(75, 75, 75, 255);          // #4B4B4B
        public static readonly Color ControlHover = new Color(90, 90, 90, 255);       // #5A5A5A
        public static readonly Color Border = new Color(30, 30, 30, 255);         // #1E1E1E

        public static readonly Color Accent = new Color(0, 190, 190, 255);        // A bright teal #00BEBE
        public static readonly Color AccentBorder = new Color(128, 222, 222, 255);   // Lighter teal

        public static readonly Color DisabledFill = new Color(55, 55, 55, 255);
        public static readonly Color DisabledBorder = new Color(40, 40, 40, 255);
        public static readonly Color DisabledText = new Color(128, 128, 128, 255);

        public static readonly Color Text = new Color(221, 221, 221, 255);     // #DDDDDD
    }

    private static class Ue5ThemeColors
    {
        // Palette based on Unreal Engine 5 Editor
        public static readonly Color Fill = new Color(42, 42, 42, 255);        // #2A2A2A
        public static readonly Color FillLighter = new Color(58, 58, 58, 255);  // #3A3A3A
        public static readonly Color Border = new Color(21, 21, 21, 255);      // #151515 (Matches window background)

        // --- CHANGE HERE ---
        // Changed from blue to a light gray for a more authentic UE5 feel.
        public static readonly Color Hover = new Color(160, 160, 160, 255);   // #A0A0A0
        // --- END CHANGE ---

        public static readonly Color Accent = new Color(255, 171, 0, 255);     // Orange #FFAB00
        public static readonly Color AccentBorder = new Color(255, 187, 51, 255); // Lighter Orange

        public static readonly Color DisabledFill = new Color(32, 32, 32, (byte)(255 * 0.8f));
        public static readonly Color DisabledBorder = new Color(48, 48, 48, (byte)(255 * 0.8f));
        public static readonly Color DisabledText = new Color(128, 128, 128, 255);

        public static readonly Color Text = new Color(240, 240, 240, 255);     // #F0F0F0
    }

    private static class OriginalColors
    {
        public static readonly Color NormalFill = new Color(64, 64, 77, 255);
        public static readonly Color NormalBorder = new Color(102, 102, 115, 255);
        public static readonly Color HoverFill = new Color(89, 89, 102, 255);
        public static readonly Color HoverBorder = new Color(128, 128, 140, 255);
        public static readonly Color Accent = new Color(51, 102, 204, 255);
        public static readonly Color AccentBorder = new Color(77, 128, 230, 255);
        public static readonly Color DisabledFill = new Color(51, 51, 51, (byte)(255 * 0.8f));
        public static readonly Color DisabledBorder = new Color(77, 77, 77, (byte)(255 * 0.8f));
        public static readonly Color DisabledText = new Color(128, 128, 128, 255);
        public static readonly Color Text = Colors.WhiteSmoke;
    }

    private static class UnityEditorThemeColors
    {
        // Palette based on Unity Editor's default dark theme (Pro skin)
        public static readonly Color Fill = new Color(56, 56, 56, 255);         // #383838 - Standard control background
        public static readonly Color Border = new Color(35, 35, 35, 255);        // #232323 - Dark, subtle border
        public static readonly Color SelectionBlue = new Color(62, 95, 150, 255); // #3E5F96 - The iconic blue for selections/presses
        public static readonly Color SelectionBlueBorder = new Color(75, 116, 185, 255); // #4B74B9 - Brighter blue for hover/focus borders

        public static readonly Color DisabledFill = new Color(56, 56, 56, (byte)(255 * 0.8f));
        public static readonly Color DisabledBorder = new Color(32, 32, 32, (byte)(255 * 0.8f));
        public static readonly Color DisabledText = new Color(128, 128, 128, 255);

        public static readonly Color Text = new Color(207, 207, 207, 255);       // #CFCFCF
    }


    // --- Current Active Theme ---
    // Change the assignments here to swap themes.

    // Basic Palette
    public static readonly Color White = Colors.White;
    public static readonly Color Black = Colors.Black;
    public static readonly Color Transparent = Colors.Transparent;

    /*
    // --- ACTIVE THEME: DAW ---
    public static readonly Color NormalFill = DAWThemeColors.Control;
    public static readonly Color NormalBorder = DAWThemeColors.Border;
    public static readonly Color HoverFill = DAWThemeColors.ControlHover;
    public static readonly Color HoverBorder = DAWThemeColors.Accent; // Use Accent for hover border for clarity
    public static readonly Color Accent = DAWThemeColors.Accent;
    public static readonly Color AccentBorder = DAWThemeColors.AccentBorder;
    public static readonly Color DisabledFill = DAWThemeColors.DisabledFill;
    public static readonly Color DisabledBorder = DAWThemeColors.DisabledBorder;
    public static readonly Color DisabledText = DAWThemeColors.DisabledText;
    public static readonly Color FocusBorder = DAWThemeColors.Accent; // Use Accent for focus border
    public static readonly Color Text = DAWThemeColors.Text;
    */

    /*
    // --- ACTIVE THEME: Unity Editor (Dark) ---
    public static readonly Color NormalFill = UnityEditorThemeColors.Fill;
    public static readonly Color NormalBorder = UnityEditorThemeColors.Border;
    public static readonly Color HoverFill = UnityEditorThemeColors.Fill; // Fill does not change on hover in Unity
    public static readonly Color HoverBorder = UnityEditorThemeColors.SelectionBlueBorder; // Border becomes blue on hover
    public static readonly Color Accent = UnityEditorThemeColors.SelectionBlue; // Accent is the pressed/active color
    public static readonly Color AccentBorder = UnityEditorThemeColors.SelectionBlueBorder;
    public static readonly Color DisabledFill = UnityEditorThemeColors.DisabledFill;
    public static readonly Color DisabledBorder = UnityEditorThemeColors.DisabledBorder;
    public static readonly Color DisabledText = UnityEditorThemeColors.DisabledText;
    public static readonly Color FocusBorder = UnityEditorThemeColors.SelectionBlueBorder; // Focus also uses the blue border
    public static readonly Color Text = UnityEditorThemeColors.Text;
    */

    // --- ACTIVE THEME: Original ---
    public static readonly Color NormalFill = OriginalColors.NormalFill;
    public static readonly Color NormalBorder = OriginalColors.NormalBorder;
    public static readonly Color HoverFill = OriginalColors.HoverFill;
    public static readonly Color HoverBorder = OriginalColors.HoverBorder;
    public static readonly Color Accent = OriginalColors.Accent;
    public static readonly Color AccentBorder = OriginalColors.AccentBorder;
    public static readonly Color DisabledFill = OriginalColors.DisabledFill;
    public static readonly Color DisabledBorder = OriginalColors.DisabledBorder;
    public static readonly Color DisabledText = OriginalColors.DisabledText;
    public static readonly Color FocusBorder = new Color(135, 206, 250, 255); // LightSkyBlue
    public static readonly Color Text = OriginalColors.Text;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\KnobStyle.cs">
using DirectUI.Drawing;

namespace DirectUI;

public class KnobStyle
{
    /// <summary>
    /// Style for the main body of the knob.
    /// </summary>
    public BoxStyle BaseStyle { get; set; } = new();

    /// <summary>
    /// Color of the indicator line.
    /// </summary>
    public Color IndicatorColor { get; set; } = DefaultTheme.Accent;

    /// <summary>
    /// Thickness of the indicator line.
    /// </summary>
    public float IndicatorThickness { get; set; } = 2.0f;

    /// <summary>
    /// The start angle of the knob's rotation in degrees. (e.g., -135 for bottom-left start).
    /// </summary>
    public float StartAngleDegrees { get; set; } = -135f;

    /// <summary>
    /// The total range of motion for the knob in degrees. (e.g., 270 for a 3/4 turn).
    /// </summary>
    public float AngleRangeDegrees { get; set; } = 270f;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\SliderStyle.cs">
namespace DirectUI;

public class SliderStyle
{
    public BoxStyle Background { get; set; } = new()
    {
        FillColor = DefaultTheme.DisabledFill,
        BorderColor = DefaultTheme.NormalBorder,
        Roundness = 0.5f,
        BorderLength = 1.0f
    };

    public BoxStyle Foreground { get; set; } = new()
    {
        FillColor = DefaultTheme.Accent,
        BorderColor = DefaultTheme.Transparent,
        Roundness = 0.5f,
        BorderLength = 0.0f
    };
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\StyleManager.cs">
// DirectUI/Source/Styling/StyleManager.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Numerics;
using DirectUI.Animation;
using DirectUI.Drawing;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace DirectUI.Styling;

public static class StyleManager
{
    private static readonly Dictionary<string, object> s_styleCache = new();
    private static readonly IDeserializer s_yamlDeserializer = new DeserializerBuilder()
        .WithNamingConvention(PascalCaseNamingConvention.Instance)
        .Build();

    public static void LoadStylesFromFile(string filePath)
    {
        if (!File.Exists(filePath))
        {
            Console.WriteLine($"[StyleManager] Warning: Style file not found at '{filePath}'.");
            return;
        }

        try
        {
            string yamlContent = File.ReadAllText(filePath);
            var yamlStyles = s_yamlDeserializer.Deserialize<Dictionary<string, YamlButtonStylePack>>(yamlContent);

            foreach (var kvp in yamlStyles)
            {
                var stylePack = ConvertFromYaml(kvp.Value);
                s_styleCache[kvp.Key] = stylePack;
            }

            Console.WriteLine($"[StyleManager] Successfully loaded {yamlStyles.Count} styles from '{filePath}'.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[StyleManager] Error loading styles from '{filePath}': {ex.Message}");
        }
    }

    public static T Get<T>(string key) where T : class, new()
    {
        if (s_styleCache.TryGetValue(key, out var style))
        {
            if (style is T typedStyle)
            {
                // Return a copy to prevent modification of the cached master style.
                if (typedStyle is ButtonStylePack bsp)
                {
                    return new ButtonStylePack(bsp) as T ?? new T();
                }
                // Add other copy-constructible style types here in the future
                return typedStyle;
            }
        }
        Console.WriteLine($"[StyleManager] Warning: Style key '{key}' not found. Returning new default style.");
        return new T();
    }

    private static ButtonStylePack ConvertFromYaml(YamlButtonStylePack yamlPack)
    {
        var pack = new ButtonStylePack();

        // Apply pack-level properties to all styles first
        if (yamlPack.Roundness.HasValue) pack.Roundness = yamlPack.Roundness.Value;
        if (yamlPack.BorderLength.HasValue) pack.BorderLength = yamlPack.BorderLength.Value;
        if (yamlPack.FontName is not null) pack.FontName = yamlPack.FontName;
        if (yamlPack.FontSize.HasValue) pack.FontSize = yamlPack.FontSize.Value;
        if (yamlPack.FontWeight.HasValue) pack.FontWeight = yamlPack.FontWeight.Value;
        if (yamlPack.FontStyle.HasValue) pack.FontStyle = yamlPack.FontStyle.Value;
        if (yamlPack.FontStretch.HasValue) pack.FontStretch = yamlPack.FontStretch.Value;

        // Apply global animation info (acts as a fallback)
        if (yamlPack.Animation is not null)
        {
            pack.Animation = new AnimationInfo(
                yamlPack.Animation.Duration ?? 0.15f,
                Easing.GetEasingFunction(yamlPack.Animation.Easing)
            );
        }

        // Apply specific style overrides, including per-state animations
        ApplyYamlStyle(pack.Normal, yamlPack.Normal);
        ApplyYamlStyle(pack.Hover, yamlPack.Hover);
        ApplyYamlStyle(pack.Pressed, yamlPack.Pressed);
        ApplyYamlStyle(pack.Disabled, yamlPack.Disabled);
        ApplyYamlStyle(pack.Focused, yamlPack.Focused);
        ApplyYamlStyle(pack.Active, yamlPack.Active);
        ApplyYamlStyle(pack.ActiveHover, yamlPack.ActiveHover);

        return pack;
    }

    private static void ApplyYamlStyle(ButtonStyle target, YamlButtonStyle? source)
    {
        if (source is null) return;

        // BoxStyle properties
        if (source.Roundness.HasValue) target.Roundness = source.Roundness.Value;
        if (source.FillColor is not null) target.FillColor = ParseColor(source.FillColor);
        if (source.BorderColor is not null) target.BorderColor = ParseColor(source.BorderColor);
        if (source.BorderLength.HasValue) target.BorderLength = source.BorderLength.Value;
        if (source.BorderLengthTop.HasValue) target.BorderLengthTop = source.BorderLengthTop.Value;
        if (source.BorderLengthRight.HasValue) target.BorderLengthRight = source.BorderLengthRight.Value;
        if (source.BorderLengthBottom.HasValue) target.BorderLengthBottom = source.BorderLengthBottom.Value;
        if (source.BorderLengthLeft.HasValue) target.BorderLengthLeft = source.BorderLengthLeft.Value;

        // ButtonStyle properties
        if (source.FontColor is not null) target.FontColor = ParseColor(source.FontColor);
        if (source.FontName is not null) target.FontName = source.FontName;
        if (source.FontSize.HasValue) target.FontSize = source.FontSize.Value;
        if (source.FontWeight.HasValue) target.FontWeight = source.FontWeight.Value;
        if (source.FontStyle.HasValue) target.FontStyle = source.FontStyle.Value;
        if (source.FontStretch.HasValue) target.FontStretch = source.FontStretch.Value;
        if (source.Scale is not null && source.Scale.Count == 2) target.Scale = new Vector2(source.Scale[0], source.Scale[1]);

        // Per-state animation
        if (source.Animation is not null)
        {
            target.Animation = new AnimationInfo(
                source.Animation.Duration ?? 0.15f,
                Easing.GetEasingFunction(source.Animation.Easing)
            );
        }
    }

    private static Color ParseColor(object? colorObj)
    {
        if (colorObj is null)
        {
            Console.WriteLine($"[StyleManager] Warning: Null color value provided. Defaulting to transparent.");
            return Colors.Transparent;
        }

        // Case 1: Hex string like "#RRGGBB" or "#RRGGBBAA"
        if (colorObj is string colorStr)
        {
            if (string.IsNullOrEmpty(colorStr) || !colorStr.StartsWith("#"))
            {
                Console.WriteLine($"[StyleManager] Warning: Invalid hex color format '{colorStr}'. Defaulting to transparent.");
                return Colors.Transparent;
            }

            try
            {
                if (colorStr.Length != 7 && colorStr.Length != 9)
                    throw new FormatException("Hex color must be in #RRGGBB or #RRGGBBAA format.");

                byte r = Convert.ToByte(colorStr.Substring(1, 2), 16);
                byte g = Convert.ToByte(colorStr.Substring(3, 2), 16);
                byte b = Convert.ToByte(colorStr.Substring(5, 2), 16);
                byte a = 255;
                if (colorStr.Length == 9)
                {
                    a = Convert.ToByte(colorStr.Substring(7, 2), 16);
                }
                return new Color(r, g, b, a);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[StyleManager] Warning: Could not parse hex color '{colorStr}'. Error: {ex.Message}. Defaulting to transparent.");
                return Colors.Transparent;
            }
        }

        // Case 2: List of numbers like [R, G, B] or [R, G, B, A]
        if (colorObj is List<object> colorList)
        {
            try
            {
                var byteValues = colorList.Select(o => Convert.ToByte(o)).ToList();
                if (byteValues.Count == 3)
                {
                    return new Color(byteValues[0], byteValues[1], byteValues[2], 255);
                }
                if (byteValues.Count == 4)
                {
                    return new Color(byteValues[0], byteValues[1], byteValues[2], byteValues[3]);
                }
                throw new FormatException($"Color list must contain 3 (RGB) or 4 (RGBA) values. Found {byteValues.Count}.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[StyleManager] Warning: Could not parse color from list. Error: {ex.Message}. Defaulting to transparent.");
                return Colors.Transparent;
            }
        }

        Console.WriteLine($"[StyleManager] Warning: Unrecognized color format type '{colorObj.GetType().Name}'. Defaulting to transparent.");
        return Colors.Transparent;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\TabStyle.cs">
namespace DirectUI;

public class TabStyle : ButtonStyle
{
    // For now, this is a marker class. It can hold tab-specific style properties later.
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\TabStylePack.cs">
using Vortice.Mathematics;

namespace DirectUI;

public sealed class TabStylePack
{
    public TabStyle Current { get; private set; }
    public TabStyle Normal { get; set; } = new();
    public TabStyle Hover { get; set; } = new();
    public TabStyle Active { get; set; } = new();
    public TabStyle ActiveHover { get; set; } = new();
    public TabStyle Disabled { get; set; } = new();

    public TabStylePack()
    {
        var panelBg = new Color4(37 / 255f, 37 / 255f, 38 / 255f, 1.0f);
        var hoverBorder = DefaultTheme.HoverBorder;
        var accentBorder = DefaultTheme.AccentBorder;

        string fontName = "Segoe UI";
        float fontSize = 14f;

        // Inactive tab
        Normal.FillColor = DefaultTheme.NormalFill;
        Normal.BorderColor = DefaultTheme.NormalBorder;
        Normal.BorderLength = 1f;
        Normal.Roundness = 0f;
        Normal.FontName = fontName; Normal.FontSize = fontSize;

        // Inactive tab, hovered
        Hover.FillColor = DefaultTheme.HoverFill;
        Hover.BorderColor = hoverBorder;
        Hover.BorderLength = 1f;
        Hover.Roundness = 0f;
        Hover.FontName = fontName; Hover.FontSize = fontSize;

        // Active tab
        Active.FillColor = panelBg;
        Active.BorderColor = hoverBorder;
        Active.BorderLengthTop = 1f; Active.BorderLengthLeft = 1f; Active.BorderLengthRight = 1f; Active.BorderLengthBottom = 0f;
        Active.Roundness = 0f;
        Active.FontName = fontName; Active.FontSize = fontSize;

        // Active tab, hovered
        ActiveHover.FillColor = panelBg;
        ActiveHover.BorderColor = accentBorder;
        ActiveHover.BorderLengthTop = 1f; ActiveHover.BorderLengthLeft = 1f; ActiveHover.BorderLengthRight = 1f; ActiveHover.BorderLengthBottom = 0f;
        ActiveHover.Roundness = 0f;
        ActiveHover.FontName = fontName; ActiveHover.FontSize = fontSize;

        Disabled.FillColor = DefaultTheme.DisabledFill;
        Disabled.BorderColor = DefaultTheme.DisabledBorder;
        Disabled.FontColor = DefaultTheme.DisabledText;
        Disabled.FontName = fontName; Disabled.FontSize = fontSize;

        Current = Normal;
    }

    public void UpdateCurrentStyle(bool isHovering, bool isActive, bool isDisabled, bool isFocused)
    {
        if (isDisabled)
        {
            Current = Disabled;
        }
        else if (isActive) Current = isHovering ? ActiveHover : Active;
        else if (isHovering) Current = Hover;
        else
        {
            Current = Normal;
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\TreeStyle.cs">
using DirectUI.Drawing;

namespace DirectUI;

public class TreeStyle
{
    public float Indent { get; set; } = 19f;
    public float RowHeight { get; set; } = 24f; // Increased from 22f to accommodate font descenders
    public Color LineColor { get; set; } = DefaultTheme.HoverBorder;
    public ButtonStylePack ToggleStyle { get; set; }
    public ButtonStylePack NodeLabelStyle { get; set; }

    public TreeStyle()
    {
        ToggleStyle = new ButtonStylePack
        {
            Roundness = 0.2f,
            BorderLength = 1f,
            FontName = "Consolas",
            FontSize = 14
        };
        ToggleStyle.Normal.FillColor = DefaultTheme.NormalFill;
        ToggleStyle.Normal.BorderColor = DefaultTheme.NormalBorder;
        ToggleStyle.Hover.FillColor = DefaultTheme.HoverFill;
        ToggleStyle.Hover.BorderColor = DefaultTheme.HoverBorder;
        ToggleStyle.Pressed.FillColor = DefaultTheme.Accent;
        ToggleStyle.Pressed.BorderColor = DefaultTheme.AccentBorder;

        NodeLabelStyle = new ButtonStylePack
        {
            Roundness = 0f,
            BorderLength = 0f,
            FontName = "Segoe UI",
            FontSize = 14
        };
        NodeLabelStyle.Normal.FillColor = DefaultTheme.Transparent;
        NodeLabelStyle.Normal.FontColor = DefaultTheme.Text;
        NodeLabelStyle.Hover.FillColor = new Color(64, 64, 64, 128); // Semi-transparent gray
        NodeLabelStyle.Hover.FontColor = DefaultTheme.Text;
        NodeLabelStyle.Pressed.FillColor = DefaultTheme.Accent;
        NodeLabelStyle.Pressed.FontColor = DefaultTheme.White;
        NodeLabelStyle.Pressed.BorderColor = DefaultTheme.AccentBorder;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\YamlStyleModels.cs">
// DirectUI/Source/Styling/YamlStyleModels.cs
using System;
using System.Collections.Generic;
using DirectUI.Animation;
using Silk.NET.OpenAL;
using Silk.NET.Vulkan;
using System.Threading.Channels;
using Vortice.Direct2D1.Effects;
using Vortice.DirectWrite;

namespace DirectUI.Styling;

internal class YamlAnimationInfo
{
    public float? Duration { get; set; }
    public string? Easing { get; set; }
}

internal class YamlButtonStyle
{
    // BoxStyle properties
    public float? Roundness { get; set; }
    public object? FillColor { get; set; }
    public object? BorderColor { get; set; }
    public float? BorderLength { get; set; }
    public float? BorderLengthTop { get; set; }
    public float? BorderLengthRight { get; set; }
    public float? BorderLengthBottom { get; set; }
    public float? BorderLengthLeft { get; set; }

    // ButtonStyle properties
    public object? FontColor { get; set; }
    public string? FontName { get; set; }
    public float? FontSize { get; set; }
    public FontWeight? FontWeight { get; set; }
    public FontStyle? FontStyle { get; set; }
    public FontStretch? FontStretch { get; set; }
    public List<float>? Scale { get; set; }

    // State-specific animation
    public YamlAnimationInfo? Animation { get; set; }
}

internal class YamlButtonStylePack
{
    // Properties to match ButtonStylePack states
    public YamlButtonStyle? Normal { get; set; }
    public YamlButtonStyle? Hover { get; set; }
    public YamlButtonStyle? Pressed { get; set; }
    public YamlButtonStyle? Disabled { get; set; }
    public YamlButtonStyle? Focused { get; set; }
    public YamlButtonStyle? Active { get; set; }
    public YamlButtonStyle? ActiveHover { get; set; }

    // Properties that can be set on the pack level
    public float? Roundness { get; set; }
    public float? BorderLength { get; set; }
    public string? FontName { get; set; }
    public float? FontSize { get; set; }
    public FontWeight? FontWeight { get; set; }
    public FontStyle? FontStyle { get; set; }
    public FontStretch? FontStretch { get; set; }

    // Global/fallback animation properties for the pack
    public YamlAnimationInfo? Animation { get; set; }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\Button.cs">
namespace DirectUI;

public static class Button
{
    public enum ActionMode { Release, Press }
    public enum ClickBehavior { Left, Right, Both }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\DataGridColumn.cs">
// DirectUI/Source/Widgets/DataGridColumn.cs
namespace DirectUI;

/// <summary>
/// Defines a column for the DataGrid control.
/// </summary>
public class DataGridColumn
{
    /// <summary>
    /// The text displayed in the column header.
    /// </summary>
    public string HeaderText { get; }

    /// <summary>
    /// The initial width of the column. This can be changed by the user resizing the column.
    /// </summary>
    public float InitialWidth { get; }

    /// <summary>
    /// The name of the public property on the data item object from which to retrieve the cell value.
    /// </summary>
    public string DataPropertyName { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="DataGridColumn"/> class.
    /// </summary>
    /// <param name="headerText">The text to display in the column header.</param>
    /// <param name="initialWidth">The initial width of the column.</param>
    /// <param name="dataPropertyName">The name of the public property to bind to.</param>
    public DataGridColumn(string headerText, float initialWidth, string dataPropertyName)
    {
        HeaderText = headerText;
        InitialWidth = initialWidth;
        DataPropertyName = dataPropertyName;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\InputText.cs">
// Widgets/LineEdit.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using DirectUI.Core;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1; // Still used for AntialiasMode enum
using Vortice.DirectWrite; // Still used for WordWrapping, TextAlignment, ParagraphAlignment

namespace DirectUI;

// Logic and drawing for an immediate-mode LineEdit control. This class is STATELESS.
// All persistent state is managed in a separate LineEditState object.
internal class InputText
{
    // === MAIN UPDATE && DRAW METHOD ===
    public bool UpdateAndDraw(
        int intId,
        ref string text,
        InputTextState state, // The state is now passed in
        Vector2 position,
        Vector2 size,
        ButtonStylePack? theme,
        string placeholderText,
        bool isPassword,
        char passwordChar,
        int maxLength,
        bool disabled,
        Vector2 textMargin)
    {
        var context = UI.Context;
        var uiState = UI.State;
        var renderer = context.Renderer;
        var textService = context.TextService;
        var input = context.InputState;

        var themeId = HashCode.Combine(intId, "theme");
        var finalTheme = theme ?? uiState.GetOrCreateElement<ButtonStylePack>(themeId);

        // If no specific theme was provided, configure the default one for a LineEdit look.
        if (theme is null)
        {
            // This setup runs once per widget instance and is then cached.
            finalTheme.Roundness = 0.2f; // Softer corners
            finalTheme.BorderLength = 1f;

            // Normal state (dark, inset look)
            finalTheme.Normal.FillColor = new Color4(30 / 255f, 30 / 255f, 30 / 255f, 1.0f); // Even darker than controls
            finalTheme.Normal.BorderColor = DefaultTheme.NormalBorder;

            // Hover state (subtle border highlight)
            finalTheme.Hover.FillColor = finalTheme.Normal.FillColor;
            finalTheme.Hover.BorderColor = DefaultTheme.HoverBorder;

            // Focused state (bright border)
            finalTheme.Focused.FillColor = finalTheme.Normal.FillColor;
            finalTheme.Focused.BorderColor = DefaultTheme.FocusBorder;

            // Disabled state
            finalTheme.Disabled.FillColor = finalTheme.Normal.FillColor;
            finalTheme.Disabled.BorderColor = DefaultTheme.DisabledBorder;
        }

        Rect bounds = new(position.X, position.Y, size.X, size.Y);
        bool textChanged = false;

        bool isHovering = bounds.Contains(input.MousePosition.X, input.MousePosition.Y);
        if (isHovering)
        {
            uiState.SetPotentialInputTarget(intId);
        }

        bool isPressed = uiState.ActivelyPressedElementId == intId;
        bool isFocused = uiState.FocusedElementId == intId;

        finalTheme.UpdateCurrentStyle(isHovering, isPressed, disabled, isFocused);
        var currentStyle = finalTheme.Current;

        // --- Mouse Input for Selection and Caret ---
        // Handle mouse dragging to select text
        if (isPressed && input.IsLeftMouseDown && input.MousePosition != input.PreviousMousePosition)
        {
            int newCaretPos = GetCaretPositionFromMouse(input.MousePosition, text, state, isPassword, passwordChar, currentStyle, bounds, textMargin, textService);
            if (newCaretPos != state.CaretPosition)
            {
                state.CaretPosition = newCaretPos;
                UpdateView(text, state, size, textMargin);
            }
        }
        // Handle initial mouse press
        else if (input.WasLeftMousePressedThisFrame && isHovering && !disabled && uiState.PotentialInputTargetId == intId)
        {
            if (uiState.TrySetActivePress(intId, 1))
            {
                uiState.SetFocus(intId);

                int newCaretPos = GetCaretPositionFromMouse(input.MousePosition, text, state, isPassword, passwordChar, currentStyle, bounds, textMargin, textService);

                bool isShiftHeld = input.HeldKeys.Contains(Keys.Shift);
                if (!isShiftHeld)
                {
                    state.SelectionAnchor = newCaretPos;
                }
                state.CaretPosition = newCaretPos;

                state.IsBlinkOn = true;
                state.BlinkTimer = 0;
                UpdateView(text, state, size, textMargin);
            }
        }

        if (isPressed && !input.IsLeftMouseDown)
        {
            uiState.ClearActivePress(intId);
        }


        // --- Keyboard Input Processing ---
        if (isFocused && !disabled)
        {
            textChanged = ProcessInput(ref text, state, size, maxLength, textMargin, input);
        }

        // --- Drawing ---
        renderer.DrawBox(bounds, finalTheme.Current);

        // Define content area and clip to it
        Rect contentRect = new Rect(
            bounds.X + textMargin.X,
            bounds.Y + textMargin.Y,
            Math.Max(0, bounds.Width - textMargin.X * 2),
            Math.Max(0, bounds.Height - textMargin.Y * 2)
        );
        renderer.PushClipRect(contentRect, D2D.AntialiasMode.PerPrimitive);

        string textToDraw;
        ButtonStyle styleToDraw;

        if (string.IsNullOrEmpty(text) && !isFocused)
        {
            textToDraw = placeholderText;
            styleToDraw = new ButtonStyle(finalTheme.Disabled)
            {
                FontColor = new Color4(100 / 255f, 100 / 255f, 100 / 255f, 1.0f) // Custom placeholder color
            };
        }
        else
        {
            textToDraw = isPassword ? new string(passwordChar, text.Length) : text;
            styleToDraw = finalTheme.Current;
        }

        DrawSelectionHighlight(textToDraw, state, styleToDraw, contentRect);
        DrawVisibleText(textToDraw, state, size, styleToDraw, contentRect.TopLeft);

        if (isFocused && state.IsBlinkOn)
        {
            DrawCaret(textToDraw, state, size, finalTheme.Current, contentRect);
        }

        renderer.PopClipRect();

        return textChanged;
    }

    private int GetCaretPositionFromMouse(Vector2 mousePos, string text, InputTextState state, bool isPassword, char passwordChar, ButtonStyle style, Rect widgetBounds, Vector2 textMargin, ITextService textService)
    {
        var textForHitTest = isPassword ? new string(passwordChar, text.Length) : text;
        var contentRectForHitTest = new Rect(
            widgetBounds.X + textMargin.X,
            widgetBounds.Y + textMargin.Y,
            Math.Max(0, widgetBounds.Width - textMargin.X * 2),
            Math.Max(0, widgetBounds.Height - textMargin.Y * 2)
        );

        var textLayout = textService.GetTextLayout(textForHitTest, style, new(float.MaxValue, widgetBounds.Height), new Alignment(HAlignment.Left, VAlignment.Center));
        if (textLayout is null) return state.CaretPosition;

        float relativeClickX = mousePos.X - contentRectForHitTest.Left + state.ScrollPixelOffset;
        float relativeClickY = mousePos.Y - contentRectForHitTest.Top;
        var hitTestResult = textLayout.HitTestPoint(new Vector2(relativeClickX, relativeClickY));

        int newCaretPos = hitTestResult.TextPosition;
        if (hitTestResult.IsTrailingHit) newCaretPos++;
        return Math.Clamp(newCaretPos, 0, text.Length);
    }

    private bool ProcessInput(ref string text, InputTextState state, Vector2 size, int maxLength, Vector2 textMargin, InputState input)
    {
        bool textChanged = false;

        state.BlinkTimer += UI.Context.DeltaTime;

        if (state.BlinkTimer > 0.5f)
        {
            state.BlinkTimer = 0;
            state.IsBlinkOn = !state.IsBlinkOn;
        }

        bool isCtrlHeld = input.HeldKeys.Contains(Keys.Control);
        bool isShiftHeld = input.HeldKeys.Contains(Keys.Shift);

        if (input.TypedCharacters.Any())
        {
            PushUndoState(text, state);

            if (state.HasSelection)
            {
                text = text.Remove(state.SelectionStart, state.SelectionEnd - state.SelectionStart);
                state.CaretPosition = state.SelectionStart;
                textChanged = true;
            }

            foreach (char c in input.TypedCharacters)
            {
                if (text.Length >= maxLength) continue;
                text = text.Insert(state.CaretPosition, c.ToString());
                state.CaretPosition++;
                textChanged = true;
            }

            if (textChanged)
            {
                state.SelectionAnchor = state.CaretPosition;
            }
        }

        foreach (var key in input.PressedKeys)
        {
            bool hasTextChangedThisKey = false;
            PushUndoState(text, state); // Push on first key press
            switch (key)
            {
                case Keys.A when isCtrlHeld:
                    state.SelectionAnchor = 0;
                    state.CaretPosition = text.Length;
                    break;
                case Keys.Backspace:
                    if (state.HasSelection)
                    {
                        text = text.Remove(state.SelectionStart, state.SelectionEnd - state.SelectionStart);
                        state.CaretPosition = state.SelectionStart;
                        state.SelectionAnchor = state.CaretPosition;
                        hasTextChangedThisKey = true;
                    }
                    else if (state.CaretPosition > 0)
                    {
                        int removeCount = 1;
                        if (isCtrlHeld) removeCount = state.CaretPosition - FindPreviousWordStart(text, state.CaretPosition);
                        text = text.Remove(state.CaretPosition - removeCount, removeCount);
                        state.CaretPosition -= removeCount;
                        state.SelectionAnchor = state.CaretPosition;
                        hasTextChangedThisKey = true;
                    }
                    break;
                case Keys.Delete:
                    if (state.HasSelection)
                    {
                        text = text.Remove(state.SelectionStart, state.SelectionEnd - state.SelectionStart);
                        state.CaretPosition = state.SelectionStart;
                        state.SelectionAnchor = state.CaretPosition;
                        hasTextChangedThisKey = true;
                    }
                    else if (state.CaretPosition < text.Length)
                    {
                        int removeCount = 1;
                        if (isCtrlHeld) removeCount = FindNextWordEnd(text, state.CaretPosition) - state.CaretPosition;
                        text = text.Remove(state.CaretPosition, removeCount);
                        state.SelectionAnchor = state.CaretPosition;
                        hasTextChangedThisKey = true;
                    }
                    break;
                case Keys.LeftArrow:
                    if (isShiftHeld)
                    {
                        var newPos = isCtrlHeld ? FindPreviousWordStart(text, state.CaretPosition) : state.CaretPosition - 1;
                        state.CaretPosition = Math.Max(0, newPos);
                    }
                    else
                    {
                        var newPos = state.HasSelection ? state.SelectionStart : (isCtrlHeld ? FindPreviousWordStart(text, state.CaretPosition) : state.CaretPosition - 1);
                        state.CaretPosition = Math.Max(0, newPos);
                        state.SelectionAnchor = state.CaretPosition;
                    }
                    break;
                case Keys.RightArrow:
                    if (isShiftHeld)
                    {
                        var newPos = isCtrlHeld ? FindNextWordEnd(text, state.CaretPosition) : state.CaretPosition + 1;
                        state.CaretPosition = Math.Min(text.Length, newPos);
                    }
                    else
                    {
                        var newPos = state.HasSelection ? state.SelectionEnd : (isCtrlHeld ? FindNextWordEnd(text, state.CaretPosition) : state.CaretPosition + 1);
                        state.CaretPosition = Math.Min(text.Length, newPos);
                        state.SelectionAnchor = state.CaretPosition;
                    }
                    break;
                case Keys.Home:
                    state.CaretPosition = 0;
                    if (!isShiftHeld) state.SelectionAnchor = state.CaretPosition;
                    break;
                case Keys.End:
                    state.CaretPosition = text.Length;
                    if (!isShiftHeld) state.SelectionAnchor = state.CaretPosition;
                    break;
                case Keys.Z when isCtrlHeld: Undo(ref text, state); hasTextChangedThisKey = true; break;
                case Keys.Y when isCtrlHeld: Redo(ref text, state); hasTextChangedThisKey = true; break;
            }
            if (hasTextChangedThisKey) textChanged = true;
        }

        state.CaretPosition = Math.Clamp(state.CaretPosition, 0, text.Length);

        if (textChanged || input.PressedKeys.Any(k => k is Keys.LeftArrow or Keys.RightArrow or Keys.Home or Keys.End || (k == Keys.A && isCtrlHeld)))
        {
            UpdateView(text, state, size, textMargin);
            state.IsBlinkOn = true;
            state.BlinkTimer = 0;
        }

        return textChanged;
    }

    private static int FindPreviousWordStart(string text, int currentPos)
    {
        if (currentPos == 0) return 0;
        int pos = currentPos - 1;
        while (pos > 0 && char.IsWhiteSpace(text[pos])) pos--;
        while (pos > 0 && !char.IsWhiteSpace(text[pos - 1])) pos--;
        return pos;
    }

    private static int FindNextWordEnd(string text, int currentPos)
    {
        if (currentPos >= text.Length) return text.Length;
        int pos = currentPos;
        while (pos < text.Length && char.IsWhiteSpace(text[pos])) pos++;
        while (pos < text.Length && !char.IsWhiteSpace(text[pos])) pos++;
        while (pos < text.Length && char.IsWhiteSpace(text[pos])) pos++;
        return pos;
    }

    private void DrawSelectionHighlight(string text, InputTextState state, ButtonStyle style, Rect contentRect)
    {
        if (!state.HasSelection) return;

        var textService = UI.Context.TextService;
        var renderer = UI.Context.Renderer;

        var textLayout = textService.GetTextLayout(text, style, new(float.MaxValue, contentRect.Height), new Alignment(HAlignment.Left, VAlignment.Center));
        if (textLayout is null) return;

        var selectionStartMetrics = textLayout.HitTestTextPosition(state.SelectionStart, false);
        var selectionEndMetrics = textLayout.HitTestTextPosition(state.SelectionEnd, false);

        float startX = contentRect.Left + selectionStartMetrics.Point.X - state.ScrollPixelOffset;
        float endX = contentRect.Left + selectionEndMetrics.Point.X - state.ScrollPixelOffset;
        float width = endX - startX;

        if (width <= 0) return;

        Rect highlightRect = new(startX, contentRect.Top, width, contentRect.Height);

        var selectionColor = DefaultTheme.Accent;
        selectionColor.A = 100; // ~40% opacity
        var selectionStyle = new BoxStyle { FillColor = selectionColor, Roundness = 0f, BorderLength = 0f };

        renderer.DrawBox(highlightRect, selectionStyle);
    }

    private void DrawVisibleText(string fullText, InputTextState state, Vector2 size, ButtonStyle style, Vector2 contentTopLeft)
    {
        if (string.IsNullOrEmpty(fullText)) return;

        var context = UI.Context;
        var renderer = context.Renderer;
        var textService = context.TextService;

        var textLayout = textService.GetTextLayout(fullText, style, new(float.MaxValue, size.Y), new Alignment(HAlignment.Left, VAlignment.Center));
        if (textLayout is null) return;

        const float yOffsetCorrection = -1.5f;
        Vector2 drawOrigin = new Vector2(contentTopLeft.X - state.ScrollPixelOffset, contentTopLeft.Y + yOffsetCorrection);
        renderer.DrawText(drawOrigin, fullText, style, new Alignment(HAlignment.Left, VAlignment.Center), new Vector2(float.MaxValue, size.Y), style.FontColor);
    }

    private void DrawCaret(string text, InputTextState state, Vector2 size, ButtonStyle style, Rect contentRect)
    {
        var textService = UI.Context.TextService;
        var renderer = UI.Context.Renderer;

        var textLayout = textService.GetTextLayout(text, style, new(float.MaxValue, size.Y), new Alignment(HAlignment.Left, VAlignment.Center));
        if (textLayout is null) return;

        var hitTestMetrics = textLayout.HitTestTextPosition(state.CaretPosition, false);
        float caretX = contentRect.Left + hitTestMetrics.Point.X - state.ScrollPixelOffset;
        Rect caretRect = new(caretX, contentRect.Top, 1, contentRect.Height);
        renderer.DrawBox(caretRect, new BoxStyle { FillColor = style.FontColor, Roundness = 0f, BorderLength = 0f });
    }

    private void UpdateView(string text, InputTextState state, Vector2 size, Vector2 textMargin)
    {
        float availableWidth = size.X - textMargin.X * 2;
        var style = new ButtonStyle(); // A default style is fine for measuring

        var textLayout = UI.Context.TextService.GetTextLayout(text, style, new(float.MaxValue, size.Y), new Alignment(HAlignment.Left, VAlignment.Center));
        if (textLayout is null) return;

        var hitTestMetrics = textLayout.HitTestTextPosition(state.CaretPosition, false);
        float caretAbsoluteX = hitTestMetrics.Point.X;

        float viewStart = state.ScrollPixelOffset;
        float viewEnd = state.ScrollPixelOffset + availableWidth;
        const float caretWidth = 1.0f;
        const float caretVisibilityPadding = 1.0f;

        if (caretAbsoluteX + caretWidth > viewEnd)
        {
            state.ScrollPixelOffset = (caretAbsoluteX + caretWidth + caretVisibilityPadding) - availableWidth;
        }
        else if (caretAbsoluteX < viewStart)
        {
            state.ScrollPixelOffset = caretAbsoluteX;
        }

        float maxScroll = Math.Max(0, textLayout.Size.X + caretWidth + caretVisibilityPadding - availableWidth);
        state.ScrollPixelOffset = Math.Clamp(state.ScrollPixelOffset, 0, maxScroll);
    }

    private static void PushUndoState(string text, InputTextState state)
    {
        var lastState = state.UndoStack.Count > 0 ? state.UndoStack.Peek() : default;
        if (state.UndoStack.Count > 0 && lastState.Text == text && lastState.CaretPosition == state.CaretPosition && lastState.SelectionAnchor == state.SelectionAnchor) return;

        if (state.UndoStack.Count >= InputTextState.HistoryLimit) state.UndoStack.Pop();
        state.UndoStack.Push(new LineEditUndoRecord(text, state.CaretPosition, state.SelectionAnchor, state.ScrollPixelOffset));
        state.RedoStack.Clear();
    }

    private static void Undo(ref string text, InputTextState state)
    {
        if (state.UndoStack.Count == 0) return;
        state.RedoStack.Push(new LineEditUndoRecord(text, state.CaretPosition, state.SelectionAnchor, state.ScrollPixelOffset));
        var lastState = state.UndoStack.Pop();
        text = lastState.Text;
        state.CaretPosition = lastState.CaretPosition;
        state.SelectionAnchor = lastState.SelectionAnchor;
        state.ScrollPixelOffset = lastState.ScrollPixelOffset;
    }

    private static void Redo(ref string text, InputTextState state)
    {
        if (state.RedoStack.Count == 0) return;
        state.UndoStack.Push(new LineEditUndoRecord(text, state.CaretPosition, state.SelectionAnchor, state.ScrollPixelOffset));
        var nextState = state.RedoStack.Pop();
        text = nextState.Text;
        state.CaretPosition = nextState.CaretPosition;
        state.SelectionAnchor = nextState.SelectionAnchor;
        state.ScrollPixelOffset = nextState.ScrollPixelOffset;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\InputTextState.cs">
using System;
using System.Collections.Generic;

namespace DirectUI;

internal record struct LineEditUndoRecord(string Text, int CaretPosition, int SelectionAnchor, float ScrollPixelOffset);

internal class InputTextState
{
    // Selection state
    internal int CaretPosition;     // The "moving" end of the selection
    internal int SelectionAnchor;   // The "fixed" end of the selection

    // Helpers for selection
    internal bool HasSelection => CaretPosition != SelectionAnchor;
    internal int SelectionStart => Math.Min(CaretPosition, SelectionAnchor);
    internal int SelectionEnd => Math.Max(CaretPosition, SelectionAnchor);

    // View state
    internal float ScrollPixelOffset;

    // Caret blink state
    internal float BlinkTimer;
    internal bool IsBlinkOn = true;

    // Undo/Redo state
    internal readonly Stack<LineEditUndoRecord> UndoStack = new();
    internal readonly Stack<LineEditUndoRecord> RedoStack = new();
    internal const int HistoryLimit = 50;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\InternalComboboxLogic.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

/// <summary>
/// Provides the internal logic for the combobox widget, including managing popup state.
/// </summary>
internal class InternalComboboxLogic
{
    public int UpdateAndDraw(
        int id,
        int selectedIndex,
        string[] items,
        Vector2 position,
        Vector2 size,
        ButtonStylePack? theme,
        bool disabled)
    {
        var context = UI.Context;
        var state = UI.State;
        var renderer = context.Renderer; // Get the renderer from the context

        int newSelectedIndex = selectedIndex;

        // If a selection was made in the popup during the last frame's EndFrame,
        // the result will be available now for us to consume.
        if (state.PopupResultAvailable && state.PopupResultOwnerId == id)
        {
            newSelectedIndex = state.PopupResult;
        }

        var comboboxState = state.GetOrCreateElement<ComboboxState>(id);
        var themeId = HashCode.Combine(id, "theme");
        var finalTheme = theme ?? state.GetOrCreateElement<ButtonStylePack>(themeId);

        // Sync local open state with global popup state
        if (comboboxState.IsOpen && state.ActivePopupId != id)
        {
            comboboxState.IsOpen = false;
        }

        // The text on the button should reflect the potentially new index
        string currentItemText = (newSelectedIndex >= 0 && newSelectedIndex < items.Length)
            ? items[newSelectedIndex]
            : string.Empty;

        // Draw the main button
        var bounds = new Rect(position.X, position.Y, size.X, size.Y);
        bool clicked = UI.DrawButtonPrimitive(
            id,
            bounds,
            currentItemText,
            finalTheme,
            disabled,
            new Alignment(HAlignment.Left, VAlignment.Center),
            Button.ActionMode.Release,
            Button.ClickBehavior.Left,
            new Vector2(5, 0)
        ) != ClickResult.None;

        if (clicked && !disabled)
        {
            if (comboboxState.IsOpen)
            {
                // If it was already open for us, clicking again closes it.
                state.ClearActivePopup();
                comboboxState.IsOpen = false;
            }
            else
            {
                // Request to open the popup.
                // First, ensure any other popups are closed.
                state.ClearActivePopup();

                // Calculate popup properties
                float popupY = position.Y + size.Y + 2;
                float itemHeight = size.Y; // Items are same height as the button
                float popupHeight = items.Length * itemHeight;
                var popupBounds = new Rect(position.X, popupY, size.X, popupHeight);

                // Define the draw callback for the popup, which runs at EndFrame
                Action<UIContext> drawCallback = (ctx) =>
                {
                    // Draw popup background using the renderer
                    var popupStyle = new BoxStyle { FillColor = DefaultTheme.NormalFill, BorderColor = DefaultTheme.FocusBorder, BorderLength = 1f, Roundness = 0f };
                    ctx.Renderer.DrawBox(popupBounds, popupStyle);

                    // Draw items
                    for (int i = 0; i < items.Length; i++)
                    {
                        var itemBounds = new Rect(popupBounds.X, popupBounds.Y + i * itemHeight, popupBounds.Width, itemHeight);
                        var itemTheme = new ButtonStylePack { Roundness = 0f, BorderLength = 0f };
                        itemTheme.Normal.FillColor = DirectUI.Drawing.Colors.Transparent;
                        itemTheme.Hover.FillColor = DefaultTheme.HoverFill;
                        itemTheme.Pressed.FillColor = DefaultTheme.Accent;

                        int itemId = HashCode.Combine(id, "item", i);

                        if (UI.DrawButtonPrimitive(itemId, itemBounds, items[i], itemTheme, false, new Alignment(HAlignment.Left, VAlignment.Center), Button.ActionMode.Release, Button.ClickBehavior.Left, new Vector2(5, 0)) != ClickResult.None)
                        {
                            // A selection was made. Post the result to be picked up next frame.
                            state.SetPopupResult(id, i);

                            // Close the popup.
                            state.ClearActivePopup();
                        }
                    }
                };

                state.SetActivePopup(id, drawCallback, popupBounds);
                comboboxState.IsOpen = true;
            }
        }

        return newSelectedIndex;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\InternalHSliderLogic.cs">
// Widgets/InternalHSliderLogic.cs
using System;
using System.Numerics;
using System.Text.RegularExpressions;
using DirectUI.Core;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

internal class InternalHSliderLogic : InternalSliderLogic
{
    public HSliderDirection Direction { get; set; } = HSliderDirection.LeftToRight;

    protected override void CalculateTrackBounds()
    {
        trackMinBound = trackPosition.X;
        trackMaxBound = trackPosition.X + Size.X;
    }

    protected override float HandleInput(InputState input, float currentValue)
    {
        float newValue = currentValue;
        Vector2 mousePos = input.MousePosition;
        var state = UI.State;

        Vector2 currentGrabberPos = CalculateGrabberPosition(currentValue);
        Rect currentGrabberBounds = new Rect(currentGrabberPos.X, currentGrabberPos.Y, GrabberSize.X, GrabberSize.Y);
        isGrabberHovered = currentGrabberBounds.Contains(mousePos.X, mousePos.Y);

        Rect trackBoundsRect = new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y);
        isTrackHovered = trackBoundsRect.Contains(mousePos.X, mousePos.Y);

        bool isSliderHovered = isGrabberHovered || isTrackHovered;

        if (isSliderHovered)
        {
            state.SetPotentialInputTarget(GlobalIntId);
        }

        if (state.ActivelyPressedElementId == GlobalIntId && !input.IsLeftMouseDown)
        {
            state.ClearActivePress(GlobalIntId);
        }

        if (input.WasLeftMousePressedThisFrame)
        {
            if (isSliderHovered && state.PotentialInputTargetId == GlobalIntId && !state.DragInProgressFromPreviousFrame)
            {
                state.ClickCaptureServer.RequestCapture(GlobalIntId, 10);
                if (state.TrySetActivePress(GlobalIntId, 10))
                {
                    state.SetFocus(GlobalIntId);

                    if (isTrackHovered && !isGrabberHovered)
                    {
                        pendingTrackClickValueJump = true;
                        trackClickPosition = Math.Clamp(mousePos.X, trackMinBound, trackMaxBound);
                    }
                }
            }
        }

        if (state.ActivelyPressedElementId == GlobalIntId && input.IsLeftMouseDown)
        {
            if (!pendingTrackClickValueJump)
            {
                float clampedX = Math.Clamp(mousePos.X, trackMinBound, trackMaxBound);
                newValue = ConvertPositionToValue(clampedX);
                newValue = ApplyStep(newValue);
                newValue = Math.Clamp(newValue, MinValue, MaxValue);
            }
        }

        return newValue;
    }

    protected override float ConvertPositionToValue(float position)
    {
        if (trackMaxBound <= trackMinBound) return MinValue;
        float normalized = (position - trackMinBound) / (trackMaxBound - trackMinBound);
        normalized = Math.Clamp(normalized, 0.0f, 1.0f);
        if (Direction == HSliderDirection.RightToLeft) { normalized = 1.0f - normalized; }
        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return rawValue;
    }
    protected override Vector2 CalculateGrabberPosition(float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0;
        if (Direction == HSliderDirection.RightToLeft) { normalizedValue = 1.0f - normalizedValue; }
        float trackWidth = Size.X;
        float centerX = trackMinBound + normalizedValue * trackWidth;
        float xPos = centerX - (GrabberSize.X / 2.0f);
        float yPos = trackPosition.Y + (Size.Y / 2.0f) - (GrabberSize.Y / 2.0f);
        float minX = trackPosition.X;
        float maxX = trackPosition.X + Size.X - GrabberSize.X;
        if (maxX < minX) maxX = minX;
        xPos = Math.Clamp(xPos, minX, maxX);
        return new Vector2(xPos, yPos);
    }
    protected override void DrawForeground(IRenderer renderer, float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        if (valueRange <= 0 || renderer is null) return;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0.0f;
        float foregroundWidth = Size.X * normalizedValue;
        if (foregroundWidth <= 0.001f) return;
        Rect clipRect;
        if (Direction == HSliderDirection.RightToLeft) { clipRect = new Rect(trackPosition.X + Size.X - foregroundWidth, trackPosition.Y, foregroundWidth, Size.Y); }
        else { clipRect = new Rect(trackPosition.X, trackPosition.Y, foregroundWidth, Size.Y); }

        renderer.PushClipRect(clipRect, D2D.AntialiasMode.Aliased);
        // Changed to explicitly pass float components for Rect constructor
        renderer.DrawBox(new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y), Theme.Foreground);
        renderer.PopClipRect();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\InternalKnobLogic.cs">
using System;
using System.Numerics;
using DirectUI.Core;
using Vortice.Mathematics;

namespace DirectUI;

internal class InternalKnobLogic
{
    private int _id;
    private bool _isPressed;
    private Vector2 _dragStartPosition;
    private float _valueAtDragStart;

    public bool UpdateAndDraw(
        int id,
        ref float currentValue,
        float minValue,
        float maxValue,
        float radius,
        Vector2 position,
        KnobStyle? theme,
        bool disabled,
        float sensitivity = 0.005f)
    {
        _id = id;
        var context = UI.Context;
        var state = UI.State;
        var renderer = context.Renderer;
        var input = context.InputState;

        var themeId = HashCode.Combine(id, "theme");
        var finalTheme = theme ?? state.GetOrCreateElement<KnobStyle>(themeId);
        if (theme is null)
        {
            // Setup a default theme if none is provided
            finalTheme.BaseStyle.FillColor = DefaultTheme.NormalFill;
            finalTheme.BaseStyle.BorderColor = DefaultTheme.NormalBorder;
            finalTheme.BaseStyle.Roundness = 1.0f; // Circle
            finalTheme.BaseStyle.BorderLength = 1.5f;
            finalTheme.IndicatorColor = DefaultTheme.Accent;
            finalTheme.IndicatorThickness = Math.Max(1f, radius * 0.15f);
        }

        bool valueChanged = false;
        Vector2 center = position + new Vector2(radius, radius);
        Rect bounds = new(position.X, position.Y, radius * 2, radius * 2);

        bool isHovering = !disabled && bounds.Contains(input.MousePosition);
        _isPressed = state.ActivelyPressedElementId == _id;

        if (isHovering)
        {
            state.SetPotentialInputTarget(_id);
        }

        if (_isPressed && !input.IsLeftMouseDown)
        {
            state.ClearActivePress(_id);
            _isPressed = false;
        }

        if (!disabled && isHovering && input.WasLeftMousePressedThisFrame && state.PotentialInputTargetId == _id)
        {
            if (state.TrySetActivePress(_id, 1))
            {
                state.SetFocus(_id);
                _isPressed = true;
                _dragStartPosition = input.MousePosition;
                _valueAtDragStart = currentValue;
            }
        }

        if (_isPressed)
        {
            float deltaY = _dragStartPosition.Y - input.MousePosition.Y; // Inverted for natural feel
            float valueRange = maxValue - minValue;
            float change = deltaY * valueRange * sensitivity;

            float newValue = Math.Clamp(_valueAtDragStart + change, minValue, maxValue);
            if (Math.Abs(newValue - currentValue) > float.Epsilon)
            {
                currentValue = newValue;
                valueChanged = true;
            }
        }

        // --- Drawing ---
        // Base
        renderer.DrawBox(bounds, finalTheme.BaseStyle);

        // Indicator
        float normalizedValue = (currentValue - minValue) / (maxValue - minValue);
        float angleRangeRad = finalTheme.AngleRangeDegrees * (float)Math.PI / 180f;
        float startAngleRad = finalTheme.StartAngleDegrees * (float)Math.PI / 180f;
        float currentAngleRad = startAngleRad + (normalizedValue * angleRangeRad);

        Vector2 indicatorStart = center;
        Vector2 indicatorEnd = new(
            center.X + (float)Math.Cos(currentAngleRad) * radius * 0.8f,
            center.Y + (float)Math.Sin(currentAngleRad) * radius * 0.8f
        );

        renderer.DrawLine(indicatorStart, indicatorEnd, finalTheme.IndicatorColor, finalTheme.IndicatorThickness);

        return valueChanged;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\InternalScrollBarLogic.cs">
// Widgets/InternalScrollBarLogic.cs
using System;
using System.Numerics;
using Vortice.Mathematics;
using DirectUI.Core; // Ensure this is present for IRenderer

namespace DirectUI;

/// <summary>
/// Internal class that encapsulates the state, logic, and drawing for a proportional scrollbar.
/// </summary>
internal class InternalScrollBarLogic
{
    // --- Configuration (set per-frame) ---
    public Vector2 Position { get; set; }
    public float TrackLength { get; set; }
    public float TrackThickness { get; set; }
    public bool IsVertical { get; set; }
    public float ContentSize { get; set; }
    public float VisibleSize { get; set; }
    public SliderStyle Theme { get; set; } = new();
    public ButtonStylePack ThumbTheme { get; set; } = new();

    // --- Internal State ---
    private int _id;
    private bool _isThumbHovered;
    private bool _isThumbPressed;
    private bool _isFocused;
    private float _dragStartMousePos;
    private float _dragStartScrollOffset;

    /// <summary>
    /// The main update and draw entry point called by the public UI method.
    /// </summary>
    public float UpdateAndDraw(int id, float currentScrollOffset)
    {
        if (VisibleSize >= ContentSize) return 0; // No scrolling needed, offset must be 0.

        _id = id;
        var context = UI.Context;
        var state = UI.State;
        var input = context.InputState;
        var renderer = context.Renderer;

        _isFocused = state.FocusedElementId == _id;
        float newScrollOffset = HandleInput(input, currentScrollOffset);

        _isThumbPressed = state.ActivelyPressedElementId == _id;
        ThumbTheme.UpdateCurrentStyle(_isThumbHovered, _isThumbPressed, false, _isFocused);

        if (renderer is not null) // Check if renderer is available
        {
            Draw(renderer, newScrollOffset); // Pass the renderer instance
        }

        return newScrollOffset;
    }

    private Rect GetTrackBounds()
    {
        return IsVertical
            ? new Rect(Position.X, Position.Y, TrackThickness, TrackLength)
            : new Rect(Position.X, Position.Y, TrackLength, TrackThickness);
    }

    private Rect GetThumbBounds(float currentScrollOffset, out float thumbLength)
    {
        thumbLength = 0;
        if (VisibleSize >= ContentSize) return new Rect();

        float viewRatio = VisibleSize / ContentSize;
        thumbLength = TrackLength * viewRatio;
        float minThumbLength = 20f; // Ensure thumb is always grabbable
        thumbLength = Math.Max(minThumbLength, thumbLength);

        float maxScrollOffset = ContentSize - VisibleSize;
        float scrollableTrackLength = TrackLength - thumbLength;

        if (scrollableTrackLength <= 0) return GetTrackBounds();

        float scrollRatio = (maxScrollOffset > 0) ? currentScrollOffset / maxScrollOffset : 0;
        float thumbOffsetInTrack = scrollableTrackLength * scrollRatio;

        return IsVertical
            ? new Rect(Position.X, Position.Y + thumbOffsetInTrack, TrackThickness, thumbLength)
            : new Rect(Position.X + thumbOffsetInTrack, Position.Y, thumbLength, TrackThickness);
    }

    private float HandleInput(InputState input, float currentScrollOffset)
    {
        var state = UI.State;
        var trackBounds = GetTrackBounds();
        var thumbBounds = GetThumbBounds(currentScrollOffset, out float thumbLength);

        _isThumbHovered = thumbBounds.Contains(input.MousePosition);
        bool isTrackHovered = trackBounds.Contains(input.MousePosition);

        if (_isThumbHovered || isTrackHovered)
        {
            state.SetPotentialInputTarget(_id);
        }

        _isThumbPressed = state.ActivelyPressedElementId == _id;

        if (_isThumbPressed && !input.IsLeftMouseDown)
        {
            state.ClearActivePress(_id);
            _isThumbPressed = false;
        }

        if (input.WasLeftMousePressedThisFrame && state.PotentialInputTargetId == _id)
        {
            // Use a high layer to ensure scrollbars win input capture over content.
            state.ClickCaptureServer.RequestCapture(_id, 10);
            if (state.TrySetActivePress(_id, 10))
            {
                state.SetFocus(_id);
                _isThumbPressed = true;

                if (_isThumbHovered)
                {
                    _dragStartMousePos = IsVertical ? input.MousePosition.Y : input.MousePosition.X;
                    _dragStartScrollOffset = currentScrollOffset;
                }
                else // Clicked on track
                {
                    float mousePosOnTrack = IsVertical ? input.MousePosition.Y : input.MousePosition.X;
                    float thumbStart = IsVertical ? thumbBounds.Y : thumbBounds.X;
                    float thumbEnd = thumbStart + thumbLength;

                    float pageAmount = VisibleSize;
                    if (mousePosOnTrack < thumbStart)
                    {
                        return Math.Max(0, currentScrollOffset - pageAmount);
                    }
                    else if (mousePosOnTrack > thumbEnd)
                    {
                        float maxScroll = ContentSize - VisibleSize;
                        return Math.Min(maxScroll, currentScrollOffset + pageAmount);
                    }
                }
            }
        }

        if (_isThumbPressed && input.IsLeftMouseDown)
        {
            float maxScrollOffset = ContentSize - VisibleSize;
            float scrollableTrackLength = TrackLength - thumbLength;
            if (scrollableTrackLength <= 0) return currentScrollOffset;

            float currentMousePos = IsVertical ? input.MousePosition.Y : input.MousePosition.X;
            float mouseDelta = currentMousePos - _dragStartMousePos;

            float scrollDelta = mouseDelta * (maxScrollOffset / scrollableTrackLength);

            float newScrollOffset = _dragStartScrollOffset + scrollDelta;
            return Math.Clamp(newScrollOffset, 0, maxScrollOffset);
        }

        return currentScrollOffset;
    }

    private void Draw(IRenderer renderer, float currentScrollOffset) // Changed ID2D1RenderTarget to IRenderer
    {
        // Draw Track
        renderer.DrawBox(GetTrackBounds(), Theme.Background);

        // Draw Thumb
        var thumbBounds = GetThumbBounds(currentScrollOffset, out _);
        if (thumbBounds.Width > 0 && thumbBounds.Height > 0)
        {
            var thumbStyle = new BoxStyle
            {
                FillColor = ThumbTheme.Current.FillColor,
                BorderColor = ThumbTheme.Current.BorderColor,
                BorderLength = ThumbTheme.Current.BorderLength,
                Roundness = ThumbTheme.Current.Roundness
            };
            // Convert Vortice.Mathematics.Rect to System.Numerics.Vector2 for size
            renderer.DrawBox(new Rect(thumbBounds.X, thumbBounds.Y, thumbBounds.Width, thumbBounds.Height), thumbStyle);
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\InternalSliderLogic.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;
using DirectUI.Core;

namespace DirectUI;

internal abstract class InternalSliderLogic
{
    // --- Configuration ---
    public Vector2 Position { get; set; }
    public Vector2 Size { get; set; }
    public Vector2 Origin { get; set; }
    public float MinValue { get; set; }
    public float MaxValue { get; set; }
    public float Step { get; set; }
    public SliderStyle Theme { get; set; } = new();
    public ButtonStylePack GrabberTheme { get; set; } = new();
    public Vector2 GrabberSize { get; set; } = new(16, 16);
    public bool Disabled { get; set; }
    public object? UserData { get; set; }

    // --- Internal State ---
    protected bool isGrabberPressed = false;
    protected bool isGrabberHovered = false;
    protected bool isTrackHovered = false;
    protected bool isFocused = false;
    protected Vector2 trackPosition;
    protected float trackMinBound;
    protected float trackMaxBound;
    protected bool pendingTrackClickValueJump = false;
    protected float trackClickPosition = 0f;
    protected int GlobalIntId { get; private set; } = 0;


    // --- Calculated Properties ---
    public Rect GlobalBounds => new(Position.X - Origin.X, Position.Y - Origin.Y, Size.X, Size.Y);

    // --- Abstract Methods ---
    protected abstract void CalculateTrackBounds();
    protected abstract float HandleInput(InputState input, float currentValue);
    protected abstract float ConvertPositionToValue(float position);
    protected abstract Vector2 CalculateGrabberPosition(float currentValue);
    protected abstract void DrawForeground(IRenderer renderer, float currentValue);


    // --- Common Logic ---
    internal float UpdateAndDraw(int id, float currentValue)
    {
        var context = UI.Context;
        var state = UI.State;
        var renderer = context.Renderer;

        GlobalIntId = id;
        isFocused = state.FocusedElementId == GlobalIntId;
        trackPosition = Position - Origin;
        CalculateTrackBounds();

        pendingTrackClickValueJump = false;
        float newValue = currentValue;

        if (Disabled)
        {
            isGrabberHovered = false;
            isGrabberPressed = false;
            isTrackHovered = false;
            if (state.ActivelyPressedElementId == GlobalIntId) state.ClearActivePress(GlobalIntId);
        }
        else
        {
            newValue = HandleInput(context.InputState, currentValue);
        }

        if (pendingTrackClickValueJump && state.InputCaptorId == GlobalIntId)
        {
            newValue = ConvertPositionToValue(trackClickPosition);
            newValue = ApplyStep(newValue);
            newValue = Math.Clamp(newValue, MinValue, MaxValue);
        }
        pendingTrackClickValueJump = false;

        UpdateGrabberThemeStyle();

        if (renderer is null)
        {
            Console.WriteLine("Error: Renderer is null during Slider UpdateAndDraw.");
            return newValue;
        }

        try
        {
            DrawBackground(renderer);
            DrawForeground(renderer, newValue);
            DrawGrabber(renderer, newValue);
        }
        catch (SharpGen.Runtime.SharpGenException ex) when (ex.ResultCode.Code == Vortice.Direct2D1.ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Slider Draw failed (RecreateTarget): {ex.Message}. External cleanup needed.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error drawing slider: {ex.Message}");
        }

        return newValue;
    }

    // --- Helper Methods ---
    protected float ApplyStep(float value)
    {
        float clampedValue = Math.Clamp(value, MinValue, MaxValue);
        if (Step <= 0 || MaxValue <= MinValue)
        {
            return clampedValue;
        }

        float range = MaxValue - MinValue;
        if (range < Step && Step > 0)
        {
            return (value - MinValue < range / 2.0f) ? MinValue : MaxValue;
        }

        float stepsFromMin = (float)Math.Round((clampedValue - MinValue) / Step);
        float steppedValue = MinValue + stepsFromMin * Step;

        return Math.Clamp(steppedValue, MinValue, MaxValue);
    }


    protected void UpdateGrabberThemeStyle()
    {
        isGrabberPressed = UI.State.ActivelyPressedElementId == GlobalIntId;
        isFocused = UI.State.FocusedElementId == GlobalIntId;
        GrabberTheme.UpdateCurrentStyle(isGrabberHovered, isGrabberPressed, Disabled, isFocused);
    }


    // --- Drawing Methods ---
    protected void DrawBackground(IRenderer renderer)
    {
        // Explicitly pass X, Y, Width, Height components to Rect constructor
        renderer.DrawBox(new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y), Theme.Background);
    }

    protected void DrawGrabber(IRenderer renderer, float currentValue)
    {
        Vector2 grabberPos = CalculateGrabberPosition(currentValue);
        // Explicitly pass X, Y, Width, Height components to Rect constructor
        renderer.DrawBox(new Rect(grabberPos.X, grabberPos.Y, GrabberSize.X, GrabberSize.Y), GrabberTheme.Current);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\InternalVSlider.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;
using DirectUI.Core; // Added for IRenderer
using D2D = Vortice.Direct2D1; // Added this using directive

namespace DirectUI;

internal class InternalVSliderLogic : InternalSliderLogic
{
    public VSliderDirection Direction { get; set; } = VSliderDirection.TopToBottom;

    protected override void CalculateTrackBounds()
    {
        trackMinBound = trackPosition.Y;
        trackMaxBound = trackPosition.Y + Size.Y;
    }

    protected override float HandleInput(InputState input, float currentValue)
    {
        float newValue = currentValue;
        Vector2 mousePos = input.MousePosition;
        var state = UI.State;

        Vector2 currentGrabberPos = CalculateGrabberPosition(currentValue);
        Rect currentGrabberBounds = new Rect(currentGrabberPos.X, currentGrabberPos.Y, GrabberSize.X, GrabberSize.Y);
        isGrabberHovered = currentGrabberBounds.Contains(mousePos.X, mousePos.Y);

        Rect trackBoundsRect = new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y);
        isTrackHovered = trackBoundsRect.Contains(mousePos.X, mousePos.Y);

        bool isSliderHovered = isGrabberHovered || isTrackHovered;

        if (isSliderHovered)
        {
            state.SetPotentialInputTarget(GlobalIntId);
        }

        if (state.ActivelyPressedElementId == GlobalIntId && !input.IsLeftMouseDown)
        {
            state.ClearActivePress(GlobalIntId);
        }

        if (input.WasLeftMousePressedThisFrame)
        {
            if (isSliderHovered && state.PotentialInputTargetId == GlobalIntId && !state.DragInProgressFromPreviousFrame)
            {
                state.ClickCaptureServer.RequestCapture(GlobalIntId, 10);
                if (state.TrySetActivePress(GlobalIntId, 10))
                {
                    state.SetFocus(GlobalIntId);

                    if (isTrackHovered && !isGrabberHovered)
                    {
                        pendingTrackClickValueJump = true;
                        trackClickPosition = Math.Clamp(mousePos.Y, trackMinBound, trackMaxBound);
                    }
                }
            }
        }

        if (state.ActivelyPressedElementId == GlobalIntId && input.IsLeftMouseDown)
        {
            if (!pendingTrackClickValueJump)
            {
                float clampedY = Math.Clamp(mousePos.Y, trackMinBound, trackMaxBound);
                newValue = ConvertPositionToValue(clampedY);
                newValue = ApplyStep(newValue);
                newValue = Math.Clamp(newValue, MinValue, MaxValue);
            }
        }

        return newValue;
    }

    protected override float ConvertPositionToValue(float position)
    {
        if (trackMaxBound <= trackMinBound) return MinValue;
        float normalized = (position - trackMinBound) / (trackMaxBound - trackMinBound);
        normalized = Math.Clamp(normalized, 0.0f, 1.0f);
        if (Direction == VSliderDirection.BottomToTop) { normalized = 1.0f - normalized; }
        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return rawValue;
    }
    protected override Vector2 CalculateGrabberPosition(float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0;
        if (Direction == VSliderDirection.BottomToTop) { normalizedValue = 1.0f - normalizedValue; }
        float trackHeight = Size.Y;
        float centerY = trackMinBound + normalizedValue * trackHeight;
        float yPos = centerY - (GrabberSize.Y / 2.0f);
        float xPos = trackPosition.X + (Size.X / 2.0f) - (GrabberSize.X / 2.0f);
        float minY = trackPosition.Y;
        float maxY = trackPosition.Y + Size.Y - GrabberSize.Y;
        if (maxY < minY) maxY = minY;
        yPos = Math.Clamp(yPos, minY, maxY);
        return new Vector2(xPos, yPos);
    }
    protected override void DrawForeground(IRenderer renderer, float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        if (valueRange <= 0 || renderer is null) return;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0.0f;
        float foregroundHeight = Size.Y * normalizedValue;
        if (foregroundHeight <= 0.001f) return;
        Rect clipRect;
        if (Direction == VSliderDirection.BottomToTop) { clipRect = new Rect(trackPosition.X, trackPosition.Y + Size.Y - foregroundHeight, Size.X, foregroundHeight); }
        else { clipRect = new Rect(trackPosition.X, trackPosition.Y, Size.X, foregroundHeight); }
        renderer.PushClipRect(clipRect, D2D.AntialiasMode.Aliased);
        renderer.DrawBox(new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y), Theme.Foreground);
        renderer.PopClipRect();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\SliderDirection.cs">
namespace DirectUI;

public enum HSliderDirection { LeftToRight, RightToLeft }
public enum VSliderDirection { TopToBottom, BottomToTop }
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\TabBarState.cs">
namespace DirectUI;

internal class TabBarState
{
    internal float CachedUniformWidth = -1f;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\TreeNode.cs">
using System.Collections.Generic;

namespace DirectUI;

/// <summary>
/// Represents a node in a generic tree structure.
/// </summary>
/// <typeparam name="T">The type of the user data associated with the node.</typeparam>
public class TreeNode<T>
{
    public string Text { get; set; }
    public T UserData { get; set; }
    public bool IsExpanded { get; set; }
    public List<TreeNode<T>> Children { get; } = new();

    public TreeNode(string text, T userData, bool expanded = false)
    {
        Text = text;
        UserData = userData;
        IsExpanded = expanded;
    }

    /// <summary>
    /// Adds a new child node to this node.
    /// </summary>
    /// <param name="text">The display text of the child node.</param>
    /// <param name="userData">The user data associated with the child node.</param>
    /// <param name="expanded">Whether the child node is expanded by default.</param>
    /// <returns>The newly created child node.</returns>
    public TreeNode<T> AddChild(string text, T userData, bool expanded = false)
    {
        var child = new TreeNode<T>(text, userData, expanded);
        Children.Add(child);
        return child;
    }

    /// <summary>
    /// Adds an existing TreeNode as a child of this node.
    /// </summary>
    /// <param name="child">The child node to add.</param>
    /// <returns>The added child node.</returns>
    public TreeNode<T> AddChild(TreeNode<T> child)
    {
        Children.Add(child);
        return child;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Direct2D\Direct2DRenderer.cs">
using System.Numerics;
using DirectUI.Core;
using SharpGen.Runtime;
using Vortice.Direct2D1;
using Vortice.Direct3D;
using Vortice.Direct3D11;
using Vortice.DirectWrite;
using Vortice.DXGI;
using Vortice.Mathematics;
using InputElementDescription = Vortice.Direct3D11.InputElementDescription;

namespace DirectUI.Backends;

/// <summary>
/// A rendering backend that uses Direct2D to implement the IRenderer interface.
/// It now holds a reference to the DuiGraphicsDevice to ensure it always uses a valid render target.
/// </summary>
public class Direct2DRenderer : IRenderer
{
    private readonly DuiGraphicsDevice _graphicsDevice;
    private readonly Dictionary<Color, ID2D1SolidColorBrush> _brushCache = new();

    // D3D resources for the cube
    private ID3D11Buffer? _cubeVertexBuffer;
    private ID3D11Buffer? _cubeIndexBuffer;
    private ID3D11Buffer? _cubeConstantBuffer;
    private ID3D11VertexShader? _cubeVertexShader;
    private ID3D11PixelShader? _cubePixelShader;
    private ID3D11InputLayout? _cubeInputLayout;
    private ID3D11RasterizerState? _cubeRasterizerState;
    private ID3D11DepthStencilState? _cubeDepthStencilState;


    // Internal text layout cache for DrawText method
    private readonly Dictionary<TextLayoutCacheKey, IDWriteTextLayout> _textLayoutCache = new();
    private readonly Dictionary<FontKey, IDWriteTextFormat> _textFormatCache = new();

    // Internal cache key for text layouts (similar to UIResources.TextLayoutCacheKey)
    private readonly struct TextLayoutCacheKey : IEquatable<TextLayoutCacheKey>
    {
        public readonly string Text;
        public readonly FontKey FontKey;
        public readonly Vector2 MaxSize;
        public readonly HAlignment HAlign;
        public readonly VAlignment VAlign;

        public TextLayoutCacheKey(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment)
        {
            Text = text;
            FontKey = new FontKey(style);
            MaxSize = maxSize;
            HAlign = alignment.Horizontal;
            VAlign = alignment.Vertical;
        }

        public bool Equals(TextLayoutCacheKey other) => Text == other.Text && MaxSize.Equals(other.MaxSize) && HAlign == other.HAlign && VAlign == other.VAlign && FontKey.Equals(other.FontKey);
        public override bool Equals(object? obj) => obj is TextLayoutCacheKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(Text, FontKey, MaxSize, HAlign, VAlign);
    }

    private readonly struct FontKey : IEquatable<FontKey>
    {
        public readonly string FontName;
        public readonly float FontSize;
        public readonly FontWeight FontWeight;
        public readonly FontStyle FontStyle;
        public readonly FontStretch FontStretch;

        public FontKey(ButtonStyle style)
        {
            FontName = style.FontName;
            FontSize = style.FontSize;
            FontWeight = style.FontWeight;
            FontStyle = style.FontStyle;
            FontStretch = style.FontStretch;
        }

        public bool Equals(FontKey other) => FontName == other.FontName && FontSize.Equals(other.FontSize) && FontWeight == other.FontWeight && FontStyle == other.FontStyle && FontStretch == other.FontStretch;
        public override bool Equals(object? obj) => obj is FontKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(FontName, FontSize, FontWeight, FontStyle, FontStretch);
    }


    public Vector2 RenderTargetSize
    {
        get
        {
            if (_graphicsDevice.RenderTarget is null)
            {
                return Vector2.Zero;
            }
            var size = _graphicsDevice.RenderTarget.Size;
            return new Vector2(size.Width, size.Height);
        }
    }

    public Direct2DRenderer(DuiGraphicsDevice graphicsDevice)
    {
        _graphicsDevice = graphicsDevice ?? throw new ArgumentNullException(nameof(graphicsDevice));
        CreateCubeResources();
    }

    public void DrawLine(Vector2 p1, Vector2 p2, Drawing.Color color, float strokeWidth)
    {
        var renderTarget = _graphicsDevice.RenderTarget;
        if (renderTarget is null) return;

        var brush = GetOrCreateBrush(color);
        if (brush is null) return;
        renderTarget.DrawLine(p1, p2, brush, strokeWidth);
    }

    public void DrawBox(Vortice.Mathematics.Rect rect, BoxStyle style)
    {
        var renderTarget = _graphicsDevice.RenderTarget;
        if (renderTarget is null || style is null || rect.Width <= 0 || rect.Height <= 0) return;

        var pos = rect.TopLeft;
        var size = new Vector2(rect.Width, rect.Height);

        ID2D1SolidColorBrush? fillBrush = GetOrCreateBrush(style.FillColor);
        ID2D1SolidColorBrush? borderBrush = GetOrCreateBrush(style.BorderColor);

        float borderTop = Math.Max(0f, style.BorderLengthTop);
        float borderRight = Math.Max(0f, style.BorderLengthRight);
        float borderBottom = Math.Max(0f, style.BorderLengthBottom);
        float borderLeft = Math.Max(0f, style.BorderLengthLeft);

        bool hasVisibleFill = style.FillColor.A > 0 && fillBrush is not null;
        bool hasVisibleBorder = style.BorderColor.A > 0 && borderBrush is not null && (borderTop > 0 || borderRight > 0 || borderBottom > 0 || borderLeft > 0);

        if (!hasVisibleFill && !hasVisibleBorder) return;

        if (style.Roundness > 0.0f)
        {
            Vortice.Mathematics.Rect outerBounds = new Vortice.Mathematics.Rect(pos.X, pos.Y, size.X, size.Y);
            float maxRadius = Math.Min(outerBounds.Width * 0.5f, outerBounds.Height * 0.5f);
            float radius = Math.Max(0f, maxRadius * Math.Clamp(style.Roundness, 0.0f, 1.0f));

            if (float.IsFinite(radius) && radius >= 0)
            {
                if (hasVisibleBorder)
                {
                    System.Drawing.RectangleF outerRectF = new(outerBounds.X, outerBounds.Y, outerBounds.Width, outerBounds.Height);
                    renderTarget.FillRoundedRectangle(new RoundedRectangle(outerRectF, radius, radius), borderBrush);
                }
                if (hasVisibleFill)
                {
                    float fillX = pos.X + borderLeft;
                    float fillY = pos.Y + borderTop;
                    float fillWidth = Math.Max(0f, size.X - borderLeft - borderRight);
                    float fillHeight = Math.Max(0f, size.Y - borderTop - borderBottom);
                    if (fillWidth > 0 && fillHeight > 0)
                    {
                        float avgBorderX = (borderLeft + borderRight) * 0.5f;
                        float avgBorderY = (borderTop + borderBottom) * 0.5f;
                        float innerRadiusX = Math.Max(0f, radius - avgBorderX);
                        float innerRadiusY = Math.Max(0f, radius - avgBorderY);
                        System.Drawing.RectangleF fillRectF = new(fillX, fillY, fillWidth, fillHeight);
                        renderTarget.FillRoundedRectangle(new RoundedRectangle(fillRectF, innerRadiusX, innerRadiusY), fillBrush);
                    }
                    else if (!hasVisibleBorder && fillBrush is not null)
                    {
                        System.Drawing.RectangleF outerRectF = new(outerBounds.X, outerBounds.Y, outerBounds.Width, outerBounds.Height);
                        renderTarget.FillRoundedRectangle(new RoundedRectangle(outerRectF, radius, radius), fillBrush);
                    }
                }
                return;
            }
        }
        if (hasVisibleBorder && borderBrush is not null)
        {
            renderTarget.FillRectangle(rect, borderBrush);
        }
        if (hasVisibleFill)
        {
            float fillX = pos.X + borderLeft;
            float fillY = pos.Y + borderTop;
            float fillWidth = Math.Max(0f, size.X - borderLeft - borderRight);
            float fillHeight = Math.Max(0f, size.Y - borderTop - borderBottom);
            if (fillWidth > 0 && fillHeight > 0)
            {
                renderTarget.FillRectangle(new Vortice.Mathematics.Rect(fillX, fillY, fillWidth, fillHeight), fillBrush);
            }
            else if (!hasVisibleBorder && fillBrush is not null)
            {
                renderTarget.FillRectangle(rect, fillBrush);
            }
        }
    }

    public void DrawText(Vector2 origin, string text, ButtonStyle style, Alignment alignment, Vector2 maxSize, Drawing.Color color)
    {
        var renderTarget = _graphicsDevice.RenderTarget;
        if (renderTarget is null || string.IsNullOrEmpty(text)) return;

        var textBrush = GetOrCreateBrush(color);
        if (textBrush is null) return;

        var layoutKey = new TextLayoutCacheKey(text, style, maxSize, alignment);
        if (!_textLayoutCache.TryGetValue(layoutKey, out var textLayout))
        {
            var textFormat = GetOrCreateTextFormat(style);
            if (textFormat is null || _graphicsDevice.DWriteFactory is null) return;

            textLayout = _graphicsDevice.DWriteFactory.CreateTextLayout(text, textFormat, maxSize.X, maxSize.Y);
            textLayout.TextAlignment = alignment.Horizontal switch
            {
                HAlignment.Left => Vortice.DirectWrite.TextAlignment.Leading,
                HAlignment.Center => Vortice.DirectWrite.TextAlignment.Center,
                HAlignment.Right => Vortice.DirectWrite.TextAlignment.Trailing,
                _ => Vortice.DirectWrite.TextAlignment.Leading
            };
            textLayout.ParagraphAlignment = alignment.Vertical switch
            {
                VAlignment.Top => ParagraphAlignment.Near,
                VAlignment.Center => ParagraphAlignment.Center,
                VAlignment.Bottom => ParagraphAlignment.Far,
                _ => ParagraphAlignment.Near
            };
            _textLayoutCache[layoutKey] = textLayout;
        }

        // A small vertical adjustment to compensate for font metrics making text appear slightly too low when using ParagraphAlignment.Center.
        float yOffsetCorrection = (alignment.Vertical == VAlignment.Center) ? -1.5f : 0f;

        renderTarget.DrawTextLayout(new Vector2(origin.X, origin.Y + yOffsetCorrection), textLayout, textBrush, Vortice.Direct2D1.DrawTextOptions.None);
    }

    public void PushClipRect(Vortice.Mathematics.Rect rect, AntialiasMode antialiasMode)
    {
        _graphicsDevice.RenderTarget?.PushAxisAlignedClip(rect, antialiasMode);
    }

    public void PopClipRect()
    {
        _graphicsDevice.RenderTarget?.PopAxisAlignedClip();
    }

    public void Flush()
    {
        // Direct2D is an immediate-mode API in this context, no flush needed.
    }

    public void Cleanup()
    {
        foreach (var pair in _brushCache)
        {
            pair.Value?.Dispose();
        }
        _brushCache.Clear();

        foreach (var pair in _textLayoutCache)
        {
            pair.Value?.Dispose();
        }
        _textLayoutCache.Clear();

        foreach (var pair in _textFormatCache)
        {
            pair.Value?.Dispose();
        }
        _textFormatCache.Clear();

        _cubeVertexBuffer?.Dispose();
        _cubeIndexBuffer?.Dispose();
        _cubeConstantBuffer?.Dispose();
        _cubeVertexShader?.Dispose();
        _cubePixelShader?.Dispose();
        _cubeInputLayout?.Dispose();
        _cubeRasterizerState?.Dispose();
        _cubeDepthStencilState?.Dispose();
    }

    private ID2D1SolidColorBrush? GetOrCreateBrush(Drawing.Color color)
    {
        var renderTarget = _graphicsDevice.RenderTarget;
        if (renderTarget is null)
        {
            // Don't log here to avoid spam on resize. The caller will just not draw.
            return null;
        }

        if (_brushCache.TryGetValue(color, out var brush) && brush is not null)
        {
            return brush;
        }

        if (brush is null && _brushCache.ContainsKey(color))
        {
            _brushCache.Remove(color);
        }

        try
        {
            Vortice.Mathematics.Color4 color4 = color;
            brush = renderTarget.CreateSolidColorBrush(color4);
            if (brush is not null)
            {
                _brushCache[color] = brush;
                return brush;
            }

            Console.WriteLine($"Warning: CreateSolidColorBrush returned null for color {color}");
            return null;
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == Vortice.Direct2D1.ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Brush creation failed due to RecreateTarget error (Color: {color}). External cleanup needed.");
            return null;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error creating brush for color {color}: {ex.Message}");
            return null;
        }
    }

    private IDWriteTextFormat? GetOrCreateTextFormat(ButtonStyle style)
    {
        var dwriteFactory = _graphicsDevice.DWriteFactory;
        if (dwriteFactory is null) return null;

        var key = new FontKey(style);
        if (_textFormatCache.TryGetValue(key, out var format))
        {
            return format;
        }

        try
        {
            var newFormat = dwriteFactory.CreateTextFormat(style.FontName, null, style.FontWeight, style.FontStyle, style.FontStretch, style.FontSize, "en-us");
            if (newFormat is not null) { _textFormatCache[key] = newFormat; }
            return newFormat;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error creating text format for font '{style.FontName}': {ex.Message}");
            return null;
        }
    }

    private void CreateCubeResources()
    {
        var d3dDevice = _graphicsDevice.D3DDevice;
        if (d3dDevice is null)
        {
            Console.WriteLine("Cannot create cube resources: D3DDevice is null.");
            return;
        }

        var vertices = new[]
        {
            // Front face (-Z) - Red - (TL, TR, BR, BL) - Clockwise
            new Vector4(-1.0f,  1.0f, -1.0f, 1.0f), new Vector4(1.0f, 0.0f, 0.0f, 1.0f), // 0
            new Vector4( 1.0f,  1.0f, -1.0f, 1.0f), new Vector4(1.0f, 0.0f, 0.0f, 1.0f), // 1
            new Vector4( 1.0f, -1.0f, -1.0f, 1.0f), new Vector4(1.0f, 0.0f, 0.0f, 1.0f), // 2
            new Vector4(-1.0f, -1.0f, -1.0f, 1.0f), new Vector4(1.0f, 0.0f, 0.0f, 1.0f), // 3

            // Back face (+Z) - Green - (TR, TL, BL, BR) - Clockwise
            new Vector4( 1.0f,  1.0f, 1.0f, 1.0f), new Vector4(0.0f, 1.0f, 0.0f, 1.0f), // 4
            new Vector4(-1.0f,  1.0f, 1.0f, 1.0f), new Vector4(0.0f, 1.0f, 0.0f, 1.0f), // 5
            new Vector4(-1.0f, -1.0f, 1.0f, 1.0f), new Vector4(0.0f, 1.0f, 0.0f, 1.0f), // 6
            new Vector4( 1.0f, -1.0f, 1.0f, 1.0f), new Vector4(0.0f, 1.0f, 0.0f, 1.0f), // 7

            // Top face (+Y) - Blue - (TL, TR, BR, BL) - Clockwise
            new Vector4(-1.0f, 1.0f,  1.0f, 1.0f), new Vector4(0.0f, 0.0f, 1.0f, 1.0f), // 8
            new Vector4( 1.0f, 1.0f,  1.0f, 1.0f), new Vector4(0.0f, 0.0f, 1.0f, 1.0f), // 9
            new Vector4( 1.0f, 1.0f, -1.0f, 1.0f), new Vector4(0.0f, 0.0f, 1.0f, 1.0f), // 10
            new Vector4(-1.0f, 1.0f, -1.0f, 1.0f), new Vector4(0.0f, 0.0f, 1.0f, 1.0f), // 11

            // Bottom face (-Y) - Yellow - (BL, BR, TR, TL) - Clockwise
            new Vector4(-1.0f, -1.0f, -1.0f, 1.0f), new Vector4(1.0f, 1.0f, 0.0f, 1.0f), // 12
            new Vector4( 1.0f, -1.0f, -1.0f, 1.0f), new Vector4(1.0f, 1.0f, 0.0f, 1.0f), // 13
            new Vector4( 1.0f, -1.0f,  1.0f, 1.0f), new Vector4(1.0f, 1.0f, 0.0f, 1.0f), // 14
            new Vector4(-1.0f, -1.0f,  1.0f, 1.0f), new Vector4(1.0f, 1.0f, 0.0f, 1.0f), // 15

            // Left face (-X) - Cyan - (TL, TR, BR, BL) - Clockwise
            new Vector4(-1.0f,  1.0f,  1.0f, 1.0f), new Vector4(0.0f, 1.0f, 1.0f, 1.0f), // 16
            new Vector4(-1.0f,  1.0f, -1.0f, 1.0f), new Vector4(0.0f, 1.0f, 1.0f, 1.0f), // 17
            new Vector4(-1.0f, -1.0f, -1.0f, 1.0f), new Vector4(0.0f, 1.0f, 1.0f, 1.0f), // 18
            new Vector4(-1.0f, -1.0f,  1.0f, 1.0f), new Vector4(0.0f, 1.0f, 1.0f, 1.0f), // 19

            // Right face (+X) - Magenta - (TL, TR, BR, BL) - Clockwise
            new Vector4( 1.0f,  1.0f, -1.0f, 1.0f), new Vector4(1.0f, 0.0f, 1.0f, 1.0f), // 20
            new Vector4( 1.0f,  1.0f,  1.0f, 1.0f), new Vector4(1.0f, 0.0f, 1.0f, 1.0f), // 21
            new Vector4( 1.0f, -1.0f,  1.0f, 1.0f), new Vector4(1.0f, 0.0f, 1.0f, 1.0f), // 22
            new Vector4( 1.0f, -1.0f, -1.0f, 1.0f), new Vector4(1.0f, 0.0f, 1.0f, 1.0f)  // 23
        };

        var indices = new ushort[]
        {
            0,  1,  2,      0,  2,  3,    // Front
            4,  5,  6,      4,  6,  7,    // Back
            8,  9,  10,     8,  10, 11,   // Top
            12, 13, 14,     12, 14, 15,  // Bottom
            16, 17, 18,     16, 18, 19,  // Left
            20, 21, 22,     20, 22, 23   // Right
        };

        _cubeVertexBuffer = d3dDevice.CreateBuffer(vertices, BindFlags.VertexBuffer);
        _cubeIndexBuffer = d3dDevice.CreateBuffer(indices, BindFlags.IndexBuffer);

        using var vertexShaderByteCode = ShaderCompiler.Compile(
@"
cbuffer ConstantBuffer : register(b0)
{
    matrix WorldViewProjection;
}

struct VS_Input
{
    float4 Position : POSITION;
    float4 Color : COLOR;
};

struct PS_Input
{
    float4 Position : SV_POSITION;
    float4 Color : COLOR;
};

PS_Input VS(VS_Input input)
{
    PS_Input output;
    output.Position = mul(input.Position, WorldViewProjection);
    output.Color = input.Color;
    return output;
}
", "VS", "vs_5_0");

        using var pixelShaderByteCode = ShaderCompiler.Compile(
@"
struct PS_Input
{
    float4 Position : SV_POSITION;
    float4 Color : COLOR;
};

float4 PS(PS_Input input) : SV_TARGET
{
    return input.Color;
}
", "PS", "ps_5_0");

        byte[] vsBytes = vertexShaderByteCode.AsBytes();
        byte[] psBytes = pixelShaderByteCode.AsBytes();

        _cubeVertexShader = d3dDevice.CreateVertexShader(vsBytes);
        _cubePixelShader = d3dDevice.CreatePixelShader(psBytes);

        var inputElements = new[]
        {
            new InputElementDescription("POSITION", 0, Format.R32G32B32A32_Float, 0, 0),
            new InputElementDescription("COLOR", 0, Format.R32G32B32A32_Float, 16, 0)
        };

        _cubeInputLayout = d3dDevice.CreateInputLayout(inputElements, vsBytes);
        _cubeConstantBuffer = d3dDevice.CreateBuffer(new BufferDescription(64, BindFlags.ConstantBuffer));

        var rasterizerDesc = new RasterizerDescription(CullMode.Back, Vortice.Direct3D11.FillMode.Solid);
        _cubeRasterizerState = d3dDevice.CreateRasterizerState(rasterizerDesc);

        var depthStencilDesc = new DepthStencilDescription
        {
            DepthEnable = true,
            DepthWriteMask = DepthWriteMask.All,
            DepthFunc = ComparisonFunction.Less,
            StencilEnable = false
        };
        _cubeDepthStencilState = d3dDevice.CreateDepthStencilState(depthStencilDesc);
    }


    public void DrawCube()
    {
        var d3dDevice = _graphicsDevice.D3DDevice;
        var d3dContext = _graphicsDevice.D3DContext;
        var swapChain = _graphicsDevice.SwapChain;
        var depthStencilView = _graphicsDevice.DepthStencilView;

        if (d3dDevice is null || d3dContext is null || swapChain is null || depthStencilView is null) return;
        if (_cubeConstantBuffer is null || _cubeInputLayout is null || _cubeVertexShader is null || _cubePixelShader is null || _cubeVertexBuffer is null || _cubeIndexBuffer is null || _cubeRasterizerState is null || _cubeDepthStencilState is null)
        {
            return;
        }

        // --- ASPECT RATIO FIX ---
        // Prevent division by zero if the window is minimized or has zero height.
        if (RenderTargetSize.Y < 1.0f)
        {
            return;
        }

        var view = Matrix4x4.CreateLookAt(new Vector3(0, 0, -5), Vector3.Zero, Vector3.UnitY);

        // --- CHANGE: Switch to Orthographic Projection ---
        // This removes perspective distortion, so faces don't change size based on distance.
        float aspectRatio = RenderTargetSize.X / RenderTargetSize.Y;
        float viewHeight = 4.0f; // Defines the vertical size of the viewing volume
        float viewWidth = viewHeight * aspectRatio;
        var proj = Matrix4x4.CreateOrthographic(viewWidth, viewHeight, 0.1f, 100.0f);
        // --- END CHANGE ---

        var world = Matrix4x4.CreateFromYawPitchRoll(
            (float)DateTime.Now.TimeOfDay.TotalSeconds,
            (float)DateTime.Now.TimeOfDay.TotalSeconds / 2f,
            (float)DateTime.Now.TimeOfDay.TotalSeconds / 3f);

        var worldViewProj = Matrix4x4.Transpose(world * view * proj);
        d3dContext.UpdateSubresource(worldViewProj, _cubeConstantBuffer);

        d3dContext.RSSetViewport(new Viewport(RenderTargetSize.X, RenderTargetSize.Y));
        d3dContext.RSSetState(_cubeRasterizerState);
        d3dContext.OMSetDepthStencilState(_cubeDepthStencilState);

        d3dContext.IASetPrimitiveTopology(PrimitiveTopology.TriangleList);
        d3dContext.IASetInputLayout(_cubeInputLayout);
        d3dContext.VSSetShader(_cubeVertexShader);
        d3dContext.VSSetConstantBuffer(0, _cubeConstantBuffer);
        d3dContext.PSSetShader(_cubePixelShader);
        d3dContext.IASetVertexBuffer(0, _cubeVertexBuffer, 32);
        d3dContext.IASetIndexBuffer(_cubeIndexBuffer, Format.R16_UInt, 0);

        using (var backBuffer = swapChain.GetBuffer<ID3D11Texture2D>(0))
        {
            using var renderTargetView = d3dDevice.CreateRenderTargetView(backBuffer);
            d3dContext.ClearRenderTargetView(renderTargetView, Colors.CornflowerBlue);
            d3dContext.ClearDepthStencilView(depthStencilView, DepthStencilClearFlags.Depth, 1.0f, 0);
            d3dContext.OMSetRenderTargets([renderTargetView], depthStencilView);
            d3dContext.DrawIndexed(36, 0, 0);
        }

        // Unbind render targets before flushing, to release control for Direct2D
        d3dContext.OMSetRenderTargets(new ID3D11RenderTargetView(0));

        // Flush the 3D commands to ensure they are executed before D2D begins drawing.
        d3dContext.Flush();
    }

    public void DrawImage(byte[] imageData, string imageKey, Rect destination)
    {
        throw new NotImplementedException();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Direct2D\DirectWriteTextLayout.cs">
// DirectUI/Backends/DirectWriteTextLayout.cs
using System;
using System.Numerics;
using DirectUI.Core;
using Vortice.DirectWrite;
using SharpGen.Runtime;

namespace DirectUI.Backends;

/// <summary>
/// A DirectWrite-specific implementation of the ITextLayout interface.
/// This class wraps an IDWriteTextLayout object. It is internal to the backend.
/// </summary>
internal class DirectWriteTextLayout : ITextLayout
{
    public IDWriteTextLayout DWriteLayout { get; }

    public Vector2 Size { get; }
    public string Text { get; }

    public DirectWriteTextLayout(IDWriteTextLayout dwriteLayout, string text) // Added 'string text' parameter
    {
        DWriteLayout = dwriteLayout;
        Size = new Vector2(dwriteLayout.Metrics.WidthIncludingTrailingWhitespace, dwriteLayout.Metrics.Height);
        Text = text; // Assign the provided text
    }

    public TextHitTestMetrics HitTestTextPosition(int textPosition, bool isTrailingHit)
    {
        DWriteLayout.HitTestTextPosition((uint)textPosition, isTrailingHit, out float x, out float y, out var metrics);
        return new TextHitTestMetrics(new Vector2(x, y), new Vector2(metrics.Width, metrics.Height));
    }

    public TextHitTestResult HitTestPoint(Vector2 point)
    {
        DWriteLayout.HitTestPoint(point.X, point.Y, out RawBool isTrailingHit, out RawBool isInside, out var hitTestMetrics);

        var metrics = new TextHitTestMetrics(
            new Vector2(hitTestMetrics.Left, hitTestMetrics.Top),
            new Vector2(hitTestMetrics.Width, hitTestMetrics.Height)
        );

        return new TextHitTestResult(
            (int)hitTestMetrics.TextPosition,
            isTrailingHit,
            isInside,
            metrics
        );
    }

    public void Dispose()
    {
        DWriteLayout.Dispose();
        GC.SuppressFinalize(this);
    }

    ~DirectWriteTextLayout()
    {
        Dispose();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Direct2D\DirectWriteTextService.cs">
// DirectUI/Backends/DirectWriteTextService.cs
using System;
using System.Collections.Generic;
using System.Numerics;
using DirectUI.Core;
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace DirectUI.Backends;

/// <summary>
/// An implementation of ITextService that uses DirectWrite.
/// It manages caches for text formats, layouts, and measured sizes.
/// </summary>
public class DirectWriteTextService : ITextService
{
    private readonly IDWriteFactory _dwriteFactory;
    private readonly Dictionary<FontKey, IDWriteTextFormat> _textFormatCache = new();
    private readonly Dictionary<TextLayoutCacheKey, ITextLayout> _textLayoutCache = new();
    private readonly Dictionary<(string, FontKey), Vector2> _textSizeCache = new();

    // Internal cache key structs
    internal readonly struct FontKey(ButtonStyle style) : IEquatable<FontKey>
    {
        private readonly string FontName = style.FontName;
        private readonly float FontSize = style.FontSize;
        private readonly FontWeight FontWeight = style.FontWeight;
        private readonly FontStyle FontStyle = style.FontStyle;
        private readonly FontStretch FontStretch = style.FontStretch;
        public bool Equals(FontKey other) => FontName == other.FontName && FontSize.Equals(other.FontSize) && FontWeight == other.FontWeight && FontStyle == other.FontStyle && FontStretch == other.FontStretch;
        public override bool Equals(object? obj) => obj is FontKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(FontName, FontSize, FontWeight, FontStyle, FontStretch);
    }

    internal readonly struct TextLayoutCacheKey(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment) : IEquatable<TextLayoutCacheKey>
    {
        private readonly string Text = text;
        private readonly FontKey FontKey = new(style);
        private readonly Vector2 MaxSize = maxSize;
        private readonly HAlignment HAlign = alignment.Horizontal;
        private readonly VAlignment VAlign = alignment.Vertical;
        public bool Equals(TextLayoutCacheKey other) => Text == other.Text && MaxSize.Equals(other.MaxSize) && HAlign == other.HAlign && VAlign == other.VAlign && FontKey.Equals(other.FontKey);
        public override bool Equals(object? obj) => obj is TextLayoutCacheKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(Text, FontKey, MaxSize, HAlign, VAlign);
    }

    public DirectWriteTextService(IDWriteFactory dwriteFactory)
    {
        _dwriteFactory = dwriteFactory ?? throw new ArgumentNullException(nameof(dwriteFactory));
    }

    public Vector2 MeasureText(string text, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(text) || style is null) return Vector2.Zero;

        var fontKey = new FontKey(style);
        var cacheKey = (text, fontKey);
        if (_textSizeCache.TryGetValue(cacheKey, out var cachedSize)) return cachedSize;

        IDWriteTextFormat? textFormat = GetOrCreateTextFormat(style);
        if (textFormat is null)
        {
            Console.WriteLine("Warning: Failed to create/get TextFormat for measurement.");
            return Vector2.Zero;
        }

        using var textLayout = _dwriteFactory.CreateTextLayout(text, textFormat, float.MaxValue, float.MaxValue);
        TextMetrics textMetrics = textLayout.Metrics;
        var measuredSize = new Vector2(textMetrics.WidthIncludingTrailingWhitespace, textMetrics.Height);
        _textSizeCache[cacheKey] = measuredSize;
        return measuredSize;
    }

    public ITextLayout GetTextLayout(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment)
    {
        var layoutKey = new TextLayoutCacheKey(text, style, maxSize, alignment);
        if (_textLayoutCache.TryGetValue(layoutKey, out var cachedLayout))
        {
            return cachedLayout;
        }

        var textFormat = GetOrCreateTextFormat(style);
        if (textFormat is null) return null!; // Should ideally return a null object or throw.

        var dwriteLayout = _dwriteFactory.CreateTextLayout(text, textFormat, maxSize.X, maxSize.Y);
        dwriteLayout.TextAlignment = alignment.Horizontal switch
        {
            HAlignment.Left => TextAlignment.Leading,
            HAlignment.Center => TextAlignment.Center,
            HAlignment.Right => TextAlignment.Trailing,
            _ => TextAlignment.Leading
        };
        dwriteLayout.ParagraphAlignment = alignment.Vertical switch
        {
            VAlignment.Top => ParagraphAlignment.Near,
            VAlignment.Center => ParagraphAlignment.Center,
            VAlignment.Bottom => ParagraphAlignment.Far,
            _ => ParagraphAlignment.Near
        };

        var newLayout = new DirectWriteTextLayout(dwriteLayout, text); // Passed 'text' as the second argument
        _textLayoutCache[layoutKey] = newLayout;
        return newLayout;
    }

    private IDWriteTextFormat? GetOrCreateTextFormat(ButtonStyle style)
    {
        var key = new FontKey(style);
        if (_textFormatCache.TryGetValue(key, out var format))
        {
            return format;
        }

        try
        {
            var newFormat = _dwriteFactory.CreateTextFormat(style.FontName, null, style.FontWeight, style.FontStyle, style.FontStretch, style.FontSize, "en-us");
            if (newFormat is not null)
            {
                _textFormatCache[key] = newFormat;
            }
            return newFormat;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error creating text format for font '{style.FontName}': {ex.Message}");
            return null;
        }
    }

    public void Cleanup()
    {
        Console.WriteLine("DirectWriteTextService Cleanup: Disposing cached resources...");
        foreach (var pair in _textFormatCache) { pair.Value?.Dispose(); }
        _textFormatCache.Clear();
        foreach (var pair in _textLayoutCache) { pair.Value?.Dispose(); }
        _textLayoutCache.Clear();
        _textSizeCache.Clear();
        Console.WriteLine("DirectWriteTextService Cleanup finished.");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Direct2D\DuiGraphicsDevice.cs">
using DirectUI;
using SharpGen.Runtime;
using Vortice.Direct2D1;
using Vortice.Direct3D;
using Vortice.Direct3D11;
using Vortice.DirectWrite;
using Vortice.DXGI;
using Vortice.Mathematics;

using System;
using Vortice.Direct2D1;
using Vortice.Direct3D;
using Vortice.Direct3D11;
using Vortice.DirectWrite;
using Vortice.DXGI;
using SharpGen.Runtime;
using Vortice.Mathematics;
using Vortice.DCommon;
using D2D = Vortice.Direct2D1;
using DW = Vortice.DirectWrite;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI;

public class DuiGraphicsDevice : IDisposable
{
    public ID2D1Factory1? D2DFactory => SharedGraphicsResources.D2DFactory;
    public IDWriteFactory? DWriteFactory => SharedGraphicsResources.DWriteFactory;
    public ID2D1RenderTarget? RenderTarget { get; private set; }
    public ID3D11Device? D3DDevice { get; private set; }
    public ID3D11DeviceContext? D3DContext { get; private set; }
    public IDXGISwapChain? SwapChain { get; private set; }
    public ID3D11DepthStencilView? DepthStencilView { get; private set; } // Added
    public bool IsInitialized { get; private set; } = false;

    private ID3D11Texture2D? _depthStencilBuffer; // Added
    private bool _isDisposed = false;

    public bool VSync { get; set; } = false;

    public bool Initialize(IntPtr hwnd, SizeI size)
    {
        if (IsInitialized) return true;
        if (hwnd == IntPtr.Zero) return false;

        Console.WriteLine($"Attempting Graphics Initialization for HWND {hwnd} with size {size}...");
        try
        {
            // Clean up any previous (potentially invalid) instance resources
            CleanupRenderTarget();

            if (D2DFactory is null || DWriteFactory is null)
            {
                throw new InvalidOperationException("Shared graphics factories are not initialized. Application.Run() must be called first.");
            }

            if (size.Width <= 0 || size.Height <= 0)
            {
                Console.WriteLine($"Invalid client rect size ({size}). Aborting graphics initialization.");
                return false;
            }

            var swapChainDesc = new SwapChainDescription()
            {
                BufferCount = 1,
                BufferDescription = new ModeDescription((uint)size.Width, (uint)size.Height, Format.B8G8R8A8_UNorm),
                BufferUsage = Usage.RenderTargetOutput,
                OutputWindow = hwnd,
                SampleDescription = new SampleDescription(1, 0),
                Windowed = true
            };

            D3D11.D3D11CreateDeviceAndSwapChain(
                null,
                DriverType.Hardware,
                DeviceCreationFlags.BgraSupport,
                null,
                swapChainDesc,
                out var swapChain,
                out var d3dDevice,
                out _,
                out var d3dContext).CheckError();

            SwapChain = swapChain;
            D3DDevice = d3dDevice;
            D3DContext = d3dContext;

            using (var backBuffer = SwapChain.GetBuffer<ID3D11Texture2D>(0))
            using (var surface = backBuffer.QueryInterface<IDXGISurface>())
            {
                var renderTargetProperties = new RenderTargetProperties(new PixelFormat(Format.B8G8R8A8_UNorm, Vortice.DCommon.AlphaMode.Premultiplied));
                RenderTarget = D2DFactory.CreateDxgiSurfaceRenderTarget(surface, renderTargetProperties);
            }

            CreateDepthStencilView(size); // Create depth buffer

            if (RenderTarget is null) throw new InvalidOperationException("Render target creation returned null unexpectedly.");

            RenderTarget.TextAntialiasMode = D2D.TextAntialiasMode.Cleartype;

            Console.WriteLine($"Vortice Graphics initialized successfully for HWND {hwnd}.");
            IsInitialized = true;
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Graphics Initialization failed: {ex.Message}");
            Cleanup(); // Ensures we are in a clean state after failure
            return false;
        }
    }

    private void CreateDepthStencilView(SizeI size)
    {
        if (D3DDevice is null) return;

        // Clean up old resources first
        _depthStencilBuffer?.Dispose();
        DepthStencilView?.Dispose();

        var depthStencilDesc = new Texture2DDescription
        {
            Width = size.Width,
            Height = size.Height,
            MipLevels = 1,
            ArraySize = 1,
            Format = Format.D24_UNorm_S8_UInt,
            SampleDescription = new SampleDescription(1, 0),
            Usage = ResourceUsage.Default,
            BindFlags = BindFlags.DepthStencil,
        };
        _depthStencilBuffer = D3DDevice.CreateTexture2D(depthStencilDesc);
        DepthStencilView = D3DDevice.CreateDepthStencilView(_depthStencilBuffer);
    }


    public void Resize(SizeI newSize)
    {
        if (!IsInitialized || RenderTarget is null || SwapChain is null) return;

        try
        {
            Console.WriteLine($"Resizing render target to {newSize}...");
            RenderTarget.Dispose();

            // Also dispose depth resources before resizing
            DepthStencilView?.Dispose();
            _depthStencilBuffer?.Dispose();

            SwapChain.ResizeBuffers(1, (uint)newSize.Width, (uint)newSize.Height, Format.B8G8R8A8_UNorm, 0);
            using (var backBuffer = SwapChain.GetBuffer<ID3D11Texture2D>(0))
            using (var surface = backBuffer.QueryInterface<IDXGISurface>())
            {
                var renderTargetProperties = new RenderTargetProperties(new PixelFormat(Format.B8G8R8A8_UNorm, Vortice.DCommon.AlphaMode.Premultiplied));
                RenderTarget = D2DFactory.CreateDxgiSurfaceRenderTarget(surface, renderTargetProperties);
            }

            // Recreate depth resources with the new size
            CreateDepthStencilView(newSize);

            Console.WriteLine("Successfully resized render target.");
        }
        catch (SharpGenException ex)
        {
            Console.WriteLine($"Failed to resize Render Target (SharpGenException): {ex.Message} HRESULT: {ex.ResultCode}");
            if (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
            {
                Console.WriteLine("Render target needs recreation (Detected in Resize Exception).");
                MarkAsLost();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to resize Render Target (General Exception): {ex}");
            MarkAsLost();
        }
    }

    public void BeginDraw()
    {
        if (!IsInitialized || RenderTarget is null)
        {
            return;
        }
        RenderTarget.BeginDraw();
    }

    public void EndDraw()
    {
        if (!IsInitialized || RenderTarget is null) return;

        try
        {
            Result endDrawResult = RenderTarget.EndDraw();
            if (endDrawResult.Failure)
            {
                Console.WriteLine($"EndDraw failed: {endDrawResult.Description}");
                if (endDrawResult.Code == D2D.ResultCode.RecreateTarget.Code)
                {
                    Console.WriteLine("Render target needs recreation (Detected in EndDraw).");
                    MarkAsLost();
                }
            }
            SwapChain?.Present((uint)(VSync ? 1 : 0), 0);
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Render target needs recreation (Caught SharpGenException in EndDraw): {ex.Message}");
            MarkAsLost();
        }
    }

    private void MarkAsLost()
    {
        if (!IsInitialized) return;
        Console.WriteLine("Marking graphics device as lost. Resources will be recreated on next opportunity.");
        Cleanup();
    }

    private void CleanupRenderTarget()
    {
        RenderTarget?.Dispose();
        RenderTarget = null;
    }

    public void Cleanup()
    {
        bool resourcesExisted = RenderTarget is not null;
        if (resourcesExisted) Console.WriteLine("Cleaning up GraphicsDevice instance resources...");

        CleanupRenderTarget();
        DepthStencilView?.Dispose();
        DepthStencilView = null;
        _depthStencilBuffer?.Dispose();
        _depthStencilBuffer = null;
        D3DContext?.Dispose();
        D3DContext = null;
        D3DDevice?.Dispose();
        D3DDevice = null;
        SwapChain?.Dispose();
        SwapChain = null;
        IsInitialized = false;

        if (resourcesExisted) Console.WriteLine("Finished cleaning GraphicsDevice instance resources.");
    }

    public void Dispose()
    {
        if (_isDisposed) return;
        Cleanup();
        _isDisposed = true;
        GC.SuppressFinalize(this);
    }

    ~DuiGraphicsDevice()
    {
        Dispose();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Direct2D\ShaderCompiler.cs">
using SharpGen.Runtime;
using Vortice.D3DCompiler;
using Vortice.Direct3D;

namespace DirectUI.Backends;

public static class ShaderCompiler
{
    public static Blob Compile(string source, string entryPoint, string profile)
    {
        // Calling the overload with positional arguments to avoid naming errors.
        // This is the 10-argument overload.
        // The error suggests the entryPoint and sourceFileName parameters are swapped in the user's library version.
        Result compileResult = Compiler.Compile(
            source,          // 1: string sourceCode
            null,            // 2: ShaderMacro[] defines
            null,            // 3: Include include
            entryPoint,      // 4: string entryPoint (was "ShaderSource")
            "ShaderSource",  // 5: string sourceFileName (was entryPoint)
            profile,         // 6: string profile
            ShaderFlags.None,// 7: ShaderFlags shaderFlags
            EffectFlags.None,// 8: EffectFlags effectFlags
            out Blob? code,  // 9: out Blob result
            out Blob? error  // 10: out Blob errorBlob
        );

        // Check if the compilation failed.
        if (compileResult.Failure)
        {
            string errorMessage = "Shader compilation failed";
            if (error is not null)
            {
                // The error blob contains detailed diagnostics from the compiler.
                errorMessage = error.AsString();
                error.Dispose();
            }
            code?.Dispose(); // Clean up the code blob if it was created.

            // Log the detailed error to the console before throwing.
            Console.WriteLine($"--- SHADER COMPILATION FAILED ---");
            Console.WriteLine($"Entry Point: {entryPoint}");
            Console.WriteLine($"Profile: {profile}");
            Console.WriteLine($"Error: {errorMessage}");
            Console.WriteLine("--- Shader Source ---");
            Console.WriteLine(source);
            Console.WriteLine("---------------------");

            // Throw an exception with the detailed message from the compiler.
            throw new SharpGenException(compileResult, errorMessage);
        }

        // On success, the error blob is usually null, but dispose it just in case.
        error?.Dispose();

        if (code is null)
        {
            // This should not happen if compilation succeeded, but it's a good safeguard.
            throw new InvalidOperationException("Shader compilation succeeded but the resulting blob is null.");
        }

        return code;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Direct2D\Win32AppServicesInitializer.cs">
using Vortice.Mathematics;

namespace DirectUI;

public static class Win32AppServicesInitializer
{
    public static AppServices Initialize(IntPtr hwnd, SizeI clientSize, Action<UIContext> uiDrawCallback, Color4 backgroundColor)
    {
        var appEngine = new AppEngine(uiDrawCallback, backgroundColor);
        var graphicsDevice = new DuiGraphicsDevice();

        if (!graphicsDevice.Initialize(hwnd, clientSize))
        {
            throw new InvalidOperationException("Failed to initialize DuiGraphicsDevice.");
        }

        if (graphicsDevice.DWriteFactory is null)
        {
            throw new InvalidOperationException("CRITICAL: GraphicsDevice did not provide a valid DWriteFactory for TextService initialization.");
        }

        // Pass the entire graphics device to the renderer. This ensures the renderer
        // always has access to the current, valid render target, even after a resize.
        var renderer = new Backends.Direct2DRenderer(graphicsDevice);
        var textService = new Backends.DirectWriteTextService(graphicsDevice.DWriteFactory);

        appEngine.Initialize(textService, renderer);

        Console.WriteLine($"Win32AppServices Initializer: Services created for HWND {hwnd}.");
        return new AppServices(appEngine, graphicsDevice, renderer, textService);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Direct2D\Win32Window.cs">
// Win32Window.cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;
using DirectUI.Core; // Added for IWindowHost

namespace DirectUI;

public abstract class Win32Window : IDisposable
{
    private readonly string _windowClassName;
    private readonly string _windowTitle;
    private readonly int _initialWidth;
    private readonly int _initialHeight;
    private IntPtr _hwnd = IntPtr.Zero;
    private IntPtr _hInstance = IntPtr.Zero;
    private NativeMethods.WndProc _wndProcDelegate;
    private bool _isDisposed = false;
    private static readonly HashSet<string> RegisteredClassNames = new HashSet<string>();
    private GCHandle _gcHandle;

    private readonly Dictionary<uint, Func<IntPtr, IntPtr, IntPtr, IntPtr>> _messageHandlers;

    public IntPtr Handle => _hwnd;
    public string Title => _windowTitle;
    public int Width { get; protected set; }
    public int Height { get; protected set; }
    protected IntPtr OwnerHandle { get; private set; } = IntPtr.Zero;

    protected Win32Window(string title, int width, int height, string className = null)
    {
        _windowTitle = title ?? "Win32 Window";
        _initialWidth = width > 0 ? width : 800;
        _initialHeight = height > 0 ? height : 600;
        Width = _initialWidth;
        Height = _initialHeight;
        _windowClassName = className ?? ("Win32Window_" + Guid.NewGuid().ToString("N"));
        _wndProcDelegate = WindowProcedure;

        _messageHandlers = new Dictionary<uint, Func<IntPtr, IntPtr, IntPtr, IntPtr>>();
        InitializeMessageHandlers();
    }

    private void InitializeMessageHandlers()
    {
        _messageHandlers.Add(NativeMethods.WM_PAINT, Handle_WmPaint);
        _messageHandlers.Add(NativeMethods.WM_SIZE, Handle_WmSize);
        _messageHandlers.Add(NativeMethods.WM_MOUSEMOVE, Handle_WmMouseMove);
        _messageHandlers.Add(NativeMethods.WM_LBUTTONDOWN, (h, w, l) => Handle_WmMouseButton(MouseButton.Left, h, w, l, true));
        _messageHandlers.Add(NativeMethods.WM_LBUTTONUP, (h, w, l) => Handle_WmMouseButton(MouseButton.Left, h, w, l, false));
        _messageHandlers.Add(NativeMethods.WM_RBUTTONDOWN, (h, w, l) => Handle_WmMouseButton(MouseButton.Right, h, w, l, true));
        _messageHandlers.Add(NativeMethods.WM_MBUTTONDOWN, (h, w, l) => Handle_WmMouseButton(MouseButton.Middle, h, w, l, true));
        _messageHandlers.Add(NativeMethods.WM_MBUTTONUP, (h, w, l) => Handle_WmMouseButton(MouseButton.Middle, h, w, l, false));
        _messageHandlers.Add(NativeMethods.WM_XBUTTONDOWN, (h, w, l) => Handle_WmXMouseButton(h, w, l, true));
        _messageHandlers.Add(NativeMethods.WM_XBUTTONUP, (h, w, l) => Handle_WmXMouseButton(h, w, l, false));
        _messageHandlers.Add(NativeMethods.WM_MOUSEWHEEL, Handle_WmMouseWheel);
        _messageHandlers.Add(NativeMethods.WM_KEYDOWN, (h, w, l) => Handle_WmKey(true, h, w, l));
        _messageHandlers.Add(NativeMethods.WM_KEYUP, (h, w, l) => Handle_WmKey(false, h, w, l));
        _messageHandlers.Add(NativeMethods.WM_SYSKEYUP, (h, w, l) => Handle_WmKey(false, h, w, l));
        _messageHandlers.Add(NativeMethods.WM_CHAR, Handle_WmChar);
        _messageHandlers.Add(NativeMethods.WM_CLOSE, Handle_WmClose);
        _messageHandlers.Add(NativeMethods.WM_DESTROY, Handle_WmDestroy);
        _messageHandlers.Add(NativeMethods.WM_NCDESTROY, Handle_WmNcDestroy);
    }

    public bool Create(IntPtr owner = default, uint? style = null, int? x = null, int? y = null)
    {
        OwnerHandle = owner;

        if (_hwnd != IntPtr.Zero)
        {
            return true;
        }

        if (!TryCreateWindow(owner, style, x, y))
        {
            Console.WriteLine("Window creation failed.");
            Dispose();
            return false;
        }

        if (!Initialize())
        {
            Console.WriteLine("Derived init failed.");
            Dispose();
            return false;
        }

        NativeMethods.ShowWindow(_hwnd, NativeMethods.SW_SHOWNORMAL);
        NativeMethods.UpdateWindow(_hwnd);

        return true;
    }

    private bool TryCreateWindow(IntPtr owner, uint? style, int? x, int? y)
    {
        _hInstance = NativeMethods.GetModuleHandle(null);

        if (_hInstance == IntPtr.Zero)
        {
            _hInstance = Process.GetCurrentProcess().Handle;
        }

        Win32WindowHost.RegisterWindow(this);

        lock (RegisteredClassNames)
        {
            if (!RegisteredClassNames.Contains(_windowClassName))
            {
                NativeMethods.WNDCLASSEX wndClass = new()
                {
                    cbSize = Marshal.SizeOf(typeof(NativeMethods.WNDCLASSEX)),
                    style = NativeMethods.CS_HREDRAW | NativeMethods.CS_VREDRAW,
                    lpfnWndProc = _wndProcDelegate,
                    hInstance = _hInstance,
                    lpszClassName = _windowClassName,
                    hIcon = NativeMethods.LoadIcon(IntPtr.Zero, (IntPtr)32512),
                    hCursor = NativeMethods.LoadCursor(IntPtr.Zero, 32512),
                };

                if (NativeMethods.RegisterClassEx(ref wndClass) == 0)
                {
                    Console.WriteLine($"RegisterClassEx failed: {Marshal.GetLastWin32Error()}");
                    return false;
                }

                RegisteredClassNames.Add(_windowClassName);
                Console.WriteLine($"Class '{_windowClassName}' registered.");
            }
        }

        _gcHandle = GCHandle.Alloc(this, GCHandleType.Normal); // Explicitly specify Normal type

        uint windowStyle = style ?? (NativeMethods.WS_OVERLAPPEDWINDOW | NativeMethods.WS_VISIBLE);

        int finalX = x ?? NativeMethods.CW_USEDEFAULT;
        int finalY = y ?? NativeMethods.CW_USEDEFAULT;

        _hwnd = NativeMethods.CreateWindowEx(
            0,
            _windowClassName,
            _windowTitle,
            windowStyle,
            finalX,
            finalY,
            _initialWidth,
            _initialHeight,
            owner,
            IntPtr.Zero,
            _hInstance,
            GCHandle.ToIntPtr(_gcHandle));

        if (_hwnd == IntPtr.Zero)
        {
            Console.WriteLine($"CreateWindowEx failed: {Marshal.GetLastWin32Error()}");

            if (_gcHandle.IsAllocated)
            {
                _gcHandle.Free();
            }

            return false;
        }

        Console.WriteLine($"Window created: {_hwnd}"); return true;
    }

    private static IntPtr WindowProcedure(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        Win32Window? window = null;

        if (msg == NativeMethods.WM_NCCREATE)
        {
            var cs = Marshal.PtrToStructure<NativeMethods.CREATESTRUCT>(lParam);
            var handle = GCHandle.FromIntPtr(cs.lpCreateParams);
            window = handle.Target as Win32Window;

            NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, GCHandle.ToIntPtr(handle));
            Console.WriteLine($"WM_NCCREATE: Associated instance with HWND {hWnd}");
        }
        else
        {
            IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA);

            if (ptr != IntPtr.Zero)
            {
                var handle = GCHandle.FromIntPtr(ptr);
                window = handle.Target as Win32Window;
            }
        }

        if (window is null)
        {
            return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
        }

        try
        {
            return window.HandleMessage(hWnd, msg, wParam, lParam);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling msg {msg}: {ex}");
        }

        return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
    }

    protected virtual IntPtr HandleMessage(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        if (_messageHandlers.TryGetValue(msg, out var handler))
        {
            return handler(hWnd, wParam, lParam);
        }
        return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
    }

    private IntPtr Handle_WmPaint(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        OnPaint();
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmSize(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        Width = NativeMethods.LoWord(lParam);
        Height = NativeMethods.HiWord(lParam);
        OnSize(Width, Height);
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmMouseMove(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        OnMouseMove(NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmMouseButton(MouseButton button, IntPtr hWnd, IntPtr wParam, IntPtr lParam, bool isDown)
    {
        if (isDown) NativeMethods.SetCapture(hWnd);
        else NativeMethods.ReleaseCapture();

        if (isDown) OnMouseDown(button, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
        else OnMouseUp(button, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmXMouseButton(IntPtr hWnd, IntPtr wParam, IntPtr lParam, bool isDown)
    {
        short xButton = NativeMethods.HiWord(wParam);
        MouseButton button = (xButton == 1) ? MouseButton.XButton1 : MouseButton.XButton2;

        if (isDown) NativeMethods.SetCapture(hWnd);
        else NativeMethods.ReleaseCapture();

        if (isDown) OnMouseDown(button, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
        else OnMouseUp(button, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmMouseWheel(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        short wheelDelta = NativeMethods.HiWord(wParam);
        OnMouseWheel((float)wheelDelta / 120.0f); // Normalize delta
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmKey(bool isDown, IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        Keys key = (Keys)wParam;
        if (isDown) OnKeyDown(key);
        else OnKeyUp(key);
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmChar(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        OnChar((char)wParam);
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmClose(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        if (OnClose())
        {
            NativeMethods.DestroyWindow(hWnd);
        }
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmDestroy(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        Console.WriteLine($"WM_DESTROY for {_hwnd}.");
        Win32WindowHost.UnregisterWindow(this);
        OnDestroy();

        if (OwnerHandle == IntPtr.Zero)
        {
            Win32WindowHost.Exit();
        }
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmNcDestroy(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        Console.WriteLine($"WM_NCDESTROY: Releasing GCHandle for {hWnd}.");

        IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA);

        if (ptr != IntPtr.Zero)
        {
            var handle = GCHandle.FromIntPtr(ptr);

            if (handle.IsAllocated)
            {
                handle.Free();
            }

            NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, IntPtr.Zero);
        }

        if (_gcHandle.IsAllocated)
        {
            _gcHandle.Free();
            _gcHandle = default;
        }

        _hwnd = IntPtr.Zero;
        return IntPtr.Zero;
    }


    public void Close()
    {
        if (_hwnd == IntPtr.Zero)
        {
            return;
        }

        // Post a close message instead of destroying directly.
        // This is a safer pattern, allowing the window to process the close request
        // through its own message loop, preventing re-entrancy issues if called
        // from within a message handler (like a button click during WM_PAINT).
        NativeMethods.PostMessage(_hwnd, NativeMethods.WM_CLOSE, IntPtr.Zero, IntPtr.Zero);
    }

    public void Invalidate()
    {
        if (_hwnd == IntPtr.Zero)
        {
            return;
        }

        NativeMethods.InvalidateRect(_hwnd, IntPtr.Zero, false);
    }

    public virtual void FrameUpdate()
    {

    }

    internal bool GetWindowRect(out NativeMethods.RECT rect)
    {
        if (Handle == IntPtr.Zero)
        {
            rect = default;
            return false;
        }

        return NativeMethods.GetWindowRect(Handle, out rect);
    }

    protected virtual bool Initialize()
    {
        return true;
    }

    protected abstract void OnPaint();

    protected virtual void OnSize(int width, int height)
    {

    }

    protected virtual void OnMouseDown(MouseButton button, int x, int y)
    {

    }

    protected virtual void OnMouseUp(MouseButton button, int x, int y)
    {

    }

    protected virtual void OnMouseMove(int x, int y)
    {

    }

    protected virtual void OnKeyDown(Keys key)
    {

    }

    protected virtual void OnKeyUp(Keys key)
    {

    }

    protected virtual void OnMouseWheel(float delta)
    {

    }

    protected virtual void OnChar(char c)
    {

    }

    protected virtual bool OnClose()
    {
        return true;
    }

    protected virtual void OnDestroy()
    {

    }

    protected virtual void Cleanup()
    {

    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (_isDisposed)
        {
            return;
        }

        if (disposing)
        {
            Console.WriteLine("Disposing Win32Window (managed)...");
            Cleanup();
        }

        Console.WriteLine("Disposing Win32Window (unmanaged)...");

        if (_hwnd != IntPtr.Zero)
        {
            Console.WriteLine($"Destroying window {_hwnd} during Dispose...");
            NativeMethods.DestroyWindow(_hwnd);
            _hwnd = IntPtr.Zero;
        }
        else
        {
            // If _hwnd is already zero, it means DestroyWindow was likely called via WM_DESTROY/WM_NCDESTROY.
            // In that case, the GCHandle should have already been freed by Handle_WmNcDestroy.
            // Only free it here if it's still allocated and _hwnd is zero, indicating a Dispose() call
            // that didn't go through the full Win32 message loop shutdown for some reason.
            if (_gcHandle.IsAllocated)
            {
                Console.WriteLine("Freeing dangling GCHandle during Dispose (unexpected, but cleaning up).");
                _gcHandle.Free();
                _gcHandle = default;
            }
        }

        _isDisposed = true;

        Console.WriteLine("Win32Window disposed.");
    }

    ~Win32Window()
    {
        Console.WriteLine("Win32Window Finalizer!");
        Dispose(false);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Direct2D\Win32WindowHost.cs">
// Entire file content here
using DirectUI.Core;
using DirectUI.Input;
using Vortice.Mathematics;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI;

public class Win32WindowHost : Win32Window, IWindowHost, IModalWindowService
{
    private AppServices? appServices;

    private ModalWindow? activeModalWindow;
    private int modalResultCode;
    private Action<int>? onModalClosedCallback;
    private bool _isModalClosing;
    private readonly System.Diagnostics.Stopwatch _throttleTimer = new();
    private long _lastModalRepaintTicks;
    private static readonly long _modalRepaintIntervalTicks = System.Diagnostics.Stopwatch.Frequency / 10;
    private bool _isCtrlDown; // For zoom

    // --- Logic moved from Application.cs ---
    private static readonly List<Win32Window> s_windows = [];
    private static bool s_isRunning = false;

    public bool IsModalWindowOpen
    {
        get
        {
            return activeModalWindow is not null
                && activeModalWindow.Handle != IntPtr.Zero;
        }
    }

    public Win32WindowHost(string title = "DirectUI Win32 Host", int width = 800, int height = 600)
        : base(title, width, height)
    {
        _throttleTimer.Start();
    }

    public AppEngine AppEngine => appServices?.AppEngine ?? throw new InvalidOperationException("AppEngine is not initialized.");
    public InputManager Input => appServices?.AppEngine.Input ?? new();
    public SizeI ClientSize => GetClientRectSize();

    public bool ShowFpsCounter
    {
        get
        {
            return appServices?.AppEngine.ShowFpsCounter ?? false;
        }

        set
        {
            if (appServices is null)
            {
                return;
            }

            appServices.AppEngine.ShowFpsCounter = value;
        }
    }

    public IModalWindowService ModalWindowService => this;

    public bool Initialize(Action<UIContext> uiDrawCallback, Color4 backgroundColor, float initialScale = 1.0f)
    {
        Console.WriteLine("Win32WindowHost initializing...");

        // Initialize shared resources required by the Win32 backend.
        SharedGraphicsResources.Initialize();

        // Create the window before initializing services, as the window handle is required.
        if (!base.Create())
        {
            Console.WriteLine("Win32WindowHost failed to create its window handle.");
            return false;
        }

        try
        {
            appServices = Win32AppServicesInitializer.Initialize(Handle, GetClientRectSize(), uiDrawCallback, backgroundColor);
            appServices.AppEngine.UIScale = initialScale;
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to initialize Win32WindowHost services: {ex.Message}");
            return false;
        }
    }

    void IWindowHost.Cleanup()
    {
        Cleanup();
    }

    protected override void Cleanup()
    {
        if (_isModalClosing)
        {
            return;
        }

        Console.WriteLine("Win32WindowHost cleaning up its resources...");
        appServices?.AppEngine.Cleanup();
        appServices?.TextService.Cleanup();
        (appServices?.Renderer as Backends.Direct2DRenderer)?.Cleanup();
        appServices?.GraphicsDevice.Cleanup();

        // Cleanup shared resources when the host is disposed.
        SharedGraphicsResources.Cleanup();

        appServices = null;
        activeModalWindow = null;

        base.Cleanup();
    }

    public void RunLoop()
    {
        if (s_windows.Count == 0)
        {
            Console.WriteLine("Win32WindowHost.RunLoop() called with no windows registered.");
            return;
        }

        s_isRunning = true;

        while (s_isRunning)
        {
            ProcessMessages();

            if (!s_isRunning)
            {
                continue;
            }

            foreach (Win32Window? window in s_windows.ToList())
            {
                window.FrameUpdate();
            }
        }
    }

    private static void ProcessMessages()
    {
        while (NativeMethods.PeekMessage(out var msg, IntPtr.Zero, 0, 0, NativeMethods.PM_REMOVE))
        {
            if (msg.message == NativeMethods.WM_QUIT)
            {
                s_isRunning = false;
                break;
            }

            NativeMethods.TranslateMessage(ref msg);
            NativeMethods.DispatchMessage(ref msg);
        }
    }

    internal static void RegisterWindow(Win32Window window)
    {
        if (!s_windows.Contains(window))
        {
            s_windows.Add(window);
        }
    }

    internal static void UnregisterWindow(Win32Window window)
    {
        s_windows.Remove(window);

        if (s_windows.Count == 0)
        {
            Exit();
        }
    }

    internal static void Exit()
    {
        if (!s_isRunning)
        {
            return;
        }
        s_isRunning = false;
        NativeMethods.PostQuitMessage(0);
    }
    // --- End of logic moved from Application.cs ---

    protected override void OnPaint()
    {
        if (appServices is null || !appServices.GraphicsDevice.IsInitialized)
        {
            Console.WriteLine("Render services not initialized. Skipping paint.");
            return;
        }

        appServices.GraphicsDevice.BeginDraw();
        try
        {
            if (appServices.AppEngine is not null && appServices.GraphicsDevice.RenderTarget is not null)
            {
                appServices.GraphicsDevice.RenderTarget.Clear(appServices.AppEngine.BackgroundColor);
            }

            // If a modal is open, this host window is disabled and should not process UI logic.
            // Just clearing the background is enough to keep it from looking "wiped" by the OS.
            if (!IsModalWindowOpen)
            {
                appServices?.AppEngine?.UpdateAndRender(appServices.Renderer, appServices.TextService);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred during drawing: {ex}");
            appServices.GraphicsDevice.Cleanup();
        }
        finally
        {
            appServices.GraphicsDevice.EndDraw();
        }
    }

    public override void FrameUpdate()
    {
        if (IsModalWindowOpen)
        {
            long currentTicks = _throttleTimer.ElapsedTicks;
            if (currentTicks - _lastModalRepaintTicks > _modalRepaintIntervalTicks)
            {
                OnPaint();
                _lastModalRepaintTicks = currentTicks;
            }
        }
        else
        {
            Invalidate();
        }
        HandleModalLifecycle();
    }

    protected override void OnSize(int width, int height)
    {
        appServices?.GraphicsDevice.Resize(new SizeI(width, height));
    }

    protected override void OnMouseMove(int x, int y)
    {
        appServices?.AppEngine.Input.SetMousePosition(x, y);
        Invalidate();
    }

    protected override void OnMouseDown(MouseButton button, int x, int y)
    {
        appServices?.AppEngine.Input.SetMousePosition(x, y);
        appServices?.AppEngine.Input.SetMouseDown(button);
        Invalidate();
    }

    protected override void OnMouseUp(MouseButton button, int x, int y)
    {
        appServices?.AppEngine.Input.SetMousePosition(x, y);
        appServices?.AppEngine.Input.SetMouseUp(button);
        Invalidate();
    }

    protected override void OnMouseWheel(float delta)
    {
        if (appServices is null) return;

        if (_isCtrlDown)
        {
            float scaleDelta = delta * 0.1f;
            appServices.AppEngine.UIScale = Math.Clamp(appServices.AppEngine.UIScale + scaleDelta, 0.5f, 3.0f);
        }
        else
        {
            appServices.AppEngine.Input.AddMouseWheelDelta(delta);
        }
        Invalidate();
    }

    protected override void OnKeyDown(Keys key)
    {
        if (key == Keys.Control) _isCtrlDown = true;

        appServices?.AppEngine.Input.AddKeyPressed(key);

        if (key == Keys.Escape)
        {
            Close();
        }

        if (key == Keys.F3 && appServices?.AppEngine is not null)
        {
            appServices.AppEngine.ShowFpsCounter = !appServices.AppEngine.ShowFpsCounter;
        }

        Invalidate();
    }

    protected override void OnKeyUp(Keys key)
    {
        if (key == Keys.Control) _isCtrlDown = false;
        appServices?.AppEngine.Input.AddKeyReleased(key);
        Invalidate();
    }

    protected override void OnChar(char c)
    {
        appServices?.AppEngine.Input.AddCharacterInput(c);
        Invalidate();
    }

    protected override bool OnClose()
    {
        return true;
    }

    protected override void OnDestroy()
    {
        base.OnDestroy();

        if (activeModalWindow is null || activeModalWindow.Handle == IntPtr.Zero)
        {
            return;
        }

        activeModalWindow.Close();
    }

    private SizeI GetClientRectSize()
    {
        if (Handle == nint.Zero || !NativeMethods.GetClientRect(Handle, out NativeMethods.RECT r))
        {
            return new(Width, Height);
        }

        int width = int.Max(1, r.right - r.left);
        int height = int.Max(1, r.bottom - r.top);

        return new(width, height);
    }

    public void OpenModalWindow(string title, int width, int height, Action<UIContext> drawCallback, Action<int>? onClosedCallback = null)
    {
        if (activeModalWindow is not null && activeModalWindow.Handle != IntPtr.Zero)
        {
            Console.WriteLine("Warning: Cannot open a new modal window while another is already active.");
            return;
        }

        activeModalWindow = new(this, title, width, height, drawCallback);

        if (activeModalWindow.CreateAsModal())
        {
            OnPaint();
            _lastModalRepaintTicks = _throttleTimer.ElapsedTicks;
            this.onModalClosedCallback = onClosedCallback;
            modalResultCode = -1;
            Console.WriteLine("Modal window opened successfully.");
        }
        else
        {
            Console.WriteLine("Failed to create modal window.");
            activeModalWindow.Dispose();
            activeModalWindow = null;
            onClosedCallback?.Invoke(-1);
        }
    }

    public void CloseModalWindow(int resultCode = 0)
    {
        if (activeModalWindow is null || activeModalWindow.Handle == IntPtr.Zero)
        {
            return;
        }

        modalResultCode = resultCode;
        activeModalWindow.Close();
    }

    /// <summary>
    /// This method is now a fallback for cleanup, but the primary notification
    /// comes from NotifyModalHasClosed.
    /// </summary>
    private void HandleModalLifecycle()
    {
        if (activeModalWindow is null)
        {
            return;
        }

        // If the handle is zero, it means the window was destroyed, but our new
        // notification mechanism might have already handled it. This is a safety net.
        if (activeModalWindow.Handle == IntPtr.Zero && !_isModalClosing)
        {
            Console.WriteLine("[LIFECYCLE-FALLBACK] Cleaning up orphaned modal window.");
            NotifyModalHasClosed();
        }
    }

    /// <summary>
    /// Called directly by the ModalWindow from its OnDestroy method.
    /// This is the new, reliable way to trigger the close callback.
    /// </summary>
    public void NotifyModalHasClosed()
    {
        if (_isModalClosing) return; // Re-entrancy guard
        _isModalClosing = true;

        Console.WriteLine($"Modal window closed. Result: {modalResultCode}");
        onModalClosedCallback?.Invoke(modalResultCode);

        // The modal window is already disposing, so we just clear our references to it.
        activeModalWindow = null;
        onModalClosedCallback = null;
        modalResultCode = 0;
        _isModalClosing = false;
    }

    public bool Initialize(Action<UIContext> uiDrawCallback, Color4 backgroundColor)
    {
        throw new NotImplementedException();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\NewFolder\DwmApi.cs">
using System;
using System.Runtime.InteropServices;

namespace DirectUI.Backends.SkiaSharp;

/// <summary>
/// Contains P/Invoke definitions for the Windows Desktop Window Manager (DWM) API.
/// </summary>
internal static class DwmApi
{
    [DllImport("dwmapi.dll")]
    internal static extern int DwmSetWindowAttribute(IntPtr hwnd, DWMWINDOWATTRIBUTE dwAttribute, ref int pvAttribute, int cbAttribute);

    internal enum DWMWINDOWATTRIBUTE
    {
        DWMWA_USE_IMMERSIVE_DARK_MODE = 20,
        DWMWA_SYSTEMBACKDROP_TYPE = 38,
        DWMWA_WINDOW_CORNER_PREFERENCE = 33
    }

    internal enum DWM_WINDOW_CORNER_PREFERENCE
    {
        DWMWCP_DEFAULT = 0,
        DWMWCP_DONOTROUND = 1,
        DWMWCP_ROUND = 2,
        DWMWCP_ROUNDSMALL = 3
    }

    internal enum DWMSYSTEMBACKDROP_TYPE
    {
        DWMSBT_AUTO = 0,
        DWMSBT_NONE = 1,
        DWMSBT_MAINWINDOW = 2,       // Mica
        DWMSBT_TRANSIENTWINDOW = 3,  // Acrylic
        DWMSBT_TABBEDWINDOW = 4      // Tabbed
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\NewFolder\SilkNetRenderer.cs">
using System;
using System.Collections.Generic;
using System.Numerics;
using DirectUI.Core;
using DirectUI.Drawing;
using SkiaSharp;
using Vortice.Direct2D1;
using Vortice.Mathematics;

namespace DirectUI.Backends.SkiaSharp;

public class SilkNetRenderer : IRenderer
{
    private SKCanvas? _canvas;
    private Vector2 _renderTargetSize;
    private readonly SilkNetTextService _textService;
    private readonly Dictionary<string, SKBitmap> _bitmapCache = new();

    public Vector2 RenderTargetSize => _renderTargetSize;

    public SilkNetRenderer(SilkNetTextService textService)
    {
        _textService = textService;
    }

    public void SetCanvas(SKCanvas canvas, Vector2 size)
    {
        _canvas = canvas;
        _renderTargetSize = size;
    }

    public void DrawLine(Vector2 p1, Vector2 p2, Color color, float strokeWidth)
    {
        if (_canvas is null) return;
        using var paint = new SKPaint
        {
            Color = new SKColor(color.R, color.G, color.B, color.A),
            StrokeWidth = strokeWidth,
            IsAntialias = true,
            Style = SKPaintStyle.Stroke
        };
        _canvas.DrawLine(p1.X, p1.Y, p2.X, p2.Y, paint);
    }

    public void DrawBox(Rect rect, BoxStyle style)
    {
        if (_canvas is null || style is null || rect.Width <= 0 || rect.Height <= 0) return;

        var skRect = new SKRect(rect.Left, rect.Top, rect.Right, rect.Bottom);
        float maxRadius = Math.Min(rect.Width, rect.Height) / 2f;
        float radius = Math.Clamp(style.Roundness * maxRadius, 0, maxRadius);

        // Draw fill
        if (style.FillColor.A > 0)
        {
            using var fillPaint = new SKPaint
            {
                Color = new SKColor(style.FillColor.R, style.FillColor.G, style.FillColor.B, style.FillColor.A),
                IsAntialias = true,
                Style = SKPaintStyle.Fill
            };
            _canvas.DrawRoundRect(skRect, radius, radius, fillPaint);
        }

        // Draw border
        if (style.BorderColor.A > 0 && style.BorderLength > 0)
        {
            using var borderPaint = new SKPaint
            {
                Color = new SKColor(style.BorderColor.R, style.BorderColor.G, style.BorderColor.B, style.BorderColor.A),
                IsAntialias = true,
                Style = SKPaintStyle.Stroke,
                StrokeWidth = style.BorderLength
            };
            // Inset the rectangle slightly so the stroke is drawn on the edge, not half-in/half-out
            skRect.Inflate(-style.BorderLength / 2f, -style.BorderLength / 2f);
            _canvas.DrawRoundRect(skRect, radius, radius, borderPaint);
        }
    }

    public void DrawText(Vector2 origin, string text, ButtonStyle style, Alignment alignment, Vector2 maxSize, Color color)
    {
        if (_canvas is null || string.IsNullOrEmpty(text)) return;

        var typeface = _textService.GetOrCreateTypeface(style);
        using var font = new SKFont(typeface, style.FontSize);
        using var paint = new SKPaint(font)
        {
            Color = new SKColor(color.R, color.G, color.B, color.A),
            IsAntialias = true
        };

        var textBounds = new SKRect();
        paint.MeasureText(text, ref textBounds);
        var textDrawPos = origin;

        // --- Horizontal alignment (based on actual measured text width) ---
        if (maxSize.X > 0)
        {
            switch (alignment.Horizontal)
            {
                case HAlignment.Center:
                    textDrawPos.X += (maxSize.X - textBounds.Width) / 2f - textBounds.Left;
                    break;
                case HAlignment.Right:
                    textDrawPos.X += maxSize.X - textBounds.Width - textBounds.Left;
                    break;
                default: // Left
                    textDrawPos.X -= textBounds.Left;
                    break;
            }
        }
        else
        {
            textDrawPos.X -= textBounds.Left;
        }


        // --- Vertical alignment (based on stable font metrics to prevent jiggling) ---
        var fontMetrics = paint.FontMetrics;
        var baselineY = origin.Y;

        if (maxSize.Y > 0)
        {
            switch (alignment.Vertical)
            {
                case VAlignment.Top:
                    // Align the top of the text (ascent) with the top of the layout box.
                    // Since Ascent is negative, we subtract it.
                    baselineY -= fontMetrics.Ascent;
                    break;
                case VAlignment.Center:
                    // Center the line of text within the layout box.
                    float fontHeight = fontMetrics.Descent - fontMetrics.Ascent;
                    baselineY += (maxSize.Y - fontHeight) / 2f - fontMetrics.Ascent;

                    // Add a small correction for better visual centering, similar to the D2D backend.
                    // The metric center is often lower than the perceived visual center, so we move it up slightly.
                    baselineY -= 1.5f;
                    break;
                case VAlignment.Bottom:
                    // Align the bottom of the text (descent) with the bottom of the layout box.
                    baselineY += maxSize.Y - fontMetrics.Descent;
                    break;
            }
        }
        else
        {
            // If no max size, just align to top as a default
            baselineY -= fontMetrics.Ascent;
        }

        // The Y position for DrawText is the baseline, not the top.
        textDrawPos.Y = baselineY;


        _canvas.DrawText(text, textDrawPos.X, textDrawPos.Y, paint);
    }

    public void DrawImage(byte[] imageData, string imageKey, Rect destination)
    {
        if (_canvas is null || imageData is null || imageData.Length == 0) return;

        if (!_bitmapCache.TryGetValue(imageKey, out var bitmap))
        {
            try
            {
                bitmap = SKBitmap.Decode(imageData);
                if (bitmap is not null)
                {
                    _bitmapCache[imageKey] = bitmap;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to decode image with key {imageKey}: {ex.Message}");
                // Cache a null to prevent re-trying every frame
                _bitmapCache[imageKey] = null!;
                return;
            }
        }

        if (bitmap is null) return; // Decoding failed previously or image is invalid

        var destRect = new SKRect(destination.Left, destination.Top, destination.Right, destination.Bottom);

        // Use an SKPaint object with high-quality filtering to ensure the stretched image is blurry, not pixelated.
        using var paint = new SKPaint { FilterQuality = SKFilterQuality.High };
        _canvas.DrawBitmap(bitmap, destRect, paint);
    }

    public void PushClipRect(Rect rect, AntialiasMode antialiasMode)
    {
        _canvas?.Save();
        _canvas?.ClipRect(new SKRect(rect.Left, rect.Top, rect.Right, rect.Bottom), SKClipOperation.Intersect, true);
    }

    public void PopClipRect()
    {
        _canvas?.Restore();
    }

    public void Flush()
    {
        _canvas?.Flush();
    }

    public void Cleanup()
    {
        // Canvas is managed by the host
        _canvas = null;

        // Dispose cached bitmaps
        foreach (var bitmap in _bitmapCache.Values)
        {
            bitmap?.Dispose();
        }
        _bitmapCache.Clear();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\NewFolder\SilkNetSkiaWindow.cs">
using System;
using System.Numerics;
using DirectUI.Input;
using Silk.NET.Input;
using Silk.NET.Maths;
using Silk.NET.OpenGL;
using Silk.NET.Windowing;
using SkiaSharp;
using Vortice.Mathematics;
using SizeI = Vortice.Mathematics.SizeI;
using Key = Silk.NET.Input.Key;
using Silk.NET.GLFW;

namespace DirectUI.Backends.SkiaSharp;

public class SilkNetSkiaWindow : IDisposable
{
    private readonly SilkNetWindowHost _owner;
    private readonly bool _isModal;
    private readonly Vector2D<int>? _initialPosition;

    internal IWindow IWindow { get; }
    internal AppEngine AppEngine { get; private set; }
    private SilkNetRenderer? _renderer;
    private SilkNetTextService? _textService;
    private GL? _gl;
    private GRContext? _grContext;
    private SKSurface? _skSurface;
    private GRBackendRenderTarget? _renderTarget;
    private IInputContext? _inputContext;
    private bool _isDisposed;
    private bool _isCtrlDown; // For zoom
    private float _initialScale = 1.0f;

    public IntPtr Handle => IWindow.Native.Win32?.Hwnd ?? IntPtr.Zero;
    public InputManager Input => AppEngine?.Input ?? new InputManager();
    public SizeI ClientSize => new(IWindow.Size.X, IWindow.Size.Y);
    public bool ShowFpsCounter
    {
        get => AppEngine?.ShowFpsCounter ?? false;
        set { if (AppEngine is not null) AppEngine.ShowFpsCounter = value; }
    }

    public SilkNetSkiaWindow(
        string title,
        int width,
        int height,
        SilkNetWindowHost owner,
        bool isModal,
        Vector2D<int>? initialPosition = null)
    {
        _owner = owner;
        _isModal = isModal;
        _initialPosition = initialPosition;

        var options = WindowOptions.Default;

        // 1) constructor-time hint
        if (_initialPosition.HasValue)
            options.Position = _initialPosition.Value;

        options.Size = new Vector2D<int>(width, height);
        options.Title = title;
        options.API = new GraphicsAPI(
            ContextAPI.OpenGL,
            ContextProfile.Core,
            ContextFlags.Default,
            new APIVersion(3, 3)
        );
        options.ShouldSwapAutomatically = false;
        options.WindowBorder = isModal
            ? WindowBorder.Fixed
            : WindowBorder.Resizable;

        // keep hidden until we’re fully configured
        options.IsVisible = false;

        if (OperatingSystem.IsWindowsVersionAtLeast(10, 0, 22000))
            options.TransparentFramebuffer = true;

        IWindow = Window.Create(options);
    }

    public bool Initialize(Action<UIContext> uiDrawCallback, Color4 backgroundColor, float initialScale = 1.0f)
    {
        if (IWindow is null) return false;

        _initialScale = initialScale; // Store the scale for the OnLoad event.
        IWindow.Load += () => OnLoad(uiDrawCallback, backgroundColor);
        IWindow.Closing += OnClose;
        IWindow.Resize += OnResize;

        return true;
    }

    private void OnLoad(Action<UIContext> uiDrawCallback, Color4 backgroundColor)
    {
        // 3) final reposition safe-guard
        if (_initialPosition.HasValue)
            IWindow.Position = _initialPosition.Value;

        _gl = IWindow.CreateOpenGL();
        ApplyWindowStyles();

        bool useTransparentBg = _owner.BackdropType != WindowBackdropType.Default
                                && OperatingSystem.IsWindowsVersionAtLeast(10, 0, 22621);

        var finalBg = useTransparentBg
            ? (_owner.TitleBarTheme == WindowTitleBarTheme.Light
                ? new Color4(243 / 255f, 243 / 255f, 243 / 255f, 1 / 255f)
                : new Color4(0, 0, 0, 1 / 255f))
            : backgroundColor;

        _gl.ClearColor(finalBg.R, finalBg.G, finalBg.B, finalBg.A);

        var glInterface = GRGlInterface.Create();
        _grContext = GRContext.CreateGl(glInterface);

        // build the initial Skia surface
        OnResize(IWindow.Size);

        AppEngine = new AppEngine(uiDrawCallback, finalBg);
        AppEngine.UIScale = _initialScale; // Apply the stored scale here.
        _textService = new SilkNetTextService();
        _renderer = new SilkNetRenderer(_textService);
        AppEngine.Initialize(_textService, _renderer);

        _inputContext = IWindow.CreateInput();
        foreach (var kb in _inputContext.Keyboards)
        {
            kb.KeyDown += OnKeyDown;
            kb.KeyUp += OnKeyUp;
            kb.KeyChar += OnKeyChar;
        }
        foreach (var m in _inputContext.Mice)
        {
            m.MouseDown += OnMouseDown;
            m.MouseUp += OnMouseUp;
            m.MouseMove += OnMouseMove;
            m.Scroll += OnMouseWheel;
        }
    }

    public void Render()
    {
        if (IWindow.IsClosing
            || _skSurface is null
            || _renderer is null
            || _textService is null
            || AppEngine is null
            || _gl is null)
            return;

        IWindow.GLContext?.MakeCurrent();
        _gl.Clear(
            ClearBufferMask.ColorBufferBit
          | ClearBufferMask.DepthBufferBit
          | ClearBufferMask.StencilBufferBit
        );

        var bg = AppEngine.BackgroundColor;
        _skSurface.Canvas.Clear(new SKColor(
            (byte)(bg.R * 255),
            (byte)(bg.G * 255),
            (byte)(bg.B * 255),
            (byte)(bg.A * 255)
        ));

        _renderer.SetCanvas(_skSurface.Canvas, new Vector2(IWindow.Size.X, IWindow.Size.Y));
        AppEngine.UpdateAndRender(_renderer, _textService);
        _skSurface.Canvas.Flush();
        IWindow.SwapBuffers();
    }

    private void OnResize(Vector2D<int> size)
    {
        _gl?.Viewport(size);

        _renderTarget?.Dispose();
        _skSurface?.Dispose();

        _renderTarget = new GRBackendRenderTarget(
            size.X, size.Y, 0, 8,
            new GRGlFramebufferInfo(0, (uint)GLEnum.Rgba8)
        );

        _skSurface = SKSurface.Create(
            _grContext,
            _renderTarget,
            GRSurfaceOrigin.BottomLeft,
            SKColorType.Rgba8888
        );

        // This is the fix: Clear all cached text resources.
        // The cached resources (like SKTypeface) can hold onto metrics related to the old
        // window size/DPI. Clearing them ensures they are recreated with correct,
        // up-to-date metrics on the next frame, fixing caret measurement issues.
        _textService?.Cleanup();

        // --- THE FIX ---
        // By calling Render() here, we force a redraw and buffer swap
        // within the OS's modal resize loop, creating the live effect.
        Render();
    }

    private void OnClose() { }

    private void ApplyWindowStyles()
    {
        if (!OperatingSystem.IsWindows() || Handle == IntPtr.Zero)
            return;

        var backdrop = _owner.BackdropType;
        var theme = _owner.TitleBarTheme;
        bool modern = backdrop != WindowBackdropType.Default
                       && OperatingSystem.IsWindowsVersionAtLeast(10, 0, 22621);

        if (OperatingSystem.IsWindowsVersionAtLeast(10, 0, 17763))
        {
            bool immersive = modern || theme != WindowTitleBarTheme.Default;
            if (immersive)
            {
                int dark = theme == WindowTitleBarTheme.Light ? 0 : 1;
                DwmApi.DwmSetWindowAttribute(
                    Handle,
                    DwmApi.DWMWINDOWATTRIBUTE.DWMWA_USE_IMMERSIVE_DARK_MODE,
                    ref dark,
                    sizeof(int)
                );
            }
        }

        if (modern)
        {
            int val = backdrop switch
            {
                WindowBackdropType.Mica => (int)DwmApi.DWMSYSTEMBACKDROP_TYPE.DWMSBT_MAINWINDOW,
                WindowBackdropType.Acrylic => (int)DwmApi.DWMSYSTEMBACKDROP_TYPE.DWMSBT_TRANSIENTWINDOW,
                WindowBackdropType.Tabbed => (int)DwmApi.DWMSYSTEMBACKDROP_TYPE.DWMSBT_TABBEDWINDOW,
                _ => (int)DwmApi.DWMSYSTEMBACKDROP_TYPE.DWMSBT_AUTO,
            };

            if (backdrop == WindowBackdropType.Mica
                && theme == WindowTitleBarTheme.Light)
            {
                val = (int)DwmApi.DWMSYSTEMBACKDROP_TYPE.DWMSBT_TRANSIENTWINDOW;
            }

            DwmApi.DwmSetWindowAttribute(
                Handle,
                DwmApi.DWMWINDOWATTRIBUTE.DWMWA_SYSTEMBACKDROP_TYPE,
                ref val,
                sizeof(int)
            );
        }
    }

    #region Input Callbacks & Mapping

    private void OnKeyDown(IKeyboard kb, Key k, int s)
    {
        if (k is Key.ControlLeft or Key.ControlRight) _isCtrlDown = true;
        Input.AddKeyPressed(MapKey(k));
    }
    private void OnKeyUp(IKeyboard kb, Key k, int s)
    {
        if (k is Key.ControlLeft or Key.ControlRight) _isCtrlDown = false;
        Input.AddKeyReleased(MapKey(k));
    }
    private void OnKeyChar(IKeyboard kb, char c) => Input.AddCharacterInput(c);

    private void OnMouseDown(IMouse m, Silk.NET.Input.MouseButton b)
        => Input.SetMouseDown(MapMouseButton(b));
    private void OnMouseUp(IMouse m, Silk.NET.Input.MouseButton b)
        => Input.SetMouseUp(MapMouseButton(b));
    private void OnMouseMove(IMouse m, Vector2 pos)
        => Input.SetMousePosition((int)pos.X, (int)pos.Y);
    private void OnMouseWheel(IMouse m, ScrollWheel s)
    {
        if (AppEngine is null) return;
        if (_isCtrlDown)
        {
            float scaleDelta = s.Y * 0.1f;
            AppEngine.UIScale = Math.Clamp(AppEngine.UIScale + scaleDelta, 0.5f, 3.0f);
        }
        else
        {
            Input.AddMouseWheelDelta(s.Y);
        }
    }

    // full MapKey/MapMouseButton omitted for brevity—you keep yours here unchanged

    #endregion

    public void Dispose()
    {
        if (_isDisposed) return;

        AppEngine?.Cleanup();
        _renderer?.Cleanup();
        _textService?.Cleanup();
        _skSurface?.Dispose();
        _renderTarget?.Dispose();
        _grContext?.Dispose();
        _gl?.Dispose();
        _inputContext?.Dispose();
        IWindow?.Dispose();

        _isDisposed = true;
        GC.SuppressFinalize(this);
    }

    // inside SilkNetSkiaWindow class, below your OnMouseWheel handler:

    /// <summary>
    /// Maps a Silk.NET key into your DirectUI.Input.Keys enum.
    /// </summary>
    private static Keys MapKey(Key key) => key switch
    {
        Key.Space => Keys.Space,
        Key.Number0 => Keys.D0,
        Key.Number1 => Keys.D1,
        Key.Number2 => Keys.D2,
        Key.Number3 => Keys.D3,
        Key.Number4 => Keys.D4,
        Key.Number5 => Keys.D5,
        Key.Number6 => Keys.D6,
        Key.Number7 => Keys.D7,
        Key.Number8 => Keys.D8,
        Key.Number9 => Keys.D9,
        Key.A => Keys.A,
        Key.B => Keys.B,
        Key.C => Keys.C,
        Key.D => Keys.D,
        Key.E => Keys.E,
        Key.F => Keys.F,
        Key.G => Keys.G,
        Key.H => Keys.H,
        Key.I => Keys.I,
        Key.J => Keys.J,
        Key.K => Keys.K,
        Key.L => Keys.L,
        Key.M => Keys.M,
        Key.N => Keys.N,
        Key.O => Keys.O,
        Key.P => Keys.P,
        Key.Q => Keys.Q,
        Key.R => Keys.R,
        Key.S => Keys.S,
        Key.T => Keys.T,
        Key.U => Keys.U,
        Key.V => Keys.V,
        Key.W => Keys.W,
        Key.X => Keys.X,
        Key.Y => Keys.Y,
        Key.Z => Keys.Z,
        Key.Escape => Keys.Escape,
        Key.Enter => Keys.Enter,
        Key.Tab => Keys.Tab,
        Key.Backspace => Keys.Backspace,
        Key.Insert => Keys.Insert,
        Key.Delete => Keys.Delete,
        Key.Right => Keys.RightArrow,
        Key.Left => Keys.LeftArrow,
        Key.Down => Keys.DownArrow,
        Key.Up => Keys.UpArrow,
        Key.PageUp => Keys.PageUp,
        Key.PageDown => Keys.PageDown,
        Key.Home => Keys.Home,
        Key.End => Keys.End,
        Key.CapsLock => Keys.CapsLock,
        Key.Pause => Keys.Pause,
        Key.F1 => Keys.F1,
        Key.F2 => Keys.F2,
        Key.F3 => Keys.F3,
        Key.F4 => Keys.F4,
        Key.F5 => Keys.F5,
        Key.F6 => Keys.F6,
        Key.F7 => Keys.F7,
        Key.F8 => Keys.F8,
        Key.F9 => Keys.F9,
        Key.F10 => Keys.F10,
        Key.F11 => Keys.F11,
        Key.F12 => Keys.F12,
        Key.Keypad0 => Keys.D0,
        Key.Keypad1 => Keys.D1,
        Key.Keypad2 => Keys.D2,
        Key.Keypad3 => Keys.D3,
        Key.Keypad4 => Keys.D4,
        Key.Keypad5 => Keys.D5,
        Key.Keypad6 => Keys.D6,
        Key.Keypad7 => Keys.D7,
        Key.Keypad8 => Keys.D8,
        Key.Keypad9 => Keys.D9,
        Key.ShiftLeft => Keys.Shift,
        Key.ShiftRight => Keys.Shift,
        Key.ControlLeft => Keys.Control,
        Key.ControlRight => Keys.Control,
        Key.AltLeft => Keys.Alt,
        Key.AltRight => Keys.Alt,
        Key.SuperLeft => Keys.LeftWindows,
        Key.SuperRight => Keys.RightWindows,
        Key.Menu => Keys.Menu,
        _ => Keys.Unknown,
    };

    /// <summary>
    /// Maps a Silk.NET mouse button into your DirectUI.MouseButton enum.
    /// </summary>
    private static DirectUI.MouseButton MapMouseButton(Silk.NET.Input.MouseButton button) => button switch
    {
        Silk.NET.Input.MouseButton.Left => DirectUI.MouseButton.Left,
        Silk.NET.Input.MouseButton.Right => DirectUI.MouseButton.Right,
        Silk.NET.Input.MouseButton.Middle => DirectUI.MouseButton.Middle,
        Silk.NET.Input.MouseButton.Button4 => DirectUI.MouseButton.XButton1,
        Silk.NET.Input.MouseButton.Button5 => DirectUI.MouseButton.XButton2,
        _ => DirectUI.MouseButton.Left,
    };

}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\NewFolder\SilkNetTextLayout.cs">
using System;
using System.Numerics;
using DirectUI.Core;
using SkiaSharp;
using Typography.OpenFont;

namespace DirectUI.Backends.SkiaSharp;

internal class SilkNetTextLayout : ITextLayout
{
    public Vector2 Size { get; }
    public string Text { get; }
    private readonly SKTypeface _typeface;
    private readonly ButtonStyle _style;

    public SilkNetTextLayout(string text, SKTypeface typeface, ButtonStyle style)
    {
        Text = text;
        _typeface = typeface;
        _style = style;
        using var font = new SKFont(typeface, style.FontSize);
        using var paint = new SKPaint(font) { IsAntialias = true };

        // Use a robust measurement that includes trailing spaces
        float width = MeasureTextWithTrailingWhitespace(paint, text);
        var rect = new SKRect();
        // Measure normally to get an accurate height
        paint.MeasureText("Gg", ref rect); // Use characters with ascenders/descenders for stable height
        Size = new Vector2(width, rect.Height);
    }
    public TextHitTestMetrics HitTestTextPosition(int textPosition, bool isTrailingHit)
    {
        if (string.IsNullOrEmpty(Text) && textPosition == 0)
        {
            return new TextHitTestMetrics(Vector2.Zero, new Vector2(1, Size.Y)); // Default caret for empty string
        }
        textPosition = Math.Clamp(textPosition, 0, Text.Length);

        using var font = new SKFont(_typeface, _style.FontSize);
        using var paint = new SKPaint(font) { IsAntialias = true };

        // Measure the substring up to the caret position to get the X coordinate.
        string sub = Text[..textPosition];
        float x = MeasureTextWithTrailingWhitespace(paint, sub);

        // Measure the width of the character at the caret position to determine its size.
        float charWidth;
        if (textPosition < Text.Length)
        {
            // Use the robust measurement here as well in case the character is a space
            charWidth = MeasureTextWithTrailingWhitespace(paint, Text[textPosition].ToString());
        }
        else // Caret is at the end of the string.
        {
            // Use the width of a space as a sensible default for the caret after the last character.
            charWidth = paint.MeasureText(" ");
        }

        return new TextHitTestMetrics(new Vector2(x, 0), new Vector2(charWidth, Size.Y));
    }

    public TextHitTestResult HitTestPoint(Vector2 point)
    {
        if (string.IsNullOrEmpty(Text))
        {
            return new TextHitTestResult(0, false, false, new TextHitTestMetrics(Vector2.Zero, Vector2.Zero));
        }

        using var font = new SKFont(_typeface, _style.FontSize);
        using var paint = new SKPaint(font) { IsAntialias = true };

        bool isInside = point.X >= 0 && point.X <= Size.X && point.Y >= 0 && point.Y <= Size.Y;

        // Use BreakText to find the character index that corresponds to the click's X coordinate.
        // This is still a good starting point.
        int textPosition = (int)paint.BreakText(Text, point.X);
        textPosition = Math.Clamp(textPosition, 0, Text.Length);

        // Determine if it's a "trailing hit" by checking which side of the character's midpoint the click landed on.
        float charStartPos = MeasureTextWithTrailingWhitespace(paint, Text[..textPosition]);
        float charEndPos = (textPosition < Text.Length)
            ? charStartPos + MeasureTextWithTrailingWhitespace(paint, Text[textPosition].ToString())
            : charStartPos;

        bool isTrailingHit = (point.X - charStartPos) > ((charEndPos - charStartPos) / 2f);

        // Get metrics for the hit character.
        var metrics = HitTestTextPosition(textPosition, false);

        return new TextHitTestResult(textPosition, isTrailingHit, isInside, metrics);
    }

    /// <summary>
    /// Measures text width while reliably including trailing whitespace, which SKPaint.MeasureText often trims.
    /// </summary>
    private static float MeasureTextWithTrailingWhitespace(SKPaint paint, string text)
    {
        if (string.IsNullOrEmpty(text)) return 0;

        string trimmedText = text.TrimEnd(' ');
        float width = paint.MeasureText(trimmedText);

        int trailingSpaceCount = text.Length - trimmedText.Length;
        if (trailingSpaceCount > 0)
        {
            // Measure a single space to get its width accurately for the current font.
            float spaceWidth = paint.MeasureText(" ");
            width += trailingSpaceCount * spaceWidth;
        }

        return width;
    }

    public void Dispose()
    {
        // This class doesn't own unmanaged resources directly
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\NewFolder\SilkNetTextService.cs">
using System;
using System.Collections.Generic;
using System.Numerics;
using DirectUI.Core;
using SkiaSharp;
using Typography.OpenFont;
using Vortice.DirectWrite; // For FontWeight, etc.

namespace DirectUI.Backends.SkiaSharp;

public class SilkNetTextService : ITextService
{
    private readonly Dictionary<FontKey, SKTypeface> _typefaceCache = new();
    private readonly Dictionary<TextLayoutCacheKey, ITextLayout> _textLayoutCache = new();
    private readonly Dictionary<(string, FontKey), Vector2> _textSizeCache = new();

    private readonly struct FontKey : IEquatable<FontKey>
    {
        private readonly string FontName;
        private readonly FontWeight FontWeight;
        private readonly FontStyle FontStyle;
        private readonly float FontSize; // Added FontSize to the key for measurement

        public FontKey(ButtonStyle style)
        {
            FontName = style.FontName;
            FontWeight = style.FontWeight;
            FontStyle = style.FontStyle;
            FontSize = style.FontSize; // Capture FontSize
        }

        public bool Equals(FontKey other) => FontName == other.FontName && FontWeight == other.FontWeight && FontStyle == other.FontStyle && FontSize.Equals(other.FontSize);
        public override bool Equals(object? obj) => obj is FontKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(FontName, FontWeight, FontStyle, FontSize);
    }
    private readonly struct TextLayoutCacheKey : IEquatable<TextLayoutCacheKey>
    {
        private readonly string Text;
        private readonly FontKey FontKey;
        private readonly float FontSize;
        public TextLayoutCacheKey(string text, ButtonStyle style)
        {
            Text = text;
            FontKey = new FontKey(style);
            FontSize = style.FontSize;
        }
        public bool Equals(TextLayoutCacheKey other) => Text == other.Text && FontKey.Equals(other.FontKey) && FontSize.Equals(other.FontSize);
        public override bool Equals(object? obj) => obj is TextLayoutCacheKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(Text, FontKey, FontSize);
    }
    public SKTypeface GetOrCreateTypeface(ButtonStyle style)
    {
        // Re-create a key without FontSize for typeface caching, as a typeface is size-independent.
        var typefaceKey = new FontKey(new ButtonStyle { FontName = style.FontName, FontWeight = style.FontWeight, FontStyle = style.FontStyle });
        if (_typefaceCache.TryGetValue(typefaceKey, out var typeface))
        {
            return typeface;
        }

        SKFontStyleWeight weight = (SKFontStyleWeight)style.FontWeight;
        SKFontStyleSlant slant = style.FontStyle == FontStyle.Italic ? SKFontStyleSlant.Italic : SKFontStyleSlant.Upright;

        typeface = SKTypeface.FromFamilyName(style.FontName, weight, SKFontStyleWidth.Normal, slant);
        _typefaceCache[typefaceKey] = typeface;
        return typeface;
    }
    public Vector2 MeasureText(string text, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(text)) return Vector2.Zero;

        // Use the full FontKey that includes size for measurement caching.
        var measurementKey = new FontKey(style);
        var cacheKey = (text, measurementKey);
        if (_textSizeCache.TryGetValue(cacheKey, out var cachedSize))
        {
            return cachedSize;
        }

        var typeface = GetOrCreateTypeface(style);
        using var font = new SKFont(typeface, style.FontSize);
        using var paint = new SKPaint(font);
        var rect = new SKRect();
        paint.MeasureText(text, ref rect);

        var measuredSize = new Vector2(rect.Width, rect.Height);
        _textSizeCache[cacheKey] = measuredSize; // Store in cache
        return measuredSize;
    }

    public ITextLayout GetTextLayout(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment)
    {
        var key = new TextLayoutCacheKey(text, style);
        if (_textLayoutCache.TryGetValue(key, out var layout))
        {
            return layout;
        }

        var typeface = GetOrCreateTypeface(style);
        var newLayout = new SilkNetTextLayout(text, typeface, style);
        _textLayoutCache[key] = newLayout;
        return newLayout;
    }

    public void Cleanup()
    {
        foreach (var typeface in _typefaceCache.Values)
        {
            typeface.Dispose();
        }
        _typefaceCache.Clear();
        _textLayoutCache.Clear();
        _textSizeCache.Clear();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\NewFolder\SilkNetWindowHost.cs">
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using DirectUI.Core;
using DirectUI.Input;
using Silk.NET.Maths;
using Vortice.Mathematics;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI.Backends.SkiaSharp
{
    public enum WindowBackdropType { Default, Mica, Acrylic, Tabbed }
    public enum WindowTitleBarTheme { Default, Dark, Light }

    public class SilkNetWindowHost : Core.IWindowHost, IModalWindowService
    {
        private readonly string _title;
        private readonly int _width;
        private readonly int _height;
        private readonly Color4 _backgroundColor;

        private SilkNetSkiaWindow? _mainWindow;
        private SilkNetSkiaWindow? _activeModalWindow;
        private Action<int>? _onModalClosedCallback;
        private int _modalResultCode;
        private readonly Stopwatch _throttleTimer = new();
        private long _lastMainRepaintTicks;
        private static readonly long _modalRepaintIntervalTicks = Stopwatch.Frequency / 10;
        private bool _isDisposed;

        // Win32 fallback (only on Windows) for precise positioning
#if WINDOWS
        [DllImport("user32.dll", SetLastError = true)]
        private static extern bool SetWindowPos(
            IntPtr hWnd,
            IntPtr hWndInsertAfter,
            int X,
            int Y,
            int cx,
            int cy,
            uint uFlags);

        private const uint SWP_NOSIZE     = 0x0001;
        private const uint SWP_NOZORDER   = 0x0004;
        private const uint SWP_NOACTIVATE = 0x0010;
#endif

        [DllImport("user32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool EnableWindow(IntPtr hWnd, bool bEnable);

        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool SetForegroundWindow(IntPtr hWnd);

        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr SetWindowLongPtr(
            IntPtr hWnd,
            int nIndex,
            IntPtr dwNewLong);
        private const int GWL_HWNDPARENT = -8;

        public AppEngine AppEngine => _mainWindow?.AppEngine ?? throw new InvalidOperationException("AppEngine is not initialized.");
        public IntPtr Handle => _mainWindow?.Handle ?? IntPtr.Zero;
        public InputManager Input => _mainWindow?.Input ?? new InputManager();
        public SizeI ClientSize => _mainWindow?.ClientSize ?? new SizeI(_width, _height);

        public bool ShowFpsCounter
        {
            get => _mainWindow?.ShowFpsCounter ?? false;
            set { if (_mainWindow is not null) _mainWindow.ShowFpsCounter = value; }
        }

        public IModalWindowService ModalWindowService => this;
        public bool IsModalWindowOpen => _activeModalWindow is not null;

        public WindowBackdropType BackdropType { get; set; } = WindowBackdropType.Default;
        public WindowTitleBarTheme TitleBarTheme { get; set; } = WindowTitleBarTheme.Dark;

        public SilkNetWindowHost(string title, int width, int height, Color4 backgroundColor)
        {
            _title = title;
            _width = width;
            _height = height;
            _backgroundColor = backgroundColor;
            _throttleTimer.Start();
        }

        public bool Initialize(Action<UIContext> uiDrawCallback, Color4 backgroundColor, float initialScale = 1.0f)
        {
            _mainWindow = new SilkNetSkiaWindow(
                _title, _width, _height, this, isModal: false);

            // Pass the initial scale down to the window, which will apply it when its AppEngine is created.
            return _mainWindow.Initialize(uiDrawCallback, backgroundColor, initialScale);
        }

        public void RunLoop()
        {
            if (_mainWindow is null)
                return;

            // 1) Create GL/Skia contexts (still hidden)
            _mainWindow.IWindow.Initialize();

            // 2) Pre‐render one frame off‐screen to avoid the blank flash
            _mainWindow.Render();

            // 3) Now show the main window with its first frame already painted
            _mainWindow.IWindow.IsVisible = true;

            // 4) Enter the regular event/render loop
            while (!_mainWindow.IWindow.IsClosing)
            {
                _mainWindow.IWindow.DoEvents();

                bool renderMain = !IsModalWindowOpen;
                if (IsModalWindowOpen)
                {
                    var now = _throttleTimer.ElapsedTicks;
                    if (now - _lastMainRepaintTicks > _modalRepaintIntervalTicks)
                    {
                        renderMain = true;
                        _lastMainRepaintTicks = now;
                    }
                }

                if (renderMain)
                    _mainWindow.Render();

                if (IsModalWindowOpen && !_activeModalWindow!.IWindow.IsClosing)
                    _activeModalWindow.Render();

                if (IsModalWindowOpen && _activeModalWindow!.IWindow.IsClosing)
                    HandleModalClose();
            }
        }

        public void OpenModalWindow(
            string title,
            int width,
            int height,
            Action<UIContext> drawCallback,
            Action<int>? onClosedCallback = null)
        {
            if (IsModalWindowOpen || _mainWindow is null)
                return;

            // Compute centered coords relative to parent
            var parentPos = _mainWindow.IWindow.Position;
            var parentSize = _mainWindow.IWindow.Size;
            var center = new Vector2D<int>(
                parentPos.X + (parentSize.X - width) / 2,
                parentPos.Y + (parentSize.Y - height) / 2
            );

            _onModalClosedCallback = onClosedCallback;
            _modalResultCode = -1;

            // Create the modal window hidden off‐screen
            var offscreen = new Vector2D<int>(-10000, -10000);
            _activeModalWindow = new SilkNetSkiaWindow(
                title, width, height, this, isModal: true, initialPosition: offscreen);

            if (!_activeModalWindow.Initialize(
                    drawCallback,
                    new Color4(60 / 255f, 60 / 255f, 60 / 255f, 1f)))
            {
                HandleModalClose();
                return;
            }

            // Force native handle creation (still hidden)
            _activeModalWindow.IWindow.Initialize();

            // Tell the OS about the owner relationship
            var modalHwnd = _activeModalWindow.Handle;
            var parentHwnd = Handle;
            if (modalHwnd != IntPtr.Zero && parentHwnd != IntPtr.Zero)
                SetWindowLongPtr(modalHwnd, GWL_HWNDPARENT, parentHwnd);

            // Cross‐platform reposition (Win32 fallback on Windows)
            if (modalHwnd != IntPtr.Zero)
            {
#if WINDOWS
                SetWindowPos(
                    modalHwnd,
                    IntPtr.Zero,
                    center.X, center.Y,
                    0, 0,
                    SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
#else
                _activeModalWindow.IWindow.Position = center;
#endif
            }

            // Pre‐render the modal’s first frame off‐screen
            _activeModalWindow.Render();

            // Now reveal the modal with no blank flash
            _activeModalWindow.IWindow.IsVisible = true;

            // Disable and repaint the parent to avoid a blank‐frame
            if (parentHwnd != IntPtr.Zero)
            {
                EnableWindow(parentHwnd, false);
                _mainWindow.Render();
            }

            _lastMainRepaintTicks = _throttleTimer.ElapsedTicks;
        }

        public void CloseModalWindow(int resultCode = 0)
        {
            if (!IsModalWindowOpen)
                return;

            _modalResultCode = resultCode;
            _activeModalWindow?.IWindow.Close();
        }

        private void HandleModalClose()
        {
            var parentHwnd = Handle;

            // First, re-enable the parent window. The OS expects this during a modal teardown.
            if (parentHwnd != IntPtr.Zero)
            {
                EnableWindow(parentHwnd, true);
            }

            if (_activeModalWindow is not null)
            {
                // Now, before the OS can repaint, instantly move the modal far off-screen
                // and hide it. This is the crucial step to prevent the visual glitch.
                _activeModalWindow.IWindow.Position = new Vector2D<int>(-30000, -30000);
                _activeModalWindow.IWindow.IsVisible = false;
                _activeModalWindow.Dispose();
            }
            _activeModalWindow = null;

            // After the modal is gone, bring the parent window to the foreground.
            if (parentHwnd != IntPtr.Zero)
            {
                SetForegroundWindow(parentHwnd);
                _mainWindow?.IWindow.Focus();
            }

            Input.HardReset();
            _onModalClosedCallback?.Invoke(_modalResultCode);
            _onModalClosedCallback = null;
        }

        public void Cleanup()
        {
            if (_isDisposed) return;
            _activeModalWindow?.Dispose();
            _mainWindow?.Dispose();
            _isDisposed = true;
        }

        public void Dispose()
        {
            Cleanup();
            GC.SuppressFinalize(this);
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Raylib\RaylibRenderer.cs">
// DirectUI/Backends/Raylib/RaylibRenderer.cs
using System;
using System.Collections.Generic;
using System.Numerics;
using DirectUI.Core;
using DirectUI.Drawing;
using Vortice.Direct2D1; // For AntialiasMode enum, even if not used by Raylib
using Raylib_cs;
using Vortice.Mathematics; // Raylib specific library

namespace DirectUI.Backends;

/// <summary>
/// A rendering backend that uses Raylib to implement the IRenderer interface.
/// </summary>
public class RaylibRenderer : IRenderer
{
    // This factor compensates for the perceptual size difference between DirectWrite and FreeType rendering.
    // DirectWrite text tends to appear slightly larger/bolder for the same point size.
    private const float FONT_SCALE_FACTOR = 1.125f;
    private readonly Stack<Rectangle> _clipRectStack = new();

    public Vector2 RenderTargetSize
    {
        get
        {
            return new(
                Raylib.GetScreenWidth(),
                Raylib.GetScreenHeight());
        }
    }

    public RaylibRenderer()
    {
        // Raylib is typically initialized externally (e.g., in Program.cs or AppHost)
        // No Raylib-specific initialization needed here in the constructor.
    }

    public void DrawLine(Vector2 p1, Vector2 p2, Drawing.Color color, float strokeWidth)
    {
        // Raylib draws lines with thickness 1 by default, or you can use DrawLineEx for thicker lines
        Raylib.DrawLineEx(p1, p2, strokeWidth, color);
    }

    public void DrawBox(Vortice.Mathematics.Rect rect, BoxStyle style)
    {
        Raylib_cs.Color fillColor = style.FillColor;
        Raylib_cs.Color borderColor = style.BorderColor;

        // Round coordinates to align to the pixel grid for sharper rendering.
        float roundedX = MathF.Round(rect.X);
        float roundedY = MathF.Round(rect.Y);
        // Round the right/bottom edges and calculate width/height to avoid shimmering/gaps.
        float roundedWidth = MathF.Round(rect.X + rect.Width) - roundedX;
        float roundedHeight = MathF.Round(rect.Y + rect.Height) - roundedY;

        // Use this rounded rectangle for all drawing operations.
        Raylib_cs.Rectangle rlRect = new(roundedX, roundedY, roundedWidth, roundedHeight);

        // Border
        if (style.BorderColor.A > 0 && (style.BorderLengthTop > 0 || style.BorderLengthRight > 0 || style.BorderLengthBottom > 0 || style.BorderLengthLeft > 0))
        {
            if (style.Roundness > 0)
            {
                // Draw the outer rounded rectangle for the border
                Raylib.DrawRectangleRounded(rlRect, style.Roundness, 0, borderColor);

                // Calculate the inner rectangle for the fill
                var fillRect = new Raylib_cs.Rectangle(
                    rlRect.X + style.BorderLengthLeft,
                    rlRect.Y + style.BorderLengthTop,
                    rlRect.Width - style.BorderLengthLeft - style.BorderLengthRight,
                    rlRect.Height - style.BorderLengthTop - style.BorderLengthBottom
                );

                // Calculate the inner roundness
                float innerRoundness = style.Roundness; // This might need more sophisticated calculation

                // Draw the inner rounded rectangle for the fill color, effectively creating the border
                if (style.FillColor.A > 0 && fillRect.Width > 0 && fillRect.Height > 0)
                {
                    Raylib.DrawRectangleRounded(fillRect, innerRoundness, 0, fillColor);
                }
            }
            else
            {
                // Use original line-by-line drawing for non-rounded rectangles with rounded coordinates
                float right = rlRect.X + rlRect.Width;
                float bottom = rlRect.Y + rlRect.Height;

                // Top border
                if (style.BorderLengthTop > 0) Raylib.DrawLineEx(new Vector2(rlRect.X, rlRect.Y), new Vector2(right, rlRect.Y), style.BorderLengthTop, borderColor);
                // Right border
                if (style.BorderLengthRight > 0) Raylib.DrawLineEx(new Vector2(right, rlRect.Y), new Vector2(right, bottom), style.BorderLengthRight, borderColor);
                // Bottom border
                if (style.BorderLengthBottom > 0) Raylib.DrawLineEx(new Vector2(right, bottom), new Vector2(rlRect.X, bottom), style.BorderLengthBottom, borderColor);
                // Left border
                if (style.BorderLengthLeft > 0) Raylib.DrawLineEx(new Vector2(rlRect.X, bottom), new Vector2(rlRect.X, rlRect.Y), style.BorderLengthLeft, borderColor);

                // Now, draw the fill rectangle inside the borders
                if (style.FillColor.A > 0)
                {
                    var fillRect = new Raylib_cs.Rectangle(
                        rlRect.X + style.BorderLengthLeft,
                        rlRect.Y + style.BorderLengthTop,
                        rlRect.Width - style.BorderLengthLeft - style.BorderLengthRight,
                        rlRect.Height - style.BorderLengthTop - style.BorderLengthBottom
                    );
                    if (fillRect.Width > 0 && fillRect.Height > 0)
                    {
                        Raylib.DrawRectangleRec(fillRect, fillColor);
                    }
                }
            }
        }
        else if (style.FillColor.A > 0) // No border, just fill
        {
            if (style.Roundness > 0)
            {
                Raylib.DrawRectangleRounded(rlRect, style.Roundness, 0, fillColor);
            }
            else
            {
                Raylib.DrawRectangleRec(rlRect, fillColor);
            }
        }
    }

    public void DrawText(Vector2 origin, string text, ButtonStyle style, Alignment alignment, Vector2 maxSize, Drawing.Color color)
    {
        if (string.IsNullOrEmpty(text))
        {
            return;
        }

        float finalFontSize = style.FontSize * FONT_SCALE_FACTOR;
        int atlasSize = (int)Math.Round(finalFontSize);
        if (atlasSize <= 0) atlasSize = 1; // Prevent loading font at size 0.

        Raylib_cs.Color rlColor = color;

        // Use the FontManager to get the appropriate font, loaded at the native resolution and correct weight.
        Font rlFont = FontManager.GetFont(style.FontName, atlasSize, style.FontWeight);

        // The font size passed to Raylib should be the integer size the font atlas was generated with
        // to ensure 1:1 pixel rendering and avoid scaling artifacts.
        Vector2 measuredSize = Raylib.MeasureTextEx(rlFont, text, atlasSize, atlasSize / 10f);

        Vector2 textDrawPos = origin;

        // Apply horizontal alignment
        if (maxSize.X > 0 && measuredSize.X < maxSize.X)
        {
            switch (alignment.Horizontal)
            {
                case HAlignment.Center:
                    textDrawPos.X += (maxSize.X - measuredSize.X) / 2f;
                    break;
                case HAlignment.Right:
                    textDrawPos.X += (maxSize.X - measuredSize.X);
                    break;
            }
        }

        // Apply vertical alignment
        if (maxSize.Y > 0)
        {
            switch (alignment.Vertical)
            {
                case VAlignment.Center:
                    textDrawPos.Y += (maxSize.Y - measuredSize.Y) / 2f;
                    break;
                case VAlignment.Bottom:
                    textDrawPos.Y += (maxSize.Y - measuredSize.Y);
                    break;
            }
        }

        // Round the final position to the nearest whole pixel to prevent sub-pixel "wobble".
        textDrawPos = new Vector2(MathF.Round(textDrawPos.X), MathF.Round(textDrawPos.Y));

        // Draw using the integer atlas size to prevent scaling.
        Raylib.DrawTextEx(rlFont, text, textDrawPos, atlasSize, atlasSize / 10f, rlColor);
    }

    public void PushClipRect(Vortice.Mathematics.Rect rect, AntialiasMode antialiasMode)
    {
        // Store the original float rect on our stack to preserve precision.
        _clipRectStack.Push(new Raylib_cs.Rectangle(rect.X, rect.Y, rect.Width, rect.Height));
        ApplyScissorFromRect(rect);
    }

    public void PopClipRect()
    {
        if (_clipRectStack.Count <= 0)
        {
            return;
        }

        _clipRectStack.Pop();

        if (_clipRectStack.Count > 0)
        {
            // Re-apply the previous clip rect from the stack.
            var prevRect = _clipRectStack.Peek();
            ApplyScissorFromRect(new Vortice.Mathematics.Rect(prevRect.X, prevRect.Y, prevRect.Width, prevRect.Height));
        }
        else
        {
            // If stack is empty, end scissor mode entirely.
            Raylib.EndScissorMode();
        }
    }

    private void ApplyScissorFromRect(Vortice.Mathematics.Rect rect)
    {
        // Raylib's scissor mode is integer-based. To avoid clipping artifacts with
        // fractional coordinates, we calculate an integer-based bounding box that
        // fully contains the desired float-based rectangle.
        int x = (int)MathF.Floor(rect.X);
        int y = (int)MathF.Floor(rect.Y);
        // Add the fractional part of the origin back to the size before ceiling to ensure the rect is fully covered.
        int width = (int)MathF.Ceiling(rect.Width + (rect.X - x));
        int height = (int)MathF.Ceiling(rect.Height + (rect.Y - y));

        Raylib.BeginScissorMode(x, y, width, height);
    }

    public void Flush()
    {
        // Raylib is an immediate-mode API, no flush needed.
    }

    // Raylib specific cleanup (if any resources like fonts were loaded dynamically)
    public void Cleanup()
    {
        // No Raylib-specific font objects to dispose that are loaded here per layout.
        // If fonts were loaded with LoadFontEx, they would need UnloadFont.
        _clipRectStack.Clear();
    }

    public void DrawImage(byte[] imageData, string imageKey, Rect destination)
    {
        throw new NotImplementedException();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Raylib\RaylibTextLayout.cs">
// DirectUI/Backends/Raylib/RaylibTextLayout.cs
using System;
using System.Numerics;
using DirectUI.Core;
using Vortice.Mathematics; // For Color4, Rect
using Raylib_cs; // Raylib specific library

namespace DirectUI.Backends;

/// <summary>
/// A Raylib-specific implementation of the ITextLayout interface.
/// This class stores text and provides approximate metrics.
/// </summary>
internal class RaylibTextLayout : ITextLayout
{
    public Vector2 Size { get; }
    public string Text { get; }

    private readonly Font _raylibFont;

    public RaylibTextLayout(string text, Font preloadedFont, int atlasSize)
    {
        Text = text;
        _raylibFont = preloadedFont;

        // Measure using the integer size the font was generated with to ensure 1:1 metrics.
        Size = Raylib.MeasureTextEx(_raylibFont, text, atlasSize, atlasSize / 10f);
    }

    public TextHitTestMetrics HitTestTextPosition(int textPosition, bool isTrailingHit)
    {
        // Raylib doesn't provide fine-grained text metrics per character easily.
        // This is a rough approximation based on overall text width.
        if (string.IsNullOrEmpty(Text)) return new TextHitTestMetrics(Vector2.Zero, Vector2.Zero);

        float approxCharWidth = Size.X / Text.Length;
        float x = textPosition * approxCharWidth;
        float width = approxCharWidth;

        // Adjust x if it's a trailing hit, to measure the position AFTER the character
        if (isTrailingHit) x += approxCharWidth;

        // Clamp to prevent out-of-bounds positions
        x = Math.Clamp(x, 0, Size.X);

        return new TextHitTestMetrics(new Vector2(x, 0), new Vector2(width, Size.Y));
    }

    public TextHitTestResult HitTestPoint(Vector2 point)
    {
        // This is a rough approximation for hit testing in Raylib
        if (string.IsNullOrEmpty(Text))
        {
            return new TextHitTestResult(0, false, false, new TextHitTestMetrics(Vector2.Zero, Vector2.Zero));
        }

        bool isInside = point.X >= 0 && point.X <= Size.X && point.Y >= 0 && point.Y <= Size.Y;

        float approxCharWidth = (Text.Length > 0) ? Size.X / Text.Length : 0;
        int textPosition = 0;
        bool isTrailingHit = false;

        if (approxCharWidth > 0)
        {
            textPosition = (int)(point.X / approxCharWidth);
            isTrailingHit = (point.X % approxCharWidth) > (approxCharWidth / 2f);
        }

        // Caret position can be one past the last character (i.e., at the end of the string).
        textPosition = Math.Clamp(textPosition, 0, Text.Length);
        if (isTrailingHit && textPosition < Text.Length) // If it's a trailing hit and not at the very end
        {
            textPosition++;
        }
        textPosition = Math.Clamp(textPosition, 0, Text.Length); // Final clamp

        // Recalculate metrics for the specific hit position
        float hitMetricX = (textPosition == 0) ? 0 : (textPosition * approxCharWidth);
        if (isTrailingHit && textPosition > 0) hitMetricX -= approxCharWidth; // Adjust if hit is trailing edge

        return new TextHitTestResult(textPosition, isTrailingHit, isInside,
            new TextHitTestMetrics(new Vector2(hitMetricX, 0), new Vector2(approxCharWidth, Size.Y)));
    }

    public void Dispose()
    {
        // This object doesn't own the font resource, so it does not dispose it.
        // FontManager is responsible for unloading fonts.
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Raylib\RaylibTextService.cs">
// DirectUI/Backends/Raylib/RaylibTextService.cs
using System;
using System.Collections.Generic;
using System.Numerics;
using DirectUI.Core;
using DirectUI.Drawing;
using Vortice.Mathematics; // For Color4, Rect
using Raylib_cs; // Raylib specific library

namespace DirectUI.Backends;

/// <summary>
/// An implementation of ITextService that uses Raylib.
/// It manages caches for text layouts.
/// </summary>
public class RaylibTextService : ITextService
{
    // This factor compensates for the perceptual size difference between DirectWrite and FreeType rendering.
    // DirectWrite text tends to appear slightly larger/bolder for the same point size.
    private const float FONT_SCALE_FACTOR = 1.125f;

    private readonly Dictionary<TextLayoutCacheKey, ITextLayout> _textLayoutCache = new();
    private readonly Dictionary<(string, FontKey), Vector2> _textSizeCache = new();

    // Internal cache key structs (re-defined or referenced from a common place)
    internal readonly struct FontKey(ButtonStyle style) : IEquatable<FontKey>
    {
        private readonly string FontName = style.FontName;
        private readonly float FontSize = style.FontSize;
        private readonly Vortice.DirectWrite.FontWeight FontWeight = style.FontWeight;
        private readonly Vortice.DirectWrite.FontStyle FontStyle = style.FontStyle;
        private readonly Vortice.DirectWrite.FontStretch FontStretch = style.FontStretch;
        public bool Equals(FontKey other) => FontName == other.FontName && FontSize.Equals(other.FontSize) && FontWeight == other.FontWeight && FontStyle == other.FontStyle && FontStretch == other.FontStretch;
        public override bool Equals(object? obj) => obj is FontKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(FontName, FontSize, FontWeight, FontStyle, FontStretch);
    }

    internal readonly struct TextLayoutCacheKey(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment) : IEquatable<TextLayoutCacheKey>
    {
        private readonly string Text = text;
        private readonly FontKey FontKey = new(style);
        private readonly Vector2 MaxSize = maxSize;
        private readonly HAlignment HAlign = alignment.Horizontal;
        private readonly VAlignment VAlign = alignment.Vertical;
        public bool Equals(TextLayoutCacheKey other) => Text == other.Text && MaxSize.Equals(other.MaxSize) && HAlign == other.HAlign && VAlign == other.VAlign && FontKey.Equals(other.FontKey);
        public override bool Equals(object? obj) => obj is TextLayoutCacheKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(Text, FontKey, MaxSize, HAlign, VAlign);
    }

    public RaylibTextService()
    {
        // No specific Raylib font factory initialization needed here
    }

    public Vector2 MeasureText(string text, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(text) || style is null) return Vector2.Zero;

        var fontKey = new FontKey(style);
        var cacheKey = (text, fontKey);
        if (_textSizeCache.TryGetValue(cacheKey, out var cachedSize)) return cachedSize;

        float finalFontSize = style.FontSize * FONT_SCALE_FACTOR;
        int atlasSize = (int)Math.Round(finalFontSize);
        if (atlasSize <= 0) atlasSize = 1;

        // Use the FontManager to get the appropriate font at the native resolution and correct weight.
        Font rlFont = FontManager.GetFont(style.FontName, atlasSize, style.FontWeight);

        // Measure using the integer atlas size for accurate, non-scaled metrics.
        Vector2 measuredSize = Raylib.MeasureTextEx(rlFont, text, atlasSize, atlasSize / 10f);
        _textSizeCache[cacheKey] = measuredSize;
        return measuredSize;
    }

    public ITextLayout GetTextLayout(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment)
    {
        var layoutKey = new TextLayoutCacheKey(text, style, maxSize, alignment);
        if (_textLayoutCache.TryGetValue(layoutKey, out var cachedLayout))
        {
            return cachedLayout;
        }

        float finalFontSize = style.FontSize * FONT_SCALE_FACTOR;
        int atlasSize = (int)Math.Round(finalFontSize);
        if (atlasSize <= 0) atlasSize = 1;

        // Fetch the font at the correct, native atlas resolution and weight.
        var font = FontManager.GetFont(style.FontName, atlasSize, style.FontWeight);

        // Pass the pre-loaded font and the integer atlas size to the layout constructor.
        var newLayout = new RaylibTextLayout(text, font, atlasSize);
        _textLayoutCache[layoutKey] = newLayout;
        return newLayout;
    }

    public void Cleanup()
    {
        Console.WriteLine("RaylibTextService Cleanup: Clearing cached resources...");
        foreach (var pair in _textLayoutCache) { pair.Value?.Dispose(); } // Dispose the ITextLayout instances
        _textLayoutCache.Clear();
        _textSizeCache.Clear();
        Console.WriteLine("RaylibTextService Cleanup finished.");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Raylib\RaylibWindowHost.cs">
// DirectUI/RaylibWindowHost.cs
using System;
using System.Numerics;
using DirectUI.Core; // For IWindowHost, IModalWindowService
using DirectUI.Drawing;
using DirectUI.Input;
using Raylib_cs;
using Vortice.Mathematics;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI;

/// <summary>
/// A concrete implementation of <see cref="IWindowHost"/> for the Raylib backend.
/// </summary>
public class RaylibWindowHost : IWindowHost
{
    private readonly string _title;
    private readonly int _width;
    private readonly int _height;
    private readonly Color4 _backgroundColor;

    private AppEngine? _appEngine;
    private IRenderer? _renderer;
    private ITextService? _textService;
    private bool _isDisposed = false;

    public AppEngine AppEngine => _appEngine ?? throw new InvalidOperationException("AppEngine is not initialized.");
    public IntPtr Handle => IntPtr.Zero;
    public InputManager Input => _appEngine?.Input ?? new InputManager();
    public SizeI ClientSize => new SizeI(Raylib.GetScreenWidth(), Raylib.GetScreenHeight());

    public bool ShowFpsCounter
    {
        get => _appEngine?.ShowFpsCounter ?? false;
        set { if (_appEngine is not null) _appEngine.ShowFpsCounter = value; }
    }

    public IModalWindowService ModalWindowService { get; } = new RaylibDummyModalWindowService();

    public RaylibWindowHost(string title, int width, int height, Color4 backgroundColor)
    {
        _title = title;
        _width = width;
        _height = height;
        _backgroundColor = backgroundColor;
    }

    public bool Initialize(Action<UIContext> uiDrawCallback, Color4 backgroundColor, float initialScale = 1.0f)
    {
        Console.WriteLine("RaylibWindowHost initializing...");
        try
        {
            Raylib.SetConfigFlags(ConfigFlags.Msaa4xHint);
            Raylib.InitWindow(_width, _height, _title);
            Raylib.SetTargetFPS(60);

            _appEngine = new AppEngine(uiDrawCallback, backgroundColor);
            _appEngine.UIScale = initialScale;
            _renderer = new DirectUI.Backends.RaylibRenderer();
            _textService = new DirectUI.Backends.RaylibTextService();

            // Raylib-specific font initialization and registration
            FontManager.Initialize();
            FontManager.RegisterFontVariant("Segoe UI", Vortice.DirectWrite.FontWeight.Normal, "C:/Windows/Fonts/segoeui.ttf");
            FontManager.RegisterFontVariant("Segoe UI", Vortice.DirectWrite.FontWeight.SemiBold, "C:/Windows/Fonts/seguisb.ttf");
            FontManager.RegisterFontVariant("Consolas", Vortice.DirectWrite.FontWeight.Normal, "C:/Windows/Fonts/consola.ttf");
            FontManager.RegisterFontVariant("Consolas", Vortice.DirectWrite.FontWeight.Bold, "C:/Windows/Fonts/consolab.ttf");

            _appEngine.Initialize(_textService, _renderer);
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to initialize RaylibWindowHost: {ex.Message}");
            Cleanup(); // Ensure partial initialization is cleaned up
            return false;
        }
    }

    public void RunLoop()
    {
        while (!Raylib.WindowShouldClose())
        {
            if (_appEngine is null) continue;

            // --- Zoom Logic ---
            bool isCtrlDown = Raylib.IsKeyDown(KeyboardKey.LeftControl) || Raylib.IsKeyDown(KeyboardKey.RightControl);
            float wheelMove = Raylib.GetMouseWheelMove();
            if (isCtrlDown && wheelMove != 0)
            {
                float scaleDelta = wheelMove * 0.1f;
                _appEngine.UIScale = Math.Clamp(_appEngine.UIScale + scaleDelta, 0.5f, 3.0f);
                // Consume the scroll event by not passing it to the InputManager.
                // We still need to process other inputs, so we create a temporary manager.
                var tempInput = new InputManager();
                tempInput.ProcessRaylibInput();
                // Manually add the scroll delta we are ignoring
                tempInput.AddMouseWheelDelta(-wheelMove);
                _appEngine.Input.ProcessRaylibInput();
            }
            else
            {
                // If not zooming, process input normally
                _appEngine.Input.ProcessRaylibInput();
            }


            // Begin drawing
            Raylib.BeginDrawing();
            Raylib.ClearBackground(new Raylib_cs.Color(
                (byte)(_backgroundColor.R * 255),
                (byte)(_backgroundColor.G * 255),
                (byte)(_backgroundColor.B * 255),
                (byte)(_backgroundColor.A * 255)
            ));

            // Update and render the UI through the AppEngine
            if (_renderer is not null && _textService is not null)
            {
                _appEngine.UpdateAndRender(_renderer, _textService);
            }

            // End drawing
            Raylib.EndDrawing();
        }
    }

    public void Cleanup()
    {
        if (_isDisposed) return;
        Console.WriteLine("RaylibWindowHost cleaning up its resources...");
        _appEngine?.Cleanup();
        (_renderer as DirectUI.Backends.RaylibRenderer)?.Cleanup(); // Explicit cast for Cleanup
        (_textService as DirectUI.Backends.RaylibTextService)?.Cleanup(); // Explicit cast for Cleanup
        FontManager.UnloadAll(); // Unload all Raylib fonts

        if (Raylib.IsWindowReady())
        {
            Raylib.CloseWindow();
        }
        _appEngine = null;
        _renderer = null;
        _textService = null;
        _isDisposed = true;
        GC.SuppressFinalize(this);
    }

    public void Dispose()
    {
        Cleanup();
    }

    public bool Initialize(Action<UIContext> uiDrawCallback, Color4 backgroundColor)
    {
        throw new NotImplementedException();
    }

    private class RaylibDummyModalWindowService : IModalWindowService
    {
        public bool IsModalWindowOpen => false;

        public void OpenModalWindow(string title, int width, int height, Action<UIContext> drawCallback, Action<int>? onClosedCallback = null)
        {
            Console.WriteLine($"Modal window '{title}' requested but not supported in Raylib backend.");
            onClosedCallback?.Invoke(-1); // Immediately report as closed/failed
        }

        public void CloseModalWindow(int resultCode = 0)
        {
            // Do nothing as no modal windows are opened.
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\SDL3\SDL3Renderer.cs">
using System.Numerics;
using DirectUI.Core;
using SDL3;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace DirectUI.Backends.SDL3;

public unsafe class SDL3Renderer : IRenderer
{
    private readonly nint _rendererPtr;
    private readonly nint _windowPtr;

    private int _windowWidth;
    private int _windowHeight;

    private readonly Stack<Rect> _clipRectStack = new();
    private readonly Dictionary<TextRenderCacheKey, nint> _textTextureCache = new();

    private const float FONT_SCALE_FACTOR = 1.125f;

    private readonly struct TextRenderCacheKey : IEquatable<TextRenderCacheKey>
    {
        public readonly string Text;
        public readonly float FontSize;
        public readonly FontWeight FontWeight;
        public readonly FontStyle FontStyle;
        public readonly FontStretch FontStretch;
        public readonly Color Color;

        public TextRenderCacheKey(string text, ButtonStyle style, Color color)
        {
            Text = text;
            FontSize = style.FontSize;
            FontWeight = style.FontWeight;
            FontStyle = style.FontStyle;
            FontStretch = style.FontStretch;
            Color = color;
        }

        public bool Equals(TextRenderCacheKey other)
        {
            return Text == other.Text 
                && FontSize.Equals(other.FontSize) 
                && FontWeight == other.FontWeight 
                && FontStyle == other.FontStyle 
                && FontStretch == other.FontStretch 
                && Color.Equals(other.Color);
        }

        public override bool Equals(object? obj)
        {
            return obj is TextRenderCacheKey other && Equals(other);
        }

        public override int GetHashCode()
        {
            return HashCode.Combine(
                Text,
                FontSize,
                FontWeight,
                FontStyle,
                FontStretch,
                Color);
        }
    }

    public Vector2 RenderTargetSize
    {
        get
        {
            SDL.GetWindowSize(_windowPtr, out _windowWidth, out _windowHeight);
            return new(_windowWidth, _windowHeight);
        }
    }

    public SDL3Renderer(nint rendererPtr, nint windowPtr)
    {
        _rendererPtr = rendererPtr;
        _windowPtr = windowPtr;

        SDL.GetWindowSize(_windowPtr, out _windowWidth, out _windowHeight);
    }

    internal void UpdateWindowSize(int width, int height)
    {
        _windowWidth = width;
        _windowHeight = height;
    }

    public void DrawLine(Vector2 p1, Vector2 p2, Drawing.Color color, float strokeWidth)
    {
        SDL.SetRenderDrawColor(_rendererPtr, color.R, color.G, color.B, color.A);

        if (strokeWidth <= 1.0f)
        {
            // Draw 1-pixel thin line
            SDL.RenderLine(_rendererPtr, (int)p1.X, (int)p1.Y, (int)p2.X, (int)p2.Y);
        }
        else
        {
            // For thicker lines, approximate with a filled rectangle.
            // This is a basic approximation, primarily for axis-aligned or near-axis-aligned lines.
            // For general diagonal lines with thickness, more complex geometry (like a rotated rectangle or two triangles)
            // or a dedicated library (e.g., SDL_gfx or custom shader) would be required.

            float halfStroke = strokeWidth / 2f;
            float dx = p2.X - p1.X;
            float dy = p2.Y - p1.Y;

            // If it's more horizontal
            if (Math.Abs(dx) >= Math.Abs(dy))
            {
                SDL.FRect rectangle = new()
                {
                    X = Math.Min(p1.X, p2.X),
                    Y = (p1.Y + p2.Y) / 2f - halfStroke, // Center Y on the line's average Y
                    W = Math.Abs(dx),
                    H = strokeWidth
                };
                SDL.RenderFillRect(_rendererPtr, rectangle);
            }
            // If it's more vertical
            else
            {
                SDL.FRect rectangle = new()
                {
                    X = (p1.X + p2.X) / 2f - halfStroke, // Center X on the line's average X
                    Y = Math.Min(p1.Y, p2.Y),
                    W = strokeWidth,
                    H = Math.Abs(dy)
                };
                SDL.RenderFillRect(_rendererPtr, rectangle);
            }
        }
    }

    public void DrawBox(Vortice.Mathematics.Rect rect, BoxStyle style)
    {
        // Convert Vortice.Mathematics.Rect to SDL.FRect for drawing
        SDL.FRect outerRect = new()
        {
            X = rect.X,
            Y = rect.Y,
            W = rect.Width,
            H = rect.Height
        };

        // 1. Draw the border background (entire rectangle with border color)
        // If border color is transparent or all border lengths are zero, this step effectively does nothing visually.
        if (style.BorderColor.A > 0 && (style.BorderLengthTop > 0 || style.BorderLengthRight > 0 || style.BorderLengthBottom > 0 || style.BorderLengthLeft > 0))
        {
            SDL.SetRenderDrawColor(_rendererPtr, style.BorderColor.R, style.BorderColor.G, style.BorderColor.B, style.BorderColor.A);
            SDL.RenderFillRect(_rendererPtr, outerRect);
        }

        // 2. Draw the inner fill rectangle (inset by border lengths)
        if (style.FillColor.A > 0)
        {
            float fillX = rect.X + style.BorderLengthLeft;
            float fillY = rect.Y + style.BorderLengthTop;
            float fillWidth = Math.Max(0f, rect.Width - style.BorderLengthLeft - style.BorderLengthRight);
            float fillHeight = Math.Max(0f, rect.Height - style.BorderLengthTop - style.BorderLengthBottom);

            if (fillWidth > 0 && fillHeight > 0)
            {
                SDL.FRect fillRect = new()
                {
                    X = fillX,
                    Y = fillY,
                    W = fillWidth,
                    H = fillHeight
                };

                SDL.SetRenderDrawColor(_rendererPtr, style.FillColor.R, style.FillColor.G, style.FillColor.B, style.FillColor.A);
                SDL.RenderFillRect(_rendererPtr, fillRect);
            }
            // Special case: If no border is defined (all lengths 0) and the fill itself is opaque,
            // the above fillRect might be invalid (e.g. if original rect had 0 width/height)
            // In such a scenario, we still want to draw the full outerRect with the fill color if it's visible.
            else if (style.BorderLengthTop == 0 && style.BorderLengthRight == 0 && style.BorderLengthBottom == 0 && style.BorderLengthLeft == 0 && (outerRect.W > 0 && outerRect.H > 0))
            {
                SDL.SetRenderDrawColor(_rendererPtr, style.FillColor.R, style.FillColor.G, style.FillColor.B, style.FillColor.A);
                SDL.RenderFillRect(_rendererPtr, outerRect);
            }
        }
        // Roundness is not natively supported by SDL's basic renderer. It will be drawn as square corners.
    }

    public void DrawText(Vector2 origin, string text, ButtonStyle style, Alignment alignment, Vector2 maxSize, Drawing.Color color)
    {
        if (string.IsNullOrEmpty(text))
        {
            return;
        }

        if (UI.Context.TextService is not SDL3TextService textService)
        {
            Console.WriteLine("Error: SDL3TextService not available for text rendering.");
            return;
        }

        // Get the font
        float effectiveFontSize = style.FontSize * FONT_SCALE_FACTOR;
        nint fontPtr = textService.GetOrCreateFont(style.FontName, (int)Math.Round(effectiveFontSize), style.FontWeight);

        if (fontPtr == nint.Zero)
        {
            Console.WriteLine($"Error: Font '{style.FontName}' could not be loaded.");
            return;
        }

        TextRenderCacheKey cacheKey = new(text, style, color);
        
        if (!_textTextureCache.TryGetValue(cacheKey, out nint textTexture))
        {
            SDL.Color sdlColor = new() { R = color.R, G = color.G, B = color.B, A = color.A };
            nint textSurface = TTF.RenderTextBlended(fontPtr, text, 0, sdlColor);

            if (textSurface == nint.Zero)
            {
                Console.WriteLine($"Error rendering text surface: {SDL.GetError()}");
                return;
            }

            textTexture = SDL.CreateTextureFromSurface(_rendererPtr, textSurface);
            SDL.DestroySurface(textSurface);

            if (textTexture == nint.Zero)
            {
                Console.WriteLine($"Error creating text texture: {SDL.GetError()}");
                return;
            }

            _textTextureCache[cacheKey] = textTexture;
        }

        // ✅ SDL3-compatible way to get texture dimensions

        if (!SDL.GetTextureSize(textTexture, out float texW, out float texH))
        {
            Console.WriteLine($"Error getting texture size: {SDL.GetError()}");
            return;
        }

        Vector2 measuredSize = new(texW, texH);
        Vector2 textDrawPos = origin;

        // Horizontal alignment
        if (maxSize.X > 0 && measuredSize.X < maxSize.X)
        {
            switch (alignment.Horizontal)
            {
                case HAlignment.Center:
                    textDrawPos.X += (maxSize.X - measuredSize.X) / 2f;
                    break;
                case HAlignment.Right:
                    textDrawPos.X += (maxSize.X - measuredSize.X);
                    break;
            }
        }

        // Vertical alignment
        if (maxSize.Y > 0)
        {
            switch (alignment.Vertical)
            {
                case VAlignment.Center:
                    textDrawPos.Y += (maxSize.Y - measuredSize.Y) / 2f;
                    break;
                case VAlignment.Bottom:
                    textDrawPos.Y += (maxSize.Y - measuredSize.Y);
                    break;
            }
        }

        SDL.FRect dstRect = new()
        {
            X = textDrawPos.X,
            Y = textDrawPos.Y,
            W = texW,
            H = texH
        };

        SDL.RenderTexture(_rendererPtr, textTexture, nint.Zero, dstRect);
    }

    public void PushClipRect(Rect rect, AntialiasMode antialiasMode)
    {
        _clipRectStack.Push(rect);
        ApplyClipRect(rect);
    }

    public void PopClipRect()
    {
        if (_clipRectStack.Count <= 0)
        {
            return;
        }

        _clipRectStack.Pop();

        if (_clipRectStack.Count > 0)
        {
            ApplyClipRect(_clipRectStack.Peek());
        }
        else
        {
            // Clear clip rect
            SDL.Rect rect = new()
            {
                X = 0,
                Y = 0,
                W = _windowWidth,
                H = _windowHeight,
            };

            SDL.SetRenderClipRect(_rendererPtr, rect);
        }
    }

    private void ApplyClipRect(Rect rect)
    {
        SDL.Rect clipRect = new()
        {
            X = (int)float.Floor(rect.X),
            Y = (int)float.Floor(rect.Y),
            W = (int)float.Ceiling(rect.Width + (rect.X - float.Floor(rect.X))),
            H = (int)float.Ceiling(rect.Height + (rect.Y - float.Floor(rect.Y)))
        };

        SDL.SetRenderClipRect(_rendererPtr, clipRect);
    }

    public void Flush()
    {
        // SDL's 2D renderer typically renders commands immediately to an internal buffer.
        // The SDL_RenderPresent call (handled by SDL3UIHost) does the actual flush to screen.
    }

    public void Cleanup()
    {
        _clipRectStack.Clear();

        foreach (nint texture in _textTextureCache.Values)
        {
            SDL.DestroyTexture(texture);
        }

        _textTextureCache.Clear();
        // The renderer and window are managed and destroyed by ApplicationRunner.
    }

    public void DrawImage(byte[] imageData, string imageKey, Rect destination)
    {
        throw new NotImplementedException();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\SDL3\SDL3TextLayout.cs">
using System;
using System.Numerics;
using DirectUI.Core;
using SDL3;
using Vortice.DirectWrite; // For FontWeight, etc.

namespace DirectUI.Backends.SDL3;

/// <summary>
/// A minimal implementation of ITextLayout for SDL3.
/// This will be expanded in a later step.
/// </summary>
internal unsafe class SDL3TextLayout : ITextLayout
{
    public Vector2 Size { get; }
    public string Text { get; }

    private readonly nint _fontPtr; // Pointer to the TTF.Font object

    public SDL3TextLayout(string text, nint fontPtr)
    {
        Text = text;
        _fontPtr = fontPtr;

        // SDL3_ttf: Use TTF.GetStringSize instead of deprecated TTF.SizeUTF8
        if (!string.IsNullOrEmpty(text) && fontPtr != nint.Zero)
        {
            if (TTF.GetStringSize(fontPtr, text, 0, out int w, out int h))
            {
                Size = new Vector2(w, h);
            }
            else
            {
                Console.WriteLine($"Error measuring text '{text}': {SDL.GetError()}");
                Size = Vector2.Zero;
            }
        }
        else
        {
            Size = Vector2.Zero;
        }
    }

    public TextHitTestMetrics HitTestTextPosition(int textPosition, bool isTrailingHit)
    {
        // Placeholder implementation as SDL_ttf does not provide direct hit-testing.
        if (string.IsNullOrEmpty(Text)) return new TextHitTestMetrics(Vector2.Zero, Vector2.Zero);

        float approxCharWidth = Size.X / Math.Max(1, Text.Length);
        float x = textPosition * approxCharWidth;
        float width = approxCharWidth;

        // Adjust x if it's a trailing hit, to measure the position AFTER the character
        if (isTrailingHit) x += approxCharWidth;

        // Clamp to prevent out-of-bounds positions
        x = Math.Clamp(x, 0, Size.X);

        return new TextHitTestMetrics(new Vector2(x, 0), new Vector2(width, Size.Y));
    }

    public TextHitTestResult HitTestPoint(Vector2 point)
    {
        // Placeholder implementation as SDL_ttf does not provide direct hit-testing.
        if (string.IsNullOrEmpty(Text))
        {
            return new TextHitTestResult(0, false, false, new TextHitTestMetrics(Vector2.Zero, Vector2.Zero));
        }

        bool isInside = point.X >= 0 && point.X <= Size.X && point.Y >= 0 && point.Y <= Size.Y;

        float approxCharWidth = (Text.Length > 0) ? Size.X / Text.Length : 0;
        int textPosition = 0;
        bool isTrailingHit = false;

        if (approxCharWidth > 0)
        {
            textPosition = (int)(point.X / approxCharWidth);
            isTrailingHit = (point.X % approxCharWidth) > (approxCharWidth / 2f);
        }

        // Caret position can be one past the last character (i.e., at the end of the string).
        textPosition = Math.Clamp(textPosition, 0, Text.Length);
        if (isTrailingHit && textPosition < Text.Length) // If it's a trailing hit and not at the very end
        {
            textPosition++;
        }
        textPosition = Math.Clamp(textPosition, 0, Text.Length); // Final clamp

        // Recalculate metrics for the specific hit position
        float hitMetricX = (textPosition == 0) ? 0 : (textPosition * approxCharWidth);
        if (isTrailingHit && textPosition > 0) hitMetricX -= approxCharWidth; // Adjust if hit is trailing edge

        return new TextHitTestResult(textPosition, isTrailingHit, isInside,
            new TextHitTestMetrics(new Vector2(hitMetricX, 0), new Vector2(approxCharWidth, Size.Y)));
    }

    public void Dispose()
    {
        // This object does not own the font pointer; it's owned by SDL3TextService.
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\SDL3\SDL3TextService.cs">
using System;
using System.Collections.Generic;
using System.IO;
using System.Numerics;
using DirectUI.Core;
using DirectUI.Drawing;
using SDL3;
using Vortice.DirectWrite; // For FontWeight, FontStyle, FontStretch

namespace DirectUI.Backends.SDL3;

public unsafe class SDL3TextService : ITextService
{
    private readonly Dictionary<FontKey, nint> _fontCache = new();
    private readonly Dictionary<TextLayoutCacheKey, ITextLayout> _textLayoutCache = new();
    private readonly Dictionary<(string, FontKey), Vector2> _textSizeCache = new();

    // This factor compensates for the perceptual size difference between DirectWrite and FreeType rendering.
    private const float FONT_SCALE_FACTOR = 1.125f;

    // Internal static dictionary for font file paths for SDL3
    private static readonly Dictionary<string, Dictionary<FontWeight, string>> s_sdlFontFilePaths = new();
    private static bool s_defaultFontsRegistered = false; // Flag to ensure registration happens only once

    // Internal cache key structs
    internal readonly struct FontKey(string fontName, int fontSize, FontWeight fontWeight) : IEquatable<FontKey>
    {
        private readonly string FontName = fontName;
        private readonly int FontSize = fontSize; // Stored as integer atlas size
        private readonly FontWeight FontWeight = fontWeight;
        // FontStyle and FontStretch are not directly supported by TTF.OpenFont,
        // so we omit them from the key or map them to file paths.

        public bool Equals(FontKey other) => FontName == other.FontName && FontSize.Equals(other.FontSize) && FontWeight == other.FontWeight;
        public override bool Equals(object? obj) => obj is FontKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(FontName, FontSize, FontWeight);
    }

    internal readonly struct TextLayoutCacheKey(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment) : IEquatable<TextLayoutCacheKey>
    {
        private readonly string Text = text;
        private readonly FontKey FontKey = new(style.FontName, (int)Math.Round(style.FontSize * FONT_SCALE_FACTOR), style.FontWeight); // Cache by actual font properties
        private readonly Vector2 MaxSize = maxSize;
        private readonly HAlignment HAlign = alignment.Horizontal;
        private readonly VAlignment VAlign = alignment.Vertical;
        public bool Equals(TextLayoutCacheKey other) => Text == other.Text && MaxSize.Equals(other.MaxSize) && HAlign == other.HAlign && VAlign == other.VAlign && FontKey.Equals(other.FontKey);
        public override bool Equals(object? obj) => obj is TextLayoutCacheKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(Text, FontKey, MaxSize, HAlign, VAlign);
    }

    public SDL3TextService()
    {
        // TTF.Init() should be called globally ONCE, not per instance.
        // It's handled by SDL3WindowHost now.
    }

    /// <summary>
    /// Registers default font paths for SDL_ttf. This should be called once globally.
    /// </summary>
    internal static void RegisterDefaultFonts()
    {
        if (s_defaultFontsRegistered) return;

        s_sdlFontFilePaths["Segoe UI"] = new Dictionary<FontWeight, string>
        {
            { FontWeight.Normal, "C:/Windows/Fonts/segoeui.ttf" },
            { FontWeight.SemiBold, "C:/Windows/Fonts/seguisb.ttf" }
        };
        s_sdlFontFilePaths["Consolas"] = new Dictionary<FontWeight, string>
        {
            { FontWeight.Normal, "C:/Windows/Fonts/consola.ttf" },
            { FontWeight.Bold, "C:/Windows/Fonts/consolab.ttf" }
        };
        s_sdlFontFilePaths["Arial"] = new Dictionary<FontWeight, string>
        {
            { FontWeight.Normal, "C:/Windows/Fonts/arial.ttf" }
        };

        s_defaultFontsRegistered = true;
    }

    /// <summary>
    /// Attempts to retrieve the file path for a registered font variant for SDL_ttf.
    /// </summary>
    internal static bool TryGetSdlFontFilePath(string familyName, FontWeight weight, out string? filePath)
    {
        filePath = null;
        if (s_sdlFontFilePaths.TryGetValue(familyName, out var variants))
        {
            if (variants.TryGetValue(weight, out filePath))
            {
                return true;
            }
            // Fallback to Normal weight if specific weight not found
            if (variants.TryGetValue(FontWeight.Normal, out filePath))
            {
                return true;
            }
        }
        // Fallback to Arial if original family not found
        if (s_sdlFontFilePaths.TryGetValue("Arial", out var arialVariants) && arialVariants.TryGetValue(FontWeight.Normal, out filePath))
        {
            Console.WriteLine($"Warning: Font family '{familyName}' (weight {weight}) not found. Falling back to Arial.");
            return true;
        }
        return false;
    }


    public nint GetOrCreateFont(string familyName, int fontSize, FontWeight weight)
    {
        FontKey key = new(familyName, fontSize, weight);

        if (_fontCache.TryGetValue(key, out nint fontPtr))
        {
            return fontPtr;
        }

        if (!TryGetSdlFontFilePath(familyName, weight, out string? filePath))
        {
            Console.WriteLine($"Warning: Could not find font file for family '{familyName}' (weight {weight}) or a fallback. Returning null font pointer.");
            return nint.Zero;
        }

        // Open font using SDL_ttf
        fontPtr = TTF.OpenFont(filePath, fontSize);

        if (fontPtr == nint.Zero)
        {
            Console.WriteLine($"Error opening font '{filePath}' at size {fontSize}: {SDL.GetError()}");
            return nint.Zero;
        }

        _fontCache[key] = fontPtr;
        return fontPtr;
    }

    public Vector2 MeasureText(string text, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(text) || style is null)
            return Vector2.Zero;

        float effectiveFontSize = style.FontSize * FONT_SCALE_FACTOR;
        int atlasSize = Math.Max(1, (int)Math.Round(effectiveFontSize));

        var fontKey = new FontKey(style.FontName, atlasSize, style.FontWeight);
        var cacheKey = (text, fontKey);
        if (_textSizeCache.TryGetValue(cacheKey, out var cachedSize))
            return cachedSize;

        nint fontPtr = GetOrCreateFont(style.FontName, atlasSize, style.FontWeight);
        if (fontPtr == nint.Zero)
            return Vector2.Zero;

        if (TTF.GetStringSize(fontPtr, text, 0, out int w, out int h))
        {
            var measuredSize = new Vector2(w, h);
            _textSizeCache[cacheKey] = measuredSize;
            return measuredSize;
        }
        else
        {
            Console.WriteLine($"Error measuring text '{text}': {SDL.GetError()}");
            return Vector2.Zero;
        }
    }

    public ITextLayout GetTextLayout(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment)
    {
        var layoutKey = new TextLayoutCacheKey(text, style, maxSize, alignment);
        if (_textLayoutCache.TryGetValue(layoutKey, out var cachedLayout))
        {
            return cachedLayout;
        }

        float effectiveFontSize = style.FontSize * FONT_SCALE_FACTOR;
        int atlasSize = (int)Math.Round(effectiveFontSize);
        if (atlasSize <= 0) atlasSize = 1;

        nint fontPtr = GetOrCreateFont(style.FontName, atlasSize, style.FontWeight);
        if (fontPtr == nint.Zero)
        {
            Console.WriteLine($"Error: Font not found for text layout '{text}'");
            return new SDL3TextLayout("", nint.Zero); // Return a dummy layout
        }

        var newLayout = new SDL3TextLayout(text, fontPtr);
        _textLayoutCache[layoutKey] = newLayout;
        return newLayout;
    }

    public void Cleanup()
    {
        Console.WriteLine("SDL3TextService Cleanup: Disposing cached resources...");
        // Close fonts for this specific instance's cache
        foreach (var fontPtr in _fontCache.Values)
        {
            if (fontPtr != nint.Zero)
            {
                TTF.CloseFont(fontPtr);
            }
        }
        _fontCache.Clear();
        _textLayoutCache.Clear();
        _textSizeCache.Clear();

        // TTF.Quit() is now handled globally by SDL3WindowHost
        Console.WriteLine("SDL3TextService Cleanup finished.");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\SDL3\SDL3WindowHost.cs">
using DirectUI.Core;
using DirectUI.Input;
using SDL3;
using Vortice.Mathematics;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI.Backends.SDL3;

public unsafe class SDL3WindowHost : IWindowHost, IModalWindowService
{
    private readonly string _title;
    private readonly int _initialWidth;
    private readonly int _initialHeight;
    private readonly Color4 _backgroundColor;

    private nint _windowPtr;
    private nint _rendererPtr;

    private AppEngine? _appEngine;
    private SDL3Renderer? _renderer;
    private SDL3TextService? _textService;
    private bool _isDisposed;

    private static int s_sdlInitCount = 0;
    private static int s_ttfInitCount = 0;

    private SDL3WindowHost? _activeModalWindow;
    private Action<UIContext>? _modalDrawCallback;
    private Action<int>? _onModalClosedCallback;
    private int _modalResultCode;
    private bool _isModalClosing;

    public AppEngine AppEngine => _appEngine ?? throw new InvalidOperationException("AppEngine is not initialized.");
    public IntPtr Handle => _windowPtr;
    public InputManager Input => _appEngine?.Input ?? new();
    public SizeI ClientSize
    {
        get
        {
            SDL.GetWindowSize(_windowPtr, out int w, out int h);
            return new SizeI(w, h);
        }
    }

    public bool ShowFpsCounter
    {
        get
        {
            return _appEngine?.ShowFpsCounter ?? false;
        }

        set
        {
            if (_appEngine is null)
            {
                return;
            }

            _appEngine.ShowFpsCounter = value;
        }
    }

    public IModalWindowService ModalWindowService => this;

    public SDL3WindowHost(string title, int width, int initialHeight, Color4 backgroundColor)
    {
        _title = title;
        _initialWidth = width;
        _initialHeight = initialHeight;
        _backgroundColor = backgroundColor;
    }

    public bool Initialize(Action<UIContext> uiDrawCallback, Color4 backgroundColor, float initialScale = 1.0f)
    {
        Console.WriteLine($"SDL3WindowHost initializing for '{_title}'...");

        try
        {
            Interlocked.Increment(ref s_sdlInitCount);

            if (s_sdlInitCount == 1)
            {
                if (!SDL.Init(SDL.InitFlags.Video))
                {
                    Console.WriteLine($"SDL could not initialize! SDL_Error: {SDL.GetError()}");
                    return false;
                }
            }

            Interlocked.Increment(ref s_ttfInitCount);

            if (s_ttfInitCount == 1)
            {
                if (!TTF.Init())
                {
                    Console.WriteLine($"SDL_ttf could not initialize! SDL_Error: {SDL.GetError()}");
                    return false;
                }
                SDL3TextService.RegisterDefaultFonts();
            }

            _windowPtr = SDL.CreateWindow(_title, _initialWidth, _initialHeight, SDL.WindowFlags.Resizable);

            if (_windowPtr == nint.Zero)
            {
                Console.WriteLine($"Window could not be created! SDL_Error: {SDL.GetError()}");
                return false;
            }

            _rendererPtr = SDL.CreateRenderer(_windowPtr, null);

            if (_rendererPtr == nint.Zero)
            {
                Console.WriteLine($"Renderer could not be created! SDL Error: {SDL.GetError()}");
                SDL.DestroyWindow(_windowPtr);
                return false;
            }

            _appEngine = new(uiDrawCallback, backgroundColor);
            _appEngine.UIScale = initialScale;
            _renderer = new(_rendererPtr, _windowPtr);
            _textService = new();
            _appEngine.Initialize(_textService, _renderer);

            Console.WriteLine($"SDL3WindowHost '{_title}' initialized successfully. (SDL_Init count: {s_sdlInitCount}, TTF_Init count: {s_ttfInitCount})");
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred during SDL3WindowHost initialization: {ex.Message}");
            Cleanup();
            return false;
        }
    }

    public void RunLoop()
    {
        bool running = true;

        while (running)
        {
            if (IsModalWindowOpen && _activeModalWindow is not null)
            {
                _activeModalWindow.ModalRunLoop();
                HandleModalLifecycle();
            }
            else
            {
                while (SDL.PollEvent(out SDL.Event ev))
                {
                    var keyModifiers = SDL.GetModState();
                    bool isCtrlDown = (keyModifiers & SDL.Keymod.Ctrl) != 0;

                    if (ev.Type == (uint)SDL.EventType.Quit)
                    {
                        running = false;
                        break;
                    }

                    if (ev.Type == (uint)SDL.EventType.MouseWheel && isCtrlDown && _appEngine is not null)
                    {
                        float deltaY = ev.Wheel.Y;
                        float scaleDelta = deltaY * 0.1f;
                        _appEngine.UIScale = Math.Clamp(_appEngine.UIScale + scaleDelta, 0.5f, 3.0f);
                    }
                    else
                    {
                        Input.ProcessSDL3Event(ev);
                    }
                }

                RenderFrame();
            }
        }
    }

    private void ModalRunLoop()
    {
        bool modalRunning = true;

        while (modalRunning)
        {
            while (SDL.PollEvent(out SDL.Event ev))
            {
                var keyModifiers = SDL.GetModState();
                bool isCtrlDown = (keyModifiers & SDL.Keymod.Ctrl) != 0;

                if (ev.Type == (uint)SDL.EventType.Quit)
                {
                    modalRunning = false;
                    _modalResultCode = -1;
                    break;
                }
                else if (ev.Type == (uint)SDL.EventType.WindowCloseRequested)
                {
                    if (ev.Window.WindowID == SDL.GetWindowID(_windowPtr))
                    {
                        modalRunning = false;
                        _modalResultCode = -1;
                        break;
                    }
                }

                if (ev.Type == (uint)SDL.EventType.MouseWheel && isCtrlDown && _appEngine is not null)
                {
                    float deltaY = ev.Wheel.Y;
                    float scaleDelta = deltaY * 0.1f;
                    _appEngine.UIScale = Math.Clamp(_appEngine.UIScale + scaleDelta, 0.5f, 3.0f);
                }
                else
                {
                    Input.ProcessSDL3Event(ev);
                }
            }

            if (_isModalClosing)
            {
                modalRunning = false;
            }

            ModalRenderFrame();
        }

        _isModalClosing = true;
    }

    private void RenderFrame()
    {
        SDL.SetRenderDrawColor(_rendererPtr, (byte)(_backgroundColor.R * 255), (byte)(_backgroundColor.G * 255), (byte)(_backgroundColor.B * 255), (byte)(_backgroundColor.A * 255));
        SDL.RenderClear(_rendererPtr);

        if (_renderer is not null && _textService is not null && _appEngine is not null)
        {
            _appEngine.UpdateAndRender(_renderer, _textService);
        }

        SDL.RenderPresent(_rendererPtr);
    }

    private void ModalRenderFrame()
    {
        SDL.SetRenderDrawColor(_rendererPtr, (byte)(_backgroundColor.R * 255), (byte)(_backgroundColor.G * 255), (byte)(_backgroundColor.B * 255), (byte)(_backgroundColor.A * 255));
        SDL.RenderClear(_rendererPtr);

        if (_renderer is not null && _textService is not null && _appEngine is not null && _modalDrawCallback is not null)
        {
            _appEngine.UpdateAndRender(_renderer, _textService);
        }

        SDL.RenderPresent(_rendererPtr);
    }

    public void Cleanup()
    {
        if (_isDisposed) return;
        Console.WriteLine($"SDL3WindowHost cleanup for '{_title}'...");

        _activeModalWindow?.Cleanup();

        _appEngine?.Cleanup();
        _renderer?.Cleanup();
        _textService?.Cleanup();

        if (_rendererPtr != nint.Zero)
        {
            SDL.DestroyRenderer(_rendererPtr);
            _rendererPtr = nint.Zero;
        }

        if (_windowPtr != nint.Zero)
        {
            SDL.DestroyWindow(_windowPtr);
            _windowPtr = nint.Zero;
        }

        Interlocked.Decrement(ref s_ttfInitCount);

        if (s_ttfInitCount == 0)
        {
            Console.WriteLine("Final TTF.Quit().");
            TTF.Quit();
        }

        Interlocked.Decrement(ref s_sdlInitCount);

        if (s_sdlInitCount == 0)
        {
            Console.WriteLine("Final SDL.Quit()..");
            SDL.Quit();
        }

        _isDisposed = true;

        GC.SuppressFinalize(this);
        Console.WriteLine($"SDL3WindowHost '{_title}' cleaned up. (SDL_Init count: {s_sdlInitCount}, TTF_Init count: {s_ttfInitCount})");
    }

    public void Dispose()
    {
        Cleanup();
    }

    public bool IsModalWindowOpen
    {
        get
        {
            return _activeModalWindow is not null;
        }
    }

    public void OpenModalWindow(string title, int width, int height, Action<UIContext> drawCallback, Action<int>? onClosedCallback = null)
    {
        if (_activeModalWindow is not null)
        {
            Console.WriteLine("Warning: Cannot open a new modal window while another is already active.");
            return;
        }

        _activeModalWindow = new SDL3WindowHost(title, width, height, _backgroundColor);
        _activeModalWindow._modalDrawCallback = drawCallback;
        _onModalClosedCallback = onClosedCallback;
        _modalResultCode = -1;

        if (!_activeModalWindow.InitializeModalInternal())
        {
            Console.WriteLine("Failed to initialize modal SDL window.");
            _activeModalWindow.Dispose();
            _activeModalWindow = null;
            onClosedCallback?.Invoke(-1);
            return;
        }

        if (!SDL.SetWindowParent(_activeModalWindow._windowPtr, _windowPtr))
        {
            Console.WriteLine($"Failed to set window parent: {SDL.GetError()}");
            _activeModalWindow.Dispose();
            _activeModalWindow = null;
            onClosedCallback?.Invoke(-1);
            return;
        }

        if (!SDL.SetWindowModal(_activeModalWindow._windowPtr, true))
        {
            Console.WriteLine($"Failed to set modal flag on window: {SDL.GetError()}");
            _activeModalWindow.Dispose();
            _activeModalWindow = null;
            onClosedCallback?.Invoke(-1);
            return;
        }

        Console.WriteLine("Modal window opened successfully.");
    }

    private bool InitializeModalInternal()
    {
        return Initialize(_modalDrawCallback!, _backgroundColor);
    }

    public void CloseModalWindow(int resultCode = 0)
    {
        if (_activeModalWindow is null)
        {
            return;
        }

        _activeModalWindow._modalResultCode = resultCode;
        _activeModalWindow._isModalClosing = true;
    }

    private void HandleModalLifecycle()
    {
        if (_activeModalWindow is null)
        {
            return;
        }

        if (!_activeModalWindow._isModalClosing)
        {
            return;
        }

        Console.WriteLine($"Modal window closed. Result: {_activeModalWindow._modalResultCode}");
        _onModalClosedCallback?.Invoke(_activeModalWindow._modalResultCode);

        if (_windowPtr != nint.Zero)
        {
            SDL.RaiseWindow(_windowPtr);
        }

        _activeModalWindow.Dispose();
        _activeModalWindow = null;
        _onModalClosedCallback = null;
        _modalResultCode = 0;
        _isModalClosing = false;
    }

    public bool Initialize(Action<UIContext> uiDrawCallback, Color4 backgroundColor)
    {
        throw new NotImplementedException();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\Animations\AnimatedValue.cs">
// DirectUI/Source/Animation/AnimatedValue.cs
using System;

namespace DirectUI.Animation;

internal class AnimatedValue
{
    public object CurrentValue { get; set; }
    public object StartValue { get; set; }
    public object TargetValue { get; set; }
    public float StartTime { get; set; }
    public float Duration { get; set; }
    public Func<float, float> Easing { get; set; }
    public bool IsAnimating { get; set; }

    public AnimatedValue(object initialValue)
    {
        CurrentValue = initialValue;
        StartValue = initialValue;
        TargetValue = initialValue;
        Easing = DirectUI.Animation.Easing.Linear;
    }

    public void Start(object newTarget, float currentTime, float duration, Func<float, float> easing)
    {
        // Don't restart if we are already animating towards the same target,
        // unless the new target is actually different from the current animated value.
        // This handles cases where the state flickers but the target value is the same.
        if (newTarget.Equals(TargetValue) && IsAnimating) return;

        StartValue = CurrentValue;
        TargetValue = newTarget;
        StartTime = currentTime;
        Duration = duration;
        Easing = easing;
        IsAnimating = true;
    }

    public bool Update(float currentTime)
    {
        if (!IsAnimating) return false; // Not running

        float elapsedTime = currentTime - StartTime;
        if (elapsedTime >= Duration)
        {
            CurrentValue = TargetValue;
            IsAnimating = false;
            return false; // Animation just finished
        }

        float progress = Easing(elapsedTime / Duration);
        CurrentValue = ValueInterpolators.Lerp(StartValue, TargetValue, progress);

        return true; // Still running
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\Animations\AnimationInfo.cs">
namespace DirectUI.Animation;

public class AnimationInfo
{
    public float Duration { get; }
    public Func<float, float> Easing { get; }

    public AnimationInfo(float duration = 0.15f, Func<float, float>? easing = null)
    {
        Duration = duration;
        Easing = easing ?? DirectUI.Animation.Easing.EaseOutQuad;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\Animations\AnimationManager.cs">
// DirectUI/Source/Animation/AnimationManager.cs
using System;
using System.Collections.Generic;

namespace DirectUI.Animation;

public class AnimationManager
{
    private readonly Dictionary<int, AnimatedValue> _animatedProperties = new();

    public void Update(float currentTime)
    {
        var keys = new List<int>(_animatedProperties.Keys);
        foreach (var key in keys)
        {
            if (_animatedProperties.TryGetValue(key, out var animValue))
            {
                animValue.Update(currentTime);
            }
        }
    }

    public T GetOrAnimate<T>(int propertyId, T targetValue, float currentTime, float duration, Func<float, float> easing)
    {
        if (!_animatedProperties.TryGetValue(propertyId, out var animValue))
        {
            animValue = new AnimatedValue(targetValue);
            _animatedProperties[propertyId] = animValue;
        }

        // Check if the target has changed
        if (animValue.TargetValue is not T || !EqualityComparer<T>.Default.Equals((T)animValue.TargetValue, targetValue))
        {
            animValue.Start(targetValue, currentTime, duration, easing);
        }

        return (T)animValue.CurrentValue;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\Animations\Easing.cs">
// DirectUI/Source/Animation/Easing.cs
using System;
using System.Collections.Generic;

namespace DirectUI.Animation;

public static class Easing
{
    private static readonly Dictionary<string, Func<float, float>> s_easingFunctions = new(StringComparer.OrdinalIgnoreCase)
    {
        { "Linear", Linear },
        { "EaseInQuad", EaseInQuad },
        { "EaseOutQuad", EaseOutQuad },
        { "EaseInOutQuad", EaseInOutQuad }
    };

    public static float Linear(float t) => t;
    public static float EaseInQuad(float t) => t * t;
    public static float EaseOutQuad(float t) => t * (2 - t);
    public static float EaseInOutQuad(float t) => t < 0.5f ? 2 * t * t : -1 + (4 - 2 * t) * t;

    public static Func<float, float> GetEasingFunction(string? name)
    {
        if (name is not null && s_easingFunctions.TryGetValue(name, out var func))
        {
            return func;
        }
        return Linear; // Default to Linear if not found or name is null
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\Animations\ValueInterpolator.cs">
// DirectUI/Source/Animation/ValueInterpolators.cs
using System.Numerics;
using DirectUI.Drawing;

namespace DirectUI.Animation;

internal static class ValueInterpolators
{
    // Generic Lerp selector
    public static T Lerp<T>(T from, T to, float progress)
    {
        if (from is float fFrom && to is float fTo)
        {
            return (T)(object)LerpFloat(fFrom, fTo, progress);
        }
        if (from is Color cFrom && to is Color cTo)
        {
            return (T)(object)LerpColor(cFrom, cTo, progress);
        }
        if (from is Vector2 v2From && to is Vector2 v2To)
        {
            return (T)(object)LerpVector2(v2From, v2To, progress);
        }
        // If no specific lerp is found, snap to the target value at the end of the animation
        return progress >= 1.0f ? to : from;
    }

    private static float LerpFloat(float from, float to, float progress) => from + (to - from) * progress;

    private static Vector2 LerpVector2(Vector2 from, Vector2 to, float progress) => from + (to - from) * progress;

    private static Color LerpColor(Color from, Color to, float progress)
    {
        return new Color(
            (byte)(from.R + (to.R - from.R) * progress),
            (byte)(from.G + (to.G - from.G) * progress),
            (byte)(from.B + (to.B - from.B) * progress),
            (byte)(from.A + (to.A - from.A) * progress)
        );
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\Interface\IAppLogic.cs">
namespace DirectUI.Core;

public interface IAppLogic
{
    void DrawUI(UIContext context);
    void SaveState();
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\Interface\ILayoutContainer.cs">
using System.Numerics;

namespace DirectUI;

public interface ILayoutContainer
{
    Vector2 GetCurrentPosition();
    void Advance(Vector2 elementSize);
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\Interface\IModalWindowService.cs">
// DirectUI/Core/IModalWindowService.cs
using System;
using Vortice.Mathematics;

namespace DirectUI.Core;

/// <summary>
/// Defines the contract for a service that can open modal windows.
/// This allows application UI logic to request a modal window without
/// knowing the underlying platform's windowing specifics.
/// </summary>
public interface IModalWindowService
{
    /// <summary>
    /// Opens a modal window with the specified properties.
    /// </summary>
    /// <param name="title">The title of the modal window.</param>
    /// <param name="width">The width of the modal window.</param>
    /// <param name="height">The height of the modal window.</param>
    /// <param name="drawCallback">The UI drawing logic for the content of the modal window.</param>
    /// <param name="onClosedCallback">An action to be invoked when the modal window is closed. Receives a result code (0 for success, non-zero for error/cancel).</param>
    void OpenModalWindow(string title, int width, int height, Action<UIContext> drawCallback, Action<int>? onClosedCallback = null);

    /// <summary>
    /// Closes the currently active modal window, if any, with a specified result code.
    /// </summary>
    /// <param name="resultCode">A code indicating the outcome of the modal interaction (e.g., 0 for OK, 1 for Cancel).</param>
    void CloseModalWindow(int resultCode = 0);

    /// <summary>
    /// Checks if a modal window is currently open.
    /// </summary>
    bool IsModalWindowOpen { get; }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\Interface\IRenderer.cs">
// DirectUI/Core/IRenderer.cs
using System.Numerics;
using DirectUI.Drawing;
using Vortice.Direct2D1; // Required for AntialiasMode
using Vortice.Mathematics;

namespace DirectUI.Core;

/// <summary>
/// Defines the abstract contract for a rendering backend.
/// The UI library uses this interface to issue all drawing commands.
/// </summary>
public interface IRenderer
{
    /// <summary>
    /// Gets the current size of the render target.
    /// </summary>
    Vector2 RenderTargetSize { get; }

    /// <summary>
    /// Draws a line between two points.
    /// </summary>
    void DrawLine(Vector2 p1, Vector2 p2, Color color, float strokeWidth);

    /// <summary>
    /// Draws a box with fill, border, and rounding based on a style.
    /// </summary>
    void DrawBox(Vortice.Mathematics.Rect rect, BoxStyle style);

    /// <summary>
    /// Draws text. The renderer is responsible for its own text layout and caching.
    /// </summary>
    void DrawText(Vector2 origin, string text, ButtonStyle style, Alignment alignment, Vector2 maxSize, Color color);

    /// <summary>
    /// Draws an image from its raw byte data within a destination rectangle.
    /// The renderer is responsible for caching the decoded image using the provided key.
    /// </summary>
    /// <param name="imageData">The raw byte data of the image (e.g., JPEG, PNG).</param>
    /// <param name="imageKey">A unique key to identify and cache this image.</param>
    /// <param name="destination">The rectangle where the image will be drawn.</param>
    void DrawImage(byte[] imageData, string imageKey, Vortice.Mathematics.Rect destination);

    /// <summary>
    /// Pushes a clipping rectangle onto the stack. All subsequent drawing will be clipped to this rectangle.
    /// </summary>
    void PushClipRect(Vortice.Mathematics.Rect rect, AntialiasMode antialiasMode = AntialiasMode.PerPrimitive);

    /// <summary>
    /// Pops the last clipping rectangle from the stack.
    /// </summary>
    void PopClipRect();

    /// <summary>
    /// Flushes any batched rendering commands, particularly for text.
    /// </summary>
    void Flush();
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\Interface\ITextLayout.cs">
// DirectUI/Core/ITextLayout.cs
using System;
using System.Numerics;

namespace DirectUI.Core;

/// <summary>
/// Represents a block of text that has been fully processed for layout.
/// This is a backend-agnostic interface.
/// </summary>
public interface ITextLayout : IDisposable
{
    /// <summary>
    /// The final measured size of the laid-out text.
    /// </summary>
    Vector2 Size { get; }

    /// <summary>
    /// The original string content of this layout.
    /// </summary>
    string Text { get; }

    /// <summary>
    /// Retrieves the metrics for a glyph at a specific text position.
    /// </summary>
    /// <param name="textPosition">The zero-based index of the target character.</param>
    /// <param name="isTrailingHit">Indicates whether to measure the leading or trailing edge of the character.</param>
    /// <returns>Metrics describing the position and size of the specified character position.</returns>
    TextHitTestMetrics HitTestTextPosition(int textPosition, bool isTrailingHit);

    /// <summary>
    /// Performs a hit-test to determine which character position is at a given point.
    /// </summary>
    /// <param name="point">The point to test, relative to the layout's origin.</param>
    /// <returns>A result object containing the metrics and character position of the hit.</returns>
    TextHitTestResult HitTestPoint(Vector2 point);
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\Interface\ITextService.cs">
// DirectUI/Core/ITextService.cs
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI.Core;

/// <summary>
/// Defines the abstract contract for text processing services like measurement and layout.
/// The UI library uses this to handle all font-related operations.
/// </summary>
public interface ITextService
{
    /// <summary>
    /// Measures the bounding box of a string given a specific style, without layout constraints.
    /// </summary>
    Vector2 MeasureText(string text, ButtonStyle style);

    /// <summary>
    /// Creates or retrieves a cached, fully formatted text layout object.
    /// </summary>
    ITextLayout GetTextLayout(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment);

    /// <summary>
    /// Cleans up any cached resources managed by the text service.
    /// </summary>
    void Cleanup();
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\Interface\IWindowHost.cs">
// DirectUI/Core/IWindowHost.cs
using System;
using DirectUI.Input;
using Vortice.Mathematics;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI.Core;

/// <summary>
/// Defines the contract for a platform-specific window host that integrates with the DirectUI engine.
/// This interface abstracts window creation, main loop management, and exposes input and modal services.
/// </summary>
public interface IWindowHost : IDisposable
{
    /// <summary>
    /// Gets the native window handle, if applicable. Returns IntPtr.Zero otherwise.
    /// </summary>
    IntPtr Handle { get; }

    /// <summary>
    /// Gets the AppEngine instance associated with this host.
    /// </summary>
    AppEngine AppEngine { get; }

    /// <summary>
    /// Provides access to the InputManager for the host to feed input events.
    /// </summary>
    InputManager Input { get; }

    /// <summary>
    /// Gets the current client size of the window.
    /// </summary>
    SizeI ClientSize { get; }

    /// <summary>
    /// Gets or sets whether the FPS counter should be displayed.
    /// </summary>
    bool ShowFpsCounter { get; set; }

    /// <summary>
    /// Provides access to a service for opening modal windows specific to this host's platform.
    /// </summary>
    IModalWindowService ModalWindowService { get; }

    /// <summary>
    /// Initializes the window host and the DirectUI engine.
    /// </summary>
    /// <param name="uiDrawCallback">The callback function that contains the application's UI drawing logic.</param>
    /// <param name="backgroundColor">The background color to clear the window with each frame.</param>
    /// <param name="initialScale">The initial UI scale factor to apply.</param>
    /// <returns>True if initialization was successful, false otherwise.</returns>
    bool Initialize(Action<UIContext> uiDrawCallback, Color4 backgroundColor, float initialScale = 1.0f);

    /// <summary>
    /// Runs the platform-specific main message/event loop for the application.
    /// </summary>
    void RunLoop();

    /// <summary>
    /// Cleans up resources owned by the window host.
    /// </summary>
    void Cleanup();
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Bankan\Source\AppLogic.cs">
using System.Numerics;
using Bankan.Rendering;
using DirectUI;
using DirectUI.Core;
using DirectUI.Drawing;
using DirectUI.Styling;

namespace Bankan;

public class AppLogic : IAppLogic
{
    private const string BoardStateFile = "kanban_board.json";
    private const string SettingsStateFile = "kanban_settings.json";

    private KanbanBoard _board = new();
    private KanbanSettings _settings = new();

    private readonly ModalManager _modalManager;
    private readonly DragDropHandler _dragDropHandler;
    private readonly BoardRenderer _boardRenderer;

    public AppLogic(IWindowHost windowHost)
    {
        LoadState();
        StyleManager.LoadStylesFromFile("Data/styles.yaml");

        _dragDropHandler = new DragDropHandler(_board);
        _modalManager = new ModalManager(windowHost, _board, SaveState);
        _boardRenderer = new BoardRenderer(_board, _settings, _modalManager, _dragDropHandler);
    }

    private void LoadState()
    {
        _board = StateSerializer.Load<KanbanBoard>(BoardStateFile) ?? new KanbanBoard();
        _settings = StateSerializer.Load<KanbanSettings>(SettingsStateFile) ?? new KanbanSettings();

        if (_board.Columns.Count != 0)
        {
            return;
        }

        _board.Columns.Add(new()
        {
            Id = "todo",
            Title = "To Do",
            Tasks = 
            [
                new()
                {
                    Text = "Design the main UI",
                    ColorHex = "#bb86fc"
                },
                new()
                {
                    Text = "Implement drag and drop",
                    ColorHex = "#ff7597"
                },
            ]
        });

        _board.Columns.Add(new()
        {
            Id = "inprogress",
            Title = "In Progress",
            Tasks = 
            [
                new()
                {
                    Text = "Set up DirectUI project",
                    ColorHex = "#75ffff"
                }
            ]
        });

        _board.Columns.Add(new()
        {
            Id = "done",
            Title = "Done",
            Tasks = 
            [
                new()
                {
                    Text = "Analyze the web Kanban board",
                    ColorHex = "#75ff9f"
                }
            ]
        });
    }

    public void SaveState()
    {
        StateSerializer.Save(_board, BoardStateFile);
        StateSerializer.Save(_settings, SettingsStateFile);
    }

    public void DrawUI(UIContext context)
    {
        Vector2 windowSize = UI.Context.Renderer.RenderTargetSize;
        var scale = context.UIScale;

        // --- Process Logic ---
        if (_dragDropHandler.Update())
        {
            SaveState(); // Save if drag-drop resulted in a change
        }
        _modalManager.ProcessPendingActions();

        // --- Draw UI ---
        DrawSettingsButton(windowSize, scale);

        // --- Define board dimensions in LOGICAL units for UI controls ---
        float columnLogicalWidth = 350f;
        float columnLogicalGap = 40f;
        var boardLogicalPadding = new Vector2(20, 20);
        var topLogicalMargin = 80f;

        // The scroll area takes up the remaining space.
        var scrollAreaLogicalSize = new Vector2(
            (windowSize.X / scale) - boardLogicalPadding.X * 2,
            (windowSize.Y / scale) - topLogicalMargin - boardLogicalPadding.Y
        );

        // Use a container to position the scroll area within the padding.
        UI.BeginVBoxContainer("main_layout", Vector2.Zero);
        UI.Context.Layout.AdvanceLayout(new Vector2(boardLogicalPadding.X, topLogicalMargin));

        UI.BeginScrollArea("board_scroll_area", scrollAreaLogicalSize);

        // Inside the scroll area, we use the BoardRenderer which starts its own HBox.
        // We pass logical (unscaled) dimensions to it.
        _boardRenderer.DrawBoard(columnLogicalWidth, columnLogicalGap);

        UI.EndScrollArea();
        UI.EndVBoxContainer();

        // Draw overlays (e.g., the task being dragged) on top of everything else.
        // The width passed here should be physical.
        _dragDropHandler.DrawDraggedTaskOverlay((columnLogicalWidth * scale) - (30f * scale));
    }

    private void DrawSettingsButton(Vector2 windowSize, float scale)
    {
        Vector2 settingsButtonSize = new Vector2(40, 40) * scale;
        _ = new Vector2(windowSize.X - settingsButtonSize.X - (20 * scale), 20 * scale);

        ButtonStylePack settingsTheme = new()
        {
            Roundness = 0.5f,
            Normal =
            {
                FontName = "Seoge UI Symbol",
                FontSize = 20 * scale,
                FillColor = Colors.Transparent,
                BorderLength = 0,
            },
            Hover =
            {
                FillColor = new(50, 50, 50, 255)
            }
        };

        if (UI.Button(
            "settings_btn",
            "⚙️",
            size: new(40, 40),
            origin: new(windowSize.X / scale - 40 - 20, 20),
            theme: settingsTheme))
        {
            _modalManager.OpenSettingsModal(_settings);
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Bankan\Source\BoardRenderer.cs">
using System.Numerics;
using Bankan.Rendering;
using DirectUI;

namespace Bankan;

public class BoardRenderer
{
    private readonly KanbanBoard _board;
    private readonly ColumnRenderer _columnRenderer;
    private readonly DragDropHandler _dragDropHandler;

    public BoardRenderer(KanbanBoard board, KanbanSettings settings, ModalManager modalManager, DragDropHandler dragDropHandler)
    {
        _board = board;
        _dragDropHandler = dragDropHandler;
        TaskRenderer taskRenderer = new(settings, modalManager, dragDropHandler);
        _columnRenderer = new(taskRenderer, dragDropHandler, modalManager);
    }

    public void DrawBoard(float columnLogicalWidth, float columnLogicalGap)
    {
        _dragDropHandler.PrepareNextFrameTarget();

        UI.BeginHBoxContainer(
            "board_content_hbox",
            UI.Context.Layout.GetCurrentPosition(),
            gap: columnLogicalGap);
        
        foreach (var column in _board.Columns)
        {
            _columnRenderer.DrawColumnContent(column, columnLogicalWidth);
        }

        UI.EndHBoxContainer();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Bankan\Source\ColumnRenderer.cs">
using System.Numerics;
using DirectUI;
using DirectUI.Drawing;
using DirectUI.Styling;

namespace Bankan.Rendering;

public class ColumnRenderer
{
    private readonly TaskRenderer _taskRenderer;
    private readonly DragDropHandler _dragDropHandler;
    private readonly ModalManager _modalManager;

    public ColumnRenderer(TaskRenderer taskRenderer, DragDropHandler dragDropHandler, ModalManager modalManager)
    {
        _taskRenderer = taskRenderer;
        _dragDropHandler = dragDropHandler;
        _modalManager = modalManager;
    }

    private void DrawColumnInterior(KanbanColumn column, float innerContentLogicalWidth)
    {
        DrawColumnHeader(column, innerContentLogicalWidth);
        DrawColumnTasks(column, innerContentLogicalWidth);
        DrawAddTaskButton(column, innerContentLogicalWidth);
    }

    public void DrawColumnContent(KanbanColumn column, float logicalColumnWidth)
    {
        var scale = UI.Context.UIScale;
        var contentPadding = 15f;
        var gap = 10f;
        var innerContentLogicalWidth = logicalColumnWidth - contentPadding * 2;

        // --- 1. Calculation Pass ---
        // Use the built-in layout calculation feature to determine the content's size
        // by running the shared drawing logic in a "dry run" mode.
        var contentSize = UI.CalculateLayout(() =>
        {
            UI.BeginVBoxContainer(
                column.Id + "_calc",
                Vector2.Zero,
                gap: gap);

            DrawColumnInterior(column, innerContentLogicalWidth);

            UI.EndVBoxContainer();
        });

        // The total size of the column includes its internal padding.
        var columnLogicalHeight = contentSize.Y + contentPadding * 2;
        var columnLogicalSize = new Vector2(logicalColumnWidth, columnLogicalHeight);

        // --- 2. Drawing Pass ---
        var columnLogicalPosition = UI.Context.Layout.GetCurrentPosition();
        var columnPhysicalPosition = columnLogicalPosition * scale;

        DrawColumnBackground(
            columnPhysicalPosition,
            new Vector2(columnLogicalSize.X * scale, columnLogicalSize.Y * scale));

        var contentStartPosition = columnLogicalPosition + new Vector2(contentPadding, contentPadding);

        // Begin a VBox for arranging the content. It will NOT advance the parent layout itself.
        UI.BeginVBoxContainer(
            column.Id,
            contentStartPosition,
            gap: gap);

        // Call the shared logic again, this time for actual rendering.
        DrawColumnInterior(column, innerContentLogicalWidth);

        // Update the drop target for the entire column area, now that we know its final physical size.
        var columnBoundsForDropTarget = new Vortice.Mathematics.Rect(columnPhysicalPosition.X, columnPhysicalPosition.Y, columnLogicalSize.X * scale, columnLogicalSize.Y * scale);
        int finalTaskIndex = column.Tasks.Count;
        _dragDropHandler.UpdateDropTargetForColumn(column, columnBoundsForDropTarget, finalTaskIndex);

        // End the container without advancing the parent (the HBox).
        UI.EndVBoxContainer(advanceParentLayout: false);

        // Manually advance the parent HBox layout by the full calculated size of this column widget.
        UI.Context.Layout.AdvanceLayout(columnLogicalSize);
    }

    private static void DrawColumnBackground(Vector2 position, Vector2 size)
    {
        Color columnBgColor = new(30, 30, 30, 255);

        BoxStyle columnStyle = new()
        {
            FillColor =
            columnBgColor,
            Roundness = 0.1f,
            BorderLength = 0
        };

        UI.Context.Renderer.DrawBox(
            new(position.X, position.Y, size.X, size.Y),
            columnStyle);
    }

    private static void DrawColumnHeader(KanbanColumn column, float innerContentLogicalWidth)
    {
        ButtonStyle titleStyle = new()
        {
            FontColor = new(224, 224, 224, 255),
            FontSize = 18,
            FontWeight = Vortice.DirectWrite.FontWeight.SemiBold
        };

        UI.Text(
            column.Id + "_title",
            column.Title,
            new(innerContentLogicalWidth, 30),
            titleStyle,
            new(HAlignment.Center, VAlignment.Center));

        UI.Separator(
            innerContentLogicalWidth,
            2,
            5,
            new(51, 51, 51, 255));
    }

    private void DrawColumnTasks(KanbanColumn column, float innerContentLogicalWidth)
    {
        int currentTaskIndex = 0;

        foreach (Task task in column.Tasks)
        {
            _taskRenderer.DrawDropIndicator(column, currentTaskIndex, innerContentLogicalWidth);

            if (task != _dragDropHandler.DraggedTask)
            {
                _taskRenderer.DrawTaskWidget(column, task, currentTaskIndex, innerContentLogicalWidth);
            }
            else
            {
                TaskRenderer.DrawDragPlaceholder(task, innerContentLogicalWidth);
            }

            currentTaskIndex++;
        }

        _taskRenderer.DrawDropIndicator(column, currentTaskIndex, innerContentLogicalWidth);
    }

    private void DrawAddTaskButton(KanbanColumn column, float innerContentLogicalWidth)
    {
        if (column.Id != "todo")
        {
            return;
        }

        // --- DEMONSTRATION OF BOTH STYLING METHODS ---

        // Method 1: Data-Driven (from styles.yaml)
        // This is the recommended approach for styles that are shared or need easy tweaking.
        var addTaskTheme = StyleManager.Get<ButtonStylePack>("addTaskButton");


        // Method 2: Code-Driven (defined directly here)
        // This is useful for one-off styles or for developers who prefer to keep everything in C#.
        // To use this, just uncomment this block and comment out the StyleManager line above.
        //ButtonStylePack addTaskTheme = new()
        //{
        //    Animation = new(2.5f), // Fallback animation
        //    Normal =
        //    {
        //        FillColor = Colors.Transparent,
        //        BorderColor = new(51, 51, 51, 255)
        //    },
        //    Hover =
        //    {
        //        FillColor = DefaultTheme.Accent,
        //        BorderColor = DefaultTheme.Accent,
        //        Scale = new(0.95f, 0.95f),
        //        Animation = new(0.25f) // Faster animation TO this state
        //    },
        //    Pressed =
        //    {
        //        Scale = new(0.9f, 0.9f)
        //    }
        //};


        if (UI.Button(
            id: column.Id + "_add_task",
            text: "+ Add Task",
            size: new(innerContentLogicalWidth, 40),
            theme: addTaskTheme))
        {
            _modalManager.OpenAddTaskModal(column);
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Bankan\Source\DragDropHandler.cs">
using System;
using System.Linq;
using System.Numerics;
using DirectUI;
using DirectUI.Drawing;

namespace Bankan;

public class DragDropHandler
{
    public Task? DraggedTask { get; private set; }

    // State for the CURRENT frame's render pass (calculated last frame)
    public KanbanColumn? DropTargetColumn { get; private set; }
    public int DropIndex { get; private set; } = -1;

    private KanbanColumn? _sourceColumn;
    private Vector2 _dragOffset;
    private readonly KanbanBoard _board;

    // State being calculated THIS frame for use in the NEXT frame
    private KanbanColumn? _nextFrameDropTargetColumn;
    private int _nextFrameDropIndex = -1;
    private bool _dropTargetFoundThisFrame;

    public DragDropHandler(KanbanBoard board)
    {
        _board = board;
    }

    public bool IsDragging() => DraggedTask is not null;

    public void BeginDrag(Task task, KanbanColumn sourceColumn, Vector2 mousePosition, Vector2 taskPosition)
    {
        DraggedTask = task;
        _sourceColumn = sourceColumn;
        _dragOffset = mousePosition - taskPosition;
    }

    /// <summary>
    /// Resets the state that will be calculated this frame for use in the next one.
    /// </summary>
    public void PrepareNextFrameTarget()
    {
        if (!IsDragging()) return;
        _nextFrameDropTargetColumn = null;
        _nextFrameDropIndex = -1;
        _dropTargetFoundThisFrame = false;
    }

    public bool Update()
    {
        var input = UI.Context.InputState;
        if (DraggedTask is null) return false;

        // At the start of the logic update, cycle the state. The drop target calculated
        // in the previous frame's render pass now becomes the current drop target.
        DropTargetColumn = _nextFrameDropTargetColumn;
        DropIndex = _nextFrameDropIndex;

        if (!input.IsLeftMouseDown)
        {
            bool modified = false;
            // Use the now-current DropTargetColumn and DropIndex for the final action.
            if (DraggedTask is not null && _sourceColumn is not null && DropTargetColumn is not null && DropIndex != -1)
            {
                int originalIndex = _sourceColumn.Tasks.IndexOf(DraggedTask);
                if (originalIndex != -1)
                {
                    _sourceColumn.Tasks.RemoveAt(originalIndex);
                    if (_sourceColumn == DropTargetColumn && DropIndex > originalIndex)
                    {
                        DropIndex--;
                    }
                    int clampedDropIndex = Math.Clamp(DropIndex, 0, DropTargetColumn.Tasks.Count);
                    DropTargetColumn.Tasks.Insert(clampedDropIndex, DraggedTask);
                    modified = true;
                }
            }

            // Clean up all state now that the drag is over
            DraggedTask = null;
            _sourceColumn = null;
            DropTargetColumn = null;
            DropIndex = -1;
            _nextFrameDropTargetColumn = null;
            _nextFrameDropIndex = -1;

            UI.State.ClearAllActivePressState();
            return modified;
        }
        return false;
    }

    /// <summary>
    /// Called by the renderer for each task widget. It calculates the drop target for the NEXT frame.
    /// </summary>
    public void UpdateDropTarget(KanbanColumn column, int taskIndex, Vortice.Mathematics.Rect taskBounds)
    {
        if (!IsDragging() || _dropTargetFoundThisFrame) return;

        var mousePos = UI.Context.InputState.MousePosition;

        if (mousePos.X >= taskBounds.Left && mousePos.X <= taskBounds.Right)
        {
            float midPointY = taskBounds.Y + taskBounds.Height / 2f;
            if (mousePos.Y < midPointY)
            {
                _nextFrameDropTargetColumn = column;
                _nextFrameDropIndex = taskIndex;
                _dropTargetFoundThisFrame = true;
            }
        }
    }

    /// <summary>
    /// Called by the renderer for each column to handle dropping at the end. It calculates for the NEXT frame.
    /// </summary>
    public void UpdateDropTargetForColumn(KanbanColumn column, Vortice.Mathematics.Rect columnBounds, int lastTaskIndex)
    {
        if (!IsDragging() || _dropTargetFoundThisFrame) return;

        var mousePos = UI.Context.InputState.MousePosition;
        if (columnBounds.Contains(mousePos))
        {
            _nextFrameDropTargetColumn = column;
            _nextFrameDropIndex = lastTaskIndex;
            _dropTargetFoundThisFrame = true;
        }
    }

    public void DrawDraggedTaskOverlay(float physicalWidth)
    {
        if (DraggedTask is null || physicalWidth <= 0) return;
        var scale = UI.Context.UIScale;
        var mousePos = UI.Context.InputState.MousePosition;

        var textStyle = new ButtonStyle { FontName = "Segoe UI", FontSize = 14 * scale };
        var wrappedLayout = UI.Context.TextService.GetTextLayout(DraggedTask.Text, textStyle, new Vector2(physicalWidth - (30 * scale), float.MaxValue), new Alignment(HAlignment.Left, VAlignment.Top));
        float physicalHeight = wrappedLayout.Size.Y + (30 * scale);
        var pos = mousePos - _dragOffset;

        var bounds = new Vortice.Mathematics.Rect(pos.X, pos.Y, physicalWidth, physicalHeight);
        var semiTransparent = DraggedTask.Color;
        semiTransparent.A = 220;
        var style = new BoxStyle { FillColor = semiTransparent, BorderColor = Colors.White, BorderLength = 1 * scale, Roundness = 0.1f };
        UI.Context.Renderer.DrawBox(bounds, style);

        var textBounds = new Vortice.Mathematics.Rect(bounds.X + (15 * scale), bounds.Y, bounds.Width - (30 * scale), bounds.Height);
        var renderTextStyle = new ButtonStyle { FontName = "Segoe UI", FontSize = 14, FontColor = new Color(18, 18, 18, 255) };
        UI.DrawTextPrimitive(textBounds, DraggedTask.Text, renderTextStyle, new Alignment(HAlignment.Left, VAlignment.Center), Vector2.Zero);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Bankan\Source\KanbanBoard.cs">
namespace Bankan;

public class KanbanBoard
{
    public List<KanbanColumn> Columns { get; set; } = new();
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Bankan\Source\KanbanColumn.cs">
namespace Bankan;

public class KanbanColumn
{
    public string Id { get; set; } = string.Empty;
    public string Title { get; set; } = string.Empty;
    public List<Task> Tasks { get; set; } = [];
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Bankan\Source\KanbanSettings.cs">
namespace Bankan;

public class KanbanSettings
{
    public TaskColorStyle ColorStyle { get; set; } = TaskColorStyle.Border;
    public TaskTextAlign TextAlign { get; set; } = TaskTextAlign.Left;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Bankan\Source\ModalManager.cs">
using Bankan.Modals;
using DirectUI.Core;

namespace Bankan;

public class ModalManager
{
    public bool IsModalOpen => _windowHost.ModalWindowService.IsModalWindowOpen;

    private readonly IWindowHost _windowHost;
    private readonly KanbanBoard _board;
    private readonly Action _saveRequestCallback;
    
    private readonly AddTaskModal _addTaskModal;
    private readonly EditTaskModal _editTaskModal;

    private Task? _taskToDelete;

    public ModalManager(IWindowHost windowHost, KanbanBoard board, Action saveRequestCallback)
    {
        _windowHost = windowHost;
        _board = board;
        _saveRequestCallback = saveRequestCallback;

        List<string> availableColors = ["#bb86fc", "#ff7597", "#75ffff", "#75ff9f", "#ffdf75"];
        _addTaskModal = new(_windowHost, availableColors);
        _editTaskModal = new(_windowHost, availableColors);
    }

    public void RequestSave()
    {
        _saveRequestCallback.Invoke();
    }

    public void RequestTaskDeletion(Task task)
    {
        _taskToDelete = task;
    }

    public void ProcessPendingActions()
    {
        if (_taskToDelete is null)
        {
            return;
        }
        
        KanbanColumn? column = _board.Columns.FirstOrDefault(c => c.Tasks.Contains(_taskToDelete));
        
        if (column is not null)
        {
            column.Tasks.Remove(_taskToDelete);
            RequestSave();
        }

        _taskToDelete = null;
    }

    public void OpenSettingsModal(KanbanSettings settings)
    {
        if (IsModalOpen)
        {
            return;
        }

        SettingsModal settingsModal = new(settings, _windowHost);
        
        _windowHost.ModalWindowService.OpenModalWindow(
            "Settings", 
            400, 
            250,
            settingsModal.DrawUI,
            _ => RequestSave()
        );
    }

    public void OpenAddTaskModal(KanbanColumn column)
    {
        if (IsModalOpen)
        {
            return;
        }

        _addTaskModal.Open();

        _windowHost.ModalWindowService.OpenModalWindow(
            "Create New Task", 
            450, 
            280,
            _addTaskModal.DrawUI,
            resultCode =>
            {
                AddTask(column, resultCode);
            }
        );
    }

    private void AddTask(KanbanColumn column, int resultCode)
    {
        if (resultCode != 0 || string.IsNullOrWhiteSpace(_addTaskModal.TaskText))
        {
            return;
        }

        Task newTask = new()
        {
            Text = _addTaskModal.TaskText.Trim(),
            ColorHex = _addTaskModal.SelectedColorHex
        };

        column.Tasks.Add(newTask);
        RequestSave();
    }

    public void OpenEditTaskModal(Task task)
    {
        if (IsModalOpen)
        {
            return;
        }

        _editTaskModal.Open(task);
        
        _windowHost.ModalWindowService.OpenModalWindow(
            "Edit Task", 
            450, 
            320,
            _editTaskModal.DrawUI,
            EditTask
        );
    }

    private void EditTask(int resultCode)
    {
        Task? taskToEdit = _editTaskModal.TaskToEdit;

        if (taskToEdit is null)
        {
            return;
        }

        switch (resultCode)
        {
            case 0 when !string.IsNullOrWhiteSpace(_editTaskModal.TaskText):
                taskToEdit.Text = _editTaskModal.TaskText.Trim();
                taskToEdit.ColorHex = _editTaskModal.SelectedColorHex;
                RequestSave();
                return;
            case 2:
                RequestTaskDeletion(taskToEdit);
                break;
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Bankan\Source\Persistence.cs">
using System.Text.Json;

namespace Bankan;

public static class StateSerializer
{
    private static readonly JsonSerializerOptions Options = new()
    {
        WriteIndented = true,
        PropertyNameCaseInsensitive = true
    };

    public static void Save<T>(T data, string filePath)
    {
        try
        {
            string? directory = Path.GetDirectoryName(filePath);
            
            if (!string.IsNullOrEmpty(directory))
            {
                Directory.CreateDirectory(directory);
            }

            string json = JsonSerializer.Serialize(data, Options);
            File.WriteAllText(filePath, json);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving state to {filePath}: {ex.Message}");
        }
    }

    public static T? Load<T>(string filePath) where T : class, new()
    {
        if (!File.Exists(filePath))
        {
            return new T();
        }

        try
        {
            string json = File.ReadAllText(filePath);
            return JsonSerializer.Deserialize<T>(json, Options) ?? new T();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading state from {filePath}: {ex.Message}");
            return new T();
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Bankan\Source\Program.cs">
using DirectUI;
using DirectUI.Core;

namespace Bankan;

public static class Program
{
    public static void Main()
    {
        ApplicationRunner.Run(GraphicsBackend.SkiaSharp, CreateKanbanApp);
    }

    private static IAppLogic CreateKanbanApp(IWindowHost windowHost)
    {
        return new AppLogic(windowHost);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Bankan\Source\Task.cs">
using System.Text.Json.Serialization;
using DirectUI;
using DirectUI.Drawing;

namespace Bankan;

// --- Board Models ---

public class Task
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Text { get; set; } = string.Empty;

    [JsonIgnore] // Don't save the DirectUI.Color struct directly
    public Color Color { get; set; } = DefaultTheme.Accent;

    // Use a helper property for JSON serialization to store color as hex string
    [JsonPropertyName("Color")]
    public string ColorHex
    {
        get => $"#{Color.R:X2}{Color.G:X2}{Color.B:X2}";
        set
        {
            if (!string.IsNullOrEmpty(value) && value.StartsWith("#") && value.Length == 7)
            {
                try
                {
                    byte r = Convert.ToByte(value.Substring(1, 2), 16);
                    byte g = Convert.ToByte(value.Substring(3, 2), 16);
                    byte b = Convert.ToByte(value.Substring(5, 2), 16);
                    Color = new Color(r, g, b, 255);
                }
                catch
                {
                    Color = DefaultTheme.Accent; // Fallback
                }
            }
            else
            {
                Color = DefaultTheme.Accent; // Fallback
            }
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Bankan\Source\TaskColorStyle.cs">
namespace Bankan;

// --- Settings Models ---

public enum TaskColorStyle
{
    Border,
    Background
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Bankan\Source\TaskRenderer.cs">
using System.Numerics;
using DirectUI;
using DirectUI.Animation;
using DirectUI.Core;
using DirectUI.Drawing;

namespace Bankan.Rendering;

public class TaskRenderer
{
    private readonly KanbanSettings _settings;
    private readonly ModalManager _modalManager;
    private readonly DragDropHandler _dragDropHandler;
    private string? _activeContextMenuTaskId;

    private readonly record struct InteractionState(bool IsHovering, bool IsPressed, bool IsInteractive);

    public TaskRenderer(KanbanSettings settings, ModalManager modalManager, DragDropHandler dragDropHandler)
    {
        _settings = settings;
        _modalManager = modalManager;
        _dragDropHandler = dragDropHandler;
    }

    public void DrawTaskWidget(KanbanColumn column, Task task, int taskIndex, float logicalWidth)
    {
        (Vector2 logicalSize, Vector2 physicalPos, Vortice.Mathematics.Rect taskBounds) = CalculateTaskGeometry(task, logicalWidth);

        _dragDropHandler.UpdateDropTarget(column, taskIndex, taskBounds);

        if (!UI.Context.Layout.IsRectVisible(taskBounds))
        {
            UI.Context.Layout.AdvanceLayout(logicalSize);
            return;
        }

        ButtonStylePack taskTheme = CreateTaskTheme(task);
        InteractionState interaction = HandleInteraction(task, column, physicalPos, taskBounds);

        HandleContextMenu(task, interaction);

        DrawAnimatedTask(task, taskTheme, interaction, taskBounds);

        UI.Context.Layout.AdvanceLayout(logicalSize);
    }

    private static (Vector2 logicalSize, Vector2 physicalPos, Vortice.Mathematics.Rect taskBounds) CalculateTaskGeometry(Task task, float logicalWidth)
    {
        Vector2 logicalSize = CalculateTaskLogicalSize(task, logicalWidth);
        float scale = UI.Context.UIScale;

        Vector2 logicalPos = UI.Context.Layout.GetCurrentPosition();
        Vector2 physicalPos = logicalPos * scale;
        Vector2 physicalSize = new(logicalWidth * scale, logicalSize.Y * scale);
        Vortice.Mathematics.Rect taskBounds = new(physicalPos.X, physicalPos.Y, physicalSize.X, physicalSize.Y);

        return (logicalSize, physicalPos, taskBounds);
    }

    private static Vector2 CalculateTaskLogicalSize(Task task, float logicalWidth)
    {
        UIContext context = UI.Context;
        float scale = context.UIScale;
        float logicalFontSize = 14f;

        ButtonStyle measurementStyle = new() { FontName = "Segoe UI", FontSize = logicalFontSize * scale };
        ITextLayout wrappedLayout = context.TextService.GetTextLayout(task.Text, measurementStyle, new Vector2((logicalWidth - 30) * scale, float.MaxValue), new Alignment(HAlignment.Left, VAlignment.Top));
        float logicalHeight = (wrappedLayout.Size.Y / scale) + 30;

        return new (logicalWidth, logicalHeight);
    }

    private ButtonStylePack CreateTaskTheme(Task task)
    {
        ButtonStylePack taskTheme = new() 
        { 
            Roundness = 0.1f 
        };

        Color cardBackground = new(42, 42, 42, 255);

        ButtonStyle fontStyle = new()
        {
            FontName = "Segoe UI",
            FontSize = 14f
        };

        if (_settings.ColorStyle == TaskColorStyle.Background)
        {
            taskTheme.Normal.FillColor = task.Color;
            taskTheme.Normal.BorderColor = Colors.Transparent;
            fontStyle.FontColor = new Color(18, 18, 18, 255);

            Color baseHoverColor = task.Color;
            
            taskTheme.Hover.FillColor = new Color(
                (byte)float.Min(255, baseHoverColor.R * 1.2f),
                (byte)float.Min(255, baseHoverColor.G * 1.2f),
                (byte)float.Min(255, baseHoverColor.B * 1.2f),
                baseHoverColor.A);
        }
        else
        {
            taskTheme.Normal.FillColor = cardBackground;
            taskTheme.Normal.BorderColor = task.Color;
            taskTheme.Normal.BorderLengthLeft = 4f;
            taskTheme.Normal.BorderLengthTop = 0;
            taskTheme.Normal.BorderLengthRight = 0;
            taskTheme.Normal.BorderLengthBottom = 0;
            fontStyle.FontColor = DefaultTheme.Text;
            taskTheme.Hover.FillColor = new Color(60, 60, 60, 255);
        }

        ButtonStyle[] allStyles = [taskTheme.Normal, taskTheme.Hover, taskTheme.Pressed, taskTheme.Disabled, taskTheme.Focused, taskTheme.Active, taskTheme.ActiveHover];
       
        foreach (ButtonStyle s in allStyles)
        {
            s.FontName = fontStyle.FontName;
            s.FontSize = fontStyle.FontSize;
            s.FontColor = fontStyle.FontColor;
        }

        taskTheme.Animation = new AnimationInfo(0.15f, Easing.EaseOutQuad);
        taskTheme.Hover.Scale = new Vector2(0.98f, 0.98f);
        taskTheme.Pressed.Scale = new Vector2(0.95f, 0.95f);

        return taskTheme;
    }

    private InteractionState HandleInteraction(Task task, KanbanColumn column, Vector2 physicalPos, Vortice.Mathematics.Rect taskBounds)
    {
        UIContext context = UI.Context;
        bool isInteractive = !UI.State.IsPopupOpen && !_modalManager.IsModalOpen;
        bool isHovering = isInteractive && taskBounds.Contains(context.InputState.MousePosition);
        int taskIdHash = task.Id.GetHashCode();

        if (isHovering)
        {
            UI.State.SetPotentialInputTarget(taskIdHash);
        }

        if (context.InputState.WasLeftMousePressedThisFrame && isHovering && UI.State.PotentialInputTargetId == taskIdHash && UI.State.TrySetActivePress(taskIdHash, 1))
        {
            _dragDropHandler.BeginDrag(task, column, context.InputState.MousePosition, physicalPos);
        }

        bool isPressed = UI.State.ActivelyPressedElementId == taskIdHash;

        return new(isHovering, isPressed, isInteractive);
    }

    private void HandleContextMenu(Task task, InteractionState interaction)
    {
        if (interaction.IsInteractive && UI.BeginContextMenu(task.Id))
        {
            _activeContextMenuTaskId = task.Id;
        }

        if (_activeContextMenuTaskId != task.Id)
        {
            return;
        }

        int choice = UI.ContextMenu($"context_menu_{task.Id}", ["Edit Task", "Delete Task"]);

        switch (choice)
        {
            case -1:
                if (UI.State.IsPopupOpen)
                {
                    break;
                }

                _activeContextMenuTaskId = null;
                break;
            case 0:
                _modalManager.OpenEditTaskModal(task);
                break;
            case 1:
                _modalManager.RequestTaskDeletion(task);
                break;
        }
    }

    private static ButtonStyle CalculateAnimatedStyle(int taskIdHash, ButtonStylePack theme, InteractionState interaction)
    {
        theme.UpdateCurrentStyle(interaction.IsHovering, interaction.IsPressed, !interaction.IsInteractive, false, false);
        ButtonStyle targetStyle = theme.Current;
        AnimationInfo? finalAnimation = targetStyle.Animation ?? theme.Animation;

        if (finalAnimation is null || !interaction.IsInteractive)
        {
            return targetStyle;
        }

        AnimationManager animManager = UI.State.AnimationManager;
        float currentTime = UI.Context.TotalTime;

        return new(targetStyle)
        {
            FillColor = animManager.GetOrAnimate(HashCode.Combine(taskIdHash, "FillColor"), targetStyle.FillColor, currentTime, finalAnimation.Duration, finalAnimation.Easing),
            BorderColor = animManager.GetOrAnimate(HashCode.Combine(taskIdHash, "BorderColor"), targetStyle.BorderColor, currentTime, finalAnimation.Duration, finalAnimation.Easing),
            BorderLengthLeft = animManager.GetOrAnimate(HashCode.Combine(taskIdHash, "BorderLengthLeft"), targetStyle.BorderLengthLeft, currentTime, finalAnimation.Duration, finalAnimation.Easing),
            Scale = animManager.GetOrAnimate(HashCode.Combine(taskIdHash, "Scale"), targetStyle.Scale, currentTime, finalAnimation.Duration, finalAnimation.Easing)
        };
    }

    private void DrawAnimatedTask(Task task, ButtonStylePack theme, InteractionState interaction, Vortice.Mathematics.Rect taskBounds)
    {
        UIContext context = UI.Context;
        float scale = context.UIScale;
        int taskIdHash = task.Id.GetHashCode();

        ButtonStyle animatedStyle = CalculateAnimatedStyle(taskIdHash, theme, interaction);

        Vector2 center = new(taskBounds.X + taskBounds.Width / 2f, taskBounds.Y + taskBounds.Height / 2f);
        float renderWidth = taskBounds.Width * animatedStyle.Scale.X;
        float renderHeight = taskBounds.Height * animatedStyle.Scale.Y;
        Vortice.Mathematics.Rect renderBounds = new(center.X - renderWidth / 2f, center.Y - renderHeight / 2f, renderWidth, renderHeight);

        ButtonStyle renderBoxStyle = new(animatedStyle);
        renderBoxStyle.BorderLengthLeft *= scale;
        context.Renderer.DrawBox(renderBounds, renderBoxStyle);

        Vortice.Mathematics.Rect textBounds = new(taskBounds.X + (15 * scale), taskBounds.Y, taskBounds.Width - (30 * scale), taskBounds.Height);
        ButtonStyle renderTextStyle = new()
        {
            FontName = animatedStyle.FontName,
            FontSize = animatedStyle.FontSize * scale,
            FontColor = animatedStyle.FontColor
        };
        Alignment textAlign = GetTextAlignment();
        UI.DrawTextPrimitive(textBounds, task.Text, renderTextStyle, textAlign, Vector2.Zero);
    }

    private Alignment GetTextAlignment()
    {
        return _settings.TextAlign == TaskTextAlign.Left
            ? new(HAlignment.Left, VAlignment.Center)
            : new(HAlignment.Center, VAlignment.Center);
    }

    public static void DrawDragPlaceholder(Task task, float logicalWidth)
    {
        Vector2 logicalSize = CalculateTaskLogicalSize(task, logicalWidth);
        float scale = UI.Context.UIScale;

        Vector2 physicalSize = logicalSize * scale;
        Vector2 physicalPos = UI.Context.Layout.ApplyLayout(Vector2.Zero);
        Vortice.Mathematics.Rect bounds = new(physicalPos.X, physicalPos.Y, physicalSize.X, physicalSize.Y);

        BoxStyle style = new()
        {
            FillColor = new Color(0, 0, 0, 100),
            BorderColor = DefaultTheme.Accent,
            BorderLength = 1 * scale,
            Roundness = 0.1f
        };
        UI.Context.Renderer.DrawBox(bounds, style);
        UI.Context.Layout.AdvanceLayout(logicalSize);
    }

    public void DrawDropIndicator(KanbanColumn column, int index, float logicalWidth)
    {
        float scale = UI.Context.UIScale;
        if (!_dragDropHandler.IsDragging() || _dragDropHandler.DropTargetColumn != column || _dragDropHandler.DropIndex != index)
        {
            return;
        }

        Vector2 physicalPos = UI.Context.Layout.ApplyLayout(Vector2.Zero);
        Vortice.Mathematics.Rect indicatorRect = new(physicalPos.X, physicalPos.Y - (5 * scale), logicalWidth * scale, 4 * scale);

        BoxStyle style = new()
        {
            FillColor = DefaultTheme.Accent,
            BorderLength = 0,
            Roundness = 0.5f
        };

        UI.Context.Renderer.DrawBox(indicatorRect, style);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Bankan\Source\TaskTextAlign.cs">
namespace Bankan;

public enum TaskTextAlign
{
    Left,
    Center
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Bankan\Source\Modals\AddTaskModal.cs">
using System.Collections.Generic;
using System.Numerics;
using DirectUI;
using DirectUI.Core;
using DirectUI.Drawing;

namespace Bankan.Modals;

public class AddTaskModal
{
    public string TaskText { get; private set; } = "";
    public string SelectedColorHex { get; private set; } = "";

    private readonly IWindowHost _windowHost;
    private readonly List<string> _availableTaskColors;

    public AddTaskModal(IWindowHost windowHost, List<string> availableColors)
    {
        _windowHost = windowHost;
        _availableTaskColors = availableColors;
    }

    public void Open()
    {
        TaskText = "";
        SelectedColorHex = _availableTaskColors.Count > 0 ? _availableTaskColors[0] : "#bb86fc";
    }

    public void DrawUI(UIContext context)
    {
        var windowSize = context.Renderer.RenderTargetSize;
        UI.BeginVBoxContainer("add_task_vbox", new Vector2(20, 20), gap: 15f);
        UI.Text("add_task_title", "Create New Task", style: new ButtonStyle { FontSize = 18, FontWeight = Vortice.DirectWrite.FontWeight.SemiBold });

        string tempText = TaskText;
        UI.InputText("new_task_input", ref tempText, new Vector2(windowSize.X - 40, 40), placeholderText: "Enter task description...");
        TaskText = tempText;

        string tempColor = SelectedColorHex;
        // Replaced local implementation with a call to the new built-in DirectUI widget.
        UI.ColorSelector("add_task_color_selector", ref tempColor, _availableTaskColors, new Vector2(30, 30));
        SelectedColorHex = tempColor;

        UI.Separator(windowSize.X - 40);

        UI.BeginHBoxContainer("add_task_actions_hbox", UI.Context.Layout.GetCurrentPosition(), gap: 10f);
        if (UI.Button("save_task_btn", "Save Task", size: new Vector2(120, 40))) _windowHost.ModalWindowService.CloseModalWindow(0);
        if (UI.Button("cancel_task_btn", "Cancel", size: new Vector2(120, 40))) _windowHost.ModalWindowService.CloseModalWindow(1);
        UI.EndHBoxContainer();
        UI.EndVBoxContainer();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Bankan\Source\Modals\EditTaskModal.cs">
using System.Collections.Generic;
using System.Numerics;
using DirectUI;
using DirectUI.Core;
using DirectUI.Drawing;

namespace Bankan.Modals;

public class EditTaskModal
{
    public string TaskText { get; private set; } = "";
    public string SelectedColorHex { get; private set; } = "";
    public Task? TaskToEdit { get; private set; }

    private readonly IWindowHost _windowHost;
    private readonly List<string> _availableTaskColors;

    public EditTaskModal(IWindowHost windowHost, List<string> availableColors)
    {
        _windowHost = windowHost;
        _availableTaskColors = availableColors;
    }

    public void Open(Task task)
    {
        TaskToEdit = task;
        TaskText = task.Text;
        SelectedColorHex = task.ColorHex;
    }

    public void DrawUI(UIContext context)
    {
        var windowSize = context.Renderer.RenderTargetSize;
        UI.BeginVBoxContainer("edit_task_vbox", new Vector2(20, 20), gap: 15f);
        UI.Text("edit_task_title", "Edit Task", style: new ButtonStyle { FontSize = 18, FontWeight = Vortice.DirectWrite.FontWeight.SemiBold });

        string tempText = TaskText;
        UI.InputText("edit_task_input", ref tempText, new Vector2(windowSize.X - 40, 40), placeholderText: "Enter task description...");
        TaskText = tempText;

        string tempColor = SelectedColorHex;
        // Replaced local implementation with a call to the new built-in DirectUI widget.
        UI.ColorSelector("edit_task_color_selector", ref tempColor, _availableTaskColors, new Vector2(30, 30));
        SelectedColorHex = tempColor;

        UI.Separator(windowSize.X - 40);

        UI.BeginHBoxContainer("edit_task_actions_hbox", UI.Context.Layout.GetCurrentPosition(), gap: 10f);
        if (UI.Button("save_edit_btn", "Save Changes", size: new Vector2(140, 40))) _windowHost.ModalWindowService.CloseModalWindow(0);
        var deleteTheme = new ButtonStylePack { Normal = { FillColor = new Color(207, 102, 121, 255) }, Hover = { FillColor = new Color(176, 81, 98, 255) } };
        if (UI.Button("delete_task_btn", "Delete Task", size: new Vector2(120, 40), theme: deleteTheme)) _windowHost.ModalWindowService.CloseModalWindow(2);
        UI.EndHBoxContainer();
        UI.EndVBoxContainer();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Bankan\Source\Modals\SettingsModal.cs">
using System.Numerics;
using DirectUI;
using DirectUI.Core;

namespace Bankan.Modals;

public class SettingsModal
{
    private readonly KanbanSettings _settings;
    private readonly IWindowHost _windowHost;

    public SettingsModal(KanbanSettings settings, IWindowHost windowHost)
    {
        _settings = settings;
        _windowHost = windowHost;
    }

    public void DrawUI(UIContext context)
    {
        Vector2 windowSize = context.Renderer.RenderTargetSize;

        UI.BeginVBoxContainer("settings_vbox", new(20, 20), gap: 15f);
        {
            DrawHeader(windowSize);
            DrawColorStyleSelectors();
            DrawTextAlignSelectors();
            DrawCloseButton(windowSize);
        }
        UI.EndVBoxContainer();
    }

    private static void DrawHeader(Vector2 windowSize)
    {
        ButtonStyle style = new()
        {
            FontSize = 18,
            FontWeight =
            Vortice.DirectWrite.FontWeight.SemiBold
        };

        UI.Text("settings_title", "Settings", style: style);

        UI.Separator(windowSize.X - 40);
    }

    private void DrawColorStyleSelectors()
    {
        UI.Text("color_style_label", "Task Color Style");

        int colorStyleIndex = (int)_settings.ColorStyle;

        if (UI.RadioButtons("color_style_selectors", ["Border", "Background"], ref colorStyleIndex))
        {
            _settings.ColorStyle = (TaskColorStyle)colorStyleIndex;
        }
    }

    private void DrawTextAlignSelectors()
    {
        UI.Text("align_label", "Task Text Alignment");

        int textAlignIndex = (int)_settings.TextAlign;

        if (UI.RadioButtons("text_align_selectors", ["Left", "Center"], ref textAlignIndex))
        {
            _settings.TextAlign = (TaskTextAlign)textAlignIndex;
        }
    }

    private void DrawCloseButton(Vector2 windowSize)
    {
        Vector2 closeButtonPos = new((windowSize.X - 100) / 2, windowSize.Y - 60);

        if (UI.Button("close_settings_btn", "Close", size: new(100, 40), origin: closeButtonPos))
        {
            _windowHost.ModalWindowService.CloseModalWindow(0);
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Bankan\Data\styles.yaml">
addTaskButton:
  # This is the fallback animation for any state that doesn't define its own.
  # This will be used when transitioning from Hover back TO the Normal state.
  Animation:
    Duration: 0.25
    Easing: EaseOutQuad
  Normal:
    FillColor: "#00000000"
    BorderColor: [51, 51, 51, 255]
  Hover:
    FillColor: "#3366CCFF"
    BorderColor: "#3366CCFF"
    Scale: [0.95, 0.95]
    # This animation is used specifically when transitioning TO the hover state.
    Animation:
      Duration: 0.1
      Easing: EaseOutQuad
  Pressed:
    Scale: [0.9, 0.9]
    # Transition to Pressed state will use the fallback 0.25s duration.
</file>

