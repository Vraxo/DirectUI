<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Alignment.cs">
// Alignment.cs
// Alignment.cs
using DirectUI.Core; // Added using directive

namespace DirectUI;

public enum HAlignment { Left, Center, Right }
public enum VAlignment { Top, Center, Bottom }

public struct Alignment(HAlignment horizontal, VAlignment vertical)
{
    public HAlignment Horizontal { get; set; } = horizontal;
    public VAlignment Vertical { get; set; } = vertical;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\AppEngine.cs">
// AppEngine.cs
using System;
using System.Diagnostics;
using System.Numerics;
using Vortice.Mathematics;
using DirectUI.Core; // For IRenderer, ITextService
using DirectUI.Drawing;
using DirectUI.Diagnostics;
using DirectUI.Input;
using Silk.NET.OpenAL;
using System.Reflection.Emit;
using System.Security.Cryptography;

namespace DirectUI;

/// <summary>
/// Manages the application's core UI engine lifecycle, input state aggregation,
/// and frame timing. It is decoupled from any specific windowing or graphics backend.
/// </summary>
public class AppEngine
{
    private readonly Action<UIContext> _drawCallback;
    private readonly FpsCounter _fpsCounter;
    private readonly InputManager _inputManager;
    private readonly Stopwatch _frameTimer = new();
    private long _lastFrameTicks;

    public bool ShowFpsCounter { get; set; } = true;
    public InputManager Input => _inputManager;
    public Color4 BackgroundColor { get; }

    public AppEngine(Action<UIContext> drawCallback, Color4 backgroundColor)
    {
        _drawCallback = drawCallback ?? throw new ArgumentNullException(nameof(drawCallback));
        BackgroundColor = backgroundColor;
        _fpsCounter = new FpsCounter();
        _inputManager = new InputManager();

        _frameTimer.Start();
        _lastFrameTicks = _frameTimer.ElapsedTicks;
    }

    /// <summary>
    /// Initializes internal components like the FPS counter.
    /// This should be called once after the renderer and text service are ready.
    /// </summary>
    public void Initialize(ITextService textService, IRenderer renderer)
    {
        _fpsCounter.Initialize(textService, renderer);
    }

    /// <summary>
    /// Cleans up internal engine resources.
    /// </summary>
    public void Cleanup()
    {
        _fpsCounter.Cleanup();
    }

    /// <summary>
    /// Updates the engine state for a single frame and renders the UI.
    /// This method is called by the specific window host after it has prepared its drawing surface.
    /// </summary>
    /// <param name="renderer">The graphics renderer for this frame.</param>
    /// <param name="textService">The text service for this frame.</param>
    public void UpdateAndRender(IRenderer renderer, ITextService textService)
    {
        // Prevent re-entrant rendering calls.
        if (UI.IsRendering) return;

        // Calculate delta time for the frame
        long currentTicks = _frameTimer.ElapsedTicks;
        float deltaTime = (float)(currentTicks - _lastFrameTicks) / Stopwatch.Frequency;
        _lastFrameTicks = currentTicks;

        // Clamp delta time to avoid huge jumps (e.g., when debugging or window is moved)
        deltaTime = Math.Min(deltaTime, 1.0f / 15.0f); // Clamp to a minimum of 15 FPS

        _fpsCounter.Update(); // Update FPS counter once per render call.

        try
        {
            // Get the immutable input state for this frame from the InputManager
            var inputState = _inputManager.GetCurrentState();

            var uiContext = new UIContext(renderer, textService, inputState, deltaTime);
            UI.BeginFrame(uiContext);

            _drawCallback(uiContext);

            if (ShowFpsCounter)
            {
                _fpsCounter.Draw();
            }

            UI.EndFrame();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred during UI drawing: {ex}");
        }
        finally
        {
            _inputManager.PrepareNextFrame();
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Application.cs">
namespace DirectUI;

public static class Application
{
    private static readonly List<Win32Window> windows = [];
    private static bool isRunning = false;

    static Application()
    {
        SharedGraphicsResources.Initialize();
    }

    public static void RegisterWindow(Win32Window window)
    {
        if (windows.Contains(window))
        {
            return;
        }

        windows.Add(window);
    }

    public static void UnregisterWindow(Win32Window window)
    {
        windows.Remove(window);

        if (windows.Count != 0)
        {
            return;
        }

        Exit();
    }

    public static void RunMessageLoop()
    {
        if (windows.Count == 0)
        {
            Console.WriteLine("Application.RunMessageLoop() called with no Win32 windows registered.");
            return;
        }

        isRunning = true;

        while (isRunning)
        {
            ProcessMessages();

            // After processing messages, if no WM_QUIT was posted, allow all registered
            // windows to perform their per-frame updates. This is crucial for logic
            // that needs to run every frame, like checking for modal window closure.
            if (!isRunning)
            {
                continue;
            }
            // Iterate over a copy so we can modify the original list (e.g., on window close).
            // This is safer than iterating over the list directly if FrameUpdate can cause
            // a window to be unregistered.
            foreach (Win32Window? window in windows.ToList())
            {
                // FrameUpdate implementations should be safe to call even if the
                // window's handle has been destroyed in the same frame.
                window.FrameUpdate();
            }
        }

        SharedGraphicsResources.Cleanup();
    }

    internal static void ProcessMessages()
    {
        while (NativeMethods.PeekMessage(out var msg, IntPtr.Zero, 0, 0, NativeMethods.PM_REMOVE))
        {
            if (msg.message == NativeMethods.WM_QUIT)
            {
                isRunning = false;
                break;
            }

            NativeMethods.TranslateMessage(ref msg);
            NativeMethods.DispatchMessage(ref msg);
        }
    }

    public static void Exit()
    {
        if (!isRunning)
        {
            return;
        }

        isRunning = false;
        NativeMethods.PostQuitMessage(0);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\AppRunner.cs">
using DirectUI.Backends.SDL3;
using DirectUI.Backends.SkiaSharp;
using DirectUI.Core; // Added for IWindowHost
using Raylib_cs;
using SDL3;
using GraphicsBackend = DirectUI.GraphicsBackend;

namespace DirectUI;

public static class ApplicationRunner
{
    private static bool _isSavedOnExit = false;

    public static void Run(GraphicsBackend backend, Func<IWindowHost, IAppLogic> appLogicFactory)
    {
        IWindowHost? host = null;
        IAppLogic? appLogic = null;

        // Define a guarded save action to prevent saving more than once on exit.
        Action? saveAction = null;

        try
        {
            host = backend switch
            {
                GraphicsBackend.Raylib => new RaylibWindowHost("My Raylib App", 1024, 768, new Vortice.Mathematics.Color4(45 / 255f, 45 / 255f, 45 / 255f, 1.0f)),
                GraphicsBackend.Direct2D => new Win32WindowHost("My D2D App", 1024, 768),
                GraphicsBackend.SDL3 => new SDL3WindowHost("My SDL3 App", 1024, 768, new Vortice.Mathematics.Color4(45 / 255f, 45 / 255f, 45 / 255f, 1.0f)),
                GraphicsBackend.SkiaSharp => new SilkNetWindowHost("My Skia App", 1024, 768, new Vortice.Mathematics.Color4(45 / 255f, 45 / 255f, 45 / 255f, 1.0f)),
                _ => throw new ArgumentOutOfRangeException(nameof(backend), backend, "Unsupported graphics backend.")
            };

            Console.WriteLine($"Using {backend} Backend.");

            appLogic = appLogicFactory(host);

            saveAction = () =>
            {
                if (_isSavedOnExit || appLogic == null) return;

                Console.WriteLine("Exit detected. Saving application state...");
                appLogic.SaveState();
                _isSavedOnExit = true;
            };

            // Hook into the AppDomain.ProcessExit event. This is a more reliable way
            // to catch process termination, including closing the console window.
            AppDomain.CurrentDomain.ProcessExit += (sender, e) =>
            {
                saveAction?.Invoke();
            };

            if (host.Initialize(appLogic.DrawUI, new Vortice.Mathematics.Color4(45 / 255f, 45 / 255f, 45 / 255f, 1.0f))) // #2D2D2D
            {
                host.RunLoop();
            }
            else
            {
                Console.WriteLine($"Failed to initialize {backend} application.");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An unhandled exception occurred: {ex}");
        }
        finally
        {
            // The finally block is executed on a clean shutdown (e.g., closing the GUI window).
            // We call the same guarded save action here.
            saveAction?.Invoke();

            host?.Cleanup();
            host?.Dispose();
        }
    }

    // Removed specific RunRaylib, RunDirect2D, RunSDL3 methods
    // as their logic is now encapsulated within their respective IWindowHost implementations.
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\AppServices.cs">
using DirectUI.Core;

namespace DirectUI;

public sealed class AppServices
{
    public AppEngine AppEngine { get; }
    public DuiGraphicsDevice GraphicsDevice { get; }
    public IRenderer Renderer { get; }
    public ITextService TextService { get; }

    internal AppServices(AppEngine appEngine, DuiGraphicsDevice graphicsDevice, IRenderer renderer, ITextService textService)
    {
        AppEngine = appEngine;
        GraphicsDevice = graphicsDevice;
        Renderer = renderer;
        TextService = textService;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\GlobalUsings.cs">
global using Color = DirectUI.Drawing.Color;
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\GraphicsBackend.cs">
namespace DirectUI;

public enum GraphicsBackend
{
    Direct2D,
    Raylib,
    SDL3,
    SkiaSharp
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\ModalWindow.cs">
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI;

public class ModalWindow : Win32Window
{
    private readonly Win32Window owner;
    private readonly Action<UIContext> drawCallback;
    private AppServices? appServices;

    public ModalWindow(Win32Window owner, string title, int width, int height, Action<UIContext> drawCallback)
        : base(title, width, height)
    {
        this.owner = owner ?? throw new ArgumentNullException(nameof(owner));
        this.drawCallback = drawCallback ?? throw new ArgumentNullException(nameof(drawCallback));
    }

    protected override bool Initialize()
    {
        Console.WriteLine("ModalWindow initializing...");

        try
        {
            appServices = Win32AppServicesInitializer.Initialize(
                Handle,
                GetClientRectSize(),
                drawCallback,
                new(60 / 255f, 60 / 255f, 60 / 255f, 1.0f));

            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to initialize modal window services: {ex.Message}");
            return false;
        }
    }

    protected override void Cleanup()
    {
        Console.WriteLine("ModalWindow cleaning up its resources...");
        appServices?.AppEngine.Cleanup();
        appServices?.TextService.Cleanup();
        (appServices?.Renderer as Backends.Direct2DRenderer)?.Cleanup();
        appServices?.GraphicsDevice.Cleanup();

        appServices = null;
    }

    protected override void OnPaint()
    {
        if (appServices is null || !appServices.GraphicsDevice.IsInitialized)
        {
            Console.WriteLine("Modal window render services not initialized. Skipping paint.");
            return;
        }

        appServices.GraphicsDevice.BeginDraw();

        try
        {
            if (appServices.AppEngine is not null && appServices.GraphicsDevice.RenderTarget is not null)
            {
                appServices.GraphicsDevice.RenderTarget.Clear(appServices.AppEngine.BackgroundColor);
            }

            appServices?.AppEngine?.UpdateAndRender(appServices.Renderer, appServices.TextService);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred during modal window drawing: {ex}");
            appServices.GraphicsDevice.Cleanup();
        }
        finally
        {
            appServices.GraphicsDevice.EndDraw();
        }
    }

    public override void FrameUpdate()
    {
        Invalidate();
    }

    protected override void OnSize(int width, int height)
    {
        appServices?.GraphicsDevice.Resize(new SizeI(width, height));
    }

    protected override void OnMouseMove(int x, int y)
    {
        appServices?.AppEngine.Input.SetMousePosition(x, y);
        Invalidate();
    }

    protected override void OnMouseDown(MouseButton button, int x, int y)
    {
        appServices?.AppEngine.Input.SetMousePosition(x, y);
        appServices?.AppEngine.Input.SetMouseDown(button);
        Invalidate();
    }

    protected override void OnMouseUp(MouseButton button, int x, int y)
    {
        appServices?.AppEngine.Input.SetMousePosition(x, y);
        appServices?.AppEngine.Input.SetMouseUp(button);
        Invalidate();
    }

    protected override void OnMouseWheel(float delta)
    {
        appServices?.AppEngine.Input.AddMouseWheelDelta(delta);
        Invalidate();
    }

    protected override void OnKeyDown(Keys key)
    {
        appServices?.AppEngine.Input.AddKeyPressed(key);

        if (key == Keys.Escape)
        {
            Close();
        }

        Invalidate();
    }

    protected override void OnKeyUp(Keys key)
    {
        appServices?.AppEngine.Input.AddKeyReleased(key);
        Invalidate();
    }

    protected override void OnChar(char c)
    {
        appServices?.AppEngine.Input.AddCharacterInput(c);
        Invalidate();
    }

    protected override bool OnClose()
    {
        return true;
    }

    public bool CreateAsModal()
    {
        if (Handle != IntPtr.Zero)
        {
            return true;
        }

        uint style =
            NativeMethods.WS_POPUP |
            NativeMethods.WS_CAPTION |
            NativeMethods.WS_SYSMENU |
            NativeMethods.WS_VISIBLE |
            NativeMethods.WS_THICKFRAME;

        int? x = null;
        int? y = null;

        if (owner.Handle != IntPtr.Zero && owner.GetWindowRect(out NativeMethods.RECT ownerRect))
        {
            int ownerWidth = ownerRect.right - ownerRect.left;
            int ownerHeight = ownerRect.bottom - ownerRect.top;
            int modalWidth = Width;
            int modalHeight = Height;

            x = ownerRect.left + (ownerWidth - modalWidth) / 2;
            y = ownerRect.top + (ownerHeight - modalHeight) / 2;
        }

        if (!Create(owner.Handle, style, x, y))
        {
            return false;
        }

        if (Handle == IntPtr.Zero)
        {
            return false;
        }

        NativeMethods.EnableWindow(owner.Handle, false);

        return true;
    }

    protected override void OnDestroy()
    {
        // Explicitly notify the owner that the modal has closed.
        // This is a more robust pattern than the owner polling the handle.
        if (owner is Win32WindowHost host)
        {
            host.NotifyModalHasClosed();
        }

        if (owner.Handle != IntPtr.Zero)
        {
            NativeMethods.EnableWindow(owner.Handle, true);
        }

        base.OnDestroy();
    }

    protected SizeI GetClientRectSize()
    {
        if (Handle != nint.Zero && NativeMethods.GetClientRect(Handle, out NativeMethods.RECT r))
        {
            int width = int.Max(1, r.right - r.left);
            int height = int.Max(1, r.bottom - r.top);
            return new(width, height);
        }

        int baseWidth = int.Max(1, Width);
        int baseHeight = int.Max(1, Height);

        if (Handle != nint.Zero)
        {
            Console.WriteLine($"GetClientRect failed. Falling back to stored size: {baseWidth}x{baseHeight}");
        }

        return new(baseWidth, baseHeight);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\MouseButton.cs">
namespace DirectUI;

public enum MouseButton
{
    Left,
    Right,
    Middle,
    XButton1,
    XButton2
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\NativeMethods.cs">
// NativeMethods.cs
using System;
using System.Runtime.InteropServices;

// No changes needed here if it was correct from the previous step.
// Ensure these constants are defined:
// WM_NCCREATE, WM_CREATE, WM_NCDESTROY, WM_PAINT, WM_DESTROY, WM_SIZE,
// WM_CLOSE, WM_KEYDOWN, WM_LBUTTONDOWN, WM_LBUTTONUP, WM_MOUSEMOVE, WM_QUIT
// GWLP_USERDATA, VK_ESCAPE, etc.
// And the structs: WNDCLASSEX, MSG, POINT, RECT, CREATESTRUCT
// And the functions: RegisterClassEx, CreateWindowEx, GetMessage, etc.
// And the delegates: WndProc

namespace DirectUI;

public static class NativeMethods
{
    // --- Constants ---
    public const uint CS_HREDRAW = 0x0002;
    public const uint CS_VREDRAW = 0x0001;
    public const uint CS_OWNDC = 0x0020;

    public const uint WS_OVERLAPPED = 0x00000000;
    public const uint WS_CAPTION = 0x00C00000;
    public const uint WS_SYSMENU = 0x00080000;
    public const uint WS_THICKFRAME = 0x00040000;
    public const uint WS_MINIMIZEBOX = 0x00020000;
    public const uint WS_MAXIMIZEBOX = 0x00010000;
    public const uint WS_OVERLAPPEDWINDOW = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
    public const uint WS_VISIBLE = 0x10000000;
    public const uint WS_POPUP = 0x80000000;

    public const int WM_NCCREATE = 0x0081;
    public const int WM_CREATE = 0x0001;
    public const int WM_NCDESTROY = 0x0082;
    public const int WM_PAINT = 0x000F;
    public const int WM_DESTROY = 0x0002;
    public const int WM_SIZE = 0x0005;
    public const int WM_CLOSE = 0x0010;
    public const int WM_KEYDOWN = 0x0100;
    public const int WM_KEYUP = 0x0101;
    public const int WM_SYSKEYUP = 0x0105;
    public const int WM_LBUTTONDOWN = 0x0201;
    public const int WM_LBUTTONUP = 0x0202; // Ensure this exists
    public const int WM_RBUTTONDOWN = 0x0204;
    public const int WM_RBUTTONUP = 0x0205;
    public const int WM_MBUTTONDOWN = 0x0207;
    public const int WM_MBUTTONUP = 0x0208;
    public const int WM_XBUTTONDOWN = 0x020B;
    public const int WM_XBUTTONUP = 0x020C;
    public const int WM_MOUSEMOVE = 0x0200; // Ensure this exists
    public const int WM_MOUSEWHEEL = 0x020A;
    public const int WM_QUIT = 0x0012;
    public const int WM_CHAR = 0x0102;


    public const int CW_USEDEFAULT = unchecked((int)0x80000000);
    public const int SW_SHOWNORMAL = 1;
    public const int GWLP_USERDATA = -21;

    public const uint PM_REMOVE = 0x0001;

    // --- Structures ---
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
    public struct WNDCLASSEX
    { /* ... as before ... */
        public int cbSize;
        public uint style;
        public WndProc lpfnWndProc; // Use delegate type directly
        public int cbClsExtra;
        public int cbWndExtra;
        public IntPtr hInstance;
        public IntPtr hIcon;
        public IntPtr hCursor;
        public IntPtr hbrBackground;
        public string lpszMenuName;
        public string lpszClassName;
        public IntPtr hIconSm;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct MSG
    { /* ... as before ... */
        public IntPtr hwnd;
        public uint message;
        public IntPtr wParam;
        public IntPtr lParam;
        public uint time;
        public POINT pt;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct POINT
    { /* ... as before ... */
        public int X;
        public int Y;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct RECT
    { /* ... as before ... */
        public int left;
        public int top;
        public int right;
        public int bottom;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct CREATESTRUCT
    { /* ... as before ... */
        public IntPtr lpCreateParams;
        public IntPtr hInstance;
        public IntPtr hMenu;
        public IntPtr hwndParent;
        public int cy; // Height
        public int cx; // Width
        public int y;  // Top
        public int x;  // Left
        public int style;
        [MarshalAs(UnmanagedType.LPWStr)] // Assuming Unicode
        public string lpszName;
        [MarshalAs(UnmanagedType.LPWStr)] // Assuming Unicode
        public string lpszClass;
        public int dwExStyle;
    }

    // --- Delegates ---
    public delegate IntPtr WndProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam);

    // --- Functions ---
    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern ushort RegisterClassEx([In] ref WNDCLASSEX lpwcx);
    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern IntPtr CreateWindowEx(uint dwExStyle, string lpClassName, string lpWindowName, uint dwStyle, int x, int y, int nWidth, int nHeight, IntPtr hWndParent, IntPtr hMenu, IntPtr hInstance, IntPtr lpParam);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool UpdateWindow(IntPtr hWnd);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool DestroyWindow(IntPtr hWnd);
    [DllImport("user32.dll")]
    public static extern IntPtr DefWindowProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam);
    [DllImport("user32.dll")]
    public static extern void PostQuitMessage(int nExitCode);
    [DllImport("user32.dll")]
    public static extern bool GetMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax);
    [DllImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool PeekMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax, uint wRemoveMsg);
    [DllImport("user32.dll")]
    public static extern bool TranslateMessage([In] ref MSG lpMsg);
    [DllImport("user32.dll")]
    public static extern IntPtr DispatchMessage([In] ref MSG lpmsg);
    [DllImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)] // Add return type annotation
    public static extern bool PostMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam); // Added
    [DllImport("user32.dll")]
    public static extern bool GetClientRect(IntPtr hWnd, out RECT lpRect);
    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern IntPtr GetModuleHandle(string lpModuleName);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool InvalidateRect(IntPtr hWnd, IntPtr lpRect, bool bErase);
    [DllImport("user32.dll")]
    public static extern IntPtr LoadCursor(IntPtr hInstance, int lpCursorName);
    [DllImport("user32.dll")]
    public static extern IntPtr LoadIcon(IntPtr hInstance, IntPtr lpIconName);
    [DllImport("user32.dll", EntryPoint = "SetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr SetWindowLongPtr64(IntPtr hWnd, int nIndex, IntPtr dwNewLong);
    [DllImport("user32.dll", EntryPoint = "SetWindowLongW", SetLastError = true)]
    private static extern IntPtr SetWindowLong32(IntPtr hWnd, int nIndex, IntPtr dwNewLong);
    [DllImport("user32.dll", EntryPoint = "GetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr GetWindowLongPtr64(IntPtr hWnd, int nIndex);
    [DllImport("user32.dll", EntryPoint = "GetWindowLongW", SetLastError = true)]
    private static extern IntPtr GetWindowLong32(IntPtr hWnd, int nIndex);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr SetCapture(IntPtr hWnd);
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool ReleaseCapture();
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool EnableWindow(IntPtr hWnd, bool bEnable);
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool GetWindowRect(IntPtr hwnd, out RECT lpRect);


    public static IntPtr SetWindowLongPtr(IntPtr hWnd, int nIndex, IntPtr dwNewLong)
    {
        if (IntPtr.Size == 8) return SetWindowLongPtr64(hWnd, nIndex, dwNewLong);
        else return SetWindowLong32(hWnd, nIndex, dwNewLong);
    }
    public static IntPtr GetWindowLongPtr(IntPtr hWnd, int nIndex)
    {
        if (IntPtr.Size == 8) return GetWindowLongPtr64(hWnd, nIndex);
        else return GetWindowLong32(hWnd, nIndex);
    }

    // --- Helpers ---
    public static short LoWord(IntPtr val) => unchecked((short)(long)val);
    public static short HiWord(IntPtr val) => unchecked((short)((long)val >> 16));
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\SharedGraphicsResources.cs">
// SharedGraphicsResources.cs
using System;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using SharpGen.Runtime;
using D2D = Vortice.Direct2D1;
using DW = Vortice.DirectWrite;

namespace DirectUI;

/// <summary>
/// Manages graphics resources that are shared across the entire application,
/// such as the main Direct2D and DirectWrite factories.
/// </summary>
internal static class SharedGraphicsResources
{
    public static ID2D1Factory1? D2DFactory { get; private set; }
    public static IDWriteFactory? DWriteFactory { get; private set; }

    private static bool s_isInitialized = false;

    /// <summary>
    /// Initializes the shared factories. Should be called once at application startup.
    /// </summary>
    public static void Initialize()
    {
        if (s_isInitialized) return;

        try
        {
            Result factoryResult = D2D1.D2D1CreateFactory(D2D.FactoryType.SingleThreaded, out ID2D1Factory1? d2dFactory);
            factoryResult.CheckError();
            D2DFactory = d2dFactory ?? throw new InvalidOperationException("Shared D2D Factory creation failed silently.");

            Result dwriteResult = DW.DWrite.DWriteCreateFactory(DW.FactoryType.Shared, out IDWriteFactory? dwriteFactory);
            dwriteResult.CheckError();
            DWriteFactory = dwriteFactory ?? throw new InvalidOperationException("Shared DWrite Factory creation failed silently.");

            Console.WriteLine("Shared Graphics Factories Initialized.");
            s_isInitialized = true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"FATAL: Could not initialize shared graphics resources: {ex.Message}");
            Cleanup();
            throw;
        }
    }

    /// <summary>
    /// Disposes of the shared factories. Should be called once when the application is closing.
    /// </summary>
    public static void Cleanup()
    {
        if (!s_isInitialized) return;
        Console.WriteLine("Cleaning up shared graphics factories...");
        DWriteFactory?.Dispose();
        DWriteFactory = null;
        D2DFactory?.Dispose();
        D2DFactory = null;
        s_isInitialized = false;
        Console.WriteLine("Shared graphics factories cleaned up.");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Containers\ComboboxState.cs">
namespace DirectUI;

internal class ComboboxState
{
    public bool IsOpen;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Containers\DataGridState.cs">
// DirectUI/Source/Containers/DataGridState.cs
using System.Collections.Generic;
using System.Numerics;

namespace DirectUI;

internal class DataGridState
{
    public int Id { get; set; }
    public List<float> ColumnWidths { get; set; } = new();
    public Vector2 ScrollOffset { get; set; } = Vector2.Zero;
    public int ResizingColumnIndex { get; set; } = -1;

    // State for column resizing drag operation
    public float ColumnResizeStartWidth { get; set; }
    public float DragStartMouseX { get; set; }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Containers\GridContainerState.cs">
using System.Numerics;

namespace DirectUI;

internal class GridContainerState : ILayoutContainer
{
    internal int Id { get; }
    internal Vector2 StartPosition { get; } // Top-left corner of the grid area
    internal int NumColumns { get; }
    internal Vector2 Gap { get; } // Gap between cells (X and Y)
    internal Vector2 AvailableSize { get; } // Total area the grid can occupy

    // Calculated layout values
    internal float CellWidth { get; }
    internal List<float> RowHeights { get; } = new(); // Store height of each completed row
    internal float CurrentRowMaxHeight { get; set; } = 0f; // Track max height of elements in the current row being built
    internal int CurrentCellIndex { get; set; } = 0; // 0-based index of the next cell to place an element in
    internal Vector2 CurrentDrawPosition { get; set; } // Calculated top-left for the next element

    // Tracking overall bounds occupied by elements
    internal float AccumulatedWidth { get; set; } = 0f;
    internal float AccumulatedHeight { get; set; } = 0f;


    internal GridContainerState(int id, Vector2 startPosition, Vector2 availableSize, int numColumns, Vector2 gap)
    {
        Id = id;
        StartPosition = startPosition;
        AvailableSize = availableSize;
        NumColumns = Math.Max(1, numColumns); // Ensure at least one column
        Gap = gap;

        // Calculate fixed cell width based on available space and gaps
        float totalHorizontalGap = Math.Max(0, NumColumns - 1) * Gap.X;
        float widthForCells = AvailableSize.X - totalHorizontalGap;
        CellWidth = (NumColumns > 0) ? Math.Max(0, widthForCells / NumColumns) : 0;

        // Initial position is the start position
        CurrentDrawPosition = startPosition;
        RowHeights.Add(0); // Add initial height for the first row (will be updated)
    }

    internal void MoveToNextCell(Vector2 elementSize)
    {
        // Update max height for the current row
        CurrentRowMaxHeight = Math.Max(CurrentRowMaxHeight, elementSize.Y);

        // Update total occupied width (conservative estimate using cell width)
        int currentCol = CurrentCellIndex % NumColumns;
        float currentWidth = (currentCol + 1) * CellWidth + currentCol * Gap.X;
        AccumulatedWidth = Math.Max(AccumulatedWidth, currentWidth);


        CurrentCellIndex++;
        int nextCol = CurrentCellIndex % NumColumns;

        if (nextCol == 0) // Moved to the start of a new row
        {
            // Finalize the height of the completed row
            RowHeights[^1] = CurrentRowMaxHeight; // Update last row's height
            AccumulatedHeight += CurrentRowMaxHeight + (RowHeights.Count > 1 ? Gap.Y : 0); // Add height and gap (if not first row)

            // Reset for the new row
            CurrentRowMaxHeight = 0f;
            RowHeights.Add(0); // Add placeholder height for the new row

            // Calculate Y position for the new row
            float newY = StartPosition.Y;
            for (int i = 0; i < RowHeights.Count - 1; i++) // Sum heights and gaps of completed rows
            {
                newY += RowHeights[i] + Gap.Y;
            }

            // Set position for the first cell of the new row
            CurrentDrawPosition = new Vector2(StartPosition.X, newY);

        }
        else // Moving to the next column in the same row
        {
            // Calculate X position for the next cell
            float currentX = StartPosition.X + nextCol * (CellWidth + Gap.X);
            CurrentDrawPosition = new Vector2(currentX, CurrentDrawPosition.Y); // Y stays the same
        }
    }

    internal Vector2 GetTotalOccupiedSize()
    {
        // Calculate final height including the current row being built
        float finalHeight = AccumulatedHeight + CurrentRowMaxHeight;
        return new Vector2(AccumulatedWidth, finalHeight);
    }

    public Vector2 GetCurrentPosition() => CurrentDrawPosition;

    public void Advance(Vector2 elementSize) => MoveToNextCell(elementSize);
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Containers\HBoxContainerState.cs">
using System.Numerics;

namespace DirectUI;

public class HBoxContainerState : ILayoutContainer
{
    internal int Id { get; }
    internal Vector2 StartPosition { get; set; }
    internal Vector2 CurrentPosition { get; set; }
    internal float Gap { get; set; }
    internal float MaxElementHeight { get; set; } = 0f;
    internal float AccumulatedWidth { get; set; } = 0f;
    internal int ElementCount { get; set; } = 0;

    internal HBoxContainerState(int id)
    {
        Id = id;
    }

    public Vector2 GetCurrentPosition() => CurrentPosition;

    public void Advance(Vector2 elementSize)
    {
        if (elementSize.Y > MaxElementHeight)
        {
            MaxElementHeight = elementSize.Y;
        }

        AccumulatedWidth += elementSize.X;
        if (ElementCount > 0)
        {
            AccumulatedWidth += Gap;
        }
        float advanceX = elementSize.X + Gap;
        CurrentPosition = new Vector2(CurrentPosition.X + advanceX, CurrentPosition.Y);
        ElementCount++;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Containers\ResizableHPanelState.cs">
using System.Numerics;

namespace DirectUI;

internal class ResizableHPanelState : ILayoutContainer
{
    internal int Id { get; }
    internal HBoxContainerState InnerHBox { get; }
    internal bool ClipRectWasPushed { get; }

    internal ResizableHPanelState(int id, HBoxContainerState innerHBox, bool clipPushed)
    {
        Id = id;
        InnerHBox = innerHBox;
        ClipRectWasPushed = clipPushed;
    }

    public Vector2 GetCurrentPosition() => InnerHBox.GetCurrentPosition();

    public void Advance(Vector2 elementSize) => InnerHBox.Advance(elementSize);
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Containers\ResizablePanelState.cs">
using System.Numerics;

namespace DirectUI;

internal class ResizablePanelState : ILayoutContainer
{
    internal int Id { get; }
    internal VBoxContainerState InnerVBox { get; }
    internal bool ClipRectWasPushed { get; }

    internal ResizablePanelState(int id, VBoxContainerState innerVBox, bool clipPushed)
    {
        Id = id;
        InnerVBox = innerVBox;
        ClipRectWasPushed = clipPushed;
    }

    public Vector2 GetCurrentPosition() => InnerVBox.GetCurrentPosition();

    public void Advance(Vector2 elementSize) => InnerVBox.Advance(elementSize);
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Containers\ScrollContainerState.cs">
using System.Numerics;

namespace DirectUI;

public class ScrollContainerState : ILayoutContainer
{
    // State managed by the UI system
    internal Vector2 CurrentScrollOffset { get; set; }

    // Per-frame calculated values
    internal int Id { get; set; }
    internal Vector2 Position { get; set; }
    internal Vector2 VisibleSize { get; set; }
    internal Vector2 ContentSize { get; set; }
    internal bool IsHovered { get; set; }
    internal VBoxContainerState ContentVBox { get; set; } = null!;

    // Public parameterless constructor required for GetOrCreateElement
    public ScrollContainerState() { }

    public Vector2 GetCurrentPosition() => ContentVBox.GetCurrentPosition();

    public void Advance(Vector2 elementSize) => ContentVBox.Advance(elementSize);
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Containers\TreeViewState.cs">
namespace DirectUI;

internal class TreeViewState
{
    internal int Id { get; }
    internal TreeStyle Style { get; }
    internal Stack<bool> IndentLineState { get; } = new();

    internal TreeViewState(int id, TreeStyle style)
    {
        Id = id;
        Style = style;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Containers\VBoxContainerState.cs">
using System.Numerics;

namespace DirectUI;

public class VBoxContainerState : ILayoutContainer
{
    internal int Id { get; }
    internal Vector2 StartPosition { get; set; }
    internal Vector2 CurrentPosition { get; set; } // Top-left for the next element
    internal float Gap { get; set; }
    internal float MaxElementWidth { get; set; } = 0f; // Track width for container bounds
    internal float AccumulatedHeight { get; set; } = 0f; // Track height for container bounds
    internal int ElementCount { get; set; } = 0;

    internal VBoxContainerState(int id)
    {
        Id = id;
    }

    public Vector2 GetCurrentPosition() => CurrentPosition;

    public void Advance(Vector2 elementSize)
    {
        if (elementSize.X > MaxElementWidth)
        {
            MaxElementWidth = elementSize.X;
        }

        AccumulatedHeight += elementSize.Y;
        if (ElementCount > 0)
        {
            AccumulatedHeight += Gap;
        }
        float advanceY = elementSize.Y + Gap;
        CurrentPosition = new Vector2(CurrentPosition.X, CurrentPosition.Y + advanceY);
        ElementCount++;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\TextMetrics.cs">
// DirectUI/Core/TextMetrics.cs
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI.Core;

/// <summary>
/// Describes the metrics of a character position within a text layout.
/// This is a backend-agnostic struct.
/// </summary>
public readonly record struct TextHitTestMetrics(
    /// <summary>
    /// The top-left corner of the character position, relative to the layout's origin.
    /// </summary>
    Vector2 Point,

    /// <summary>
    /// The measured size of the character position.
    /// </summary>
    Vector2 Size
);

/// <summary>
/// The result of a point-based hit-test on a text layout.
/// This is a backend-agnostic struct.
/// </summary>
public readonly record struct TextHitTestResult(
    /// <summary>
    /// The character position that was hit.
    /// </summary>
    int TextPosition,

    /// <summary>
    /// A value indicating whether the hit occurred on the leading or trailing edge of the character.
    /// </summary>
    bool IsTrailingHit,

    /// <summary>
    /// A value indicating whether the hit occurred inside the text string.
    /// </summary>
    bool IsInside,

    /// <summary>
    /// The detailed metrics of the hit character position.
    /// </summary>
    TextHitTestMetrics Metrics
);
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.Button.cs">
using System.Numerics;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1; // Still used for AntialiasMode enum

namespace DirectUI;

public static partial class UI
{
    public static bool Button(
        string id,
        string text,
        Vector2 size = default,
        ButtonStylePack? theme = null,
        bool disabled = false,
        bool autoWidth = false,
        Vector2? textMargin = null,
        Button.ActionMode clickMode = DirectUI.Button.ActionMode.Release,
        Button.ClickBehavior clickBehavior = DirectUI.Button.ClickBehavior.Left,
        Alignment? textAlignment = null,
        Vector2? textOffset = null,
        Vector2? origin = null,
        object? userData = null,
        bool isActive = false)
    {
        if (!IsContextValid()) return false;

        int intId = id.GetHashCode();
        var finalTheme = theme ?? State.GetOrCreateElement<ButtonStylePack>(HashCode.Combine(intId, "theme"));
        State.SetUserData(intId, userData);

        Vector2 finalSize = size == default ? new Vector2(84, 28) : size;
        Vector2 finalOrigin = origin ?? Vector2.Zero;

        // Auto-width calculation must happen before culling.
        if (autoWidth)
        {
            var styleForMeasuring = finalTheme.Normal; // Measure against the normal style
            Vector2 measuredSize = Context.TextService.MeasureText(text, styleForMeasuring);
            Vector2 margin = textMargin ?? new Vector2(10, 5);
            finalSize.X = measuredSize.X + margin.X * 2;
        }

        Vector2 drawPos = Context.Layout.GetCurrentPosition();
        Rect widgetBounds = new Rect(drawPos.X - finalOrigin.X, drawPos.Y - finalOrigin.Y, finalSize.X, finalSize.Y);

        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(finalSize);
            return false;
        }

        bool pushedClip = false;
        if (Context.Layout.IsInLayoutContainer() && Context.Layout.PeekContainer() is GridContainerState grid)
        {
            float clipStartY = grid.CurrentDrawPosition.Y;
            float gridBottomY = grid.StartPosition.Y + grid.AvailableSize.Y;
            float clipHeight = Math.Max(0f, gridBottomY - clipStartY);
            Rect cellClipRect = new Rect(grid.CurrentDrawPosition.X, clipStartY, Math.Max(0f, grid.CellWidth), clipHeight);
            if (cellClipRect.Width > 0 && cellClipRect.Height > 0)
            {
                Context.Renderer.PushClipRect(cellClipRect, D2D.AntialiasMode.Aliased);
                pushedClip = true;
            }
        }

        bool clicked = DrawButtonPrimitive(
            intId,
            widgetBounds,
            text,
            finalTheme,
            disabled,
            textAlignment ?? new Alignment(HAlignment.Center, VAlignment.Center),
            clickMode,
            clickBehavior,
            textOffset ?? Vector2.Zero,
            isActive: isActive
        );

        if (pushedClip)
        {
            Context.Renderer.PopClipRect();
        }

        Context.Layout.AdvanceLayout(finalSize);
        return clicked;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.Checkbox.cs">
using System.Numerics;
using Vortice.Mathematics;
using Vortice.Direct2D1; // Still needed for AntialiasMode enum

namespace DirectUI;

public static partial class UI
{
    public static bool Checkbox(string id, string label, ref bool isChecked, bool disabled = false, Vector2? size = null)
    {
        if (!IsContextValid()) return false;

        int intId = id.GetHashCode();

        // --- Style and Sizing (UE5 Theme Adjustments) ---
        var boxSize = new Vector2(16, 16);
        var spacing = 5f;
        // Checkmark is now pure white.
        var checkmarkColor = Colors.White;
        // Background is a specific dark grey.
        var normalFillColor = new Color4(43 / 255f, 45 / 255f, 47 / 255f, 1.0f); // #2B2D2F
        var textColor = disabled ? DefaultTheme.DisabledText : DefaultTheme.Text;
        var textStyle = new ButtonStyle { FontColor = textColor }; // Use ButtonStyle for font properties.

        var labelSize = string.IsNullOrEmpty(label) ? Vector2.Zero : Context.TextService.MeasureText(label, textStyle);

        var contentWidth = boxSize.X + (labelSize.X > 0 ? spacing + labelSize.X : 0);
        var contentHeight = Math.Max(boxSize.Y, labelSize.Y);

        var finalWidgetHeight = size?.Y > 0 ? size.Value.Y : contentHeight;
        var finalWidgetWidth = size?.X > 0 ? size.Value.X : contentWidth;
        var totalSize = new Vector2(finalWidgetWidth, finalWidgetHeight);

        var drawPos = Context.Layout.GetCurrentPosition();

        var widgetBounds = new Rect(drawPos.X, drawPos.Y, totalSize.X, totalSize.Y);

        // --- Culling ---
        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(totalSize);
            return false;
        }

        // --- Interaction ---
        bool clicked = false;
        var input = Context.InputState;
        bool isHovering = !disabled && widgetBounds.Contains(input.MousePosition);

        if (isHovering)
        {
            State.SetPotentialInputTarget(intId);
        }

        if (!disabled && isHovering && input.WasLeftMousePressedThisFrame && State.PotentialInputTargetId == intId)
        {
            clicked = true;
            isChecked = !isChecked;
            State.SetFocus(intId);
        }

        // --- Drawing ---
        var renderer = Context.Renderer;
        // This calculation centers the box inside the widget's total height.
        // A small vertical adjustment is added to compensate for font metrics in DrawTextPrimitive,
        // ensuring the checkbox and text align perfectly.
        const float yOffsetCorrection = -1.5f;
        float boxY = drawPos.Y + (totalSize.Y - boxSize.Y) / 2 + yOffsetCorrection;
        var boxRect = new Rect(drawPos.X, boxY, boxSize.X, boxSize.Y);

        // Draw the box frame
        var boxStyle = new BoxStyle();
        if (disabled)
        {
            boxStyle.FillColor = DefaultTheme.DisabledFill;
            boxStyle.BorderColor = DefaultTheme.DisabledBorder;
        }
        else if (isHovering)
        {
            boxStyle.FillColor = DefaultTheme.HoverFill;
            boxStyle.BorderColor = DefaultTheme.HoverBorder;
        }
        else
        {
            // Use the specified dark grey for the normal background.
            boxStyle.FillColor = normalFillColor;
            boxStyle.BorderColor = DefaultTheme.NormalBorder;
        }

        if (State.FocusedElementId == intId)
        {
            boxStyle.BorderColor = DefaultTheme.FocusBorder;
        }
        boxStyle.Roundness = 0.2f;
        boxStyle.BorderLength = 1f;

        renderer.DrawBox(boxRect, boxStyle);

        // Draw the checkmark if checked
        if (isChecked)
        {
            // The checkmarkColor variable was changed above to pure white.
            // A simple checkmark drawn as two lines
            float pad = boxSize.X * 0.25f;
            var p1 = new Vector2(boxRect.Left + pad, boxRect.Top + boxSize.Y * 0.5f);
            var p2 = new Vector2(boxRect.Left + boxSize.X * 0.45f, boxRect.Bottom - pad);
            var p3 = new Vector2(boxRect.Right - pad, boxRect.Top + pad);
            renderer.DrawLine(p1, p2, checkmarkColor, 2.0f);
            renderer.DrawLine(p2, p3, checkmarkColor, 2.0f);
        }

        // Draw the label
        if (!string.IsNullOrEmpty(label))
        {
            var labelPos = new Vector2(boxRect.Right + spacing, drawPos.Y);
            var labelBounds = new Rect(labelPos.X, labelPos.Y, labelSize.X, totalSize.Y);
            DrawTextPrimitive(labelBounds, label, textStyle, new Alignment(HAlignment.Left, VAlignment.Center), Vector2.Zero);
        }

        Context.Layout.AdvanceLayout(totalSize);
        return clicked;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.ComboBox.cs">
using System.Numerics;

namespace DirectUI;

public static partial class UI
{
    public static bool Combobox(
        string id,
        ref int selectedIndex,
        string[] items,
        Vector2 size,
        Vector2 position = default,
        ButtonStylePack? theme = null,
        bool disabled = false)
    {
        if (!IsContextValid())
        {
            return false;
        }

        int intId = id.GetHashCode();
        Vector2 drawPos = Context.Layout.ApplyLayout(position);

        // Culling check
        if (!Context.Layout.IsRectVisible(new(drawPos.X, drawPos.Y, size.X, size.Y)))
        {
            Context.Layout.AdvanceLayout(size);
            return false;
        }

        var comboboxInstance = State.GetOrCreateElement<InternalComboboxLogic>(intId);
        int newIndex = comboboxInstance.UpdateAndDraw(intId, selectedIndex, items, drawPos, size, theme, disabled);

        bool valueChanged = newIndex != selectedIndex;
        if (valueChanged)
        {
            selectedIndex = newIndex;
        }

        Context.Layout.AdvanceLayout(size);
        return valueChanged;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.Containers.cs">
// Core/UI.Containers.cs
using System;
using System.Numerics;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

public static partial class UI
{
    public static void BeginHBoxContainer(string id, Vector2 position, float gap = 5.0f)
    {
        Context.Layout.BeginHBox(id.GetHashCode(), position, gap);
    }

    public static void EndHBoxContainer()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not HBoxContainerState state)
        { Console.WriteLine("Error: EndHBoxContainer called without a matching BeginHBoxContainer."); return; }
        Context.Layout.PopContainer();
        if (Context.Layout.IsInLayoutContainer())
        { Context.Layout.AdvanceContainerLayout(new Vector2(state.AccumulatedWidth, state.MaxElementHeight)); }
    }

    public static void BeginVBoxContainer(string id, Vector2 position, float gap = 5.0f)
    {
        Context.Layout.BeginVBox(id.GetHashCode(), position, gap);
    }

    public static void EndVBoxContainer()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not VBoxContainerState state)
        { Console.WriteLine("Error: EndVBoxContainer called without a matching BeginVBoxContainer."); return; }
        Context.Layout.PopContainer();
        if (Context.Layout.IsInLayoutContainer())
        { Context.Layout.AdvanceContainerLayout(new Vector2(state.MaxElementWidth, state.AccumulatedHeight)); }
    }

    public static void BeginGridContainer(string id, Vector2 position, Vector2 availableSize, int numColumns, Vector2 gap)
    {
        Context.Layout.PushContainer(new GridContainerState(id.GetHashCode(), position, availableSize, numColumns, gap));
    }

    public static void EndGridContainer()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not GridContainerState state)
        { Console.WriteLine("Error: EndGridContainer called without a matching BeginGridContainer."); return; }
        Context.Layout.PopContainer();
        if (Context.Layout.IsInLayoutContainer())
        {
            Vector2 containerSize = state.GetTotalOccupiedSize();
            Context.Layout.AdvanceContainerLayout(containerSize);
        }
    }

    public static void BeginScrollableRegion(string id, Vector2 size, out float availableInnerWidth)
    {
        if (!IsContextValid())
        {
            availableInnerWidth = size.X;
            return;
        }

        int intId = id.GetHashCode();
        Vector2 position = Context.Layout.GetCurrentPosition();
        Rect regionBounds = new Rect(position.X, position.Y, size.X, size.Y);

        var scrollState = State.GetOrCreateElement<ScrollContainerState>(intId);
        scrollState.Id = intId;
        scrollState.Position = position;
        scrollState.VisibleSize = size;
        scrollState.IsHovered = regionBounds.Contains(Context.InputState.MousePosition);

        // Predict if a scrollbar will be needed based on the previous frame's content size.
        // This is a common and effective pattern in immediate-mode UIs.
        const float scrollbarThickness = 12f; // Must match the value in EndScrollableRegion
        const float scrollbarGap = 4f; // Add a small gap between content and scrollbar
        bool scrollbarWillBeVisible = scrollState.ContentSize.Y > scrollState.VisibleSize.Y;
        // If scrollbar is visible, reduce the available width by its thickness and a small gap.
        availableInnerWidth = scrollbarWillBeVisible ? size.X - scrollbarThickness - scrollbarGap : size.X;


        // Handle scroll input
        if (scrollState.IsHovered && Context.InputState.ScrollDelta != 0)
        {
            var offset = scrollState.CurrentScrollOffset;
            offset.Y -= Context.InputState.ScrollDelta * 20; // Apply scroll wheel input
            scrollState.CurrentScrollOffset = offset;
        }

        // Clamp the offset *before* using it for layout. Use the content size from the *previous* frame for this.
        float maxScrollY = Math.Max(0, scrollState.ContentSize.Y - scrollState.VisibleSize.Y);
        var clampedOffset = scrollState.CurrentScrollOffset;
        clampedOffset.Y = Math.Clamp(clampedOffset.Y, 0, maxScrollY);
        scrollState.CurrentScrollOffset = clampedOffset;

        // Begin the inner container for content layout, offset by the now-clamped scroll position
        var contentVBoxId = HashCode.Combine(intId, "scroll_vbox");
        var contentVBox = Context.Layout.GetOrCreateVBoxState(contentVBoxId);
        contentVBox.StartPosition = position - scrollState.CurrentScrollOffset;
        contentVBox.CurrentPosition = position - scrollState.CurrentScrollOffset;
        contentVBox.Gap = 0; // The user can nest another VBox inside for gaps
        contentVBox.MaxElementWidth = 0f;
        contentVBox.AccumulatedHeight = 0f;
        contentVBox.ElementCount = 0;
        scrollState.ContentVBox = contentVBox;

        Context.Layout.PushClipRect(regionBounds);
        Context.Renderer.PushClipRect(regionBounds, D2D.AntialiasMode.Aliased);

        Context.Layout.PushContainer(scrollState);
    }

    public static void EndScrollableRegion()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not ScrollContainerState scrollState)
        { Console.WriteLine("Error: EndScrollableRegion called without a matching Begin."); return; }

        // Finalize content size based on what was rendered inside the container.
        // This new size will be used for clamping in the *next* frame.
        scrollState.ContentSize = new Vector2(scrollState.ContentVBox.MaxElementWidth, scrollState.ContentVBox.AccumulatedHeight);

        // Pop the container and clip rect so the scrollbar can be drawn outside the content's clipped area.
        Context.Layout.PopContainer();
        Context.Renderer.PopClipRect();
        Context.Layout.PopClipRect();

        // Draw scrollbar if needed. This will return a new, validated scroll offset.
        if (scrollState.ContentSize.Y > scrollState.VisibleSize.Y)
        {
            string scrollBarIdString = scrollState.Id + "_scrollbar";
            float scrollbarThickness = 12f;
            var scrollBarPos = new Vector2(scrollState.Position.X + scrollState.VisibleSize.X - scrollbarThickness, scrollState.Position.Y);

            // The VScrollBar handles all its own logic, including clamping the value against the new content size.
            float newScrollY = VScrollBar(
                id: scrollBarIdString,
                currentScrollOffset: scrollState.CurrentScrollOffset.Y,
                position: scrollBarPos,
                trackHeight: scrollState.VisibleSize.Y,
                contentHeight: scrollState.ContentSize.Y,
                visibleHeight: scrollState.VisibleSize.Y,
                thickness: scrollbarThickness);

            // Update the state with the value from the scrollbar for the next frame.
            scrollState.CurrentScrollOffset = new Vector2(scrollState.CurrentScrollOffset.X, newScrollY);
        }
        else
        {
            // If no scrollbar is needed, ensure the offset is zero.
            scrollState.CurrentScrollOffset = new Vector2(scrollState.CurrentScrollOffset.X, 0);
        }

        // After everything, advance the main layout cursor by the size of the scroll region itself.
        Context.Layout.AdvanceLayout(scrollState.VisibleSize);
    }

    public static void BeginResizableVPanel(
        string id,
        ref float currentWidth,
        HAlignment alignment = HAlignment.Left,
        float topOffset = 0f,
        float minWidth = 50f,
        float maxWidth = 500f,
        float resizeHandleWidth = 5f,
        BoxStyle? panelStyle = null,
        Vector2 padding = default,
        float gap = 5f,
        bool disabled = false)
    {
        if (!IsContextValid()) return;
        var intId = id.GetHashCode();

        Vector2 finalPadding = (padding == default) ? new Vector2(5, 5) : padding;

        var input = Context.InputState;
        var renderer = Context.Renderer;
        var windowWidth = renderer.RenderTargetSize.X;
        var windowHeight = renderer.RenderTargetSize.Y;
        var availableHeight = windowHeight - topOffset;

        if (!disabled)
        {
            float handleWidth = Math.Min(resizeHandleWidth, currentWidth);
            float panelX = (alignment == HAlignment.Right) ? windowWidth - currentWidth : 0;
            float handleX = (alignment == HAlignment.Right) ? panelX : panelX + currentWidth - handleWidth;
            Rect handleRect = new Rect(handleX, topOffset, handleWidth, availableHeight);

            bool isHoveringHandle = handleRect.Contains(input.MousePosition.X, input.MousePosition.Y);
            if (isHoveringHandle) State.SetPotentialInputTarget(intId);
            if (input.WasLeftMousePressedThisFrame && isHoveringHandle && State.PotentialInputTargetId == intId && !State.DragInProgressFromPreviousFrame) State.SetPotentialCaptorForFrame(intId);
            if (State.ActivelyPressedElementId == intId && !input.IsLeftMouseDown) State.ClearActivePress(intId);
            if (State.ActivelyPressedElementId == intId && input.IsLeftMouseDown)
            {
                if (alignment == HAlignment.Left) currentWidth = Math.Clamp(input.MousePosition.X, minWidth, maxWidth);
                else currentWidth = Math.Clamp(windowWidth - input.MousePosition.X, minWidth, maxWidth);
            }
        }

        var finalPanelStyle = panelStyle ?? new BoxStyle { FillColor = new(0.15f, 0.15f, 0.2f, 1.0f), BorderColor = DefaultTheme.NormalBorder, BorderLength = 1 };
        currentWidth = Math.Max(0, currentWidth);
        float finalPanelX = (alignment == HAlignment.Right) ? windowWidth - currentWidth : 0;
        Rect panelRect = new Rect(finalPanelX, topOffset, currentWidth, availableHeight);
        if (panelRect.Width > 0 && panelRect.Height > 0)
        {
            renderer.DrawBox(new Rect(panelRect.X, panelRect.Y, panelRect.Width, panelRect.Height), finalPanelStyle);
        }

        Vector2 contentStartPosition = new Vector2(finalPanelX + finalPadding.X, topOffset + finalPadding.Y);
        Rect contentClipRect = new Rect(contentStartPosition.X, contentStartPosition.Y, Math.Max(0, currentWidth - (finalPadding.X * 2)), Math.Max(0, availableHeight - (finalPadding.Y * 2)));
        bool clipPushed = false;
        if (contentClipRect.Width > 0 && contentClipRect.Height > 0)
        {
            renderer.PushClipRect(contentClipRect, D2D.AntialiasMode.Aliased);
            Context.Layout.PushClipRect(contentClipRect); // For culling
            clipPushed = true;
        }

        var vboxId = HashCode.Combine(intId, "_vbox");
        var vboxState = Context.Layout.GetOrCreateVBoxState(vboxId);
        vboxState.StartPosition = contentStartPosition;
        vboxState.CurrentPosition = contentStartPosition;
        vboxState.Gap = gap;
        vboxState.MaxElementWidth = 0f;
        vboxState.AccumulatedHeight = 0f;
        vboxState.ElementCount = 0;

        var panelState = new ResizablePanelState(intId, vboxState, clipPushed);
        Context.Layout.PushContainer(panelState);
    }

    public static void EndResizableVPanel()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not ResizablePanelState state)
        { Console.WriteLine("Error: EndResizableVPanel called without a matching BeginResizableVPanel."); return; }
        if (state.ClipRectWasPushed)
        {
            Context.Layout.PopClipRect(); // For culling
            Context.Renderer.PopClipRect();
        }
        Context.Layout.PopContainer();
    }

    public static void BeginResizableHPanel(
        string id,
        ref float currentHeight,
        float reservedLeftSpace,
        float reservedRightSpace,
        float topOffset = 0f,
        float minHeight = 50f,
        float maxHeight = 300f,
        float resizeHandleHeight = 5f,
        BoxStyle? panelStyle = null,
        Vector2 padding = default,
        float gap = 5f,
        bool disabled = false)
    {
        if (!IsContextValid()) return;
        var intId = id.GetHashCode();

        Vector2 finalPadding = (padding == default) ? new Vector2(5, 5) : padding;

        var input = Context.InputState;
        var renderer = Context.Renderer;
        var windowWidth = renderer.RenderTargetSize.X;
        var windowHeight = renderer.RenderTargetSize.Y;
        var availableWidth = Math.Max(0, windowWidth - reservedLeftSpace - reservedRightSpace);
        var maxAllowedHeight = windowHeight - topOffset;
        var effectiveMaxHeight = Math.Min(maxHeight, maxAllowedHeight);
        float clampMax = Math.Max(minHeight, effectiveMaxHeight);

        if (!disabled)
        {
            currentHeight = Math.Clamp(currentHeight, minHeight, clampMax);
            float panelY = windowHeight - currentHeight;
            float handleHeight = Math.Min(resizeHandleHeight, currentHeight);
            Rect handleRect = new Rect(reservedLeftSpace, panelY, availableWidth, handleHeight);

            bool isHoveringHandle = handleRect.Contains(input.MousePosition.X, input.MousePosition.Y);
            if (isHoveringHandle) State.SetPotentialInputTarget(intId);
            if (input.WasLeftMousePressedThisFrame && isHoveringHandle && State.PotentialInputTargetId == intId && !State.DragInProgressFromPreviousFrame) State.SetPotentialCaptorForFrame(intId);
            if (State.ActivelyPressedElementId == intId && !input.IsLeftMouseDown) State.ClearActivePress(intId);
            if (State.ActivelyPressedElementId == intId && input.IsLeftMouseDown)
            {
                float clampedMouseY = Math.Max(input.MousePosition.Y, topOffset);
                currentHeight = Math.Clamp(windowHeight - clampedMouseY, minHeight, clampMax);
            }
        }

        var finalPanelStyle = panelStyle ?? new BoxStyle { FillColor = new(0.15f, 0.15f, 0.2f, 1.0f), BorderColor = DefaultTheme.NormalBorder, BorderLength = 1 };
        currentHeight = Math.Clamp(currentHeight, minHeight, clampMax);
        float finalPanelY = windowHeight - currentHeight;
        Rect panelRect = new Rect(reservedLeftSpace, finalPanelY, availableWidth, currentHeight);
        if (panelRect.Width > 0 && panelRect.Height > 0)
        {
            renderer.DrawBox(new Rect(panelRect.X, panelRect.Y, panelRect.Width, panelRect.Height), finalPanelStyle);
        }

        Vector2 contentStartPosition = new Vector2(reservedLeftSpace + finalPadding.X, finalPanelY + finalPadding.Y);
        Rect contentClipRect = new Rect(contentStartPosition.X, contentStartPosition.Y, Math.Max(0, availableWidth - (finalPadding.X * 2)), Math.Max(0, currentHeight - (finalPadding.Y * 2)));
        bool clipPushed = false;
        if (contentClipRect.Width > 0 && contentClipRect.Height > 0)
        {
            renderer.PushClipRect(contentClipRect, D2D.AntialiasMode.Aliased);
            Context.Layout.PushClipRect(contentClipRect); // For culling
            clipPushed = true;
        }

        var hboxId = HashCode.Combine(intId, "_hbox");
        var hboxState = Context.Layout.GetOrCreateHBoxState(hboxId);
        hboxState.StartPosition = contentStartPosition;
        hboxState.CurrentPosition = contentStartPosition;
        hboxState.Gap = gap;
        hboxState.MaxElementHeight = 0f;
        hboxState.AccumulatedWidth = 0f;
        hboxState.ElementCount = 0;

        var panelState = new ResizableHPanelState(intId, hboxState, clipPushed);
        Context.Layout.PushContainer(panelState);
    }

    public static void EndResizableHPanel()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not ResizableHPanelState state)
        { Console.WriteLine("Error: EndResizableHPanel called without a matching BeginResizableHPanel."); return; }
        if (state.ClipRectWasPushed)
        {
            Context.Layout.PopClipRect(); // For culling
            Context.Renderer.PopClipRect();
        }
        Context.Layout.PopContainer();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.cs">
using System;
using System.Numerics;

namespace DirectUI;

public static partial class UI
{
    // --- Core Components ---
    public static UIContext Context { get; private set; } = null!;
    public static UIPersistentState State { get; private set; } = null!;
    public static bool IsRendering
    {
        get; private set;
    } = false;

    // --- Frame Management ---
    public static void BeginFrame(UIContext context)
    {
        IsRendering = true;

        UI.Context = context;
        UI.State ??= new UIPersistentState();

        UI.State.ResetFrameState(context.InputState);

        UI.Context.Layout.ClearStack();
        UI.Context.treeStateStack.Clear();
    }

    public static void EndFrame()
    {
        // If a click happened this frame but no UI element captured it, and no popup was open, clear focus.
        if (UI.Context.InputState.WasLeftMousePressedThisFrame && UI.State.InputCaptorId == 0 && !UI.State.IsPopupOpen)
        {
            UI.State.SetFocus(0);
        }

        HandlePopupLogic();

        if (UI.Context.Layout.ContainerStackCount > 0)
        {
            Console.WriteLine($"Warning: Mismatch in Begin/End container calls. {UI.Context.Layout.ContainerStackCount} containers left open at EndFrame.");
            UI.Context.Layout.ClearStack();
        }
        if (UI.Context.treeStateStack.Count > 0)
        {
            Console.WriteLine($"Warning: Mismatch in Begin/End Tree calls. {UI.Context.treeStateStack.Count} trees left open at EndFrame.");
            UI.Context.treeStateStack.Clear();
        }

        // It's important that IsRendering is set to false AFTER the context is cleared.
        UI.Context = null!;
        IsRendering = false;
    }

    /// <summary>
    /// Handles popup logic at the end of a frame, ensuring they are drawn last and closed correctly.
    /// </summary>
    private static void HandlePopupLogic()
    {
        if (!UI.State.IsPopupOpen) return;

        // If a mouse press occurred outside the popup's bounds, close the popup.
        if (UI.Context.InputState.WasLeftMousePressedThisFrame || UI.Context.InputState.WasRightMousePressedThisFrame)
        {
            if (!UI.State.PopupBounds.Contains(UI.Context.InputState.MousePosition))
            {
                UI.State.ClearActivePopup();
                return; // Don't draw the popup since we just closed it.
            }
        }

        // Execute the callback to draw the popup content.
        UI.State.PopupDrawCallback?.Invoke(UI.Context);
    }

    /// <summary>
    /// Checks if a context menu should be opened for a given widget ID.
    /// A context menu is typically triggered by a right-click.
    /// </summary>
    /// <param name="widgetId">The unique ID of the widget that can open the context menu.</param>
    /// <returns>True if the context menu should be opened this frame, false otherwise.</returns>
    public static bool BeginContextMenu(string widgetId)
    {
        if (!IsContextValid()) return false;

        int intId = widgetId.GetHashCode();
        var state = UI.State;
        var input = UI.Context.InputState;

        // A context menu is opened if the right mouse button was pressed this frame,
        // and the potential input target is the widget we're checking.
        if (input.WasRightMousePressedThisFrame && state.PotentialInputTargetId == intId)
        {
            state.ClearActivePopup(); // Close any other popups first.
            return true;
        }

        return false;
    }

    /// <summary>
    /// Draws a context menu popup at the current mouse position. This should be called after BeginContextMenu returns true.
    /// </summary>
    /// <param name="popupId">A unique ID for this specific context menu instance.</param>
    /// <param name="items">An array of strings representing the menu items.</param>
    /// <returns>The index of the clicked item, or -1 if no item was clicked.</returns>
    public static int ContextMenu(string popupId, string[] items)
    {
        if (!IsContextValid() || items is null || items.Length == 0) return -1;

        var context = UI.Context;
        var state = UI.State;
        int intId = popupId.GetHashCode();

        // If a result for this menu is already available from the previous frame, consume and return it.
        if (state.PopupResultAvailable && state.PopupResultOwnerId == intId)
        {
            return state.PopupResult;
        }

        // Only set up the popup on the first frame it's requested.
        // After that, the EndFrame logic will handle drawing it using the stored state.
        if (!state.IsPopupOpen || state.ActivePopupId != intId)
        {
            // Calculate popup properties ONCE
            float itemHeight = 25;
            float itemWidth = 150;
            float popupHeight = items.Length * itemHeight;
            var popupPosition = context.InputState.MousePosition;
            var popupBounds = new Vortice.Mathematics.Rect(popupPosition.X, popupPosition.Y, itemWidth, popupHeight);

            // Define the draw callback for the popup, which runs at EndFrame
            Action<UIContext> drawCallback = (ctx) =>
            {
                var popupStyle = new BoxStyle { FillColor = DefaultTheme.NormalFill, BorderColor = DefaultTheme.FocusBorder, BorderLength = 1f, Roundness = 0.1f };
                ctx.Renderer.DrawBox(popupBounds, popupStyle);

                for (int i = 0; i < items.Length; i++)
                {
                    var itemBounds = new Vortice.Mathematics.Rect(popupBounds.X, popupBounds.Y + i * itemHeight, popupBounds.Width, itemHeight);
                    var itemTheme = new ButtonStylePack { Roundness = 0f, BorderLength = 0f };
                    itemTheme.Normal.FillColor = DefaultTheme.Transparent;
                    itemTheme.Hover.FillColor = DefaultTheme.HoverFill;
                    itemTheme.Pressed.FillColor = DefaultTheme.Accent;

                    int itemId = HashCode.Combine(intId, "item", i);

                    if (DrawButtonPrimitive(itemId, itemBounds, items[i], itemTheme, false, new Alignment(HAlignment.Left, VAlignment.Center), DirectUI.Button.ActionMode.Release, DirectUI.Button.ClickBehavior.Left, new Vector2(5, 0)))
                    {
                        state.SetPopupResult(intId, i);
                        state.ClearActivePopup();
                    }
                }
            };

            state.SetActivePopup(intId, drawCallback, popupBounds);
        }

        return -1; // No item was clicked on *this* frame
    }


    // --- Helper Methods ---
    private static bool IsContextValid()
    {
        if (UI.Context?.Renderer is null || UI.Context?.TextService is null)
        {
            Console.WriteLine($"Error: UI method called outside BeginFrame/EndFrame or context is invalid.");
            return false;
        }
        return true;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.DataGrid.cs">
// DirectUI/Source/Core/UI.DataGrid.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Reflection;
using DirectUI.Drawing;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    private static readonly Dictionary<Type, Dictionary<string, PropertyInfo?>> _propertyInfoCache = new();

    /// <summary>
    /// Renders a grid to display tabular data.
    /// </summary>
    /// <typeparam name="T">The type of data items in the collection.</typeparam>
    /// <param name="id">A unique identifier for the data grid.</param>
    /// <param name="items">The collection of data items to display.</param>
    /// <param name="columns">The column definitions for the grid.</param>
    /// <param name="selectedIndex">A reference to the index of the currently selected item.</param>
    /// <param name="size">The total size of the data grid control.</param>
    /// <param name="position">An optional absolute position for the grid. If not provided, it uses the current layout position.</param>
    /// <param name="autoSizeColumns">If true, columns are proportionally resized to fit the available width, disabling horizontal scrolling and user resizing.</param>
    /// <param name="trimCellText">If true, text that overflows a cell's width will be truncated and appended with an ellipsis (...).</param>
    public static void DataGrid<T>(
        string id,
        IReadOnlyList<T> items,
        IReadOnlyList<DataGridColumn> columns,
        ref int selectedIndex,
        Vector2 size,
        Vector2 position = default,
        bool autoSizeColumns = false,
        bool trimCellText = false)
    {
        if (!IsContextValid()) return;

        int intId = id.GetHashCode();
        var state = State.GetOrCreateElement<DataGridState>(intId);
        Vector2 drawPos = Context.Layout.ApplyLayout(position);

        // Culling
        var gridBounds = new Rect(drawPos.X, drawPos.Y, size.X, size.Y);
        if (!Context.Layout.IsRectVisible(gridBounds))
        {
            Context.Layout.AdvanceLayout(size);
            return;
        }

        InitializeDataGridState(state, intId, columns);

        // --- Style Definitions ---
        float headerHeight = 28f;
        float rowHeight = 24f;
        const float scrollbarThickness = 12f;

        var gridStyle = new BoxStyle { FillColor = new(0.1f, 0.1f, 0.1f, 1.0f), BorderLength = 0f, Roundness = 0f };
        var headerStyle = new ButtonStyle { FillColor = new(0.2f, 0.2f, 0.2f, 1.0f), Roundness = 0, BorderLength = 0, BorderColor = Colors.Transparent, FontColor = DefaultTheme.Text };
        var rowStyle = new ButtonStylePack { Roundness = 0f, BorderLength = 0f };
        rowStyle.Normal.FillColor = DefaultTheme.Transparent;
        rowStyle.Hover.FillColor = new Color4(0.25f, 0.25f, 0.25f, 1.0f);
        rowStyle.Active.FillColor = DefaultTheme.Accent;
        rowStyle.ActiveHover.FillColor = DefaultTheme.Accent;

        // --- Layout Calculation ---
        var headerBounds = new Rect(drawPos.X, drawPos.Y, size.X, headerHeight);
        var contentBounds = new Rect(drawPos.X, drawPos.Y + headerHeight, size.X, size.Y - headerHeight);
        float totalContentHeight = items.Count * rowHeight;

        // Determine scrollbar visibility and available content view size
        bool vScrollVisible = totalContentHeight > contentBounds.Height;
        float viewWidth = contentBounds.Width - (vScrollVisible ? scrollbarThickness : 0);

        // Auto-size columns if requested
        if (autoSizeColumns)
        {
            float totalInitialWidth = columns.Sum(c => c.InitialWidth);
            if (totalInitialWidth > 0 && viewWidth > 0)
            {
                float scaleFactor = viewWidth / totalInitialWidth;
                state.ColumnWidths.Clear();
                float accumulatedWidth = 0;
                for (int i = 0; i < columns.Count; i++)
                {
                    // For all but the last column, calculate and round.
                    if (i < columns.Count - 1)
                    {
                        float newWidth = (float)Math.Round(columns[i].InitialWidth * scaleFactor);
                        state.ColumnWidths.Add(newWidth);
                        accumulatedWidth += newWidth;
                    }
                    else // For the last column, use the remaining space to avoid rounding errors.
                    {
                        state.ColumnWidths.Add(Math.Max(20, viewWidth - accumulatedWidth)); // Ensure a minimum width
                    }
                }
            }
        }

        float totalContentWidth = state.ColumnWidths.Sum();
        bool hScrollVisible = !autoSizeColumns && totalContentWidth > contentBounds.Width;
        float viewHeight = contentBounds.Height - (hScrollVisible ? scrollbarThickness : 0);


        // --- Draw Main Background ---
        Context.Renderer.DrawBox(gridBounds, gridStyle);

        // --- Draw Header ---
        DrawDataGridHeader(intId, state, columns, headerBounds, headerStyle, !autoSizeColumns);

        // --- Handle Scrolling and Draw Rows ---
        var scrollOffset = state.ScrollOffset;

        // Handle Mouse Wheel Scrolling
        bool isHoveringContent = contentBounds.Contains(Context.InputState.MousePosition);
        if (isHoveringContent && Context.InputState.ScrollDelta != 0)
        {
            // Scroll delta is inverted: up is positive, but content moves down (offset increases)
            // A standard mouse wheel tick is 120, and the delta is usually +/- 1.0f in the input system.
            // Scrolling by 3 rows feels natural.
            scrollOffset.Y -= Context.InputState.ScrollDelta * rowHeight * 3;
        }

        // Clamp scroll offsets
        scrollOffset.X = Math.Clamp(scrollOffset.X, 0, Math.Max(0, totalContentWidth - viewWidth));
        scrollOffset.Y = Math.Clamp(scrollOffset.Y, 0, Math.Max(0, totalContentHeight - viewHeight));
        state.ScrollOffset = scrollOffset; // Assign back before drawing rows

        DrawDataGridRows(intId, items, columns, state, contentBounds, new Vector2(viewWidth, viewHeight), rowHeight, ref selectedIndex, rowStyle, trimCellText);

        // --- Draw Scrollbars ---
        // Re-read from state in case it was modified, then modify and write back.
        scrollOffset = state.ScrollOffset;
        if (vScrollVisible)
        {
            scrollOffset.Y = VScrollBar(
                id + "_vscroll",
                scrollOffset.Y,
                new Vector2(contentBounds.Right - scrollbarThickness, contentBounds.Y),
                contentBounds.Height - (hScrollVisible ? scrollbarThickness : 0), // Adjust track height if HScroll is visible
                totalContentHeight,
                viewHeight,
                scrollbarThickness
            );
        }
        if (hScrollVisible)
        {
            scrollOffset.X = HScrollBar(
                id + "_hscroll",
                scrollOffset.X,
                new Vector2(contentBounds.X, contentBounds.Bottom - scrollbarThickness),
                contentBounds.Width - (vScrollVisible ? scrollbarThickness : 0),
                totalContentWidth,
                viewWidth,
                scrollbarThickness
            );
        }
        state.ScrollOffset = scrollOffset; // Assign the final value back

        Context.Layout.AdvanceLayout(size);
    }

    private static void InitializeDataGridState(DataGridState state, int id, IReadOnlyList<DataGridColumn> columns)
    {
        if (state.Id == id && state.ColumnWidths.Count == columns.Count) return;
        state.Id = id;
        state.ColumnWidths.Clear();
        state.ColumnWidths.AddRange(columns.Select(c => c.InitialWidth));
    }

    private static void DrawDataGridHeader(int id, DataGridState state, IReadOnlyList<DataGridColumn> columns, Rect headerBounds, ButtonStyle style, bool allowColumnResize)
    {
        var input = Context.InputState;
        float currentX = headerBounds.X - state.ScrollOffset.X;

        Context.Renderer.PushClipRect(headerBounds);

        for (int i = 0; i < columns.Count; i++)
        {
            float colWidth = state.ColumnWidths[i];
            var colHeaderBounds = new Rect(currentX, headerBounds.Y, colWidth, headerBounds.Height);
            Context.Renderer.DrawBox(colHeaderBounds, style);
            DrawTextPrimitive(colHeaderBounds, columns[i].HeaderText, style, new Alignment(HAlignment.Left, VAlignment.Center), new Vector2(5, 0));

            if (allowColumnResize)
            {
                // Column Resizer Handle
                var handleId = HashCode.Combine(id, "resize", i);
                var handleBounds = new Rect(currentX + colWidth - 2, headerBounds.Y, 4, headerBounds.Height);

                bool isHoveringHandle = handleBounds.Contains(input.MousePosition);
                if (isHoveringHandle) State.SetPotentialInputTarget(handleId);

                if (State.ActivelyPressedElementId == handleId && input.IsLeftMouseDown)
                {
                    float deltaX = input.MousePosition.X - state.DragStartMouseX;
                    state.ColumnWidths[i] = Math.Max(20, state.ColumnResizeStartWidth + deltaX);
                }
                else if (State.ActivelyPressedElementId == handleId && !input.IsLeftMouseDown)
                {
                    State.ClearActivePress(handleId);
                }

                if (isHoveringHandle && input.WasLeftMousePressedThisFrame && State.PotentialInputTargetId == handleId)
                {
                    State.SetPotentialCaptorForFrame(handleId);
                    state.ResizingColumnIndex = i;
                    state.DragStartMouseX = input.MousePosition.X;
                    state.ColumnResizeStartWidth = state.ColumnWidths[i];
                }
            }
            currentX += colWidth;
        }

        Context.Renderer.PopClipRect();
    }

    private static string TrimTextWithEllipsis(string text, float maxWidth, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(text) || maxWidth <= 0) return string.Empty;

        var textService = UI.Context.TextService;
        const string ellipsis = "...";

        var fullSize = textService.MeasureText(text, style);
        if (fullSize.X <= maxWidth) return text;

        var ellipsisSize = textService.MeasureText(ellipsis, style);
        if (ellipsisSize.X > maxWidth) return string.Empty; // Not even ellipsis fits

        // Use a copy of the string to trim
        string trimmed = text;
        while (trimmed.Length > 0)
        {
            var tempText = trimmed + ellipsis;
            if (textService.MeasureText(tempText, style).X <= maxWidth)
            {
                return tempText;
            }
            trimmed = trimmed.Substring(0, trimmed.Length - 1);
        }

        return ellipsis; // If nothing else fits
    }

    private static void DrawDataGridRows<T>(int id, IReadOnlyList<T> items, IReadOnlyList<DataGridColumn> columns, DataGridState state, Rect contentBounds, Vector2 viewSize, float rowHeight, ref int selectedIndex, ButtonStylePack rowStyle, bool trimCellText)
    {
        var input = Context.InputState;

        Context.Renderer.PushClipRect(new Rect(contentBounds.X, contentBounds.Y, viewSize.X, viewSize.Y));

        int firstVisibleRow = (int)Math.Floor(state.ScrollOffset.Y / rowHeight);
        int visibleRowCount = (int)Math.Ceiling(viewSize.Y / rowHeight) + 1;
        int lastVisibleRow = Math.Min(items.Count - 1, firstVisibleRow + visibleRowCount);

        for (int i = firstVisibleRow; i <= lastVisibleRow; i++)
        {
            var item = items[i];
            float rowY = contentBounds.Y + (i * rowHeight) - state.ScrollOffset.Y;
            var rowBounds = new Rect(contentBounds.X, rowY, contentBounds.Width, rowHeight); // Use full width for selection
            bool isSelected = i == selectedIndex;

            int rowId = HashCode.Combine(id, "row", i);
            if (DrawButtonPrimitive(rowId, rowBounds, "", rowStyle, false, default, DirectUI.Button.ActionMode.Press, DirectUI.Button.ClickBehavior.Left, Vector2.Zero, isSelected))
            {
                selectedIndex = i;
            }

            float currentX = contentBounds.X - state.ScrollOffset.X;
            for (int j = 0; j < columns.Count; j++)
            {
                var column = columns[j];
                float colWidth = state.ColumnWidths[j];
                var cellBounds = new Rect(currentX, rowY, colWidth, rowHeight);

                var value = GetPropertyValue(item, column.DataPropertyName);
                string cellText = value?.ToString() ?? string.Empty;

                if (value is TimeSpan ts)
                {
                    cellText = $"{(int)ts.TotalMinutes:00}:{ts.Seconds:00}";
                }

                string textToDraw = cellText;
                var textMargin = new Vector2(5, 0);

                if (trimCellText)
                {
                    float availableWidth = cellBounds.Width - (textMargin.X * 2);
                    if (availableWidth > 0)
                    {
                        var measuredSize = Context.TextService.MeasureText(cellText, rowStyle.Current);
                        if (measuredSize.X > availableWidth)
                        {
                            textToDraw = TrimTextWithEllipsis(cellText, availableWidth, rowStyle.Current);
                        }
                    }
                }

                Context.Renderer.PushClipRect(cellBounds); // Clip text to cell
                DrawTextPrimitive(cellBounds, textToDraw, rowStyle.Current, new Alignment(HAlignment.Left, VAlignment.Center), textMargin);
                Context.Renderer.PopClipRect();

                currentX += colWidth;
            }
        }

        Context.Renderer.PopClipRect();
    }

    private static object? GetPropertyValue<T>(T item, string propertyName)
    {
        if (item == null || string.IsNullOrEmpty(propertyName)) return null;
        var type = typeof(T);

        if (!_propertyInfoCache.TryGetValue(type, out var propertyMap))
        {
            propertyMap = new Dictionary<string, PropertyInfo?>();
            _propertyInfoCache[type] = propertyMap;
        }

        if (!propertyMap.TryGetValue(propertyName, out var propInfo))
        {
            propInfo = type.GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance);
            propertyMap[propertyName] = propInfo;
        }

        return propInfo?.GetValue(item);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.InputText.cs">
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static bool InputText(
        string id,
        ref string text,
        Vector2 size,
        Vector2 position = default,
        ButtonStylePack? theme = null,
        string placeholderText = "",
        bool isPassword = false,
        char passwordChar = '*',
        int maxLength = 1024,
        bool disabled = false,
        Vector2? textMargin = null)
    {
        if (!IsContextValid())
        {
            return false;
        }

        int intId = id.GetHashCode();
        Vector2 finalPosition = Context.Layout.ApplyLayout(position);
        Vector2 finalMargin = textMargin ?? new(4, 2);
        Rect widgetBounds = new(finalPosition.X, finalPosition.Y, size.X, size.Y);

        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(size);
            return false;
        }

        InputText lineEditInstance = State.GetOrCreateElement<InputText>(intId);
        var lineEditState = State.GetOrCreateElement<InputTextState>(HashCode.Combine(intId, "state"));

        bool textChanged = lineEditInstance.UpdateAndDraw(
            intId,
            ref text,
            lineEditState,
            finalPosition,
            size,
            theme,
            placeholderText,
            isPassword,
            passwordChar,
            maxLength,
            disabled,
            finalMargin);

        Context.Layout.AdvanceLayout(size);
        return textChanged;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.Knob.cs">
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    /// <summary>
    /// Draws a circular knob control. Value is changed by clicking and dragging vertically.
    /// </summary>
    /// <param name="id">A unique identifier for the knob.</param>
    /// <param name="currentValue">The current value, passed by ref to be modified.</param>
    /// <param name="minValue">The minimum value of the knob.</param>
    /// <param name="maxValue">The maximum value of the knob.</param>
    /// <param name="radius">The radius of the knob.</param>
    /// <param name="theme">The style of the knob.</param>
    /// <param name="disabled">Whether the knob is disabled.</param>
    /// <param name="sensitivity">Controls how much the value changes per pixel of vertical mouse movement.</param>
    /// <returns>True if the value was changed this frame, otherwise false.</returns>
    public static bool Knob(
        string id,
        ref float currentValue,
        float minValue,
        float maxValue,
        float radius = 24f,
        KnobStyle? theme = null,
        bool disabled = false,
        float sensitivity = 0.005f)
    {
        if (!IsContextValid()) return false;

        int intId = id.GetHashCode();
        var knobInstance = State.GetOrCreateElement<InternalKnobLogic>(intId);
        
        Vector2 size = new(radius * 2, radius * 2);
        Vector2 drawPos = Context.Layout.GetCurrentPosition();
        Rect widgetBounds = new(drawPos.X, drawPos.Y, size.X, size.Y);

        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(size);
            return false;
        }

        bool valueChanged = knobInstance.UpdateAndDraw(
            intId,
            ref currentValue,
            minValue,
            maxValue,
            radius,
            drawPos,
            theme,
            disabled,
            sensitivity);

        Context.Layout.AdvanceLayout(size);
        return valueChanged;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.Label.cs">
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static void Text(string id, string text, Vector2? size = null, ButtonStyle? style = null, Alignment? textAlignment = null)
    {
        if (!IsContextValid() || string.IsNullOrEmpty(text))
        {
            return;
        }

        ButtonStyle finalStyle = style ?? new();
        finalStyle.FontColor = GetStyleColor(StyleColor.Text, finalStyle.FontColor);

        Alignment finalAlignment = textAlignment
            ?? new(HAlignment.Left, VAlignment.Center);

        Vector2 measuredSize = Context.TextService.MeasureText(text, finalStyle);

        Vector2 finalSize;
        if (size.HasValue)
        {
            finalSize = new Vector2(
                size.Value.X > 0 ? size.Value.X : measuredSize.X,
                size.Value.Y > 0 ? size.Value.Y : measuredSize.Y
            );
        }
        else
        {
            finalSize = measuredSize;
        }

        Vector2 drawPos = Context.Layout.GetCurrentPosition();
        Rect widgetBounds = new(drawPos.X, drawPos.Y, finalSize.X, finalSize.Y);

        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(finalSize);
            return;
        }

        DrawTextPrimitive(
            widgetBounds,
            text,
            finalStyle,
            finalAlignment,
            Vector2.Zero);

        Context.Layout.AdvanceLayout(finalSize);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.ScrollBar.cs">
// Core/UI.ScrollBar.cs
using System;
using System.Numerics;

namespace DirectUI;

public static partial class UI
{
    /// <summary>
    /// Draws a vertical scrollbar and handles its interaction.
    /// </summary>
    /// <param name="id">A unique identifier for the scrollbar.</param>
    /// <param name="currentScrollOffset">The current vertical scroll offset, which this control will modify.</param>
    /// <param name="position">The top-left position where the scrollbar will be drawn.</param>
    /// <param name="trackHeight">The total height of the scrollbar track.</param>
    /// <param name="contentHeight">The total height of the content being scrolled.</param>
    /// <param name="visibleHeight">The height of the visible portion of the content.</param>
    /// <param name="thickness">The width of the scrollbar.</param>
    /// <param name="theme">The style for the scrollbar's track.</param>
    /// <param name="thumbTheme">The style for the scrollbar's draggable thumb.</param>
    /// <returns>The new vertical scroll offset after user interaction.</returns>
    public static float VScrollBar(
        string id,
        float currentScrollOffset,
        Vector2 position,
        float trackHeight,
        float contentHeight,
        float visibleHeight,
        float thickness = 12f,
        SliderStyle? theme = null,
        ButtonStylePack? thumbTheme = null)
    {
        if (!IsContextValid()) return currentScrollOffset;

        int intId = id.GetHashCode();
        InternalScrollBarLogic scrollBarInstance = State.GetOrCreateElement<InternalScrollBarLogic>(intId);

        // Configure instance
        scrollBarInstance.Position = position;
        scrollBarInstance.TrackLength = trackHeight;
        scrollBarInstance.TrackThickness = thickness;
        scrollBarInstance.IsVertical = true;
        scrollBarInstance.ContentSize = contentHeight;
        scrollBarInstance.VisibleSize = visibleHeight;
        scrollBarInstance.Theme = theme ?? scrollBarInstance.Theme ?? new SliderStyle();
        scrollBarInstance.ThumbTheme = thumbTheme ?? scrollBarInstance.ThumbTheme ?? new ButtonStylePack();

        float newScrollOffset = scrollBarInstance.UpdateAndDraw(intId, currentScrollOffset);

        // A scrollbar, being an overlay, does not advance the main layout cursor.

        return newScrollOffset;
    }

    /// <summary>
    /// Draws a horizontal scrollbar and handles its interaction.
    /// </summary>
    /// <param name="id">A unique identifier for the scrollbar.</param>
    /// <param name="currentScrollOffset">The current horizontal scroll offset, which this control will modify.</param>
    /// <param name="position">The top-left position where the scrollbar will be drawn.</param>
    /// <param name="trackWidth">The total width of the scrollbar track.</param>
    /// <param name="contentWidth">The total width of the content being scrolled.</param>
    /// <param name="visibleWidth">The width of the visible portion of the content.</param>
    /// <param name="thickness">The height of the scrollbar.</param>
    /// <param name="theme">The style for the scrollbar's track.</param>
    /// <param name="thumbTheme">The style for the scrollbar's draggable thumb.</param>
    /// <returns>The new horizontal scroll offset after user interaction.</returns>
    public static float HScrollBar(
        string id,
        float currentScrollOffset,
        Vector2 position,
        float trackWidth,
        float contentWidth,
        float visibleWidth,
        float thickness = 12f,
        SliderStyle? theme = null,
        ButtonStylePack? thumbTheme = null)
    {
        if (!IsContextValid()) return currentScrollOffset;

        int intId = id.GetHashCode();
        InternalScrollBarLogic scrollBarInstance = State.GetOrCreateElement<InternalScrollBarLogic>(intId);

        // Configure instance
        scrollBarInstance.Position = position;
        scrollBarInstance.TrackLength = trackWidth;
        scrollBarInstance.TrackThickness = thickness;
        scrollBarInstance.IsVertical = false;
        scrollBarInstance.ContentSize = contentWidth;
        scrollBarInstance.VisibleSize = visibleWidth;
        scrollBarInstance.Theme = theme ?? scrollBarInstance.Theme ?? new SliderStyle();
        scrollBarInstance.ThumbTheme = thumbTheme ?? scrollBarInstance.ThumbTheme ?? new ButtonStylePack();

        float newScrollOffset = scrollBarInstance.UpdateAndDraw(intId, currentScrollOffset);

        return newScrollOffset;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.Separator.cs">
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static void Separator(float width, float thickness = 1f, float verticalPadding = 4f, Color4? color = null)
    {
        if (!IsContextValid())
        {
            return;
        }

        Color4 finalColor = color ?? DefaultTheme.NormalBorder;
        float totalHeight = thickness + (verticalPadding * 2);
        Vector2 size = new(width, totalHeight);

        Vector2 drawPos = Context.Layout.GetCurrentPosition();
        Rect widgetBounds = new(drawPos.X, drawPos.Y, size.X, size.Y);

        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(size);
            return;
        }

        float lineY = drawPos.Y + verticalPadding + (thickness * 0.5f);
        Vector2 lineStart = new(drawPos.X, lineY);
        Vector2 lineEnd = new(drawPos.X + width, lineY);

        // Use the renderer to draw the line
        Context.Renderer.DrawLine(lineStart, lineEnd, finalColor, thickness);

        Context.Layout.AdvanceLayout(size);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.Slider.cs">
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static float HSlider(
        string id,
        float currentValue,
        float minValue,
        float maxValue,
        Vector2 size,
        Vector2 position = default,
        float step = 0.01f,
        SliderStyle? theme = null,
        ButtonStylePack? grabberTheme = null,
        Vector2? grabberSize = null,
        HSliderDirection direction = HSliderDirection.LeftToRight,
        bool disabled = false,
        object? userData = null,
        Vector2? origin = null)
    {
        if (!IsContextValid()) return currentValue;

        int intId = id.GetHashCode();
        Vector2 drawPos = Context.Layout.ApplyLayout(position);

        // Culling Check
        Rect widgetBounds = new Rect(drawPos.X, drawPos.Y, size.X, size.Y);
        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(size);
            return currentValue;
        }

        InternalHSliderLogic sliderInstance = State.GetOrCreateElement<InternalHSliderLogic>(intId);
        sliderInstance.Position = drawPos;

        // Configure instance
        sliderInstance.Size = size;
        sliderInstance.MinValue = minValue;
        sliderInstance.MaxValue = maxValue;
        sliderInstance.Step = step;
        sliderInstance.Theme = theme ?? sliderInstance.Theme ?? new SliderStyle();
        sliderInstance.GrabberTheme = grabberTheme ?? sliderInstance.GrabberTheme ?? new ButtonStylePack();
        sliderInstance.GrabberSize = grabberSize ?? new Vector2(16, 16);
        sliderInstance.Origin = origin ?? Vector2.Zero;
        sliderInstance.Disabled = disabled;
        sliderInstance.UserData = userData;
        sliderInstance.Direction = direction;


        float newValue = sliderInstance.UpdateAndDraw(intId, currentValue);
        Context.Layout.AdvanceLayout(sliderInstance.Size);
        return newValue;
    }

    public static float VSlider(
        string id,
        float currentValue,
        float minValue,
        float maxValue,
        Vector2 size,
        Vector2 position = default,
        float step = 0.01f,
        SliderStyle? theme = null,
        ButtonStylePack? grabberTheme = null,
        Vector2? grabberSize = null,
        VSliderDirection direction = VSliderDirection.TopToBottom,
        bool disabled = false,
        object? userData = null,
        Vector2? origin = null)
    {
        if (!IsContextValid()) return currentValue;

        int intId = id.GetHashCode();
        Vector2 drawPos = Context.Layout.ApplyLayout(position);

        // Culling Check
        Rect widgetBounds = new Rect(drawPos.X, drawPos.Y, size.X, size.Y);
        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(size);
            return currentValue;
        }

        InternalVSliderLogic sliderInstance = State.GetOrCreateElement<InternalVSliderLogic>(intId);
        sliderInstance.Position = drawPos;

        // Configure instance
        sliderInstance.Size = size;
        sliderInstance.MinValue = minValue;
        sliderInstance.MaxValue = maxValue;
        sliderInstance.Step = step;
        sliderInstance.Theme = theme ?? sliderInstance.Theme ?? new SliderStyle();
        sliderInstance.GrabberTheme = grabberTheme ?? sliderInstance.GrabberTheme ?? new ButtonStylePack();
        sliderInstance.GrabberSize = grabberSize ?? new Vector2(16, 16);
        sliderInstance.Origin = origin ?? Vector2.Zero;
        sliderInstance.Disabled = disabled;
        sliderInstance.UserData = userData;
        sliderInstance.Direction = direction;

        float newValue = sliderInstance.UpdateAndDraw(intId, currentValue);
        Context.Layout.AdvanceLayout(sliderInstance.Size);
        return newValue;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.StatelessWidgets.cs">
using System.Numerics;
using DirectUI.Drawing;
using Vortice.Direct2D1; // Still used for AntialiasMode enum
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    /// <summary>
    /// The core, stateless primitive for drawing and interacting with a button.
    /// This is the single source of truth for all button-like controls.
    /// </summary>
    internal static bool DrawButtonPrimitive(
        int id,
        Vortice.Mathematics.Rect bounds,
        string text,
        ButtonStylePack theme,
        bool disabled,
        Alignment textAlignment,
        DirectUI.Button.ActionMode clickMode,
        DirectUI.Button.ClickBehavior clickBehavior,
        Vector2 textOffset,
        bool isActive = false)
    {
        var context = UI.Context;
        var state = UI.State;
        var renderer = context.Renderer;
        var textService = context.TextService;
        var input = context.InputState;

        // --- State Calculation ---
        bool isFocused = !disabled && state.FocusedElementId == id;
        bool isHovering = !disabled && bounds.Width > 0 && bounds.Height > 0 && bounds.Contains(input.MousePosition.X, input.MousePosition.Y);
        if (isHovering)
        {
            state.SetPotentialInputTarget(id);
        }

        // --- Click Detection ---
        bool wasClickedThisFrame = false;
        bool isPressed = state.ActivelyPressedElementId == id;

        bool primaryActionPressedThisFrame = (clickBehavior is DirectUI.Button.ClickBehavior.Left or DirectUI.Button.ClickBehavior.Both) && input.WasLeftMousePressedThisFrame;
        bool secondaryActionPressedThisFrame = (clickBehavior is DirectUI.Button.ClickBehavior.Right or DirectUI.Button.ClickBehavior.Both) && input.WasRightMousePressedThisFrame;
        bool anyActionPressedThisFrame = primaryActionPressedThisFrame || secondaryActionPressedThisFrame;

        bool primaryActionHeld = (clickBehavior is DirectUI.Button.ClickBehavior.Left or DirectUI.Button.ClickBehavior.Both) && input.IsLeftMouseDown;
        bool secondaryActionHeld = (clickBehavior is DirectUI.Button.ClickBehavior.Right or DirectUI.Button.ClickBehavior.Both) && input.IsRightMouseDown;
        bool anyActionHeld = primaryActionHeld || secondaryActionHeld;


        if (!anyActionHeld && isPressed)
        {
            if (isHovering && clickMode == DirectUI.Button.ActionMode.Release)
            {
                wasClickedThisFrame = true;
            }
            state.ClearActivePress(id);
            isPressed = false;
        }

        if (anyActionPressedThisFrame)
        {
            if (isHovering && state.PotentialInputTargetId == id && !state.DragInProgressFromPreviousFrame)
            {
                state.SetButtonPotentialCaptorForFrame(id);
                state.SetFocus(id);
                isPressed = true;
            }
        }

        if (!wasClickedThisFrame && clickMode == DirectUI.Button.ActionMode.Press && state.InputCaptorId == id)
        {
            wasClickedThisFrame = true;
        }

        // --- Style Resolution ---
        ButtonStyle currentStyle = ResolveButtonStylePrimitive(theme, isHovering, isPressed, disabled, isFocused, isActive);

        // --- Drawing ---
        if (bounds.Width > 0 && bounds.Height > 0)
        {
            // Draw Background
            renderer.DrawBox(bounds, currentStyle);

            // Draw Text
            DrawTextPrimitive(bounds, text, currentStyle, textAlignment, textOffset);
        }

        return wasClickedThisFrame;
    }

    /// <summary>
    /// Resolves the final ButtonStyle for the current frame by applying interaction state and style stack overrides.
    /// </summary>
    internal static ButtonStyle ResolveButtonStylePrimitive(ButtonStylePack theme, bool isHovering, bool isPressed, bool isDisabled, bool isFocused, bool isActive)
    {
        // Determine base style from interaction state
        theme.UpdateCurrentStyle(isHovering, isPressed, isDisabled, isFocused, isActive);
        ButtonStyle baseStyle = theme.Current;

        // Create a temporary, modifiable copy for this frame to apply style stack overrides
        var finalStyle = new ButtonStyle
        {
            FillColor = baseStyle.FillColor,
            BorderColor = baseStyle.BorderColor,
            FontColor = baseStyle.FontColor,
            BorderLengthTop = baseStyle.BorderLengthTop,
            BorderLengthRight = baseStyle.BorderLengthRight,
            BorderLengthBottom = baseStyle.BorderLengthBottom,
            BorderLengthLeft = baseStyle.BorderLengthLeft,
            Roundness = baseStyle.Roundness,
            FontName = baseStyle.FontName,
            FontSize = baseStyle.FontSize,
            FontWeight = baseStyle.FontWeight,
            FontStyle = baseStyle.FontStyle,
            FontStretch = baseStyle.FontStretch
        };

        // Override with values from the style stack if they exist
        if (isDisabled)
        {
            finalStyle.FillColor = GetStyleColor(StyleColor.ButtonDisabled, finalStyle.FillColor);
            finalStyle.BorderColor = GetStyleColor(StyleColor.BorderDisabled, finalStyle.BorderColor);
            finalStyle.FontColor = GetStyleColor(StyleColor.TextDisabled, finalStyle.FontColor);
        }
        else if (isPressed)
        {
            finalStyle.FillColor = GetStyleColor(StyleColor.ButtonPressed, finalStyle.FillColor);
            finalStyle.BorderColor = GetStyleColor(StyleColor.BorderPressed, finalStyle.BorderColor);
        }
        else if (isHovering && !isActive) // Don't apply button hover if it's an active tab/button
        {
            finalStyle.FillColor = GetStyleColor(StyleColor.ButtonHovered, finalStyle.FillColor);
            finalStyle.BorderColor = GetStyleColor(StyleColor.BorderHovered, finalStyle.BorderColor);
        }
        else if (isFocused && !isActive) // Don't apply focus border if it's an active tab/button
        {
            finalStyle.BorderColor = GetStyleColor(StyleColor.BorderFocused, finalStyle.BorderColor);
        }
        else if (!isActive) // Normal
        {
            finalStyle.FillColor = GetStyleColor(StyleColor.Button, finalStyle.FillColor);
            finalStyle.BorderColor = GetStyleColor(StyleColor.Border, finalStyle.BorderColor);
        }

        if (!isDisabled)
        {
            finalStyle.FontColor = GetStyleColor(StyleColor.Text, finalStyle.FontColor);
        }

        finalStyle.Roundness = GetStyleVar(StyleVar.FrameRounding, finalStyle.Roundness);
        finalStyle.BorderLength = GetStyleVar(StyleVar.FrameBorderSize, finalStyle.BorderLength);

        return finalStyle;
    }

    /// <summary>
    /// The single, unified primitive for drawing cached text within a bounding box.
    /// </summary>
    internal static void DrawTextPrimitive(
        Vortice.Mathematics.Rect bounds,
        string text,
        ButtonStyle style,
        Alignment textAlignment,
        Vector2 textOffset)
    {
        if (string.IsNullOrEmpty(text)) return;

        var renderer = UI.Context.Renderer;

        // Calculate a clean drawing origin without backend-specific corrections.
        Vector2 drawOrigin = new Vector2(bounds.X + textOffset.X, bounds.Y + textOffset.Y);

        // Call the backend-agnostic DrawText method on the renderer.
        // The renderer is now responsible for any specific positional adjustments.
        renderer.DrawText(drawOrigin, text, style, textAlignment, new Vector2(bounds.Width, bounds.Height), style.FontColor);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.Style.cs">
using System;
using System.Collections.Generic;
using System.Numerics;
using DirectUI.Drawing;

namespace DirectUI;

public enum StyleVar
{
    FrameRounding,
    FrameBorderSize,
    // Future additions could include:
    // ItemSpacing,
    // FramePadding,
    // ButtonTextAlign,
}

public enum StyleColor
{
    Text,
    TextDisabled,
    Button,
    ButtonHovered,
    ButtonPressed,
    ButtonDisabled,
    Border,
    BorderHovered,
    BorderPressed,
    BorderDisabled,
    BorderFocused,
}

public static partial class UI
{
    // --- Style Stack API ---

    public static void PushStyleVar(StyleVar styleVar, float value)
    {
        Context.styleVarStack.Push((styleVar, value));
    }

    public static void PushStyleVar(StyleVar styleVar, Vector2 value)
    {
        Context.styleVarStack.Push((styleVar, value));
    }

    public static void PopStyleVar(int count = 1)
    {
        for (int i = 0; i < count; i++)
        {
            if (Context.styleVarStack.Count > 0)
            {
                Context.styleVarStack.Pop();
            }
        }
    }

    public static void PushStyleColor(StyleColor styleColor, Color color)
    {
        Context.styleColorStack.Push((styleColor, color));
    }

    public static void PopStyleColor(int count = 1)
    {
        for (int i = 0; i < count; i++)
        {
            if (Context.styleColorStack.Count > 0)
            {
                Context.styleColorStack.Pop();
            }
        }
    }

    // --- Style Accessors (for internal widget use) ---

    internal static T GetStyleVar<T>(StyleVar styleVar, T defaultValue)
    {
        foreach (var (key, value) in Context.styleVarStack)
        {
            if (key == styleVar && value is T typedValue)
            {
                return typedValue;
            }
        }
        return defaultValue;
    }

    internal static Color GetStyleColor(StyleColor styleColor, Color defaultValue)
    {
        foreach (var (key, value) in Context.styleColorStack)
        {
            if (key == styleColor)
            {
                return value;
            }
        }
        return defaultValue;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.TabBar.cs">
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static void TabBar(string id, string[] tabLabels, ref int activeIndex, ButtonStylePack? theme = null)
    {
        if (!IsContextValid() || tabLabels is null || tabLabels.Length == 0) return;

        int intId = id.GetHashCode();
        var themeId = HashCode.Combine(intId, "theme_default");
        var tabTheme = theme ?? State.GetOrCreateElement<ButtonStylePack>(themeId);
        var state = State.GetOrCreateElement<TabBarState>(intId);

        const float textMarginX = 15f;
        const float tabHeight = 30f;
        float uniformTabWidth;

        if (state.CachedUniformWidth < 0) // Not calculated yet, or invalidated.
        {
            float maxWidth = 0;
            var styleForMeasuring = tabTheme.Normal;
            foreach (var label in tabLabels)
            {
                // Use ITextService to measure text
                Vector2 measuredSize = Context.TextService.MeasureText(label, styleForMeasuring);
                if (measuredSize.X > maxWidth)
                {
                    maxWidth = measuredSize.X;
                }
            }
            uniformTabWidth = maxWidth + textMarginX * 2;
            state.CachedUniformWidth = uniformTabWidth;
        }
        else
        {
            uniformTabWidth = state.CachedUniformWidth;
        }

        var tabSize = new Vector2(uniformTabWidth, tabHeight);

        var hboxIdString = id + "_hbox";
        BeginHBoxContainer(hboxIdString, Context.Layout.GetCurrentPosition(), 0);
        for (int i = 0; i < tabLabels.Length; i++)
        {
            var buttonId = HashCode.Combine(intId, i);
            var position = Context.Layout.GetCurrentPosition();
            var bounds = new Rect(position.X, position.Y, tabSize.X, tabSize.Y);

            bool wasClicked = DrawButtonPrimitive(
                buttonId,
                bounds,
                tabLabels[i],
                tabTheme,
                disabled: false,
                textAlignment: new Alignment(HAlignment.Center, VAlignment.Center),
                clickMode: DirectUI.Button.ActionMode.Release,
                clickBehavior: DirectUI.Button.ClickBehavior.Left,
                textOffset: Vector2.Zero,
                isActive: i == activeIndex
            );

            if (wasClicked)
            {
                activeIndex = i;
            }
            Context.Layout.AdvanceLayout(tabSize);
        }
        EndHBoxContainer();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UI.Tree.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static void Tree<T>(string id, TreeNode<T> root, out TreeNode<T>? clickedNode, TreeStyle? style = null)
    {
        if (!IsContextValid() || root is null) { clickedNode = null; return; }

        clickedNode = null;
        int intId = id.GetHashCode();
        var styleId = HashCode.Combine(intId, "style");
        var treeStyle = style ?? State.GetOrCreateElement<TreeStyle>(styleId);

        var treeState = new TreeViewState(intId, treeStyle);
        Context.treeStateStack.Push(treeState);
        ProcessTreeNodeRecursive(intId, 0, root, ref clickedNode);
        Context.treeStateStack.Pop();
    }

    private static void ProcessTreeNodeRecursive<T>(int parentIdHash, int index, TreeNode<T> node, ref TreeNode<T>? clickedNode)
    {
        if (Context.treeStateStack.Count == 0) return;
        var treeState = Context.treeStateStack.Peek();
        var style = treeState.Style;
        var renderer = Context.Renderer;

        var startLayoutPos = Context.Layout.GetCurrentPosition();

        // Draw indent lines
        int i = 0;
        foreach (var shouldDrawLine in treeState.IndentLineState)
        {
            if (shouldDrawLine)
            {
                float x = startLayoutPos.X + (i * style.Indent) + (style.Indent * 0.5f);
                renderer.DrawLine(new Vector2(x, startLayoutPos.Y), new Vector2(x, startLayoutPos.Y + style.RowHeight), style.LineColor, 1.0f);
            }
            i++;
        }
        if (treeState.IndentLineState.Count > 0)
        {
            float hLineXStart = startLayoutPos.X + ((treeState.IndentLineState.Count - 1) * style.Indent) + (style.Indent * 0.5f);
            float hLineY = startLayoutPos.Y + style.RowHeight * 0.5f;
            renderer.DrawLine(new Vector2(hLineXStart, hLineY), new Vector2(hLineXStart + style.Indent * 0.5f, hLineY), style.LineColor, 1.0f);
        }

        float indentSize = treeState.IndentLineState.Count * style.Indent;
        var nodeRowStartPos = startLayoutPos + new Vector2(indentSize, 0);
        float currentX = nodeRowStartPos.X;
        float gap = 5;

        int nodeHash = node.GetHashCode();
        int toggleId = HashCode.Combine(parentIdHash, index, nodeHash, 0);
        int labelId = HashCode.Combine(parentIdHash, index, nodeHash, 1);

        float toggleWidth = style.RowHeight - 4;
        if (node.Children.Count > 0)
        {
            var bounds = new Vortice.Mathematics.Rect(currentX, nodeRowStartPos.Y, toggleWidth, style.RowHeight);
            if (DrawButtonPrimitive(toggleId, bounds, node.IsExpanded ? "-" : "+", style.ToggleStyle, false, new Alignment(HAlignment.Center, VAlignment.Center), DirectUI.Button.ActionMode.Release, DirectUI.Button.ClickBehavior.Left, Vector2.Zero, false))
            {
                node.IsExpanded = !node.IsExpanded;
            }
        }
        currentX += toggleWidth;

        currentX += gap;
        var labelStyle = style.NodeLabelStyle;
        var labelTextAlignment = new Alignment(HAlignment.Left, VAlignment.Center);
        float labelMargin = 4;
        // Use ITextService to measure text
        var labelSize = Context.TextService.MeasureText(node.Text, labelStyle.Normal);
        float labelWidth = labelSize.X + labelMargin * 2;
        var labelOffset = new Vector2(labelMargin, 0);
        var labelBounds = new Vortice.Mathematics.Rect(currentX, nodeRowStartPos.Y, labelWidth, style.RowHeight);
        if (DrawButtonPrimitive(labelId, labelBounds, node.Text, labelStyle, false, labelTextAlignment, DirectUI.Button.ActionMode.Press, DirectUI.Button.ClickBehavior.Left, labelOffset, false))
        {
            clickedNode = node;
        }
        currentX += labelWidth;

        Context.Layout.AdvanceLayout(new Vector2((currentX - nodeRowStartPos.X), style.RowHeight));

        if (node.IsExpanded && node.Children.Count > 0)
        {
            for (int childIdx = 0; childIdx < node.Children.Count; childIdx++)
            {
                bool isLastChild = childIdx == node.Children.Count - 1;
                treeState.IndentLineState.Push(!isLastChild);
                ProcessTreeNodeRecursive(toggleId, childIdx, node.Children[childIdx], ref clickedNode);
                treeState.IndentLineState.Pop();
            }
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UIContext.cs">
// Core/UIContext.cs
using System.Collections.Generic;
using DirectUI.Core;
using DirectUI.Drawing;

namespace DirectUI;

public class UIContext
{
    // Per-frame services and state
    public IRenderer Renderer { get; }
    public ITextService TextService { get; }
    public InputState InputState { get; }
    public float DeltaTime { get; }

    // Layout and state management
    public UILayoutManager Layout { get; }
    internal readonly Stack<TreeViewState> treeStateStack = new();
    internal readonly Stack<(StyleVar, object)> styleVarStack = new();
    internal readonly Stack<(StyleColor, Color)> styleColorStack = new();

    public UIContext(IRenderer renderer, ITextService textService, InputState inputState, float deltaTime)
    {
        Renderer = renderer;
        TextService = textService;
        InputState = inputState;
        DeltaTime = deltaTime;
        Layout = new UILayoutManager();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UILayoutManager.cs">
using System.Numerics;
using Vortice.Mathematics;
using System;

namespace DirectUI;

public class UILayoutManager
{
    private readonly Stack<ILayoutContainer> _containerStack = new();
    private readonly Dictionary<int, object> _containerStateCache = new();
    private readonly Stack<Rect> _clipRectStack = new();

    public int ContainerStackCount => _containerStack.Count;
    public bool IsInLayoutContainer() => _containerStack.Count > 0;

    public void PushContainer(ILayoutContainer containerState) => _containerStack.Push(containerState);
    public ILayoutContainer PopContainer() => _containerStack.Pop();
    public ILayoutContainer PeekContainer() => _containerStack.Peek();
    public void ClearStack()
    {
        _containerStack.Clear();
        _clipRectStack.Clear();
    }

    public void PushClipRect(Rect rect) => _clipRectStack.Push(rect);
    public void PopClipRect()
    {
        if (_clipRectStack.Count > 0)
        {
            _clipRectStack.Pop();
        }
    }

    public Rect GetCurrentClipRect()
    {
        if (_clipRectStack.Count > 0)
        {
            return _clipRectStack.Peek();
        }
        // Return a very large rectangle representing no clipping
        return new Rect(float.MinValue / 2, float.MinValue / 2, float.MaxValue, float.MaxValue);
    }

    public bool IsRectVisible(Rect rect)
    {
        if (_clipRectStack.Count == 0) return true;

        var currentClip = GetCurrentClipRect();

        // Basic intersection test
        return rect.X < currentClip.X + currentClip.Width &&
               rect.X + rect.Width > currentClip.X &&
               rect.Y < currentClip.Y + currentClip.Height &&
               rect.Y + rect.Height > currentClip.Y;
    }

    public HBoxContainerState GetOrCreateHBoxState(int id)
    {
        if (!_containerStateCache.TryGetValue(id, out var state) || state is not HBoxContainerState hboxState)
        {
            hboxState = new HBoxContainerState(id);
            _containerStateCache[id] = hboxState;
        }
        return hboxState;
    }

    public VBoxContainerState GetOrCreateVBoxState(int id)
    {
        if (!_containerStateCache.TryGetValue(id, out var state) || state is not VBoxContainerState vboxState)
        {
            vboxState = new VBoxContainerState(id);
            _containerStateCache[id] = vboxState;
        }
        return vboxState;
    }

    public void BeginHBox(int id, Vector2 startPosition, float gap)
    {
        var hboxState = GetOrCreateHBoxState(id);

        // Reset per-frame properties
        hboxState.StartPosition = startPosition;
        hboxState.CurrentPosition = startPosition;
        hboxState.Gap = gap;
        hboxState.MaxElementHeight = 0f;
        hboxState.AccumulatedWidth = 0f;
        hboxState.ElementCount = 0;

        PushContainer(hboxState);
    }

    public void BeginVBox(int id, Vector2 startPosition, float gap)
    {
        VBoxContainerState vboxState = GetOrCreateVBoxState(id);

        // Reset per-frame properties
        vboxState.StartPosition = startPosition;
        vboxState.CurrentPosition = startPosition;
        vboxState.Gap = gap;
        vboxState.MaxElementWidth = 0f;
        vboxState.AccumulatedHeight = 0f;
        vboxState.ElementCount = 0;

        PushContainer(vboxState);
    }

    public Vector2 ApplyLayout(Vector2 defaultPosition)
    {
        return IsInLayoutContainer() ? GetCurrentPosition() : defaultPosition;
    }

    public void AdvanceLayout(Vector2 elementSize)
    {
        if (IsInLayoutContainer())
        {
            AdvanceContainerLayout(new Vector2(Math.Max(0, elementSize.X), Math.Max(0, elementSize.Y)));
        }
    }

    public Vector2 GetCurrentPosition()
    {
        if (_containerStack.Count == 0)
        {
            return Vector2.Zero;
        }
        // Polymorphic call to the container at the top of the stack.
        return _containerStack.Peek().GetCurrentPosition();
    }

    public void AdvanceContainerLayout(Vector2 elementSize)
    {
        if (_containerStack.Count == 0) return;

        // Polymorphic call to the container at the top of the stack.
        _containerStack.Peek().Advance(elementSize);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\UIPersistentState.cs">
using System;
using System.Collections.Generic;
using Vortice.Mathematics;

namespace DirectUI;

/// <summary>
/// Manages state that persists across frames, such as UI element instances
/// and input capture state (e.g., which element is currently being pressed).
/// </summary>
public class UIPersistentState
{
    // --- Persistent Element State ---
    private readonly Dictionary<int, object> uiElements = new();
    private readonly Dictionary<int, object?> _userData = new();

    // --- Popup/Overlay State ---
    private int _activePopupId;
    private Action<UIContext>? _popupDrawCallback;
    private Rect _popupBounds;

    // Staging area for results from the previous frame to be read in the current one.
    private int _nextFramePopupResult;
    private bool _nextFramePopupResultAvailable;
    private int _nextFramePopupResultOwnerId;

    public int PopupResult { get; private set; }
    public bool PopupResultAvailable { get; private set; }
    public int PopupResultOwnerId { get; private set; }


    public T GetOrCreateElement<T>(int id) where T : new()
    {
        if (uiElements.TryGetValue(id, out object? element) && element is T existingElement)
        {
            return existingElement;
        }

        T newElement = new();
        uiElements[id] = newElement;
        return newElement;
    }

    public void SetUserData(int id, object? data)
    {
        if (data is not null)
        {
            _userData[id] = data;
        }
        else
        {
            _userData.Remove(id);
        }
    }

    public object? GetUserData(int id)
    {
        return _userData.TryGetValue(id, out var data) ? data : null;
    }


    // --- Input State (persists across frames until interaction ends) ---
    public int ActivelyPressedElementId { get; private set; } = 0;
    public bool DragInProgressFromPreviousFrame { get; private set; } = false;
    public int FocusedElementId { get; private set; } = 0;

    // --- Input State (reset each frame) ---
    public int PotentialInputTargetId { get; private set; } = 0;
    public int InputCaptorId { get; private set; } = 0;
    private bool captureAttemptedThisFrame = false;
    public bool NonSliderElementClaimedPress { get; private set; } = false;


    /// <summary>
    /// Resets the per-frame state variables. Called once at the beginning of each frame.
    /// </summary>
    public void ResetFrameState(InputState input)
    {
        DragInProgressFromPreviousFrame = input.IsLeftMouseDown && ActivelyPressedElementId != 0;
        PotentialInputTargetId = 0;
        InputCaptorId = 0;
        captureAttemptedThisFrame = false;
        NonSliderElementClaimedPress = false;

        // At the start of the frame, transfer the popup result from the previous frame
        // to the current frame's readable state.
        PopupResult = _nextFramePopupResult;
        PopupResultAvailable = _nextFramePopupResultAvailable;
        PopupResultOwnerId = _nextFramePopupResultOwnerId;

        // Clear the "next frame" state, making it ready for this frame's popups to write to.
        _nextFramePopupResult = 0;
        _nextFramePopupResultAvailable = false;
        _nextFramePopupResultOwnerId = 0;
    }

    // --- Popup Management ---
    public bool IsPopupOpen => _activePopupId != 0;
    public int ActivePopupId => _activePopupId;
    public Rect PopupBounds => _popupBounds;
    public Action<UIContext>? PopupDrawCallback => _popupDrawCallback;

    public void SetActivePopup(int ownerId, Action<UIContext> drawCallback, Rect bounds)
    {
        _activePopupId = ownerId;
        _popupDrawCallback = drawCallback;
        _popupBounds = bounds;
    }

    public void SetPopupResult(int ownerId, int result)
    {
        // This sets the data that will become available at the start of the *next* frame.
        _nextFramePopupResultOwnerId = ownerId;
        _nextFramePopupResult = result;
        _nextFramePopupResultAvailable = true;
    }

    public void ClearActivePopup()
    {
        _activePopupId = 0;
        _popupDrawCallback = null;
        _popupBounds = default;
    }


    // --- Input Capture && Targeting ---
    public bool IsElementActive()
    {
        return ActivelyPressedElementId != 0;
    }

    public void SetPotentialInputTarget(int id)
    {
        // Don't allow elements to become potential targets if a popup is open and the cursor is outside it.
        if (IsPopupOpen && !_popupBounds.Contains(UI.Context.InputState.MousePosition))
        {
            return;
        }

        // The last widget drawn under the mouse is the topmost one, so it should always
        // be allowed to set itself as the potential target, overwriting any widget drawn beneath it.
        PotentialInputTargetId = id;
    }

    public void SetPotentialCaptorForFrame(int id)
    {
        captureAttemptedThisFrame = true;
        InputCaptorId = id;
        ActivelyPressedElementId = id;
    }

    public void SetButtonPotentialCaptorForFrame(int id)
    {
        captureAttemptedThisFrame = true;
        InputCaptorId = id;
        ActivelyPressedElementId = id;
        NonSliderElementClaimedPress = true;
    }

    public void ClearActivePress(int id)
    {
        if (ActivelyPressedElementId == id)
        {
            ActivelyPressedElementId = 0;
        }
    }

    // --- Focus Management ---
    public void SetFocus(int id)
    {
        FocusedElementId = id;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Diagnostics\FpsCounter.cs">
// DirectUI/Diagnostics/FpsCounter.cs
using System;
using System.Diagnostics;
using DirectUI.Core;
using Vortice.Mathematics;
using Vortice.DirectWrite;
using System.Numerics; // Still used for TextAlignment and ParagraphAlignment enums

namespace DirectUI.Diagnostics;

public class FpsCounter
{
    // Configuration
    private readonly Color4 _textColor = DefaultTheme.Text;
    private readonly string _fontName = "Consolas";
    private readonly float _fontSize = 14.0f;
    private const int UpdatesPerSecond = 2; // Update twice a second

    // State
    private readonly Stopwatch _timer = new();
    private long _lastUpdateTimeTicks = 0;
    private int _frameCountSinceUpdate = 0;
    private float _currentFps = 0.0f;
    private long _updateIntervalInStopwatchTicks;

    // DirectUI Service references
    private ITextService? _textService;
    private IRenderer? _renderer;
    // Removed ITextLayout? _fpsTextLayout; // No longer cached here for drawing

    public void Initialize(ITextService textService, IRenderer renderer)
    {
        _textService = textService ?? throw new ArgumentNullException(nameof(textService));
        _renderer = renderer ?? throw new ArgumentNullException(nameof(renderer));

        Cleanup(); // Ensure any old resources are released

        try
        {
            // Calculate the update interval based on the Stopwatch's actual frequency.
            if (Stopwatch.IsHighResolution)
            {
                _updateIntervalInStopwatchTicks = Stopwatch.Frequency / UpdatesPerSecond;
            }
            else
            {
                // Fallback for low-resolution timer
                _updateIntervalInStopwatchTicks = TimeSpan.TicksPerSecond / UpdatesPerSecond;
            }

            _frameCountSinceUpdate = 0;
            _currentFps = 0;
            _lastUpdateTimeTicks = 0;
            _timer.Restart();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Warning: Failed to initialize FPS counter: {ex.Message}");
            Cleanup(); // Clean up partial resources on failure
        }
    }

    public void Cleanup()
    {
        _timer.Stop();
        // Removed _fpsTextLayout?.Dispose();
        // Removed _fpsTextLayout = null;
    }

    /// <summary>
    /// Updates the frame count and recalculates the FPS value if the update interval has passed.
    /// This should be called once per rendered frame.
    /// </summary>
    public void Update()
    {
        if (!_timer.IsRunning) _timer.Start();

        _frameCountSinceUpdate++;
        long elapsedTicks = _timer.ElapsedTicks;
        long timeSinceLastUpdate = elapsedTicks - _lastUpdateTimeTicks;

        if (timeSinceLastUpdate >= _updateIntervalInStopwatchTicks)
        {
            long frequency = Stopwatch.IsHighResolution ? Stopwatch.Frequency : TimeSpan.TicksPerSecond;
            float secondsElapsed = (float)timeSinceLastUpdate / frequency;

            _currentFps = (secondsElapsed > 0.001f) ? (_frameCountSinceUpdate / secondsElapsed) : 0.0f;
            _frameCountSinceUpdate = 0;
            _lastUpdateTimeTicks = elapsedTicks;

            // No longer invalidate the cached text layout here, as renderer handles its own caching.
        }
    }

    public void Draw()
    {
        if (_textService is null || _renderer is null)
        {
            return;
        }

        string fpsText = $"FPS: {_currentFps:F1}";

        // The FpsCounter no longer needs to create/cache an ITextLayout for drawing.
        // It simply provides the text and style, and the renderer draws it.
        var style = new ButtonStyle
        {
            FontName = _fontName,
            FontSize = _fontSize,
            FontWeight = FontWeight.Normal,
            FontStyle = FontStyle.Normal,
            FontStretch = FontStretch.Normal,
            FontColor = _textColor
        };
        // Use a large max size as FPS counter typically won't wrap
        // The IRenderer.DrawText method requires a maxSize and alignment for its internal layout logic.
        _renderer.DrawText(new Vector2(5f, 5f), fpsText, style, new Alignment(HAlignment.Left, VAlignment.Top), new Vector2(150f, 30f), _textColor);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Drawing\Color.cs">
using System.Runtime.InteropServices;

namespace DirectUI.Drawing;

[StructLayout(LayoutKind.Sequential)]
public struct Color
{
    public byte R;
    public byte G;
    public byte B;
    public byte A;

    public Color(byte r, byte g, byte b, byte a)
    {
        R = r;
        G = g;
        B = b;
        A = a;
    }

    public Color(float r, float g, float b, float a)
    {
        R = (byte)(r * 255.0f);
        G = (byte)(g * 255.0f);
        B = (byte)(b * 255.0f);
        A = (byte)(a * 255.0f);
    }

    public static implicit operator Raylib_cs.Color(Color color)
    {
        return new Raylib_cs.Color(color.R, color.G, color.B, color.A);
    }

    public static implicit operator Vortice.Mathematics.Color4(Color color)
    {
        return new Vortice.Mathematics.Color4(color.R / 255.0f, color.G / 255.0f, color.B / 255.0f, color.A / 255.0f);
    }

    public static implicit operator Color(Vortice.Mathematics.Color4 color)
    {
        return new Color((byte)(color.R * 255), (byte)(color.G * 255), (byte)(color.B * 255), (byte)(color.A * 255));
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Drawing\FontManager.cs">
// DirectUI/Drawing/FontManager.cs
using Raylib_cs;
using System;
using System.Collections.Generic;
using Vortice.DirectWrite;

namespace DirectUI.Drawing
{
    /// <summary>
    /// Manages loading and caching of fonts for the Raylib backend.
    /// Fonts are registered by family and loaded on-demand at specific sizes and weights.
    /// </summary>
    public static class FontManager
    {
        // Caches the actual loaded Raylib Font objects. Key is (family name, font size, font weight).
        private static readonly Dictionary<(string, int, FontWeight), Font> s_loadedFontsCache = new();

        // Stores registered font families. Key is family name (e.g., "Segoe UI").
        // Value is a dictionary mapping a FontWeight to its file path.
        private static readonly Dictionary<string, Dictionary<FontWeight, string>> s_fontFamilies = new();
        private static bool s_isInitialized = false;

        /// <summary>
        /// Initializes the FontManager.
        /// </summary>
        public static void Initialize()
        {
            if (s_isInitialized) return;
            s_isInitialized = true;
        }

        /// <summary>
        /// Registers a specific font variant (a file path for a given weight) to a font family.
        /// </summary>
        /// <param name="familyName">The logical name for the font family (e.g., "Segoe UI").</param>
        /// <param name="weight">The weight of this font variant.</param>
        /// <param name="filePath">The path to the font file for this variant.</param>
        public static void RegisterFontVariant(string familyName, FontWeight weight, string filePath)
        {
            if (!s_isInitialized)
            {
                Console.WriteLine("FontManager not initialized. Call FontManager.Initialize() first.");
                return;
            }
            if (!s_fontFamilies.TryGetValue(familyName, out var variants))
            {
                variants = new Dictionary<FontWeight, string>();
                s_fontFamilies[familyName] = variants;
            }
            variants[weight] = filePath;
        }

        /// <summary>
        /// Attempts to retrieve the file path for a registered font variant.
        /// </summary>
        /// <param name="familyName">The logical name for the font family.</param>
        /// <param name="weight">The desired weight of the font.</param>
        /// <param name="filePath">When this method returns, contains the file path if found; otherwise, null.</param>
        /// <returns>True if the font file path was found, false otherwise.</returns>
        public static bool TryGetFontFilePath(string familyName, FontWeight weight, out string? filePath)
        {
            filePath = null;
            if (!s_isInitialized) return false;

            if (s_fontFamilies.TryGetValue(familyName, out var variants))
            {
                return variants.TryGetValue(weight, out filePath);
            }
            return false;
        }

        /// <summary>
        /// Retrieves a font at a specific size and weight. If not cached, it's loaded from its registered path.
        /// </summary>
        /// <param name="familyName">The name of the registered font family.</param>
        /// <param name="fontSize">The desired size of the font.</param>
        /// <param name="weight">The desired weight of the font.</param>
        /// <returns>The Raylib Font object. Returns the default font if the requested font cannot be loaded.</returns>
        public static Font GetFont(string familyName, int fontSize, FontWeight weight)
        {
            if (!s_isInitialized)
            {
                return Raylib.GetFontDefault();
            }
            if (fontSize <= 0)
            {
                fontSize = 10; // Use a default small size for safety.
            }

            var cacheKey = (familyName, fontSize, weight);
            if (s_loadedFontsCache.TryGetValue(cacheKey, out var font))
            {
                return font;
            }

            if (!TryGetFontFilePath(familyName, weight, out string? filePath) && !TryGetFontFilePath(familyName, FontWeight.Normal, out filePath))
            {
                Console.WriteLine($"Font family '{familyName}' does not have a variant for weight {weight} or a Normal fallback. Returning default font.");
                return Raylib.GetFontDefault();
            }

            try
            {
                // Load the font at the exact size requested for the atlas.
                Font newFont = Raylib.LoadFontEx(filePath, fontSize, null, 0);

                // Use Point filtering for sharp, 1:1 pixel rendering from the atlas.
                // This avoids the blurriness/shagginess of Bilinear filtering when not oversampling.
                // MSAA should handle smoothing the final glyph edges.
                Raylib.SetTextureFilter(newFont.Texture, TextureFilter.Point);

                s_loadedFontsCache[cacheKey] = newFont;
                return newFont;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to load font '{familyName}' (weight {weight}) at size {fontSize} from '{filePath}'. Reason: {ex.Message}. Returning default font.");
                return Raylib.GetFontDefault();
            }
        }

        /// <summary>
        /// Unloads all loaded fonts and clears all caches.
        /// </summary>
        public static void UnloadAll()
        {
            var defaultFont = Raylib.GetFontDefault();
            foreach (var font in s_loadedFontsCache.Values)
            {
                // Do not unload the default font, Raylib manages it.
                if (font.Texture.Id != defaultFont.Texture.Id)
                {
                    Raylib.UnloadFont(font);
                }
            }
            s_loadedFontsCache.Clear();
            s_fontFamilies.Clear();
            s_isInitialized = false;
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Input\InputManager.cs">
using System.Numerics;
using System.Runtime.InteropServices; // Added for Marshal
using Raylib_cs; // Added for Raylib backend
using SDL3;
using static SDL3.SDL; // Added for SDL3 backend

namespace DirectUI.Input;

public class InputManager
{
    // Persistent state (held across frames)
    private Vector2 _currentMousePos = new(-1, -1);
    private Vector2 _previousMousePos = new(-1, -1);
    private bool _isLeftMouseButtonDown;
    private bool _isRightMouseButtonDown;
    private bool _isMiddleMouseButtonDown;
    private readonly HashSet<Keys> _heldKeys = new();

    // Per-frame state (reset every frame)
    private bool _wasLeftMouseClickedThisFrame;
    private bool _wasRightMouseClickedThisFrame;
    private bool _wasMiddleMouseClickedThisFrame;
    private float _scrollDeltaThisFrame;
    private readonly Queue<char> _typedCharsThisFrame = new();
    private readonly List<Keys> _pressedKeysThisFrame = new();
    private readonly List<Keys> _releasedKeysThisFrame = new();
    private readonly List<MouseButton> _pressedMouseButtonsThisFrame = new();

    public InputState GetCurrentState()
    {
        return new(
            _currentMousePos,
            _previousMousePos,
            _wasLeftMouseClickedThisFrame,
            _isLeftMouseButtonDown,
            _wasRightMouseClickedThisFrame,
            _isRightMouseButtonDown,
            _wasMiddleMouseClickedThisFrame,
            _isMiddleMouseButtonDown,
            _scrollDeltaThisFrame,
            [.. _typedCharsThisFrame], // Create a copy for the readonly list
            _pressedKeysThisFrame,
            _releasedKeysThisFrame,
            _heldKeys,
            [.. _pressedMouseButtonsThisFrame] // Create a copy for the readonly list
        );
    }

    public void PrepareNextFrame()
    {
        _previousMousePos = _currentMousePos;
        _wasLeftMouseClickedThisFrame = false;
        _wasRightMouseClickedThisFrame = false;
        _wasMiddleMouseClickedThisFrame = false;
        _scrollDeltaThisFrame = 0f;
        _typedCharsThisFrame.Clear();
        _pressedKeysThisFrame.Clear();
        _releasedKeysThisFrame.Clear();
        _pressedMouseButtonsThisFrame.Clear();
    }

    public void SetMousePosition(int x, int y)
    {
        _currentMousePos = new Vector2(x, y);
    }

    public void AddMouseWheelDelta(float delta)
    {
        _scrollDeltaThisFrame += delta;
    }

    public void SetMouseDown(MouseButton button)
    {
        _pressedMouseButtonsThisFrame.Add(button);

        if (button == MouseButton.Left)
        {
            _isLeftMouseButtonDown = true;
            _wasLeftMouseClickedThisFrame = true;
        }
        else if (button == MouseButton.Right)
        {
            _isRightMouseButtonDown = true;
            _wasRightMouseClickedThisFrame = true;
        }
        else if (button == MouseButton.Middle)
        {
            _isMiddleMouseButtonDown = true;
            _wasMiddleMouseClickedThisFrame = true;
        }
    }

    public void SetMouseUp(MouseButton button)
    {
        if (button == MouseButton.Left)
        {
            _isLeftMouseButtonDown = false;
        }
        else if (button == MouseButton.Right)
        {
            _isRightMouseButtonDown = false;
        }
        else if (button == MouseButton.Middle)
        {
            _isMiddleMouseButtonDown = false;
        }
    }

    public void AddCharacterInput(char c)
    {
        // Filter out control characters except for tab and newline which might be useful in text boxes.
        if (!char.IsControl(c) || c == '\t' || c == '\n')
        {
            _typedCharsThisFrame.Enqueue(c);
        }
    }

    public void AddKeyPressed(Keys key)
    {
        if (!_heldKeys.Contains(key))
        {
            _pressedKeysThisFrame.Add(key);
            _heldKeys.Add(key);
        }
    }

    public void AddKeyReleased(Keys key)
    {
        if (_heldKeys.Contains(key))
        {
            _releasedKeysThisFrame.Add(key);
            _heldKeys.Remove(key);
        }
    }

    public void HardReset()
    {
        // Resets persistent state that might be invalid after losing focus,
        // e.g. after a modal window closes.
        _isLeftMouseButtonDown = false;
        _isRightMouseButtonDown = false;
        _isMiddleMouseButtonDown = false;
        _heldKeys.Clear();
        // Also clear per-frame state for good measure.
        PrepareNextFrame();
    }

    public void ProcessVeldridInput(Veldrid.InputSnapshot snapshot)
    {
        SetMousePosition((int)snapshot.MousePosition.X, (int)snapshot.MousePosition.Y);
        AddMouseWheelDelta(snapshot.WheelDelta);

        foreach (Veldrid.KeyEvent keyEvent in snapshot.KeyEvents)
        {
            Keys mappedKey = MapVeldridKeyToDirectUIKey(keyEvent.Key);
            if (mappedKey == Keys.Unknown) continue;

            if (keyEvent.Down)
            {
                AddKeyPressed(mappedKey);
            }
            else
            {
                AddKeyReleased(mappedKey);
            }
        }

        foreach (var mouseEvent in snapshot.MouseEvents)
        {
            MouseButton mappedButton = MapVeldridMouseButtonToDirectUIButton(mouseEvent.MouseButton);
            if (mouseEvent.Down)
            {
                SetMouseDown(mappedButton);
            }
            else
            {
                SetMouseUp(mappedButton);
            }
        }

        foreach (char c in snapshot.KeyCharPresses)
        {
            AddCharacterInput(c);
        }
    }

    private Keys MapVeldridKeyToDirectUIKey(Veldrid.Key key)
    {
        throw new NotImplementedException();
    }

    public void ProcessRaylibInput()
    {
        // Mouse position
        Vector2 mousePos = Raylib.GetMousePosition();
        SetMousePosition((int)mousePos.X, (int)mousePos.Y);

        // Mouse buttons
        if (Raylib.IsMouseButtonPressed(Raylib_cs.MouseButton.Left)) SetMouseDown(MouseButton.Left);
        if (Raylib.IsMouseButtonReleased(Raylib_cs.MouseButton.Left)) SetMouseUp(MouseButton.Left);
        if (Raylib.IsMouseButtonPressed(Raylib_cs.MouseButton.Right)) SetMouseDown(MouseButton.Right);
        if (Raylib.IsMouseButtonReleased(Raylib_cs.MouseButton.Right)) SetMouseUp(MouseButton.Right);
        if (Raylib.IsMouseButtonPressed(Raylib_cs.MouseButton.Middle)) SetMouseDown(MouseButton.Middle);
        if (Raylib.IsMouseButtonReleased(Raylib_cs.MouseButton.Middle)) SetMouseUp(MouseButton.Middle);

        // Mouse wheel
        float wheelMove = Raylib.GetMouseWheelMove();
        if (wheelMove != 0) AddMouseWheelDelta(wheelMove);

        // Keyboard keys
        foreach (KeyboardKey rlKey in Enum.GetValues(typeof(KeyboardKey)))
        {
            if (rlKey == KeyboardKey.Null) continue; // Skip NULL key

            Keys mappedKey = MapRaylibKeyToDirectUIKey(rlKey);
            if (mappedKey == Keys.Unknown) continue;

            if (Raylib.IsKeyPressed(rlKey)) AddKeyPressed(mappedKey);
            if (Raylib.IsKeyReleased(rlKey)) AddKeyReleased(mappedKey);
        }

        // Character input
        int charValue = Raylib.GetCharPressed();
        while (charValue > 0)
        {
            AddCharacterInput((char)charValue);
            charValue = Raylib.GetCharPressed();
        }
    }
    public unsafe void ProcessSDL3Event(Event sdlEvent)
    {
        switch ((EventType)sdlEvent.Type)
        {
            case EventType.MouseButtonDown:
                SetMousePosition((int)sdlEvent.Button.X, (int)sdlEvent.Button.Y); // Update position on click
                SetMouseDown(MapSDL3MouseButtonToDirectUIButton(sdlEvent.Button.Button)); // Pass byte directly
                break;
            case EventType.MouseButtonUp:
                SetMousePosition((int)sdlEvent.Button.X, (int)sdlEvent.Button.Y); // Update position on release
                SetMouseUp(MapSDL3MouseButtonToDirectUIButton(sdlEvent.Button.Button)); // Pass byte directly
                break;
            case EventType.MouseMotion: // ADDED: Handle mouse motion to update position
                SetMousePosition((int)sdlEvent.Motion.X, (int)sdlEvent.Motion.Y);
                break;
            case EventType.MouseWheel:
                // SDL wheel delta is usually in integers (e.g., 1 or -1)
                // Normalize it similar to Win32/Veldrid
                float deltaY = sdlEvent.Wheel.Y;
                AddMouseWheelDelta(deltaY);
                break;
            case EventType.KeyDown:
                Keys mappedKeyDown = MapSDL3ScanCodeToDirectUIKey(sdlEvent.Key.Scancode);
                if (mappedKeyDown != Keys.Unknown) AddKeyPressed(mappedKeyDown);
                break;
            case EventType.KeyUp:
                Keys mappedKeyUp = MapSDL3ScanCodeToDirectUIKey(sdlEvent.Key.Scancode);
                if (mappedKeyUp != Keys.Unknown) AddKeyReleased(mappedKeyUp);
                break;
            case EventType.TextInput:
                // Correct way to get character input from SDL3 when `text` is exposed as `nint`
                // `sdlEvent.Text.text` is already an unmanaged pointer (`nint`).
                string typedText = Marshal.PtrToStringUTF8(sdlEvent.Text.Text);
                if (!string.IsNullOrEmpty(typedText))
                {
                    foreach (char c in typedText)
                    {
                        AddCharacterInput(c);
                    }
                }
                break;
        }
    }

    private static MouseButton MapVeldridMouseButtonToDirectUIButton(Veldrid.MouseButton vdButton)
    {
        return vdButton switch
        {
            Veldrid.MouseButton.Left => MouseButton.Left,
            Veldrid.MouseButton.Right => MouseButton.Right,
            Veldrid.MouseButton.Middle => MouseButton.Middle,
            Veldrid.MouseButton.Button1 => MouseButton.XButton1, // Assuming Button1 is XButton1
            Veldrid.MouseButton.Button2 => MouseButton.XButton2, // Assuming Button2 is XButton2
            _ => MouseButton.Left, // Default case
        };
    }

    private static Keys MapRaylibKeyToDirectUIKey(KeyboardKey rlKey)
    {
        // Updated to use PascalCase enum members without the KEY_ prefix
        return rlKey switch
        {
            KeyboardKey.Backspace => Keys.Backspace,
            KeyboardKey.Tab => Keys.Tab,
            KeyboardKey.Enter => Keys.Enter,
            KeyboardKey.LeftShift => Keys.Shift,
            KeyboardKey.RightShift => Keys.Shift,
            KeyboardKey.LeftControl => Keys.Control,
            KeyboardKey.RightControl => Keys.Control,
            KeyboardKey.LeftAlt => Keys.Alt,
            KeyboardKey.RightAlt => Keys.Alt,
            KeyboardKey.Pause => Keys.Pause,
            KeyboardKey.CapsLock => Keys.CapsLock,
            KeyboardKey.Escape => Keys.Escape,
            KeyboardKey.Space => Keys.Space,
            KeyboardKey.PageUp => Keys.PageUp,
            KeyboardKey.PageDown => Keys.PageDown,
            KeyboardKey.End => Keys.End,
            KeyboardKey.Home => Keys.Home,
            KeyboardKey.Left => Keys.LeftArrow,
            KeyboardKey.Up => Keys.UpArrow,
            KeyboardKey.Right => Keys.RightArrow,
            KeyboardKey.Down => Keys.DownArrow,
            KeyboardKey.Insert => Keys.Insert,
            KeyboardKey.Delete => Keys.Delete,
            KeyboardKey.Zero => Keys.D0,
            KeyboardKey.One => Keys.D1,
            KeyboardKey.Two => Keys.D2,
            KeyboardKey.Three => Keys.D3,
            KeyboardKey.Four => Keys.D4,
            KeyboardKey.Five => Keys.D5,
            KeyboardKey.Six => Keys.D6,
            KeyboardKey.Seven => Keys.D7,
            KeyboardKey.Eight => Keys.D8,
            KeyboardKey.Nine => Keys.D9,
            KeyboardKey.A => Keys.A,
            KeyboardKey.B => Keys.B,
            KeyboardKey.C => Keys.C,
            KeyboardKey.D => Keys.D,
            KeyboardKey.E => Keys.E,
            KeyboardKey.F => Keys.F,
            KeyboardKey.G => Keys.G,
            KeyboardKey.H => Keys.H,
            KeyboardKey.I => Keys.I,
            KeyboardKey.J => Keys.J,
            KeyboardKey.K => Keys.K,
            KeyboardKey.L => Keys.L,
            KeyboardKey.M => Keys.M,
            KeyboardKey.N => Keys.N,
            KeyboardKey.O => Keys.O,
            KeyboardKey.P => Keys.P,
            KeyboardKey.Q => Keys.Q,
            KeyboardKey.R => Keys.R,
            KeyboardKey.S => Keys.S,
            KeyboardKey.T => Keys.T,
            KeyboardKey.U => Keys.U,
            KeyboardKey.V => Keys.V,
            KeyboardKey.W => Keys.W,
            KeyboardKey.X => Keys.X,
            KeyboardKey.Y => Keys.Y,
            KeyboardKey.Z => Keys.Z,
            KeyboardKey.F1 => Keys.F1,
            KeyboardKey.F2 => Keys.F2,
            KeyboardKey.F3 => Keys.F3,
            KeyboardKey.F4 => Keys.F4,
            KeyboardKey.F5 => Keys.F5,
            KeyboardKey.F6 => Keys.F6,
            KeyboardKey.F7 => Keys.F7,
            KeyboardKey.F8 => Keys.F8,
            KeyboardKey.F9 => Keys.F9,
            KeyboardKey.F10 => Keys.F10,
            KeyboardKey.F11 => Keys.F11,
            KeyboardKey.F12 => Keys.F12,
            _ => Keys.Unknown,
        };
    }

    private static MouseButton MapSDL3MouseButtonToDirectUIButton(byte sdlButton) // Changed parameter type to byte
    {
        return sdlButton switch
        {
            SDL.ButtonLeft => MouseButton.Left,
            SDL.ButtonMiddle => MouseButton.Middle,
            SDL.ButtonRight => MouseButton.Right,
            SDL.ButtonX1 => MouseButton.XButton1,
            SDL.ButtonX2 => MouseButton.XButton2,
            _ => MouseButton.Left, // Fallback, though ideally all used buttons are mapped.
        };
    }
    private static Keys MapSDL3ScanCodeToDirectUIKey(Scancode sdlScancode)
    {
        return sdlScancode switch
        {
            Scancode.Backspace => Keys.Backspace,
            Scancode.Tab => Keys.Tab,
            Scancode.Return => Keys.Enter, // RETURN is Enter
            Scancode.LShift => Keys.Shift,
            Scancode.RShift => Keys.Shift,
            Scancode.LCtrl => Keys.Control,
            Scancode.RCtrl => Keys.Control,
            Scancode.LAlt => Keys.Alt,
            Scancode.RAlt => Keys.Alt,
            Scancode.Pause => Keys.Pause,
            Scancode.Capslock => Keys.CapsLock,
            Scancode.Escape => Keys.Escape,
            Scancode.Space => Keys.Space,
            Scancode.Pageup => Keys.PageUp,
            Scancode.Pagedown => Keys.PageDown,
            Scancode.End => Keys.End,
            Scancode.Home => Keys.Home,
            Scancode.Left => Keys.LeftArrow,
            Scancode.Up => Keys.UpArrow,
            Scancode.Right => Keys.RightArrow,
            Scancode.Down => Keys.DownArrow,
            Scancode.Insert => Keys.Insert,
            Scancode.Delete => Keys.Delete,
            //Scancode.Num0 => Keys.D0,
            //Scancode.Num1 => Keys.D1,
            //Scancode.Num2 => Keys.D2,
            //Scancode.Num3 => Keys.D3,
            //Scancode.Num4 => Keys.D4,
            //Scancode.Num5 => Keys.D5,
            //Scancode.Num6 => Keys.D6,
            //Scancode.Num7 => Keys.D7,
            //Scancode.Num8 => Keys.D8,
            //Scancode.Num9 => Keys.D9,
            Scancode.A => Keys.A,
            Scancode.B => Keys.B,
            Scancode.C => Keys.C,
            Scancode.D => Keys.D,
            Scancode.E => Keys.E,
            Scancode.F => Keys.F,
            Scancode.G => Keys.G,
            Scancode.H => Keys.H,
            Scancode.I => Keys.I,
            Scancode.J => Keys.J,
            Scancode.K => Keys.K,
            Scancode.L => Keys.L,
            Scancode.M => Keys.M,
            Scancode.N => Keys.N,
            Scancode.O => Keys.O,
            Scancode.P => Keys.P,
            Scancode.Q => Keys.Q,
            Scancode.R => Keys.R,
            Scancode.S => Keys.S,
            Scancode.T => Keys.T,
            Scancode.U => Keys.U,
            Scancode.V => Keys.V,
            Scancode.W => Keys.W,
            Scancode.X => Keys.X,
            Scancode.Y => Keys.Y,
            Scancode.Z => Keys.Z,
            Scancode.F1 => Keys.F1,
            Scancode.F2 => Keys.F2,
            Scancode.F3 => Keys.F3,
            Scancode.F4 => Keys.F4,
            Scancode.F5 => Keys.F5,
            Scancode.F6 => Keys.F6,
            Scancode.F7 => Keys.F7,
            Scancode.F8 => Keys.F8,
            Scancode.F9 => Keys.F9,
            Scancode.F10 => Keys.F10,
            Scancode.F11 => Keys.F11,
            Scancode.F12 => Keys.F12,
            Scancode.LGUI => Keys.LeftWindows, // Left GUI key (Windows, Command, etc.)
            Scancode.RGUI => Keys.RightWindows, // Right GUI key
            Scancode.Application => Keys.Menu, // Application key (right-click menu)
            _ => Keys.Unknown,
        };
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Input\InputState.cs">
// InputState.cs
using System.Collections.Generic;
using System.Numerics;

namespace DirectUI;

// Holds input state needed for UI processing in a single frame
public readonly struct InputState
{
    public readonly Vector2 MousePosition;
    public readonly Vector2 PreviousMousePosition;
    public readonly bool WasLeftMousePressedThisFrame; // True if the left button went down this frame
    public readonly bool IsLeftMouseDown; // True if the left button is currently held down
    public readonly bool WasRightMousePressedThisFrame; // True if the right button went down this frame
    public readonly bool IsRightMouseDown; // True if the right button is currently held down
    public readonly bool WasMiddleMousePressedThisFrame;
    public readonly bool IsMiddleMouseDown;
    public readonly float ScrollDelta; // Mouse wheel scroll amount this frame
    public readonly IReadOnlyList<char> TypedCharacters; // Characters typed this frame
    public readonly IReadOnlyList<Keys> PressedKeys; // Keys pressed down this frame
    public readonly IReadOnlyList<Keys> ReleasedKeys; // Keys released this frame
    public readonly IReadOnlyCollection<Keys> HeldKeys; // Keys currently held down
    public readonly IReadOnlyList<MouseButton> PressedMouseButtons; // Mouse buttons pressed down this frame

    public InputState(
        Vector2 mousePosition,
        Vector2 previousMousePosition,
        bool wasLeftMousePressedThisFrame,
        bool isLeftMouseDown,
        bool wasRightMousePressedThisFrame,
        bool isRightMouseDown,
        bool wasMiddleMousePressedThisFrame,
        bool isMiddleMouseDown,
        float scrollDelta,
        IReadOnlyList<char> typedCharacters,
        IReadOnlyList<Keys> pressedKeys,
        IReadOnlyList<Keys> releasedKeys,
        IReadOnlyCollection<Keys> heldKeys,
        IReadOnlyList<MouseButton> pressedMouseButtons)
    {
        MousePosition = mousePosition;
        PreviousMousePosition = previousMousePosition;
        WasLeftMousePressedThisFrame = wasLeftMousePressedThisFrame;
        IsLeftMouseDown = isLeftMouseDown;
        WasRightMousePressedThisFrame = wasRightMousePressedThisFrame;
        IsRightMouseDown = isRightMouseDown;
        WasMiddleMousePressedThisFrame = wasMiddleMousePressedThisFrame;
        IsMiddleMouseDown = isMiddleMouseDown;
        ScrollDelta = scrollDelta;
        TypedCharacters = typedCharacters;
        PressedKeys = pressedKeys;
        ReleasedKeys = releasedKeys;
        HeldKeys = heldKeys;
        PressedMouseButtons = pressedMouseButtons;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Input\Keys.cs">
namespace DirectUI;

/// <summary>
/// Defines keyboard keys for use in application-level input handling.
/// The values correspond to Win32 Virtual-Key Codes.
/// </summary>
public enum Keys
{
    /// <summary>
    /// The key is not recognized.
    /// </summary>
    Unknown = 0,

    // Action Keys
    /// <summary>The BACKSPACE key.</summary>
    Backspace = 0x08,
    /// <summary>The TAB key.</summary>
    Tab = 0x09,
    /// <summary>The ENTER key.</summary>
    Enter = 0x0D,
    /// <summary>The SHIFT key.</summary>
    Shift = 0x10,
    /// <summary>The CTRL key.</summary>
    Control = 0x11,
    /// <summary>The ALT key.</summary>
    Alt = 0x12,
    /// <summary>The PAUSE key.</summary>
    Pause = 0x13,
    /// <summary>The CAPS LOCK key.</summary>
    CapsLock = 0x14,
    /// <summary>The ESC key.</summary>
    Escape = 0x1B,
    /// <summary>The SPACEBAR key.</summary>
    Space = 0x20,
    /// <summary>The PAGE UP key.</summary>
    PageUp = 0x21,
    /// <summary>The PAGE DOWN key.</summary>
    PageDown = 0x22,
    /// <summary>The END key.</summary>
    End = 0x23,
    /// <summary>The HOME key.</summary>
    Home = 0x24,
    /// <summary>The LEFT ARROW key.</summary>
    LeftArrow = 0x25,
    /// <summary>The UP ARROW key.</summary>
    UpArrow = 0x26,
    /// <summary>The RIGHT ARROW key.</summary>
    RightArrow = 0x27,
    /// <summary>The DOWN ARROW key.</summary>
    DownArrow = 0x28,
    /// <summary>The INSERT key.</summary>
    Insert = 0x2D,
    /// <summary>The DELETE key.</summary>
    Delete = 0x2E,

    // Digit Keys
    /// <summary>The 0 key.</summary>
    D0 = 0x30,
    /// <summary>The 1 key.</summary>
    D1 = 0x31,
    /// <summary>The 2 key.</summary>
    D2 = 0x32,
    /// <summary>The 3 key.</summary>
    D3 = 0x33,
    /// <summary>The 4 key.</summary>
    D4 = 0x34,
    /// <summary>The 5 key.</summary>
    D5 = 0x35,
    /// <summary>The 6 key.</summary>
    D6 = 0x36,
    /// <summary>The 7 key.</summary>
    D7 = 0x37,
    /// <summary>The 8 key.</summary>
    D8 = 0x38,
    /// <summary>The 9 key.</summary>
    D9 = 0x39,

    // Letter Keys
    /// <summary>The A key.</summary>
    A = 0x41,
    /// <summary>The B key.</summary>
    B = 0x42,
    /// <summary>The C key.</summary>
    C = 0x43,
    /// <summary>The D key.</summary>
    D = 0x44,
    /// <summary>The E key.</summary>
    E = 0x45,
    /// <summary>The F key.</summary>
    F = 0x46,
    /// <summary>The G key.</summary>
    G = 0x47,
    /// <summary>The H key.</summary>
    H = 0x48,
    /// <summary>The I key.</summary>
    I = 0x49,
    /// <summary>The J key.</summary>
    J = 0x4A,
    /// <summary>The K key.</summary>
    K = 0x4B,
    /// <summary>The L key.</summary>
    L = 0x4C,
    /// <summary>The M key.</summary>
    M = 0x4D,
    /// <summary>The N key.</summary>
    N = 0x4E,
    /// <summary>The O key.</summary>
    O = 0x4F,
    /// <summary>The P key.</summary>
    P = 0x50,
    /// <summary>The Q key.</summary>
    Q = 0x51,
    /// <summary>The R key.</summary>
    R = 0x52,
    /// <summary>The S key.</summary>
    S = 0x53,
    /// <summary>The T key.</summary>
    T = 0x54,
    /// <summary>The U key.</summary>
    U = 0x55,
    /// <summary>The V key.</summary>
    V = 0x56,
    /// <summary>The W key.</summary>
    W = 0x57,
    /// <summary>The X key.</summary>
    X = 0x58,
    /// <summary>The Y key.</summary>
    Y = 0x59,
    /// <summary>The Z key.</summary>
    Z = 0x5A,

    // Function Keys
    /// <summary>The F1 key.</summary>
    F1 = 0x70,
    /// <summary>The F2 key.</summary>
    F2 = 0x71,
    /// <summary>The F3 key.</summary>
    F3 = 0x72,
    /// <summary>The F4 key.</summary>
    F4 = 0x73,
    /// <summary>The F5 key.</summary>
    F5 = 0x74,
    /// <summary>The F6 key.</summary>
    F6 = 0x75,
    /// <summary>The F7 key.</summary>
    F7 = 0x76,
    /// <summary>The F8 key.</summary>
    F8 = 0x77,
    /// <summary>The F9 key.</summary>
    F9 = 0x78,
    /// <summary>The F10 key.</summary>
    F10 = 0x79,
    /// <summary>The F11 key.</summary>
    F11 = 0x7A,
    /// <summary>The F12 key.</summary>
    F12 = 0x7B,

    // Special Keys
    /// <summary>The left Windows logo key (Microsoft Natural Keyboard).</summary>
    LeftWindows = 0x5B,
    /// <summary>The right Windows logo key (Microsoft Natural Keyboard).</summary>
    RightWindows = 0x5C,
    /// <summary>The Application key (Microsoft Natural Keyboard).</summary>
    Menu = 0x5D,
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\BoxStyle.cs">
using DirectUI.Drawing;

namespace DirectUI;

public class BoxStyle
{
    public float Roundness { get; set; } = 0.2f;
    public Color FillColor { get; set; } = DefaultTheme.NormalFill;
    public Color BorderColor { get; set; } = DefaultTheme.NormalBorder;

    public float BorderLengthTop { get; set; } = 1.0f;
    public float BorderLengthRight { get; set; } = 1.0f;
    public float BorderLengthBottom { get; set; } = 1.0f;
    public float BorderLengthLeft { get; set; } = 1.0f;

    public float BorderLength
    {
        get => BorderLengthTop; // Return a representative value
        set
        {
            BorderLengthTop = value;
            BorderLengthRight = value;
            BorderLengthBottom = value;
            BorderLengthLeft = value;
        }
    }

    public BoxStyle() { }

    protected BoxStyle(BoxStyle other)
    {
        this.Roundness = other.Roundness;
        this.FillColor = other.FillColor;
        this.BorderColor = other.BorderColor;
        this.BorderLengthTop = other.BorderLengthTop;
        this.BorderLengthRight = other.BorderLengthRight;
        this.BorderLengthBottom = other.BorderLengthBottom;
        this.BorderLengthLeft = other.BorderLengthLeft;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\ButtonStyle.cs">
// ButtonStyle.cs
using DirectUI.Drawing;
using Vortice.DirectWrite; // For Font related enums eventually

namespace DirectUI;

public class ButtonStyle : BoxStyle
{
    // DirectWrite Font properties will be managed elsewhere (e.g., IDWriteTextFormat)
    // public float FontSpacing { get; set; } = 0; // Handled by TextFormat
    // public float FontSize { get; set; } = 16; // Handled by TextFormat
    // public Font? Font { get; set; } = null; // Represented by TextFormat
    public Color FontColor { get; set; } = DefaultTheme.Text;

    // Properties needed for creating IDWriteTextFormat
    public string FontName { get; set; } = "Segoe UI";
    public float FontSize { get; set; } = 14.0f;
    public FontWeight FontWeight { get; set; } = FontWeight.Normal;
    public FontStyle FontStyle { get; set; } = FontStyle.Normal;
    public FontStretch FontStretch { get; set; } = FontStretch.Normal;

    public ButtonStyle() { }

    public ButtonStyle(ButtonStyle other) : base(other)
    {
        this.FontColor = other.FontColor;
        this.FontName = other.FontName;
        this.FontSize = other.FontSize;
        this.FontWeight = other.FontWeight;
        this.FontStyle = other.FontStyle;
        this.FontStretch = other.FontStretch;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\ButtonStylePack.cs">
using System.Collections.Generic;
using System;
using Vortice.Mathematics;
using Vortice.DirectWrite;

namespace DirectUI;

public sealed class ButtonStylePack
{
    public ButtonStyle Current { get; internal set; }
    public ButtonStyle Normal { get; set; } = new();
    public ButtonStyle Hover { get; set; } = new();
    public ButtonStyle Pressed { get; set; } = new();
    public ButtonStyle Disabled { get; set; } = new();
    public ButtonStyle Focused { get; set; } = new();
    public ButtonStyle Active { get; set; } = new();
    public ButtonStyle ActiveHover { get; set; } = new();

    public ButtonStylePack()
    {
        Hover.FillColor = DefaultTheme.HoverFill;
        Hover.BorderColor = DefaultTheme.HoverBorder;

        Pressed.FillColor = DefaultTheme.Accent;
        Pressed.BorderColor = DefaultTheme.AccentBorder;

        Disabled.FillColor = DefaultTheme.DisabledFill;
        Disabled.BorderColor = DefaultTheme.DisabledBorder;
        Disabled.FontColor = DefaultTheme.DisabledText;

        Focused.FillColor = DefaultTheme.NormalFill;
        Focused.BorderColor = DefaultTheme.FocusBorder;
        Focused.BorderLength = 1;

        // Styles for 'Active' state, taken from the old TabStylePack
        var panelBg = new Color4(37 / 255f, 37 / 255f, 38 / 255f, 1.0f);
        Active.FillColor = panelBg;
        Active.BorderColor = DefaultTheme.HoverBorder;
        Active.BorderLengthTop = 1f; Active.BorderLengthLeft = 1f; Active.BorderLengthRight = 1f; Active.BorderLengthBottom = 0f;
        Active.Roundness = 0f;

        ActiveHover.FillColor = panelBg;
        ActiveHover.BorderColor = DefaultTheme.AccentBorder;
        ActiveHover.BorderLengthTop = 1f; ActiveHover.BorderLengthLeft = 1f; ActiveHover.BorderLengthRight = 1f; ActiveHover.BorderLengthBottom = 0f;
        ActiveHover.Roundness = 0f;

        Current = Normal;
    }

    public void UpdateCurrentStyle(bool isHovering, bool isPressed, bool isDisabled, bool isFocused, bool isActive = false)
    {
        if (isDisabled)
        {
            Current = Disabled;
        }
        else if (isPressed)
        {
            Current = Pressed;
        }
        else if (isActive)
        {
            Current = isHovering ? ActiveHover : Active;
        }
        else if (isHovering)
        {
            Current = Hover;
        }
        else if (isFocused)
        {
            Current = Focused;
        }
        else
        {
            Current = Normal;
        }
    }

    private IEnumerable<ButtonStyle> AllStyles => [Normal, Hover, Pressed, Disabled, Focused, Active, ActiveHover];

    public string FontName
    {
        set => SetAll(s => s.FontName = value);
    }

    public float FontSize
    {
        set => SetAll(s => s.FontSize = value);
    }

    public FontWeight FontWeight
    {
        set => SetAll(s => s.FontWeight = value);
    }

    public FontStyle FontStyle
    {
        set => SetAll(s => s.FontStyle = value);
    }

    public FontStretch FontStretch
    {
        set => SetAll(s => s.FontStretch = value);
    }

    public Color4 FontColor
    {
        set => SetAll(s => s.FontColor = value);
    }

    public float Roundness
    {
        set => SetAll(s => s.Roundness = value);
    }

    public float BorderLength
    {
        set => SetAll(s => s.BorderLength = value);
    }

    public Color4 FillColor
    {
        set => SetAll(s => s.FillColor = value);
    }

    public Color4 BorderColor
    {
        set => SetAll(s => s.BorderColor = value);
    }

    private void SetAll(Action<ButtonStyle> setter)
    {
        foreach (ButtonStyle style in AllStyles)
        {
            setter(style);
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\DefaultTheme.cs">
// DefaultTheme.cs
using DirectUI.Drawing;

namespace DirectUI;

// Defines default colors for the UI theme
public static class DefaultTheme
{
    // --- Theme Color Definitions ---

    private static class DAWThemeColors
    {
        // Palette inspired by modern DAWs like Ableton Live
        public static readonly Color Control = new Color(75, 75, 75, 255);          // #4B4B4B
        public static readonly Color ControlHover = new Color(90, 90, 90, 255);       // #5A5A5A
        public static readonly Color Border = new Color(30, 30, 30, 255);         // #1E1E1E

        public static readonly Color Accent = new Color(0, 190, 190, 255);        // A bright teal #00BEBE
        public static readonly Color AccentBorder = new Color(128, 222, 222, 255);   // Lighter teal

        public static readonly Color DisabledFill = new Color(55, 55, 55, 255);
        public static readonly Color DisabledBorder = new Color(40, 40, 40, 255);
        public static readonly Color DisabledText = new Color(128, 128, 128, 255);

        public static readonly Color Text = new Color(221, 221, 221, 255);     // #DDDDDD
    }

    private static class Ue5ThemeColors
    {
        // Palette based on Unreal Engine 5 Editor
        public static readonly Color Fill = new Color(42, 42, 42, 255);        // #2A2A2A
        public static readonly Color FillLighter = new Color(58, 58, 58, 255);  // #3A3A3A
        public static readonly Color Border = new Color(21, 21, 21, 255);      // #151515 (Matches window background)

        // --- CHANGE HERE ---
        // Changed from blue to a light gray for a more authentic UE5 feel.
        public static readonly Color Hover = new Color(160, 160, 160, 255);   // #A0A0A0
        // --- END CHANGE ---

        public static readonly Color Accent = new Color(255, 171, 0, 255);     // Orange #FFAB00
        public static readonly Color AccentBorder = new Color(255, 187, 51, 255); // Lighter Orange

        public static readonly Color DisabledFill = new Color(32, 32, 32, (byte)(255 * 0.8f));
        public static readonly Color DisabledBorder = new Color(48, 48, 48, (byte)(255 * 0.8f));
        public static readonly Color DisabledText = new Color(128, 128, 128, 255);

        public static readonly Color Text = new Color(240, 240, 240, 255);     // #F0F0F0
    }

    private static class OriginalColors
    {
        public static readonly Color NormalFill = new Color(64, 64, 77, 255);
        public static readonly Color NormalBorder = new Color(102, 102, 115, 255);
        public static readonly Color HoverFill = new Color(89, 89, 102, 255);
        public static readonly Color HoverBorder = new Color(128, 128, 140, 255);
        public static readonly Color Accent = new Color(51, 102, 204, 255);
        public static readonly Color AccentBorder = new Color(77, 128, 230, 255);
        public static readonly Color DisabledFill = new Color(51, 51, 51, (byte)(255 * 0.8f));
        public static readonly Color DisabledBorder = new Color(77, 77, 77, (byte)(255 * 0.8f));
        public static readonly Color DisabledText = new Color(128, 128, 128, 255);
        public static readonly Color Text = new Color(245, 245, 245, 255); // WhiteSmoke
    }

    private static class UnityEditorThemeColors
    {
        // Palette based on Unity Editor's default dark theme (Pro skin)
        public static readonly Color Fill = new Color(56, 56, 56, 255);         // #383838 - Standard control background
        public static readonly Color Border = new Color(35, 35, 35, 255);        // #232323 - Dark, subtle border
        public static readonly Color SelectionBlue = new Color(62, 95, 150, 255); // #3E5F96 - The iconic blue for selections/presses
        public static readonly Color SelectionBlueBorder = new Color(75, 116, 185, 255); // #4B74B9 - Brighter blue for hover/focus borders

        public static readonly Color DisabledFill = new Color(56, 56, 56, (byte)(255 * 0.8f));
        public static readonly Color DisabledBorder = new Color(32, 32, 32, (byte)(255 * 0.8f));
        public static readonly Color DisabledText = new Color(128, 128, 128, 255);

        public static readonly Color Text = new Color(207, 207, 207, 255);       // #CFCFCF
    }


    // --- Current Active Theme ---
    // Change the assignments here to swap themes.

    // Basic Palette
    public static readonly Color White = new Color(255, 255, 255, 255);
    public static readonly Color Black = new Color(0, 0, 0, 255);
    public static readonly Color Transparent = new Color(0, 0, 0, 0);

    /*
    // --- ACTIVE THEME: DAW ---
    public static readonly Color NormalFill = DAWThemeColors.Control;
    public static readonly Color NormalBorder = DAWThemeColors.Border;
    public static readonly Color HoverFill = DAWThemeColors.ControlHover;
    public static readonly Color HoverBorder = DAWThemeColors.Accent; // Use Accent for hover border for clarity
    public static readonly Color Accent = DAWThemeColors.Accent;
    public static readonly Color AccentBorder = DAWThemeColors.AccentBorder;
    public static readonly Color DisabledFill = DAWThemeColors.DisabledFill;
    public static readonly Color DisabledBorder = DAWThemeColors.DisabledBorder;
    public static readonly Color DisabledText = DAWThemeColors.DisabledText;
    public static readonly Color FocusBorder = DAWThemeColors.Accent; // Use Accent for focus border
    public static readonly Color Text = DAWThemeColors.Text;
    */

    /*
    // --- ACTIVE THEME: Unity Editor (Dark) ---
    public static readonly Color NormalFill = UnityEditorThemeColors.Fill;
    public static readonly Color NormalBorder = UnityEditorThemeColors.Border;
    public static readonly Color HoverFill = UnityEditorThemeColors.Fill; // Fill does not change on hover in Unity
    public static readonly Color HoverBorder = UnityEditorThemeColors.SelectionBlueBorder; // Border becomes blue on hover
    public static readonly Color Accent = UnityEditorThemeColors.SelectionBlue; // Accent is the pressed/active color
    public static readonly Color AccentBorder = UnityEditorThemeColors.SelectionBlueBorder;
    public static readonly Color DisabledFill = UnityEditorThemeColors.DisabledFill;
    public static readonly Color DisabledBorder = UnityEditorThemeColors.DisabledBorder;
    public static readonly Color DisabledText = UnityEditorThemeColors.DisabledText;
    public static readonly Color FocusBorder = UnityEditorThemeColors.SelectionBlueBorder; // Focus also uses the blue border
    public static readonly Color Text = UnityEditorThemeColors.Text;
    */


    // --- ACTIVE THEME: Original ---
    // To restore the original theme, comment out the "UE5" block above
    // and uncomment this block below.
    public static readonly Color NormalFill = OriginalColors.NormalFill;
    public static readonly Color NormalBorder = OriginalColors.NormalBorder;
    public static readonly Color HoverFill = OriginalColors.HoverFill;
    public static readonly Color HoverBorder = OriginalColors.HoverBorder;
    public static readonly Color Accent = OriginalColors.Accent;
    public static readonly Color AccentBorder = OriginalColors.AccentBorder;
    public static readonly Color DisabledFill = OriginalColors.DisabledFill;
    public static readonly Color DisabledBorder = OriginalColors.DisabledBorder;
    public static readonly Color DisabledText = OriginalColors.DisabledText;
    public static readonly Color FocusBorder = new Color(135, 206, 250, 255); // LightSkyBlue
    public static readonly Color Text = OriginalColors.Text;

}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\KnobStyle.cs">
using DirectUI.Drawing;

namespace DirectUI;

public class KnobStyle
{
    /// <summary>
    /// Style for the main body of the knob.
    /// </summary>
    public BoxStyle BaseStyle { get; set; } = new();

    /// <summary>
    /// Color of the indicator line.
    /// </summary>
    public Color IndicatorColor { get; set; } = DefaultTheme.Accent;

    /// <summary>
    /// Thickness of the indicator line.
    /// </summary>
    public float IndicatorThickness { get; set; } = 2.0f;

    /// <summary>
    /// The start angle of the knob's rotation in degrees. (e.g., -135 for bottom-left start).
    /// </summary>
    public float StartAngleDegrees { get; set; } = -135f;

    /// <summary>
    /// The total range of motion for the knob in degrees. (e.g., 270 for a 3/4 turn).
    /// </summary>
    public float AngleRangeDegrees { get; set; } = 270f;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\SliderStyle.cs">
namespace DirectUI;

public class SliderStyle
{
    public BoxStyle Background { get; set; } = new()
    {
        FillColor = DefaultTheme.DisabledFill,
        BorderColor = DefaultTheme.NormalBorder,
        Roundness = 0.5f,
        BorderLength = 1.0f
    };

    public BoxStyle Foreground { get; set; } = new()
    {
        FillColor = DefaultTheme.Accent,
        BorderColor = DefaultTheme.Transparent,
        Roundness = 0.5f,
        BorderLength = 0.0f
    };
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\TabStyle.cs">
namespace DirectUI;

public class TabStyle : ButtonStyle
{
    // For now, this is a marker class. It can hold tab-specific style properties later.
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\TabStylePack.cs">
using Vortice.Mathematics;

namespace DirectUI;

public sealed class TabStylePack
{
    public TabStyle Current { get; private set; }
    public TabStyle Normal { get; set; } = new();
    public TabStyle Hover { get; set; } = new();
    public TabStyle Active { get; set; } = new();
    public TabStyle ActiveHover { get; set; } = new();
    public TabStyle Disabled { get; set; } = new();

    public TabStylePack()
    {
        var panelBg = new Color4(37 / 255f, 37 / 255f, 38 / 255f, 1.0f);
        var hoverBorder = DefaultTheme.HoverBorder;
        var accentBorder = DefaultTheme.AccentBorder;

        string fontName = "Segoe UI";
        float fontSize = 14f;

        // Inactive tab
        Normal.FillColor = DefaultTheme.NormalFill;
        Normal.BorderColor = DefaultTheme.NormalBorder;
        Normal.BorderLength = 1f;
        Normal.Roundness = 0f;
        Normal.FontName = fontName; Normal.FontSize = fontSize;

        // Inactive tab, hovered
        Hover.FillColor = DefaultTheme.HoverFill;
        Hover.BorderColor = hoverBorder;
        Hover.BorderLength = 1f;
        Hover.Roundness = 0f;
        Hover.FontName = fontName; Hover.FontSize = fontSize;

        // Active tab
        Active.FillColor = panelBg;
        Active.BorderColor = hoverBorder;
        Active.BorderLengthTop = 1f; Active.BorderLengthLeft = 1f; Active.BorderLengthRight = 1f; Active.BorderLengthBottom = 0f;
        Active.Roundness = 0f;
        Active.FontName = fontName; Active.FontSize = fontSize;

        // Active tab, hovered
        ActiveHover.FillColor = panelBg;
        ActiveHover.BorderColor = accentBorder;
        ActiveHover.BorderLengthTop = 1f; ActiveHover.BorderLengthLeft = 1f; ActiveHover.BorderLengthRight = 1f; ActiveHover.BorderLengthBottom = 0f;
        ActiveHover.Roundness = 0f;
        ActiveHover.FontName = fontName; ActiveHover.FontSize = fontSize;

        Disabled.FillColor = DefaultTheme.DisabledFill;
        Disabled.BorderColor = DefaultTheme.DisabledBorder;
        Disabled.FontColor = DefaultTheme.DisabledText;
        Disabled.FontName = fontName; Disabled.FontSize = fontSize;

        Current = Normal;
    }

    public void UpdateCurrentStyle(bool isHovering, bool isActive, bool isDisabled, bool isFocused)
    {
        if (isDisabled)
        {
            Current = Disabled;
        }
        else if (isActive) Current = isHovering ? ActiveHover : Active;
        else if (isHovering) Current = Hover;
        else
        {
            Current = Normal;
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Styles\TreeStyle.cs">
using DirectUI.Drawing;

namespace DirectUI;

public class TreeStyle
{
    public float Indent { get; set; } = 19f;
    public float RowHeight { get; set; } = 24f; // Increased from 22f to accommodate font descenders
    public Color LineColor { get; set; } = DefaultTheme.HoverBorder;
    public ButtonStylePack ToggleStyle { get; set; }
    public ButtonStylePack NodeLabelStyle { get; set; }

    public TreeStyle()
    {
        ToggleStyle = new ButtonStylePack
        {
            Roundness = 0.2f,
            BorderLength = 1f,
            FontName = "Consolas",
            FontSize = 14
        };
        ToggleStyle.Normal.FillColor = DefaultTheme.NormalFill;
        ToggleStyle.Normal.BorderColor = DefaultTheme.NormalBorder;
        ToggleStyle.Hover.FillColor = DefaultTheme.HoverFill;
        ToggleStyle.Hover.BorderColor = DefaultTheme.HoverBorder;
        ToggleStyle.Pressed.FillColor = DefaultTheme.Accent;
        ToggleStyle.Pressed.BorderColor = DefaultTheme.AccentBorder;

        NodeLabelStyle = new ButtonStylePack
        {
            Roundness = 0f,
            BorderLength = 0f,
            FontName = "Segoe UI",
            FontSize = 14
        };
        NodeLabelStyle.Normal.FillColor = DefaultTheme.Transparent;
        NodeLabelStyle.Normal.FontColor = DefaultTheme.Text;
        NodeLabelStyle.Hover.FillColor = new Color(64, 64, 64, 128); // Semi-transparent gray
        NodeLabelStyle.Hover.FontColor = DefaultTheme.Text;
        NodeLabelStyle.Pressed.FillColor = DefaultTheme.Accent;
        NodeLabelStyle.Pressed.FontColor = DefaultTheme.White;
        NodeLabelStyle.Pressed.BorderColor = DefaultTheme.AccentBorder;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\Button.cs">
namespace DirectUI;

public static class Button
{
    public enum ActionMode { Release, Press }
    public enum ClickBehavior { Left, Right, Both }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\DataGridColumn.cs">
// DirectUI/Source/Widgets/DataGridColumn.cs
namespace DirectUI;

/// <summary>
/// Defines a column for the DataGrid control.
/// </summary>
public class DataGridColumn
{
    /// <summary>
    /// The text displayed in the column header.
    /// </summary>
    public string HeaderText { get; }

    /// <summary>
    /// The initial width of the column. This can be changed by the user resizing the column.
    /// </summary>
    public float InitialWidth { get; }

    /// <summary>
    /// The name of the public property on the data item object from which to retrieve the cell value.
    /// </summary>
    public string DataPropertyName { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="DataGridColumn"/> class.
    /// </summary>
    /// <param name="headerText">The text to display in the column header.</param>
    /// <param name="initialWidth">The initial width of the column.</param>
    /// <param name="dataPropertyName">The name of the public property to bind to.</param>
    public DataGridColumn(string headerText, float initialWidth, string dataPropertyName)
    {
        HeaderText = headerText;
        InitialWidth = initialWidth;
        DataPropertyName = dataPropertyName;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\InputText.cs">
// Widgets/LineEdit.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using DirectUI.Core;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1; // Still used for AntialiasMode enum
using Vortice.DirectWrite; // Still used for WordWrapping, TextAlignment, ParagraphAlignment

namespace DirectUI;

// Logic and drawing for an immediate-mode LineEdit control. This class is STATELESS.
// All persistent state is managed in a separate LineEditState object.
internal class InputText
{
    // === MAIN UPDATE && DRAW METHOD ===
    public bool UpdateAndDraw(
        int intId,
        ref string text,
        InputTextState state, // The state is now passed in
        Vector2 position,
        Vector2 size,
        ButtonStylePack? theme,
        string placeholderText,
        bool isPassword,
        char passwordChar,
        int maxLength,
        bool disabled,
        Vector2 textMargin)
    {
        var context = UI.Context;
        var uiState = UI.State;
        var renderer = context.Renderer;
        var textService = context.TextService;
        var input = context.InputState;

        var themeId = HashCode.Combine(intId, "theme");
        var finalTheme = theme ?? uiState.GetOrCreateElement<ButtonStylePack>(themeId);

        // If no specific theme was provided, configure the default one for a LineEdit look.
        if (theme is null)
        {
            // This setup runs once per widget instance and is then cached.
            finalTheme.Roundness = 0f;
            finalTheme.BorderLength = 1f;

            // Normal state (inset look)
            finalTheme.Normal.FillColor = DefaultTheme.NormalBorder; // Very dark, same as window border
            finalTheme.Normal.BorderColor = Colors.Black;

            // Hover state (subtle brightening)
            finalTheme.Hover.FillColor = new Color4(35 / 255f, 35 / 255f, 35 / 255f, 1.0f);
            finalTheme.Hover.BorderColor = Colors.Black;

            // Focused state (bright border)
            finalTheme.Focused.FillColor = finalTheme.Normal.FillColor;
            finalTheme.Focused.BorderColor = DefaultTheme.FocusBorder;

            // Disabled state
            finalTheme.Disabled.FillColor = finalTheme.Normal.FillColor;
            finalTheme.Disabled.BorderColor = new Color4(48 / 255f, 48 / 255f, 48 / 255f, 1.0f);
        }

        Rect bounds = new(position.X, position.Y, size.X, size.Y);
        bool textChanged = false;

        // --- Focus Management && Caret Placement on Click ---
        bool isHovering = bounds.Contains(input.MousePosition.X, input.MousePosition.Y);
        bool isActive = uiState.ActivelyPressedElementId == intId;

        // BUG FIX: Handle losing active press state on mouse up.
        // Without this, the control would lock all other input after being clicked.
        if (isActive && !input.IsLeftMouseDown)
        {
            uiState.ClearActivePress(intId);
        }

        if (input.WasLeftMousePressedThisFrame && isHovering && !disabled)
        {
            uiState.SetFocus(intId);
            uiState.SetPotentialCaptorForFrame(intId); // Claim the press

            // --- BEGIN: Caret positioning logic on click ---
            // We need to temporarily calculate drawing info here for hit-testing.
            // This is the only place we need to do this, as keyboard input moves the caret programmatically.
            finalTheme.UpdateCurrentStyle(isHovering, false, disabled, true); // We are now focused
            var styleForHitTest = finalTheme.Current;
            var textForHitTest = isPassword ? new string(passwordChar, text.Length) : text;
            var contentRectForHitTest = new Rect(
                bounds.X + textMargin.X,
                bounds.Y + textMargin.Y,
                Math.Max(0, bounds.Width - textMargin.X * 2),
                Math.Max(0, bounds.Height - textMargin.Y * 2)
            );

            // Use ITextService to get the text layout
            var textLayout = textService.GetTextLayout(textForHitTest, styleForHitTest, new(float.MaxValue, size.Y), new Alignment(HAlignment.Left, VAlignment.Center));
            if (textLayout is not null)
            {
                float relativeClickX = input.MousePosition.X - contentRectForHitTest.Left + state.ScrollPixelOffset;
                float relativeClickY = input.MousePosition.Y - contentRectForHitTest.Top;

                var hitTestResult = textLayout.HitTestPoint(new Vector2(relativeClickX, relativeClickY));

                int newCaretPos = hitTestResult.TextPosition;
                if (hitTestResult.IsTrailingHit)
                {
                    newCaretPos++;
                }

                state.CaretPosition = Math.Clamp(newCaretPos, 0, text.Length);

                // Reset blink and update scroll to show caret.
                state.IsBlinkOn = true;
                state.BlinkTimer = 0;
                UpdateView(text, state, size, textMargin);
            }
            // --- END: Caret positioning logic on click ---
        }

        // --- Input Processing ---
        if (uiState.FocusedElementId == intId && !disabled)
        {
            textChanged = ProcessInput(ref text, state, size, maxLength, textMargin, input);
        }

        // --- Drawing ---
        finalTheme.UpdateCurrentStyle(isHovering, false, disabled, uiState.FocusedElementId == intId);
        renderer.DrawBox(bounds, finalTheme.Current);

        // Define content area and clip to it
        Rect contentRect = new Rect(
            bounds.X + textMargin.X,
            bounds.Y + textMargin.Y,
            Math.Max(0, bounds.Width - textMargin.X * 2),
            Math.Max(0, bounds.Height - textMargin.Y * 2)
        );
        renderer.PushClipRect(contentRect, D2D.AntialiasMode.PerPrimitive);

        string textToDraw;
        ButtonStyle styleToDraw;

        if (string.IsNullOrEmpty(text) && !(uiState.FocusedElementId == intId))
        {
            textToDraw = placeholderText;
            styleToDraw = new ButtonStyle(finalTheme.Disabled)
            {
                FontColor = new Color4(100 / 255f, 100 / 255f, 100 / 255f, 1.0f) // Custom placeholder color
            };
        }
        else
        {
            textToDraw = isPassword ? new string(passwordChar, text.Length) : text;
            styleToDraw = finalTheme.Current;
        }

        DrawVisibleText(textToDraw, state, size, styleToDraw, contentRect.TopLeft);

        if (uiState.FocusedElementId == intId && state.IsBlinkOn)
        {
            DrawCaret(textToDraw, state, size, finalTheme.Current, contentRect);
        }

        renderer.PopClipRect();

        return textChanged;
    }

    private bool ProcessInput(ref string text, InputTextState state, Vector2 size, int maxLength, Vector2 textMargin, InputState input)
    {
        bool textChanged = false;

        state.BlinkTimer += UI.Context.DeltaTime;

        if (state.BlinkTimer > 0.5f)
        {
            state.BlinkTimer = 0;
            state.IsBlinkOn = !state.IsBlinkOn;
        }

        bool isCtrlHeld = input.HeldKeys.Contains(Keys.Control);

        if (input.TypedCharacters.Any())
        {
            PushUndoState(text, state);

            foreach (char c in input.TypedCharacters)
            {
                if (text.Length >= maxLength)
                {
                    continue;
                }

                text = text.Insert(state.CaretPosition, c.ToString());
                state.CaretPosition++;
                textChanged = true;
            }
        }

        foreach (var key in input.PressedKeys)
        {
            bool hasChanged = true;
            PushUndoState(text, state); // Push on first key press
            switch (key)
            {
                case Keys.Backspace:
                    if (state.CaretPosition > 0)
                    {
                        int removeCount = 1;
                        if (isCtrlHeld) removeCount = state.CaretPosition - FindPreviousWordStart(text, state.CaretPosition);
                        text = text.Remove(state.CaretPosition - removeCount, removeCount);
                        state.CaretPosition -= removeCount;
                    }
                    break;
                case Keys.Delete:
                    if (state.CaretPosition < text.Length)
                    {
                        int removeCount = 1;
                        if (isCtrlHeld) removeCount = FindNextWordEnd(text, state.CaretPosition) - state.CaretPosition;
                        text = text.Remove(state.CaretPosition, removeCount);
                    }
                    break;
                case Keys.LeftArrow:
                    state.CaretPosition = isCtrlHeld ? FindPreviousWordStart(text, state.CaretPosition) : state.CaretPosition - 1;
                    break;
                case Keys.RightArrow:
                    state.CaretPosition = isCtrlHeld ? FindNextWordEnd(text, state.CaretPosition) : state.CaretPosition + 1;
                    break;
                case Keys.Home: state.CaretPosition = 0; break;
                case Keys.End: state.CaretPosition = text.Length; break;
                case Keys.Z when isCtrlHeld: Undo(ref text, state); break;
                case Keys.Y when isCtrlHeld: Redo(ref text, state); break;
                default: hasChanged = false; break;
            }
            if (hasChanged) textChanged = true;
        }

        state.CaretPosition = Math.Clamp(state.CaretPosition, 0, text.Length);

        if (textChanged || input.PressedKeys.Any(k => k is Keys.LeftArrow or Keys.RightArrow or Keys.Home or Keys.End))
        {
            UpdateView(text, state, size, textMargin);
            state.IsBlinkOn = true;
            state.BlinkTimer = 0;
        }

        return textChanged;
    }

    private static int FindPreviousWordStart(string text, int currentPos)
    {
        if (currentPos == 0)
        {
            return 0;
        }

        int pos = currentPos - 1;
        while (pos > 0 && char.IsWhiteSpace(text[pos])) pos--;
        while (pos > 0 && !char.IsWhiteSpace(text[pos - 1])) pos--;
        return pos;
    }

    private static int FindNextWordEnd(string text, int currentPos)
    {
        if (currentPos >= text.Length)
        {
            return text.Length;
        }

        int pos = currentPos;
        while (pos < text.Length && !char.IsWhiteSpace(text[pos])) pos++;
        while (pos < text.Length && char.IsWhiteSpace(text[pos])) pos++;
        return pos;
    }

    private void DrawVisibleText(string fullText, InputTextState state, Vector2 size, ButtonStyle style, Vector2 contentTopLeft)
    {
        if (string.IsNullOrEmpty(fullText))
        {
            return;
        }

        var context = UI.Context;
        var renderer = context.Renderer;
        var textService = context.TextService;

        // The LineEdit widget uses ITextLayout for hit-testing and caret position calculations.
        // Even though IRenderer now takes raw text for drawing, ITextLayout is still relevant for widget logic.
        var textLayout = textService.GetTextLayout(fullText, style, new(float.MaxValue, size.Y), new Alignment(HAlignment.Left, VAlignment.Center));

        if (textLayout is null) return;

        // A small vertical adjustment to compensate for font metrics making text appear slightly too low when using ParagraphAlignment.Center.
        const float yOffsetCorrection = -1.5f;

        // Calculate the drawing origin by applying scroll offset directly.
        Vector2 drawOrigin = new Vector2(contentTopLeft.X - state.ScrollPixelOffset, contentTopLeft.Y + yOffsetCorrection);

        // Renderer's DrawText method now takes full text parameters.
        renderer.DrawText(drawOrigin, fullText, style, new Alignment(HAlignment.Left, VAlignment.Center), new Vector2(float.MaxValue, size.Y), style.FontColor);
    }

    private void DrawCaret(string text, InputTextState state, Vector2 size, ButtonStyle style, Rect contentRect)
    {
        var textService = UI.Context.TextService;
        var renderer = UI.Context.Renderer;

        // Use ITextService to get the text layout
        var textLayout = textService.GetTextLayout(text, style, new(float.MaxValue, size.Y), new Alignment(HAlignment.Left, VAlignment.Center));
        if (textLayout is null) return;

        // HitTestTextPosition on the ITextLayout (DirectWriteTextLayout provides this)
        var hitTestMetrics = textLayout.HitTestTextPosition(state.CaretPosition, false);

        float caretX = contentRect.Left + hitTestMetrics.Point.X - state.ScrollPixelOffset;
        Rect caretRect = new Rect(caretX, contentRect.Top, 1, contentRect.Height);

        renderer.DrawBox(caretRect, new BoxStyle { FillColor = style.FontColor, Roundness = 0f, BorderLength = 0f });
    }

    private ITextLayout? GetTextLayout(string text, Vector2 size, ButtonStyle style, float maxWidth)
    {
        // LineEdit needs to re-layout text based on user input, so it requests a fresh layout from the service.
        // The ITextService handles the caching internally for performance.
        return UI.Context.TextService.GetTextLayout(text, style, new(maxWidth, size.Y), new Alignment(HAlignment.Left, VAlignment.Center));
    }

    private void UpdateView(string text, InputTextState state, Vector2 size, Vector2 textMargin)
    {
        float availableWidth = size.X - textMargin.X * 2;
        var style = new ButtonStyle(); // A default style is fine for measuring

        var textLayout = UI.Context.TextService.GetTextLayout(text, style, new(float.MaxValue, size.Y), new Alignment(HAlignment.Left, VAlignment.Center));
        if (textLayout is null) return;

        var hitTestMetrics = textLayout.HitTestTextPosition(state.CaretPosition, false);
        float caretAbsoluteX = hitTestMetrics.Point.X;

        if (caretAbsoluteX - state.ScrollPixelOffset > availableWidth)
        {
            state.ScrollPixelOffset = caretAbsoluteX - availableWidth;
        }
        else if (caretAbsoluteX - state.ScrollPixelOffset < 0)
        {
            state.ScrollPixelOffset = caretAbsoluteX;
        }

        float maxScroll = Math.Max(0, textLayout.Size.X - availableWidth);
        state.ScrollPixelOffset = Math.Clamp(state.ScrollPixelOffset, 0, maxScroll);
    }

    private static void PushUndoState(string text, InputTextState state)
    {
        var lastState = state.UndoStack.Count > 0 ? state.UndoStack.Peek() : default;
        if (state.UndoStack.Count > 0 && lastState.Text == text && lastState.CaretPosition == state.CaretPosition) return;

        if (state.UndoStack.Count >= InputTextState.HistoryLimit) state.UndoStack.Pop();
        state.UndoStack.Push(new LineEditUndoRecord(text, state.CaretPosition, state.ScrollPixelOffset));
        state.RedoStack.Clear();
    }

    private static void Undo(ref string text, InputTextState state)
    {
        if (state.UndoStack.Count == 0) return;
        state.RedoStack.Push(new LineEditUndoRecord(text, state.CaretPosition, state.ScrollPixelOffset));
        var lastState = state.UndoStack.Pop();
        text = lastState.Text;
        state.CaretPosition = lastState.CaretPosition;
        state.ScrollPixelOffset = lastState.ScrollPixelOffset;
    }

    private static void Redo(ref string text, InputTextState state)
    {
        if (state.RedoStack.Count == 0) return;
        state.UndoStack.Push(new LineEditUndoRecord(text, state.CaretPosition, state.ScrollPixelOffset));
        var nextState = state.RedoStack.Pop();
        text = nextState.Text;
        state.CaretPosition = nextState.CaretPosition;
        state.ScrollPixelOffset = nextState.ScrollPixelOffset;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\InputTextState.cs">
using System.Collections.Generic;

namespace DirectUI;

internal record struct LineEditUndoRecord(string Text, int CaretPosition, float ScrollPixelOffset);

internal class InputTextState
{
    internal int CaretPosition;
    internal float ScrollPixelOffset;

    internal float BlinkTimer;
    internal bool IsBlinkOn = true;

    internal readonly Stack<LineEditUndoRecord> UndoStack = new();
    internal readonly Stack<LineEditUndoRecord> RedoStack = new();
    internal const int HistoryLimit = 50;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\InternalComboboxLogic.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

/// <summary>
/// Provides the internal logic for the combobox widget, including managing popup state.
/// </summary>
internal class InternalComboboxLogic
{
    public int UpdateAndDraw(
        int id,
        int selectedIndex,
        string[] items,
        Vector2 position,
        Vector2 size,
        ButtonStylePack? theme,
        bool disabled)
    {
        var context = UI.Context;
        var state = UI.State;
        var renderer = context.Renderer; // Get the renderer from the context

        int newSelectedIndex = selectedIndex;

        // If a selection was made in the popup during the last frame's EndFrame,
        // the result will be available now for us to consume.
        if (state.PopupResultAvailable && state.PopupResultOwnerId == id)
        {
            newSelectedIndex = state.PopupResult;
        }

        var comboboxState = state.GetOrCreateElement<ComboboxState>(id);
        var themeId = HashCode.Combine(id, "theme");
        var finalTheme = theme ?? state.GetOrCreateElement<ButtonStylePack>(themeId);

        // Sync local open state with global popup state
        if (comboboxState.IsOpen && state.ActivePopupId != id)
        {
            comboboxState.IsOpen = false;
        }

        // The text on the button should reflect the potentially new index
        string currentItemText = (newSelectedIndex >= 0 && newSelectedIndex < items.Length)
            ? items[newSelectedIndex]
            : string.Empty;

        // Draw the main button
        var bounds = new Rect(position.X, position.Y, size.X, size.Y);
        bool clicked = UI.DrawButtonPrimitive(
            id,
            bounds,
            currentItemText,
            finalTheme,
            disabled,
            new Alignment(HAlignment.Left, VAlignment.Center),
            Button.ActionMode.Release,
            Button.ClickBehavior.Left,
            new Vector2(5, 0)
        );

        if (clicked && !disabled)
        {
            if (comboboxState.IsOpen)
            {
                // If it was already open for us, clicking again closes it.
                state.ClearActivePopup();
                comboboxState.IsOpen = false;
            }
            else
            {
                // Request to open the popup.
                // First, ensure any other popups are closed.
                state.ClearActivePopup();

                // Calculate popup properties
                float popupY = position.Y + size.Y + 2;
                float itemHeight = size.Y; // Items are same height as the button
                float popupHeight = items.Length * itemHeight;
                var popupBounds = new Rect(position.X, popupY, size.X, popupHeight);

                // Define the draw callback for the popup, which runs at EndFrame
                Action<UIContext> drawCallback = (ctx) =>
                {
                    // Draw popup background using the renderer
                    var popupStyle = new BoxStyle { FillColor = DefaultTheme.NormalFill, BorderColor = DefaultTheme.FocusBorder, BorderLength = 1f, Roundness = 0f };
                    ctx.Renderer.DrawBox(popupBounds, popupStyle);

                    // Draw items
                    for (int i = 0; i < items.Length; i++)
                    {
                        var itemBounds = new Rect(popupBounds.X, popupBounds.Y + i * itemHeight, popupBounds.Width, itemHeight);
                        var itemTheme = new ButtonStylePack { Roundness = 0f, BorderLength = 0f };
                        itemTheme.Normal.FillColor = Colors.Transparent;
                        itemTheme.Hover.FillColor = DefaultTheme.HoverFill;
                        itemTheme.Pressed.FillColor = DefaultTheme.Accent;

                        int itemId = HashCode.Combine(id, "item", i);

                        if (UI.DrawButtonPrimitive(itemId, itemBounds, items[i], itemTheme, false, new Alignment(HAlignment.Left, VAlignment.Center), Button.ActionMode.Release, Button.ClickBehavior.Left, new Vector2(5, 0)))
                        {
                            // A selection was made. Post the result to be picked up next frame.
                            state.SetPopupResult(id, i);

                            // Close the popup.
                            state.ClearActivePopup();
                        }
                    }
                };

                state.SetActivePopup(id, drawCallback, popupBounds);
                comboboxState.IsOpen = true;
            }
        }

        return newSelectedIndex;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\InternalHSliderLogic.cs">
// Widgets/InternalHSliderLogic.cs
using System;
using System.Numerics;
using System.Text.RegularExpressions;
using DirectUI.Core;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

internal class InternalHSliderLogic : InternalSliderLogic
{
    public HSliderDirection Direction { get; set; } = HSliderDirection.LeftToRight;

    protected override void CalculateTrackBounds()
    {
        trackMinBound = trackPosition.X;
        trackMaxBound = trackPosition.X + Size.X;
    }

    protected override float HandleInput(InputState input, float currentValue)
    {
        float newValue = currentValue;
        Vector2 mousePos = input.MousePosition;
        var state = UI.State;

        Vector2 currentGrabberPos = CalculateGrabberPosition(currentValue);
        Rect currentGrabberBounds = new Rect(currentGrabberPos.X, currentGrabberPos.Y, GrabberSize.X, GrabberSize.Y);
        isGrabberHovered = currentGrabberBounds.Contains(mousePos.X, mousePos.Y);

        Rect trackBoundsRect = new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y);
        isTrackHovered = trackBoundsRect.Contains(mousePos.X, mousePos.Y);

        bool isSliderHovered = isGrabberHovered || isTrackHovered;

        if (isSliderHovered)
        {
            state.SetPotentialInputTarget(GlobalIntId);
        }

        if (state.ActivelyPressedElementId == GlobalIntId && !input.IsLeftMouseDown)
        {
            state.ClearActivePress(GlobalIntId);
        }

        if (input.WasLeftMousePressedThisFrame)
        {
            if (isSliderHovered && state.PotentialInputTargetId == GlobalIntId && !state.DragInProgressFromPreviousFrame)
            {
                state.SetPotentialCaptorForFrame(GlobalIntId);
                state.SetFocus(GlobalIntId);

                if (isTrackHovered && !isGrabberHovered)
                {
                    pendingTrackClickValueJump = true;
                    trackClickPosition = Math.Clamp(mousePos.X, trackMinBound, trackMaxBound);
                }
            }
        }

        if (state.ActivelyPressedElementId == GlobalIntId && input.IsLeftMouseDown)
        {
            if (!pendingTrackClickValueJump)
            {
                float clampedX = Math.Clamp(mousePos.X, trackMinBound, trackMaxBound);
                newValue = ConvertPositionToValue(clampedX);
                newValue = ApplyStep(newValue);
                newValue = Math.Clamp(newValue, MinValue, MaxValue);
            }
        }

        return newValue;
    }

    protected override float ConvertPositionToValue(float position)
    {
        if (trackMaxBound <= trackMinBound) return MinValue;
        float normalized = (position - trackMinBound) / (trackMaxBound - trackMinBound);
        normalized = Math.Clamp(normalized, 0.0f, 1.0f);
        if (Direction == HSliderDirection.RightToLeft) { normalized = 1.0f - normalized; }
        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return rawValue;
    }
    protected override Vector2 CalculateGrabberPosition(float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0;
        if (Direction == HSliderDirection.RightToLeft) { normalizedValue = 1.0f - normalizedValue; }
        float trackWidth = Size.X;
        float centerX = trackMinBound + normalizedValue * trackWidth;
        float xPos = centerX - (GrabberSize.X / 2.0f);
        float yPos = trackPosition.Y + (Size.Y / 2.0f) - (GrabberSize.Y / 2.0f);
        float minX = trackPosition.X;
        float maxX = trackPosition.X + Size.X - GrabberSize.X;
        if (maxX < minX) maxX = minX;
        xPos = Math.Clamp(xPos, minX, maxX);
        return new Vector2(xPos, yPos);
    }
    protected override void DrawForeground(IRenderer renderer, float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        if (valueRange <= 0 || renderer is null) return;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0.0f;
        float foregroundWidth = Size.X * normalizedValue;
        if (foregroundWidth <= 0.001f) return;
        Rect clipRect;
        if (Direction == HSliderDirection.RightToLeft) { clipRect = new Rect(trackPosition.X + Size.X - foregroundWidth, trackPosition.Y, foregroundWidth, Size.Y); }
        else { clipRect = new Rect(trackPosition.X, trackPosition.Y, foregroundWidth, Size.Y); }

        renderer.PushClipRect(clipRect, D2D.AntialiasMode.Aliased);
        // Changed to explicitly pass float components for Rect constructor
        renderer.DrawBox(new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y), Theme.Foreground);
        renderer.PopClipRect();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\InternalKnobLogic.cs">
using System;
using System.Numerics;
using DirectUI.Core;
using Vortice.Mathematics;

namespace DirectUI;

internal class InternalKnobLogic
{
    private int _id;
    private bool _isPressed;
    private Vector2 _dragStartPosition;
    private float _valueAtDragStart;

    public bool UpdateAndDraw(
        int id,
        ref float currentValue,
        float minValue,
        float maxValue,
        float radius,
        Vector2 position,
        KnobStyle? theme,
        bool disabled,
        float sensitivity = 0.005f)
    {
        _id = id;
        var context = UI.Context;
        var state = UI.State;
        var renderer = context.Renderer;
        var input = context.InputState;

        var themeId = HashCode.Combine(id, "theme");
        var finalTheme = theme ?? state.GetOrCreateElement<KnobStyle>(themeId);
        if (theme is null)
        {
            // Setup a default theme if none is provided
            finalTheme.BaseStyle.FillColor = DefaultTheme.NormalFill;
            finalTheme.BaseStyle.BorderColor = DefaultTheme.NormalBorder;
            finalTheme.BaseStyle.Roundness = 1.0f; // Circle
            finalTheme.BaseStyle.BorderLength = 1.5f;
            finalTheme.IndicatorColor = DefaultTheme.Accent;
            finalTheme.IndicatorThickness = Math.Max(1f, radius * 0.15f);
        }

        bool valueChanged = false;
        Vector2 center = position + new Vector2(radius, radius);
        Rect bounds = new(position.X, position.Y, radius * 2, radius * 2);

        bool isHovering = !disabled && bounds.Contains(input.MousePosition);
        _isPressed = state.ActivelyPressedElementId == _id;

        if (isHovering)
        {
            state.SetPotentialInputTarget(_id);
        }

        if (_isPressed && !input.IsLeftMouseDown)
        {
            state.ClearActivePress(_id);
            _isPressed = false;
        }

        if (!disabled && isHovering && input.WasLeftMousePressedThisFrame && state.PotentialInputTargetId == _id)
        {
            state.SetPotentialCaptorForFrame(_id);
            state.SetFocus(_id);
            _isPressed = true;
            _dragStartPosition = input.MousePosition;
            _valueAtDragStart = currentValue;
        }

        if (_isPressed)
        {
            float deltaY = _dragStartPosition.Y - input.MousePosition.Y; // Inverted for natural feel
            float valueRange = maxValue - minValue;
            float change = deltaY * valueRange * sensitivity;

            float newValue = Math.Clamp(_valueAtDragStart + change, minValue, maxValue);
            if (Math.Abs(newValue - currentValue) > float.Epsilon)
            {
                currentValue = newValue;
                valueChanged = true;
            }
        }
        
        // --- Drawing ---
        // Base
        renderer.DrawBox(bounds, finalTheme.BaseStyle);

        // Indicator
        float normalizedValue = (currentValue - minValue) / (maxValue - minValue);
        float angleRangeRad = finalTheme.AngleRangeDegrees * (float)Math.PI / 180f;
        float startAngleRad = finalTheme.StartAngleDegrees * (float)Math.PI / 180f;
        float currentAngleRad = startAngleRad + (normalizedValue * angleRangeRad);

        Vector2 indicatorStart = center;
        Vector2 indicatorEnd = new(
            center.X + (float)Math.Cos(currentAngleRad) * radius * 0.8f,
            center.Y + (float)Math.Sin(currentAngleRad) * radius * 0.8f
        );

        renderer.DrawLine(indicatorStart, indicatorEnd, finalTheme.IndicatorColor, finalTheme.IndicatorThickness);
        
        return valueChanged;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\InternalScrollBarLogic.cs">
// Widgets/InternalScrollBarLogic.cs
using System;
using System.Numerics;
using Vortice.Mathematics;
using DirectUI.Core; // Ensure this is present for IRenderer

namespace DirectUI;

/// <summary>
/// Internal class that encapsulates the state, logic, and drawing for a proportional scrollbar.
/// </summary>
internal class InternalScrollBarLogic
{
    // --- Configuration (set per-frame) ---
    public Vector2 Position { get; set; }
    public float TrackLength { get; set; }
    public float TrackThickness { get; set; }
    public bool IsVertical { get; set; }
    public float ContentSize { get; set; }
    public float VisibleSize { get; set; }
    public SliderStyle Theme { get; set; } = new();
    public ButtonStylePack ThumbTheme { get; set; } = new();

    // --- Internal State ---
    private int _id;
    private bool _isThumbHovered;
    private bool _isThumbPressed;
    private bool _isFocused;
    private float _dragStartMousePos;
    private float _dragStartScrollOffset;

    /// <summary>
    /// The main update and draw entry point called by the public UI method.
    /// </summary>
    public float UpdateAndDraw(int id, float currentScrollOffset)
    {
        if (VisibleSize >= ContentSize) return 0; // No scrolling needed, offset must be 0.

        _id = id;
        var context = UI.Context;
        var state = UI.State;
        var input = context.InputState;
        var renderer = context.Renderer;

        _isFocused = state.FocusedElementId == _id;
        float newScrollOffset = HandleInput(input, currentScrollOffset);

        _isThumbPressed = state.ActivelyPressedElementId == _id;
        ThumbTheme.UpdateCurrentStyle(_isThumbHovered, _isThumbPressed, false, _isFocused);

        if (renderer is not null) // Check if renderer is available
        {
            Draw(renderer, newScrollOffset); // Pass the renderer instance
        }

        return newScrollOffset;
    }

    private Rect GetTrackBounds()
    {
        return IsVertical
            ? new Rect(Position.X, Position.Y, TrackThickness, TrackLength)
            : new Rect(Position.X, Position.Y, TrackLength, TrackThickness);
    }

    private Rect GetThumbBounds(float currentScrollOffset, out float thumbLength)
    {
        thumbLength = 0;
        if (VisibleSize >= ContentSize) return new Rect();

        float viewRatio = VisibleSize / ContentSize;
        thumbLength = TrackLength * viewRatio;
        float minThumbLength = 20f; // Ensure thumb is always grabbable
        thumbLength = Math.Max(minThumbLength, thumbLength);

        float maxScrollOffset = ContentSize - VisibleSize;
        float scrollableTrackLength = TrackLength - thumbLength;

        if (scrollableTrackLength <= 0) return GetTrackBounds();

        float scrollRatio = (maxScrollOffset > 0) ? currentScrollOffset / maxScrollOffset : 0;
        float thumbOffsetInTrack = scrollableTrackLength * scrollRatio;

        return IsVertical
            ? new Rect(Position.X, Position.Y + thumbOffsetInTrack, TrackThickness, thumbLength)
            : new Rect(Position.X + thumbOffsetInTrack, Position.Y, thumbLength, TrackThickness);
    }

    private float HandleInput(InputState input, float currentScrollOffset)
    {
        var state = UI.State;
        var trackBounds = GetTrackBounds();
        var thumbBounds = GetThumbBounds(currentScrollOffset, out float thumbLength);

        _isThumbHovered = thumbBounds.Contains(input.MousePosition);
        bool isTrackHovered = trackBounds.Contains(input.MousePosition);

        if (_isThumbHovered || isTrackHovered)
        {
            state.SetPotentialInputTarget(_id);
        }

        _isThumbPressed = state.ActivelyPressedElementId == _id;

        if (_isThumbPressed && !input.IsLeftMouseDown)
        {
            state.ClearActivePress(_id);
            _isThumbPressed = false;
        }

        if (input.WasLeftMousePressedThisFrame && state.PotentialInputTargetId == _id)
        {
            state.SetPotentialCaptorForFrame(_id);
            state.SetFocus(_id);
            _isThumbPressed = true;

            if (_isThumbHovered)
            {
                _dragStartMousePos = IsVertical ? input.MousePosition.Y : input.MousePosition.X;
                _dragStartScrollOffset = currentScrollOffset;
            }
            else // Clicked on track
            {
                float mousePosOnTrack = IsVertical ? input.MousePosition.Y : input.MousePosition.X;
                float thumbStart = IsVertical ? thumbBounds.Y : thumbBounds.X;
                float thumbEnd = thumbStart + thumbLength;

                float pageAmount = VisibleSize;
                if (mousePosOnTrack < thumbStart)
                {
                    return Math.Max(0, currentScrollOffset - pageAmount);
                }
                else if (mousePosOnTrack > thumbEnd)
                {
                    float maxScroll = ContentSize - VisibleSize;
                    return Math.Min(maxScroll, currentScrollOffset + pageAmount);
                }
            }
        }

        if (_isThumbPressed && input.IsLeftMouseDown)
        {
            float maxScrollOffset = ContentSize - VisibleSize;
            float scrollableTrackLength = TrackLength - thumbLength;
            if (scrollableTrackLength <= 0) return currentScrollOffset;

            float currentMousePos = IsVertical ? input.MousePosition.Y : input.MousePosition.X;
            float mouseDelta = currentMousePos - _dragStartMousePos;

            float scrollDelta = mouseDelta * (maxScrollOffset / scrollableTrackLength);

            float newScrollOffset = _dragStartScrollOffset + scrollDelta;
            return Math.Clamp(newScrollOffset, 0, maxScrollOffset);
        }

        return currentScrollOffset;
    }

    private void Draw(IRenderer renderer, float currentScrollOffset) // Changed ID2D1RenderTarget to IRenderer
    {
        // Draw Track
        renderer.DrawBox(GetTrackBounds(), Theme.Background);

        // Draw Thumb
        var thumbBounds = GetThumbBounds(currentScrollOffset, out _);
        if (thumbBounds.Width > 0 && thumbBounds.Height > 0)
        {
            var thumbStyle = new BoxStyle
            {
                FillColor = ThumbTheme.Current.FillColor,
                BorderColor = ThumbTheme.Current.BorderColor,
                BorderLength = ThumbTheme.Current.BorderLength,
                Roundness = ThumbTheme.Current.Roundness
            };
            // Convert Vortice.Mathematics.Rect to System.Numerics.Vector2 for size
            renderer.DrawBox(new Rect(thumbBounds.X, thumbBounds.Y, thumbBounds.Width, thumbBounds.Height), thumbStyle);
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\InternalSliderLogic.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;
using DirectUI.Core;

namespace DirectUI;

internal abstract class InternalSliderLogic
{
    // --- Configuration ---
    public Vector2 Position { get; set; }
    public Vector2 Size { get; set; }
    public Vector2 Origin { get; set; }
    public float MinValue { get; set; }
    public float MaxValue { get; set; }
    public float Step { get; set; }
    public SliderStyle Theme { get; set; } = new();
    public ButtonStylePack GrabberTheme { get; set; } = new();
    public Vector2 GrabberSize { get; set; } = new(16, 16);
    public bool Disabled { get; set; }
    public object? UserData { get; set; }

    // --- Internal State ---
    protected bool isGrabberPressed = false;
    protected bool isGrabberHovered = false;
    protected bool isTrackHovered = false;
    protected bool isFocused = false;
    protected Vector2 trackPosition;
    protected float trackMinBound;
    protected float trackMaxBound;
    protected bool pendingTrackClickValueJump = false;
    protected float trackClickPosition = 0f;
    protected int GlobalIntId { get; private set; } = 0;


    // --- Calculated Properties ---
    public Rect GlobalBounds => new(Position.X - Origin.X, Position.Y - Origin.Y, Size.X, Size.Y);

    // --- Abstract Methods ---
    protected abstract void CalculateTrackBounds();
    protected abstract float HandleInput(InputState input, float currentValue);
    protected abstract float ConvertPositionToValue(float position);
    protected abstract Vector2 CalculateGrabberPosition(float currentValue);
    protected abstract void DrawForeground(IRenderer renderer, float currentValue);


    // --- Common Logic ---
    internal float UpdateAndDraw(int id, float currentValue)
    {
        var context = UI.Context;
        var state = UI.State;
        var renderer = context.Renderer;

        GlobalIntId = id;
        isFocused = state.FocusedElementId == GlobalIntId;
        trackPosition = Position - Origin;
        CalculateTrackBounds();

        pendingTrackClickValueJump = false;
        float newValue = currentValue;

        if (Disabled)
        {
            isGrabberHovered = false;
            isGrabberPressed = false;
            isTrackHovered = false;
            if (state.ActivelyPressedElementId == GlobalIntId) state.ClearActivePress(GlobalIntId);
        }
        else
        {
            newValue = HandleInput(context.InputState, currentValue);
        }

        if (pendingTrackClickValueJump && state.InputCaptorId == GlobalIntId && !state.NonSliderElementClaimedPress)
        {
            newValue = ConvertPositionToValue(trackClickPosition);
            newValue = ApplyStep(newValue);
            newValue = Math.Clamp(newValue, MinValue, MaxValue);
        }
        pendingTrackClickValueJump = false;

        UpdateGrabberThemeStyle();

        if (renderer is null)
        {
            Console.WriteLine("Error: Renderer is null during Slider UpdateAndDraw.");
            return newValue;
        }

        try
        {
            DrawBackground(renderer);
            DrawForeground(renderer, newValue);
            DrawGrabber(renderer, newValue);
        }
        catch (SharpGen.Runtime.SharpGenException ex) when (ex.ResultCode.Code == Vortice.Direct2D1.ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Slider Draw failed (RecreateTarget): {ex.Message}. External cleanup needed.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error drawing slider: {ex.Message}");
        }

        return newValue;
    }

    // --- Helper Methods ---
    protected float ApplyStep(float value)
    {
        float clampedValue = Math.Clamp(value, MinValue, MaxValue);
        if (Step <= 0 || MaxValue <= MinValue)
        {
            return clampedValue;
        }

        float range = MaxValue - MinValue;
        if (range < Step && Step > 0)
        {
            return (value - MinValue < range / 2.0f) ? MinValue : MaxValue;
        }

        float stepsFromMin = (float)Math.Round((clampedValue - MinValue) / Step);
        float steppedValue = MinValue + stepsFromMin * Step;

        return Math.Clamp(steppedValue, MinValue, MaxValue);
    }


    protected void UpdateGrabberThemeStyle()
    {
        isGrabberPressed = UI.State.ActivelyPressedElementId == GlobalIntId;
        isFocused = UI.State.FocusedElementId == GlobalIntId;
        GrabberTheme.UpdateCurrentStyle(isGrabberHovered, isGrabberPressed, Disabled, isFocused);
    }


    // --- Drawing Methods ---
    protected void DrawBackground(IRenderer renderer)
    {
        // Explicitly pass X, Y, Width, Height components to Rect constructor
        renderer.DrawBox(new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y), Theme.Background);
    }

    protected void DrawGrabber(IRenderer renderer, float currentValue)
    {
        Vector2 grabberPos = CalculateGrabberPosition(currentValue);
        // Explicitly pass X, Y, Width, Height components to Rect constructor
        renderer.DrawBox(new Rect(grabberPos.X, grabberPos.Y, GrabberSize.X, GrabberSize.Y), GrabberTheme.Current);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\InternalVSlider.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;
using DirectUI.Core; // Added for IRenderer
using D2D = Vortice.Direct2D1; // Added this using directive

namespace DirectUI;

internal class InternalVSliderLogic : InternalSliderLogic
{
    public VSliderDirection Direction { get; set; } = VSliderDirection.TopToBottom;

    protected override void CalculateTrackBounds()
    {
        trackMinBound = trackPosition.Y;
        trackMaxBound = trackPosition.Y + Size.Y;
    }

    protected override float HandleInput(InputState input, float currentValue)
    {
        float newValue = currentValue;
        Vector2 mousePos = input.MousePosition;
        var state = UI.State;

        Vector2 currentGrabberPos = CalculateGrabberPosition(currentValue);
        Rect currentGrabberBounds = new Rect(currentGrabberPos.X, currentGrabberPos.Y, GrabberSize.X, GrabberSize.Y);
        isGrabberHovered = currentGrabberBounds.Contains(mousePos.X, mousePos.Y);

        Rect trackBoundsRect = new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y);
        isTrackHovered = trackBoundsRect.Contains(mousePos.X, mousePos.Y);

        bool isSliderHovered = isGrabberHovered || isTrackHovered;

        if (isSliderHovered)
        {
            state.SetPotentialInputTarget(GlobalIntId);
        }

        if (state.ActivelyPressedElementId == GlobalIntId && !input.IsLeftMouseDown)
        {
            state.ClearActivePress(GlobalIntId);
        }

        if (input.WasLeftMousePressedThisFrame)
        {
            if (isSliderHovered && state.PotentialInputTargetId == GlobalIntId && !state.DragInProgressFromPreviousFrame)
            {
                state.SetPotentialCaptorForFrame(GlobalIntId);
                state.SetFocus(GlobalIntId);

                if (isTrackHovered && !isGrabberHovered)
                {
                    pendingTrackClickValueJump = true;
                    trackClickPosition = Math.Clamp(mousePos.Y, trackMinBound, trackMaxBound);
                }
            }
        }

        if (state.ActivelyPressedElementId == GlobalIntId && input.IsLeftMouseDown)
        {
            if (!pendingTrackClickValueJump)
            {
                float clampedY = Math.Clamp(mousePos.Y, trackMinBound, trackMaxBound);
                newValue = ConvertPositionToValue(clampedY);
                newValue = ApplyStep(newValue);
                newValue = Math.Clamp(newValue, MinValue, MaxValue);
            }
        }

        return newValue;
    }

    protected override float ConvertPositionToValue(float position)
    {
        if (trackMaxBound <= trackMinBound) return MinValue;
        float normalized = (position - trackMinBound) / (trackMaxBound - trackMinBound);
        normalized = Math.Clamp(normalized, 0.0f, 1.0f);
        if (Direction == VSliderDirection.BottomToTop) { normalized = 1.0f - normalized; }
        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return rawValue;
    }
    protected override Vector2 CalculateGrabberPosition(float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0;
        if (Direction == VSliderDirection.BottomToTop) { normalizedValue = 1.0f - normalizedValue; }
        float trackHeight = Size.Y;
        float centerY = trackMinBound + normalizedValue * trackHeight;
        float yPos = centerY - (GrabberSize.Y / 2.0f);
        float xPos = trackPosition.X + (Size.X / 2.0f) - (GrabberSize.X / 2.0f);
        float minY = trackPosition.Y;
        float maxY = trackPosition.Y + Size.Y - GrabberSize.Y;
        if (maxY < minY) maxY = minY;
        yPos = Math.Clamp(yPos, minY, maxY);
        return new Vector2(xPos, yPos);
    }
    protected override void DrawForeground(IRenderer renderer, float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        if (valueRange <= 0 || renderer is null) return;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0.0f;
        float foregroundHeight = Size.Y * normalizedValue;
        if (foregroundHeight <= 0.001f) return;
        Rect clipRect;
        if (Direction == VSliderDirection.BottomToTop) { clipRect = new Rect(trackPosition.X, trackPosition.Y + Size.Y - foregroundHeight, Size.X, foregroundHeight); }
        else { clipRect = new Rect(trackPosition.X, trackPosition.Y, Size.X, foregroundHeight); }
        renderer.PushClipRect(clipRect, D2D.AntialiasMode.Aliased);
        renderer.DrawBox(new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y), Theme.Foreground);
        renderer.PopClipRect();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\SliderDirection.cs">
namespace DirectUI;

public enum HSliderDirection { LeftToRight, RightToLeft }
public enum VSliderDirection { TopToBottom, BottomToTop }
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\TabBarState.cs">
namespace DirectUI;

internal class TabBarState
{
    internal float CachedUniformWidth = -1f;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Widgets\TreeNode.cs">
using System.Collections.Generic;

namespace DirectUI;

/// <summary>
/// Represents a node in a generic tree structure.
/// </summary>
/// <typeparam name="T">The type of the user data associated with the node.</typeparam>
public class TreeNode<T>
{
    public string Text { get; set; }
    public T UserData { get; set; }
    public bool IsExpanded { get; set; }
    public List<TreeNode<T>> Children { get; } = new();

    public TreeNode(string text, T userData, bool expanded = false)
    {
        Text = text;
        UserData = userData;
        IsExpanded = expanded;
    }

    /// <summary>
    /// Adds a new child node to this node.
    /// </summary>
    /// <param name="text">The display text of the child node.</param>
    /// <param name="userData">The user data associated with the child node.</param>
    /// <param name="expanded">Whether the child node is expanded by default.</param>
    /// <returns>The newly created child node.</returns>
    public TreeNode<T> AddChild(string text, T userData, bool expanded = false)
    {
        var child = new TreeNode<T>(text, userData, expanded);
        Children.Add(child);
        return child;
    }

    /// <summary>
    /// Adds an existing TreeNode as a child of this node.
    /// </summary>
    /// <param name="child">The child node to add.</param>
    /// <returns>The added child node.</returns>
    public TreeNode<T> AddChild(TreeNode<T> child)
    {
        Children.Add(child);
        return child;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Direct2D\Direct2DRenderer.cs">
using System.Numerics;
using DirectUI.Core;
using SharpGen.Runtime;
using Vortice.Direct2D1;
using Vortice.Direct3D;
using Vortice.Direct3D11;
using Vortice.DirectWrite;
using Vortice.DXGI;
using Vortice.Mathematics;
using InputElementDescription = Vortice.Direct3D11.InputElementDescription;

namespace DirectUI.Backends;

/// <summary>
/// A rendering backend that uses Direct2D to implement the IRenderer interface.
/// It now holds a reference to the DuiGraphicsDevice to ensure it always uses a valid render target.
/// </summary>
public class Direct2DRenderer : IRenderer
{
    private readonly DuiGraphicsDevice _graphicsDevice;
    private readonly Dictionary<Color, ID2D1SolidColorBrush> _brushCache = new();

    // D3D resources for the cube
    private ID3D11Buffer? _cubeVertexBuffer;
    private ID3D11Buffer? _cubeIndexBuffer;
    private ID3D11Buffer? _cubeConstantBuffer;
    private ID3D11VertexShader? _cubeVertexShader;
    private ID3D11PixelShader? _cubePixelShader;
    private ID3D11InputLayout? _cubeInputLayout;
    private ID3D11RasterizerState? _cubeRasterizerState;
    private ID3D11DepthStencilState? _cubeDepthStencilState;


    // Internal text layout cache for DrawText method
    private readonly Dictionary<TextLayoutCacheKey, IDWriteTextLayout> _textLayoutCache = new();
    private readonly Dictionary<FontKey, IDWriteTextFormat> _textFormatCache = new();

    // Internal cache key for text layouts (similar to UIResources.TextLayoutCacheKey)
    private readonly struct TextLayoutCacheKey : IEquatable<TextLayoutCacheKey>
    {
        public readonly string Text;
        public readonly FontKey FontKey;
        public readonly Vector2 MaxSize;
        public readonly HAlignment HAlign;
        public readonly VAlignment VAlign;

        public TextLayoutCacheKey(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment)
        {
            Text = text;
            FontKey = new FontKey(style);
            MaxSize = maxSize;
            HAlign = alignment.Horizontal;
            VAlign = alignment.Vertical;
        }

        public bool Equals(TextLayoutCacheKey other) => Text == other.Text && MaxSize.Equals(other.MaxSize) && HAlign == other.HAlign && VAlign == other.VAlign && FontKey.Equals(other.FontKey);
        public override bool Equals(object? obj) => obj is TextLayoutCacheKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(Text, FontKey, MaxSize, HAlign, VAlign);
    }

    private readonly struct FontKey : IEquatable<FontKey>
    {
        public readonly string FontName;
        public readonly float FontSize;
        public readonly FontWeight FontWeight;
        public readonly FontStyle FontStyle;
        public readonly FontStretch FontStretch;

        public FontKey(ButtonStyle style)
        {
            FontName = style.FontName;
            FontSize = style.FontSize;
            FontWeight = style.FontWeight;
            FontStyle = style.FontStyle;
            FontStretch = style.FontStretch;
        }

        public bool Equals(FontKey other) => FontName == other.FontName && FontSize.Equals(other.FontSize) && FontWeight == other.FontWeight && FontStyle == other.FontStyle && FontStretch == other.FontStretch;
        public override bool Equals(object? obj) => obj is FontKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(FontName, FontSize, FontWeight, FontStyle, FontStretch);
    }


    public Vector2 RenderTargetSize
    {
        get
        {
            if (_graphicsDevice.RenderTarget is null)
            {
                return Vector2.Zero;
            }
            var size = _graphicsDevice.RenderTarget.Size;
            return new Vector2(size.Width, size.Height);
        }
    }

    public Direct2DRenderer(DuiGraphicsDevice graphicsDevice)
    {
        _graphicsDevice = graphicsDevice ?? throw new ArgumentNullException(nameof(graphicsDevice));
        CreateCubeResources();
    }

    public void DrawLine(Vector2 p1, Vector2 p2, Drawing.Color color, float strokeWidth)
    {
        var renderTarget = _graphicsDevice.RenderTarget;
        if (renderTarget is null) return;

        var brush = GetOrCreateBrush(color);
        if (brush is null) return;
        renderTarget.DrawLine(p1, p2, brush, strokeWidth);
    }

    public void DrawBox(Vortice.Mathematics.Rect rect, BoxStyle style)
    {
        var renderTarget = _graphicsDevice.RenderTarget;
        if (renderTarget is null || style is null || rect.Width <= 0 || rect.Height <= 0) return;

        var pos = rect.TopLeft;
        var size = new Vector2(rect.Width, rect.Height);

        ID2D1SolidColorBrush? fillBrush = GetOrCreateBrush(style.FillColor);
        ID2D1SolidColorBrush? borderBrush = GetOrCreateBrush(style.BorderColor);

        float borderTop = Math.Max(0f, style.BorderLengthTop);
        float borderRight = Math.Max(0f, style.BorderLengthRight);
        float borderBottom = Math.Max(0f, style.BorderLengthBottom);
        float borderLeft = Math.Max(0f, style.BorderLengthLeft);

        bool hasVisibleFill = style.FillColor.A > 0 && fillBrush is not null;
        bool hasVisibleBorder = style.BorderColor.A > 0 && borderBrush is not null && (borderTop > 0 || borderRight > 0 || borderBottom > 0 || borderLeft > 0);

        if (!hasVisibleFill && !hasVisibleBorder) return;

        if (style.Roundness > 0.0f)
        {
            Vortice.Mathematics.Rect outerBounds = new Vortice.Mathematics.Rect(pos.X, pos.Y, size.X, size.Y);
            float maxRadius = Math.Min(outerBounds.Width * 0.5f, outerBounds.Height * 0.5f);
            float radius = Math.Max(0f, maxRadius * Math.Clamp(style.Roundness, 0.0f, 1.0f));

            if (float.IsFinite(radius) && radius >= 0)
            {
                if (hasVisibleBorder)
                {
                    System.Drawing.RectangleF outerRectF = new(outerBounds.X, outerBounds.Y, outerBounds.Width, outerBounds.Height);
                    renderTarget.FillRoundedRectangle(new RoundedRectangle(outerRectF, radius, radius), borderBrush);
                }
                if (hasVisibleFill)
                {
                    float fillX = pos.X + borderLeft;
                    float fillY = pos.Y + borderTop;
                    float fillWidth = Math.Max(0f, size.X - borderLeft - borderRight);
                    float fillHeight = Math.Max(0f, size.Y - borderTop - borderBottom);
                    if (fillWidth > 0 && fillHeight > 0)
                    {
                        float avgBorderX = (borderLeft + borderRight) * 0.5f;
                        float avgBorderY = (borderTop + borderBottom) * 0.5f;
                        float innerRadiusX = Math.Max(0f, radius - avgBorderX);
                        float innerRadiusY = Math.Max(0f, radius - avgBorderY);
                        System.Drawing.RectangleF fillRectF = new(fillX, fillY, fillWidth, fillHeight);
                        renderTarget.FillRoundedRectangle(new RoundedRectangle(fillRectF, innerRadiusX, innerRadiusY), fillBrush);
                    }
                    else if (!hasVisibleBorder && fillBrush is not null)
                    {
                        System.Drawing.RectangleF outerRectF = new(outerBounds.X, outerBounds.Y, outerBounds.Width, outerBounds.Height);
                        renderTarget.FillRoundedRectangle(new RoundedRectangle(outerRectF, radius, radius), fillBrush);
                    }
                }
                return;
            }
        }
        if (hasVisibleBorder && borderBrush is not null)
        {
            renderTarget.FillRectangle(rect, borderBrush);
        }
        if (hasVisibleFill)
        {
            float fillX = pos.X + borderLeft;
            float fillY = pos.Y + borderTop;
            float fillWidth = Math.Max(0f, size.X - borderLeft - borderRight);
            float fillHeight = Math.Max(0f, size.Y - borderTop - borderBottom);
            if (fillWidth > 0 && fillHeight > 0)
            {
                renderTarget.FillRectangle(new Vortice.Mathematics.Rect(fillX, fillY, fillWidth, fillHeight), fillBrush);
            }
            else if (!hasVisibleBorder && fillBrush is not null)
            {
                renderTarget.FillRectangle(rect, fillBrush);
            }
        }
    }

    public void DrawText(Vector2 origin, string text, ButtonStyle style, Alignment alignment, Vector2 maxSize, Drawing.Color color)
    {
        var renderTarget = _graphicsDevice.RenderTarget;
        if (renderTarget is null || string.IsNullOrEmpty(text)) return;

        var textBrush = GetOrCreateBrush(color);
        if (textBrush is null) return;

        var layoutKey = new TextLayoutCacheKey(text, style, maxSize, alignment);
        if (!_textLayoutCache.TryGetValue(layoutKey, out var textLayout))
        {
            var textFormat = GetOrCreateTextFormat(style);
            if (textFormat is null || _graphicsDevice.DWriteFactory is null) return;

            textLayout = _graphicsDevice.DWriteFactory.CreateTextLayout(text, textFormat, maxSize.X, maxSize.Y);
            textLayout.TextAlignment = alignment.Horizontal switch
            {
                HAlignment.Left => Vortice.DirectWrite.TextAlignment.Leading,
                HAlignment.Center => Vortice.DirectWrite.TextAlignment.Center,
                HAlignment.Right => Vortice.DirectWrite.TextAlignment.Trailing,
                _ => Vortice.DirectWrite.TextAlignment.Leading
            };
            textLayout.ParagraphAlignment = alignment.Vertical switch
            {
                VAlignment.Top => ParagraphAlignment.Near,
                VAlignment.Center => ParagraphAlignment.Center,
                VAlignment.Bottom => ParagraphAlignment.Far,
                _ => ParagraphAlignment.Near
            };
            _textLayoutCache[layoutKey] = textLayout;
        }

        // A small vertical adjustment to compensate for font metrics making text appear slightly too low when using ParagraphAlignment.Center.
        float yOffsetCorrection = (alignment.Vertical == VAlignment.Center) ? -1.5f : 0f;

        renderTarget.DrawTextLayout(new Vector2(origin.X, origin.Y + yOffsetCorrection), textLayout, textBrush, Vortice.Direct2D1.DrawTextOptions.None);
    }

    public void PushClipRect(Vortice.Mathematics.Rect rect, AntialiasMode antialiasMode)
    {
        _graphicsDevice.RenderTarget?.PushAxisAlignedClip(rect, antialiasMode);
    }

    public void PopClipRect()
    {
        _graphicsDevice.RenderTarget?.PopAxisAlignedClip();
    }

    public void Flush()
    {
        // Direct2D is an immediate-mode API in this context, no flush needed.
    }

    public void Cleanup()
    {
        foreach (var pair in _brushCache)
        {
            pair.Value?.Dispose();
        }
        _brushCache.Clear();

        foreach (var pair in _textLayoutCache)
        {
            pair.Value?.Dispose();
        }
        _textLayoutCache.Clear();

        foreach (var pair in _textFormatCache)
        {
            pair.Value?.Dispose();
        }
        _textFormatCache.Clear();

        _cubeVertexBuffer?.Dispose();
        _cubeIndexBuffer?.Dispose();
        _cubeConstantBuffer?.Dispose();
        _cubeVertexShader?.Dispose();
        _cubePixelShader?.Dispose();
        _cubeInputLayout?.Dispose();
        _cubeRasterizerState?.Dispose();
        _cubeDepthStencilState?.Dispose();
    }

    private ID2D1SolidColorBrush? GetOrCreateBrush(Drawing.Color color)
    {
        var renderTarget = _graphicsDevice.RenderTarget;
        if (renderTarget is null)
        {
            // Don't log here to avoid spam on resize. The caller will just not draw.
            return null;
        }

        if (_brushCache.TryGetValue(color, out var brush) && brush is not null)
        {
            return brush;
        }

        if (brush is null && _brushCache.ContainsKey(color))
        {
            _brushCache.Remove(color);
        }

        try
        {
            Vortice.Mathematics.Color4 color4 = color;
            brush = renderTarget.CreateSolidColorBrush(color4);
            if (brush is not null)
            {
                _brushCache[color] = brush;
                return brush;
            }

            Console.WriteLine($"Warning: CreateSolidColorBrush returned null for color {color}");
            return null;
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == Vortice.Direct2D1.ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Brush creation failed due to RecreateTarget error (Color: {color}). External cleanup needed.");
            return null;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error creating brush for color {color}: {ex.Message}");
            return null;
        }
    }

    private IDWriteTextFormat? GetOrCreateTextFormat(ButtonStyle style)
    {
        var dwriteFactory = _graphicsDevice.DWriteFactory;
        if (dwriteFactory is null) return null;

        var key = new FontKey(style);
        if (_textFormatCache.TryGetValue(key, out var format))
        {
            return format;
        }

        try
        {
            var newFormat = dwriteFactory.CreateTextFormat(style.FontName, null, style.FontWeight, style.FontStyle, style.FontStretch, style.FontSize, "en-us");
            if (newFormat is not null) { _textFormatCache[key] = newFormat; }
            return newFormat;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error creating text format for font '{style.FontName}': {ex.Message}");
            return null;
        }
    }

    private void CreateCubeResources()
    {
        var d3dDevice = _graphicsDevice.D3DDevice;
        if (d3dDevice is null)
        {
            Console.WriteLine("Cannot create cube resources: D3DDevice is null.");
            return;
        }

        var vertices = new[]
        {
            // Front face (-Z) - Red - (TL, TR, BR, BL) - Clockwise
            new Vector4(-1.0f,  1.0f, -1.0f, 1.0f), new Vector4(1.0f, 0.0f, 0.0f, 1.0f), // 0
            new Vector4( 1.0f,  1.0f, -1.0f, 1.0f), new Vector4(1.0f, 0.0f, 0.0f, 1.0f), // 1
            new Vector4( 1.0f, -1.0f, -1.0f, 1.0f), new Vector4(1.0f, 0.0f, 0.0f, 1.0f), // 2
            new Vector4(-1.0f, -1.0f, -1.0f, 1.0f), new Vector4(1.0f, 0.0f, 0.0f, 1.0f), // 3

            // Back face (+Z) - Green - (TR, TL, BL, BR) - Clockwise
            new Vector4( 1.0f,  1.0f, 1.0f, 1.0f), new Vector4(0.0f, 1.0f, 0.0f, 1.0f), // 4
            new Vector4(-1.0f,  1.0f, 1.0f, 1.0f), new Vector4(0.0f, 1.0f, 0.0f, 1.0f), // 5
            new Vector4(-1.0f, -1.0f, 1.0f, 1.0f), new Vector4(0.0f, 1.0f, 0.0f, 1.0f), // 6
            new Vector4( 1.0f, -1.0f, 1.0f, 1.0f), new Vector4(0.0f, 1.0f, 0.0f, 1.0f), // 7

            // Top face (+Y) - Blue - (TL, TR, BR, BL) - Clockwise
            new Vector4(-1.0f, 1.0f,  1.0f, 1.0f), new Vector4(0.0f, 0.0f, 1.0f, 1.0f), // 8
            new Vector4( 1.0f, 1.0f,  1.0f, 1.0f), new Vector4(0.0f, 0.0f, 1.0f, 1.0f), // 9
            new Vector4( 1.0f, 1.0f, -1.0f, 1.0f), new Vector4(0.0f, 0.0f, 1.0f, 1.0f), // 10
            new Vector4(-1.0f, 1.0f, -1.0f, 1.0f), new Vector4(0.0f, 0.0f, 1.0f, 1.0f), // 11

            // Bottom face (-Y) - Yellow - (BL, BR, TR, TL) - Clockwise
            new Vector4(-1.0f, -1.0f, -1.0f, 1.0f), new Vector4(1.0f, 1.0f, 0.0f, 1.0f), // 12
            new Vector4( 1.0f, -1.0f, -1.0f, 1.0f), new Vector4(1.0f, 1.0f, 0.0f, 1.0f), // 13
            new Vector4( 1.0f, -1.0f,  1.0f, 1.0f), new Vector4(1.0f, 1.0f, 0.0f, 1.0f), // 14
            new Vector4(-1.0f, -1.0f,  1.0f, 1.0f), new Vector4(1.0f, 1.0f, 0.0f, 1.0f), // 15

            // Left face (-X) - Cyan - (TL, TR, BR, BL) - Clockwise
            new Vector4(-1.0f,  1.0f,  1.0f, 1.0f), new Vector4(0.0f, 1.0f, 1.0f, 1.0f), // 16
            new Vector4(-1.0f,  1.0f, -1.0f, 1.0f), new Vector4(0.0f, 1.0f, 1.0f, 1.0f), // 17
            new Vector4(-1.0f, -1.0f, -1.0f, 1.0f), new Vector4(0.0f, 1.0f, 1.0f, 1.0f), // 18
            new Vector4(-1.0f, -1.0f,  1.0f, 1.0f), new Vector4(0.0f, 1.0f, 1.0f, 1.0f), // 19

            // Right face (+X) - Magenta - (TL, TR, BR, BL) - Clockwise
            new Vector4( 1.0f,  1.0f, -1.0f, 1.0f), new Vector4(1.0f, 0.0f, 1.0f, 1.0f), // 20
            new Vector4( 1.0f,  1.0f,  1.0f, 1.0f), new Vector4(1.0f, 0.0f, 1.0f, 1.0f), // 21
            new Vector4( 1.0f, -1.0f,  1.0f, 1.0f), new Vector4(1.0f, 0.0f, 1.0f, 1.0f), // 22
            new Vector4( 1.0f, -1.0f, -1.0f, 1.0f), new Vector4(1.0f, 0.0f, 1.0f, 1.0f)  // 23
        };

        var indices = new ushort[]
        {
            0,  1,  2,      0,  2,  3,    // Front
            4,  5,  6,      4,  6,  7,    // Back
            8,  9,  10,     8,  10, 11,   // Top
            12, 13, 14,     12, 14, 15,  // Bottom
            16, 17, 18,     16, 18, 19,  // Left
            20, 21, 22,     20, 22, 23   // Right
        };

        _cubeVertexBuffer = d3dDevice.CreateBuffer(vertices, BindFlags.VertexBuffer);
        _cubeIndexBuffer = d3dDevice.CreateBuffer(indices, BindFlags.IndexBuffer);

        using var vertexShaderByteCode = ShaderCompiler.Compile(
@"
cbuffer ConstantBuffer : register(b0)
{
    matrix WorldViewProjection;
}

struct VS_Input
{
    float4 Position : POSITION;
    float4 Color : COLOR;
};

struct PS_Input
{
    float4 Position : SV_POSITION;
    float4 Color : COLOR;
};

PS_Input VS(VS_Input input)
{
    PS_Input output;
    output.Position = mul(input.Position, WorldViewProjection);
    output.Color = input.Color;
    return output;
}
", "VS", "vs_5_0");

        using var pixelShaderByteCode = ShaderCompiler.Compile(
@"
struct PS_Input
{
    float4 Position : SV_POSITION;
    float4 Color : COLOR;
};

float4 PS(PS_Input input) : SV_TARGET
{
    return input.Color;
}
", "PS", "ps_5_0");

        byte[] vsBytes = vertexShaderByteCode.AsBytes();
        byte[] psBytes = pixelShaderByteCode.AsBytes();

        _cubeVertexShader = d3dDevice.CreateVertexShader(vsBytes);
        _cubePixelShader = d3dDevice.CreatePixelShader(psBytes);

        var inputElements = new[]
        {
            new InputElementDescription("POSITION", 0, Format.R32G32B32A32_Float, 0, 0),
            new InputElementDescription("COLOR", 0, Format.R32G32B32A32_Float, 16, 0)
        };

        _cubeInputLayout = d3dDevice.CreateInputLayout(inputElements, vsBytes);
        _cubeConstantBuffer = d3dDevice.CreateBuffer(new BufferDescription(64, BindFlags.ConstantBuffer));

        var rasterizerDesc = new RasterizerDescription(CullMode.Back, Vortice.Direct3D11.FillMode.Solid);
        _cubeRasterizerState = d3dDevice.CreateRasterizerState(rasterizerDesc);

        var depthStencilDesc = new DepthStencilDescription
        {
            DepthEnable = true,
            DepthWriteMask = DepthWriteMask.All,
            DepthFunc = ComparisonFunction.Less,
            StencilEnable = false
        };
        _cubeDepthStencilState = d3dDevice.CreateDepthStencilState(depthStencilDesc);
    }


    public void DrawCube()
    {
        var d3dDevice = _graphicsDevice.D3DDevice;
        var d3dContext = _graphicsDevice.D3DContext;
        var swapChain = _graphicsDevice.SwapChain;
        var depthStencilView = _graphicsDevice.DepthStencilView;

        if (d3dDevice is null || d3dContext is null || swapChain is null || depthStencilView is null) return;
        if (_cubeConstantBuffer is null || _cubeInputLayout is null || _cubeVertexShader is null || _cubePixelShader is null || _cubeVertexBuffer is null || _cubeIndexBuffer is null || _cubeRasterizerState is null || _cubeDepthStencilState is null)
        {
            return;
        }

        // --- ASPECT RATIO FIX ---
        // Prevent division by zero if the window is minimized or has zero height.
        if (RenderTargetSize.Y < 1.0f)
        {
            return;
        }

        var view = Matrix4x4.CreateLookAt(new Vector3(0, 0, -5), Vector3.Zero, Vector3.UnitY);

        // --- CHANGE: Switch to Orthographic Projection ---
        // This removes perspective distortion, so faces don't change size based on distance.
        float aspectRatio = RenderTargetSize.X / RenderTargetSize.Y;
        float viewHeight = 4.0f; // Defines the vertical size of the viewing volume
        float viewWidth = viewHeight * aspectRatio;
        var proj = Matrix4x4.CreateOrthographic(viewWidth, viewHeight, 0.1f, 100.0f);
        // --- END CHANGE ---

        var world = Matrix4x4.CreateFromYawPitchRoll(
            (float)DateTime.Now.TimeOfDay.TotalSeconds,
            (float)DateTime.Now.TimeOfDay.TotalSeconds / 2f,
            (float)DateTime.Now.TimeOfDay.TotalSeconds / 3f);

        var worldViewProj = Matrix4x4.Transpose(world * view * proj);
        d3dContext.UpdateSubresource(worldViewProj, _cubeConstantBuffer);

        d3dContext.RSSetViewport(new Viewport(RenderTargetSize.X, RenderTargetSize.Y));
        d3dContext.RSSetState(_cubeRasterizerState);
        d3dContext.OMSetDepthStencilState(_cubeDepthStencilState);

        d3dContext.IASetPrimitiveTopology(PrimitiveTopology.TriangleList);
        d3dContext.IASetInputLayout(_cubeInputLayout);
        d3dContext.VSSetShader(_cubeVertexShader);
        d3dContext.VSSetConstantBuffer(0, _cubeConstantBuffer);
        d3dContext.PSSetShader(_cubePixelShader);
        d3dContext.IASetVertexBuffer(0, _cubeVertexBuffer, 32);
        d3dContext.IASetIndexBuffer(_cubeIndexBuffer, Format.R16_UInt, 0);

        using (var backBuffer = swapChain.GetBuffer<ID3D11Texture2D>(0))
        {
            using var renderTargetView = d3dDevice.CreateRenderTargetView(backBuffer);
            d3dContext.ClearRenderTargetView(renderTargetView, Colors.CornflowerBlue);
            d3dContext.ClearDepthStencilView(depthStencilView, DepthStencilClearFlags.Depth, 1.0f, 0);
            d3dContext.OMSetRenderTargets([renderTargetView], depthStencilView);
            d3dContext.DrawIndexed(36, 0, 0);
        }

        // Unbind render targets before flushing, to release control for Direct2D
        d3dContext.OMSetRenderTargets(new ID3D11RenderTargetView(0));

        // Flush the 3D commands to ensure they are executed before D2D begins drawing.
        d3dContext.Flush();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Direct2D\DirectWriteTextLayout.cs">
// DirectUI/Backends/DirectWriteTextLayout.cs
using System;
using System.Numerics;
using DirectUI.Core;
using Vortice.DirectWrite;
using SharpGen.Runtime;

namespace DirectUI.Backends;

/// <summary>
/// A DirectWrite-specific implementation of the ITextLayout interface.
/// This class wraps an IDWriteTextLayout object. It is internal to the backend.
/// </summary>
internal class DirectWriteTextLayout : ITextLayout
{
    public IDWriteTextLayout DWriteLayout { get; }

    public Vector2 Size { get; }
    public string Text { get; }

    public DirectWriteTextLayout(IDWriteTextLayout dwriteLayout, string text) // Added 'string text' parameter
    {
        DWriteLayout = dwriteLayout;
        Size = new Vector2(dwriteLayout.Metrics.WidthIncludingTrailingWhitespace, dwriteLayout.Metrics.Height);
        Text = text; // Assign the provided text
    }

    public TextHitTestMetrics HitTestTextPosition(int textPosition, bool isTrailingHit)
    {
        DWriteLayout.HitTestTextPosition((uint)textPosition, isTrailingHit, out float x, out float y, out var metrics);
        return new TextHitTestMetrics(new Vector2(x, y), new Vector2(metrics.Width, metrics.Height));
    }

    public TextHitTestResult HitTestPoint(Vector2 point)
    {
        DWriteLayout.HitTestPoint(point.X, point.Y, out RawBool isTrailingHit, out RawBool isInside, out var hitTestMetrics);

        var metrics = new TextHitTestMetrics(
            new Vector2(hitTestMetrics.Left, hitTestMetrics.Top),
            new Vector2(hitTestMetrics.Width, hitTestMetrics.Height)
        );

        return new TextHitTestResult(
            (int)hitTestMetrics.TextPosition,
            isTrailingHit,
            isInside,
            metrics
        );
    }

    public void Dispose()
    {
        DWriteLayout.Dispose();
        GC.SuppressFinalize(this);
    }

    ~DirectWriteTextLayout()
    {
        Dispose();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Direct2D\DirectWriteTextService.cs">
// DirectUI/Backends/DirectWriteTextService.cs
using System;
using System.Collections.Generic;
using System.Numerics;
using DirectUI.Core;
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace DirectUI.Backends;

/// <summary>
/// An implementation of ITextService that uses DirectWrite.
/// It manages caches for text formats, layouts, and measured sizes.
/// </summary>
public class DirectWriteTextService : ITextService
{
    private readonly IDWriteFactory _dwriteFactory;
    private readonly Dictionary<FontKey, IDWriteTextFormat> _textFormatCache = new();
    private readonly Dictionary<TextLayoutCacheKey, ITextLayout> _textLayoutCache = new();
    private readonly Dictionary<(string, FontKey), Vector2> _textSizeCache = new();

    // Internal cache key structs
    internal readonly struct FontKey(ButtonStyle style) : IEquatable<FontKey>
    {
        private readonly string FontName = style.FontName;
        private readonly float FontSize = style.FontSize;
        private readonly FontWeight FontWeight = style.FontWeight;
        private readonly FontStyle FontStyle = style.FontStyle;
        private readonly FontStretch FontStretch = style.FontStretch;
        public bool Equals(FontKey other) => FontName == other.FontName && FontSize.Equals(other.FontSize) && FontWeight == other.FontWeight && FontStyle == other.FontStyle && FontStretch == other.FontStretch;
        public override bool Equals(object? obj) => obj is FontKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(FontName, FontSize, FontWeight, FontStyle, FontStretch);
    }

    internal readonly struct TextLayoutCacheKey(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment) : IEquatable<TextLayoutCacheKey>
    {
        private readonly string Text = text;
        private readonly FontKey FontKey = new(style);
        private readonly Vector2 MaxSize = maxSize;
        private readonly HAlignment HAlign = alignment.Horizontal;
        private readonly VAlignment VAlign = alignment.Vertical;
        public bool Equals(TextLayoutCacheKey other) => Text == other.Text && MaxSize.Equals(other.MaxSize) && HAlign == other.HAlign && VAlign == other.VAlign && FontKey.Equals(other.FontKey);
        public override bool Equals(object? obj) => obj is TextLayoutCacheKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(Text, FontKey, MaxSize, HAlign, VAlign);
    }

    public DirectWriteTextService(IDWriteFactory dwriteFactory)
    {
        _dwriteFactory = dwriteFactory ?? throw new ArgumentNullException(nameof(dwriteFactory));
    }

    public Vector2 MeasureText(string text, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(text) || style is null) return Vector2.Zero;

        var fontKey = new FontKey(style);
        var cacheKey = (text, fontKey);
        if (_textSizeCache.TryGetValue(cacheKey, out var cachedSize)) return cachedSize;

        IDWriteTextFormat? textFormat = GetOrCreateTextFormat(style);
        if (textFormat is null)
        {
            Console.WriteLine("Warning: Failed to create/get TextFormat for measurement.");
            return Vector2.Zero;
        }

        using var textLayout = _dwriteFactory.CreateTextLayout(text, textFormat, float.MaxValue, float.MaxValue);
        TextMetrics textMetrics = textLayout.Metrics;
        var measuredSize = new Vector2(textMetrics.WidthIncludingTrailingWhitespace, textMetrics.Height);
        _textSizeCache[cacheKey] = measuredSize;
        return measuredSize;
    }

    public ITextLayout GetTextLayout(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment)
    {
        var layoutKey = new TextLayoutCacheKey(text, style, maxSize, alignment);
        if (_textLayoutCache.TryGetValue(layoutKey, out var cachedLayout))
        {
            return cachedLayout;
        }

        var textFormat = GetOrCreateTextFormat(style);
        if (textFormat is null) return null!; // Should ideally return a null object or throw.

        var dwriteLayout = _dwriteFactory.CreateTextLayout(text, textFormat, maxSize.X, maxSize.Y);
        dwriteLayout.TextAlignment = alignment.Horizontal switch
        {
            HAlignment.Left => TextAlignment.Leading,
            HAlignment.Center => TextAlignment.Center,
            HAlignment.Right => TextAlignment.Trailing,
            _ => TextAlignment.Leading
        };
        dwriteLayout.ParagraphAlignment = alignment.Vertical switch
        {
            VAlignment.Top => ParagraphAlignment.Near,
            VAlignment.Center => ParagraphAlignment.Center,
            VAlignment.Bottom => ParagraphAlignment.Far,
            _ => ParagraphAlignment.Near
        };

        var newLayout = new DirectWriteTextLayout(dwriteLayout, text); // Passed 'text' as the second argument
        _textLayoutCache[layoutKey] = newLayout;
        return newLayout;
    }

    private IDWriteTextFormat? GetOrCreateTextFormat(ButtonStyle style)
    {
        var key = new FontKey(style);
        if (_textFormatCache.TryGetValue(key, out var format))
        {
            return format;
        }

        try
        {
            var newFormat = _dwriteFactory.CreateTextFormat(style.FontName, null, style.FontWeight, style.FontStyle, style.FontStretch, style.FontSize, "en-us");
            if (newFormat is not null)
            {
                _textFormatCache[key] = newFormat;
            }
            return newFormat;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error creating text format for font '{style.FontName}': {ex.Message}");
            return null;
        }
    }

    public void Cleanup()
    {
        Console.WriteLine("DirectWriteTextService Cleanup: Disposing cached resources...");
        foreach (var pair in _textFormatCache) { pair.Value?.Dispose(); }
        _textFormatCache.Clear();
        foreach (var pair in _textLayoutCache) { pair.Value?.Dispose(); }
        _textLayoutCache.Clear();
        _textSizeCache.Clear();
        Console.WriteLine("DirectWriteTextService Cleanup finished.");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Direct2D\DuiGraphicsDevice.cs">
using DirectUI;
using SharpGen.Runtime;
using Vortice.Direct2D1;
using Vortice.Direct3D;
using Vortice.Direct3D11;
using Vortice.DirectWrite;
using Vortice.DXGI;
using Vortice.Mathematics;

using System;
using Vortice.Direct2D1;
using Vortice.Direct3D;
using Vortice.Direct3D11;
using Vortice.DirectWrite;
using Vortice.DXGI;
using SharpGen.Runtime;
using Vortice.Mathematics;
using Vortice.DCommon;
using D2D = Vortice.Direct2D1;
using DW = Vortice.DirectWrite;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI;

public class DuiGraphicsDevice : IDisposable
{
    public ID2D1Factory1? D2DFactory => SharedGraphicsResources.D2DFactory;
    public IDWriteFactory? DWriteFactory => SharedGraphicsResources.DWriteFactory;
    public ID2D1RenderTarget? RenderTarget { get; private set; }
    public ID3D11Device? D3DDevice { get; private set; }
    public ID3D11DeviceContext? D3DContext { get; private set; }
    public IDXGISwapChain? SwapChain { get; private set; }
    public ID3D11DepthStencilView? DepthStencilView { get; private set; } // Added
    public bool IsInitialized { get; private set; } = false;

    private ID3D11Texture2D? _depthStencilBuffer; // Added
    private bool _isDisposed = false;

    public bool VSync { get; set; } = false;

    public bool Initialize(IntPtr hwnd, SizeI size)
    {
        if (IsInitialized) return true;
        if (hwnd == IntPtr.Zero) return false;

        Console.WriteLine($"Attempting Graphics Initialization for HWND {hwnd} with size {size}...");
        try
        {
            // Clean up any previous (potentially invalid) instance resources
            CleanupRenderTarget();

            if (D2DFactory is null || DWriteFactory is null)
            {
                throw new InvalidOperationException("Shared graphics factories are not initialized. Application.Run() must be called first.");
            }

            if (size.Width <= 0 || size.Height <= 0)
            {
                Console.WriteLine($"Invalid client rect size ({size}). Aborting graphics initialization.");
                return false;
            }

            var swapChainDesc = new SwapChainDescription()
            {
                BufferCount = 1,
                BufferDescription = new ModeDescription((uint)size.Width, (uint)size.Height, Format.B8G8R8A8_UNorm),
                BufferUsage = Usage.RenderTargetOutput,
                OutputWindow = hwnd,
                SampleDescription = new SampleDescription(1, 0),
                Windowed = true
            };

            D3D11.D3D11CreateDeviceAndSwapChain(
                null,
                DriverType.Hardware,
                DeviceCreationFlags.BgraSupport,
                null,
                swapChainDesc,
                out var swapChain,
                out var d3dDevice,
                out _,
                out var d3dContext).CheckError();

            SwapChain = swapChain;
            D3DDevice = d3dDevice;
            D3DContext = d3dContext;

            using (var backBuffer = SwapChain.GetBuffer<ID3D11Texture2D>(0))
            using (var surface = backBuffer.QueryInterface<IDXGISurface>())
            {
                var renderTargetProperties = new RenderTargetProperties(new PixelFormat(Format.B8G8R8A8_UNorm, Vortice.DCommon.AlphaMode.Premultiplied));
                RenderTarget = D2DFactory.CreateDxgiSurfaceRenderTarget(surface, renderTargetProperties);
            }

            CreateDepthStencilView(size); // Create depth buffer

            if (RenderTarget is null) throw new InvalidOperationException("Render target creation returned null unexpectedly.");

            RenderTarget.TextAntialiasMode = D2D.TextAntialiasMode.Cleartype;

            Console.WriteLine($"Vortice Graphics initialized successfully for HWND {hwnd}.");
            IsInitialized = true;
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Graphics Initialization failed: {ex.Message}");
            Cleanup(); // Ensures we are in a clean state after failure
            return false;
        }
    }

    private void CreateDepthStencilView(SizeI size)
    {
        if (D3DDevice is null) return;

        // Clean up old resources first
        _depthStencilBuffer?.Dispose();
        DepthStencilView?.Dispose();

        var depthStencilDesc = new Texture2DDescription
        {
            Width = size.Width,
            Height = size.Height,
            MipLevels = 1,
            ArraySize = 1,
            Format = Format.D24_UNorm_S8_UInt,
            SampleDescription = new SampleDescription(1, 0),
            Usage = ResourceUsage.Default,
            BindFlags = BindFlags.DepthStencil,
        };
        _depthStencilBuffer = D3DDevice.CreateTexture2D(depthStencilDesc);
        DepthStencilView = D3DDevice.CreateDepthStencilView(_depthStencilBuffer);
    }


    public void Resize(SizeI newSize)
    {
        if (!IsInitialized || RenderTarget is null || SwapChain is null) return;

        try
        {
            Console.WriteLine($"Resizing render target to {newSize}...");
            RenderTarget.Dispose();

            // Also dispose depth resources before resizing
            DepthStencilView?.Dispose();
            _depthStencilBuffer?.Dispose();

            SwapChain.ResizeBuffers(1, (uint)newSize.Width, (uint)newSize.Height, Format.B8G8R8A8_UNorm, 0);
            using (var backBuffer = SwapChain.GetBuffer<ID3D11Texture2D>(0))
            using (var surface = backBuffer.QueryInterface<IDXGISurface>())
            {
                var renderTargetProperties = new RenderTargetProperties(new PixelFormat(Format.B8G8R8A8_UNorm, Vortice.DCommon.AlphaMode.Premultiplied));
                RenderTarget = D2DFactory.CreateDxgiSurfaceRenderTarget(surface, renderTargetProperties);
            }

            // Recreate depth resources with the new size
            CreateDepthStencilView(newSize);

            Console.WriteLine("Successfully resized render target.");
        }
        catch (SharpGenException ex)
        {
            Console.WriteLine($"Failed to resize Render Target (SharpGenException): {ex.Message} HRESULT: {ex.ResultCode}");
            if (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
            {
                Console.WriteLine("Render target needs recreation (Detected in Resize Exception).");
                MarkAsLost();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to resize Render Target (General Exception): {ex}");
            MarkAsLost();
        }
    }

    public void BeginDraw()
    {
        if (!IsInitialized || RenderTarget is null)
        {
            return;
        }
        RenderTarget.BeginDraw();
    }

    public void EndDraw()
    {
        if (!IsInitialized || RenderTarget is null) return;

        try
        {
            Result endDrawResult = RenderTarget.EndDraw();
            if (endDrawResult.Failure)
            {
                Console.WriteLine($"EndDraw failed: {endDrawResult.Description}");
                if (endDrawResult.Code == D2D.ResultCode.RecreateTarget.Code)
                {
                    Console.WriteLine("Render target needs recreation (Detected in EndDraw).");
                    MarkAsLost();
                }
            }
            SwapChain?.Present((uint)(VSync ? 1 : 0), 0);
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Render target needs recreation (Caught SharpGenException in EndDraw): {ex.Message}");
            MarkAsLost();
        }
    }

    private void MarkAsLost()
    {
        if (!IsInitialized) return;
        Console.WriteLine("Marking graphics device as lost. Resources will be recreated on next opportunity.");
        Cleanup();
    }

    private void CleanupRenderTarget()
    {
        RenderTarget?.Dispose();
        RenderTarget = null;
    }

    public void Cleanup()
    {
        bool resourcesExisted = RenderTarget is not null;
        if (resourcesExisted) Console.WriteLine("Cleaning up GraphicsDevice instance resources...");

        CleanupRenderTarget();
        DepthStencilView?.Dispose();
        DepthStencilView = null;
        _depthStencilBuffer?.Dispose();
        _depthStencilBuffer = null;
        D3DContext?.Dispose();
        D3DContext = null;
        D3DDevice?.Dispose();
        D3DDevice = null;
        SwapChain?.Dispose();
        SwapChain = null;
        IsInitialized = false;

        if (resourcesExisted) Console.WriteLine("Finished cleaning GraphicsDevice instance resources.");
    }

    public void Dispose()
    {
        if (_isDisposed) return;
        Cleanup();
        _isDisposed = true;
        GC.SuppressFinalize(this);
    }

    ~DuiGraphicsDevice()
    {
        Dispose();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Direct2D\ShaderCompiler.cs">
using SharpGen.Runtime;
using Vortice.D3DCompiler;
using Vortice.Direct3D;

namespace DirectUI.Backends;

public static class ShaderCompiler
{
    public static Blob Compile(string source, string entryPoint, string profile)
    {
        // Calling the overload with positional arguments to avoid naming errors.
        // This is the 10-argument overload.
        // The error suggests the entryPoint and sourceFileName parameters are swapped in the user's library version.
        Result compileResult = Compiler.Compile(
            source,          // 1: string sourceCode
            null,            // 2: ShaderMacro[] defines
            null,            // 3: Include include
            entryPoint,      // 4: string entryPoint (was "ShaderSource")
            "ShaderSource",  // 5: string sourceFileName (was entryPoint)
            profile,         // 6: string profile
            ShaderFlags.None,// 7: ShaderFlags shaderFlags
            EffectFlags.None,// 8: EffectFlags effectFlags
            out Blob? code,  // 9: out Blob result
            out Blob? error  // 10: out Blob errorBlob
        );

        // Check if the compilation failed.
        if (compileResult.Failure)
        {
            string errorMessage = "Shader compilation failed";
            if (error != null)
            {
                // The error blob contains detailed diagnostics from the compiler.
                errorMessage = error.AsString();
                error.Dispose();
            }
            code?.Dispose(); // Clean up the code blob if it was created.

            // Log the detailed error to the console before throwing.
            Console.WriteLine($"--- SHADER COMPILATION FAILED ---");
            Console.WriteLine($"Entry Point: {entryPoint}");
            Console.WriteLine($"Profile: {profile}");
            Console.WriteLine($"Error: {errorMessage}");
            Console.WriteLine("--- Shader Source ---");
            Console.WriteLine(source);
            Console.WriteLine("---------------------");

            // Throw an exception with the detailed message from the compiler.
            throw new SharpGenException(compileResult, errorMessage);
        }

        // On success, the error blob is usually null, but dispose it just in case.
        error?.Dispose();

        if (code is null)
        {
            // This should not happen if compilation succeeded, but it's a good safeguard.
            throw new InvalidOperationException("Shader compilation succeeded but the resulting blob is null.");
        }

        return code;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Direct2D\Win32AppServicesInitializer.cs">
using Vortice.Mathematics;

namespace DirectUI;

public static class Win32AppServicesInitializer
{
    public static AppServices Initialize(IntPtr hwnd, SizeI clientSize, Action<UIContext> uiDrawCallback, Color4 backgroundColor)
    {
        var appEngine = new AppEngine(uiDrawCallback, backgroundColor);
        var graphicsDevice = new DuiGraphicsDevice();

        if (!graphicsDevice.Initialize(hwnd, clientSize))
        {
            throw new InvalidOperationException("Failed to initialize DuiGraphicsDevice.");
        }

        if (graphicsDevice.DWriteFactory is null)
        {
            throw new InvalidOperationException("CRITICAL: GraphicsDevice did not provide a valid DWriteFactory for TextService initialization.");
        }

        // Pass the entire graphics device to the renderer. This ensures the renderer
        // always has access to the current, valid render target, even after a resize.
        var renderer = new Backends.Direct2DRenderer(graphicsDevice);
        var textService = new Backends.DirectWriteTextService(graphicsDevice.DWriteFactory);

        appEngine.Initialize(textService, renderer);

        Console.WriteLine($"Win32AppServices Initializer: Services created for HWND {hwnd}.");
        return new AppServices(appEngine, graphicsDevice, renderer, textService);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Direct2D\Win32Window.cs">
// Win32Window.cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;
using DirectUI.Core; // Added for IWindowHost

namespace DirectUI;

public abstract class Win32Window : IDisposable
{
    private readonly string _windowClassName;
    private readonly string _windowTitle;
    private readonly int _initialWidth;
    private readonly int _initialHeight;
    private IntPtr _hwnd = IntPtr.Zero;
    private IntPtr _hInstance = IntPtr.Zero;
    private NativeMethods.WndProc _wndProcDelegate;
    private bool _isDisposed = false;
    private static readonly HashSet<string> RegisteredClassNames = new HashSet<string>();
    private GCHandle _gcHandle;

    private readonly Dictionary<uint, Func<IntPtr, IntPtr, IntPtr, IntPtr>> _messageHandlers;

    public IntPtr Handle => _hwnd;
    public string Title => _windowTitle;
    public int Width { get; protected set; }
    public int Height { get; protected set; }
    protected IntPtr OwnerHandle { get; private set; } = IntPtr.Zero;

    protected Win32Window(string title, int width, int height, string className = null)
    {
        _windowTitle = title ?? "Win32 Window";
        _initialWidth = width > 0 ? width : 800;
        _initialHeight = height > 0 ? height : 600;
        Width = _initialWidth;
        Height = _initialHeight;
        _windowClassName = className ?? ("Win32Window_" + Guid.NewGuid().ToString("N"));
        _wndProcDelegate = WindowProcedure;

        _messageHandlers = new Dictionary<uint, Func<IntPtr, IntPtr, IntPtr, IntPtr>>();
        InitializeMessageHandlers();
    }

    private void InitializeMessageHandlers()
    {
        _messageHandlers.Add(NativeMethods.WM_PAINT, Handle_WmPaint);
        _messageHandlers.Add(NativeMethods.WM_SIZE, Handle_WmSize);
        _messageHandlers.Add(NativeMethods.WM_MOUSEMOVE, Handle_WmMouseMove);
        _messageHandlers.Add(NativeMethods.WM_LBUTTONDOWN, (h, w, l) => Handle_WmMouseButton(MouseButton.Left, h, w, l, true));
        _messageHandlers.Add(NativeMethods.WM_LBUTTONUP, (h, w, l) => Handle_WmMouseButton(MouseButton.Left, h, w, l, false));
        _messageHandlers.Add(NativeMethods.WM_RBUTTONDOWN, (h, w, l) => Handle_WmMouseButton(MouseButton.Right, h, w, l, true));
        _messageHandlers.Add(NativeMethods.WM_MBUTTONDOWN, (h, w, l) => Handle_WmMouseButton(MouseButton.Middle, h, w, l, true));
        _messageHandlers.Add(NativeMethods.WM_MBUTTONUP, (h, w, l) => Handle_WmMouseButton(MouseButton.Middle, h, w, l, false));
        _messageHandlers.Add(NativeMethods.WM_XBUTTONDOWN, (h, w, l) => Handle_WmXMouseButton(h, w, l, true));
        _messageHandlers.Add(NativeMethods.WM_XBUTTONUP, (h, w, l) => Handle_WmXMouseButton(h, w, l, false));
        _messageHandlers.Add(NativeMethods.WM_MOUSEWHEEL, Handle_WmMouseWheel);
        _messageHandlers.Add(NativeMethods.WM_KEYDOWN, (h, w, l) => Handle_WmKey(true, h, w, l));
        _messageHandlers.Add(NativeMethods.WM_KEYUP, (h, w, l) => Handle_WmKey(false, h, w, l));
        _messageHandlers.Add(NativeMethods.WM_SYSKEYUP, (h, w, l) => Handle_WmKey(false, h, w, l));
        _messageHandlers.Add(NativeMethods.WM_CHAR, Handle_WmChar);
        _messageHandlers.Add(NativeMethods.WM_CLOSE, Handle_WmClose);
        _messageHandlers.Add(NativeMethods.WM_DESTROY, Handle_WmDestroy);
        _messageHandlers.Add(NativeMethods.WM_NCDESTROY, Handle_WmNcDestroy);
    }

    public bool Create(IntPtr owner = default, uint? style = null, int? x = null, int? y = null)
    {
        OwnerHandle = owner;

        if (_hwnd != IntPtr.Zero)
        {
            return true;
        }

        if (!TryCreateWindow(owner, style, x, y))
        {
            Console.WriteLine("Window creation failed.");
            Dispose();
            return false;
        }

        if (!Initialize())
        {
            Console.WriteLine("Derived init failed.");
            Dispose();
            return false;
        }

        NativeMethods.ShowWindow(_hwnd, NativeMethods.SW_SHOWNORMAL);
        NativeMethods.UpdateWindow(_hwnd);

        return true;
    }

    private bool TryCreateWindow(IntPtr owner, uint? style, int? x, int? y)
    {
        _hInstance = NativeMethods.GetModuleHandle(null);

        if (_hInstance == IntPtr.Zero)
        {
            _hInstance = Process.GetCurrentProcess().Handle;
        }

        Application.RegisterWindow(this);

        lock (RegisteredClassNames)
        {
            if (!RegisteredClassNames.Contains(_windowClassName))
            {
                NativeMethods.WNDCLASSEX wndClass = new()
                {
                    cbSize = Marshal.SizeOf(typeof(NativeMethods.WNDCLASSEX)),
                    style = NativeMethods.CS_HREDRAW | NativeMethods.CS_VREDRAW,
                    lpfnWndProc = _wndProcDelegate,
                    hInstance = _hInstance,
                    lpszClassName = _windowClassName,
                    hIcon = NativeMethods.LoadIcon(IntPtr.Zero, (IntPtr)32512),
                    hCursor = NativeMethods.LoadCursor(IntPtr.Zero, 32512),
                };

                if (NativeMethods.RegisterClassEx(ref wndClass) == 0)
                {
                    Console.WriteLine($"RegisterClassEx failed: {Marshal.GetLastWin32Error()}");
                    return false;
                }

                RegisteredClassNames.Add(_windowClassName);
                Console.WriteLine($"Class '{_windowClassName}' registered.");
            }
        }

        _gcHandle = GCHandle.Alloc(this, GCHandleType.Normal); // Explicitly specify Normal type

        uint windowStyle = style ?? (NativeMethods.WS_OVERLAPPEDWINDOW | NativeMethods.WS_VISIBLE);

        int finalX = x ?? NativeMethods.CW_USEDEFAULT;
        int finalY = y ?? NativeMethods.CW_USEDEFAULT;

        _hwnd = NativeMethods.CreateWindowEx(
            0,
            _windowClassName,
            _windowTitle,
            windowStyle,
            finalX,
            finalY,
            _initialWidth,
            _initialHeight,
            owner,
            IntPtr.Zero,
            _hInstance,
            GCHandle.ToIntPtr(_gcHandle));

        if (_hwnd == IntPtr.Zero)
        {
            Console.WriteLine($"CreateWindowEx failed: {Marshal.GetLastWin32Error()}");

            if (_gcHandle.IsAllocated)
            {
                _gcHandle.Free();
            }

            return false;
        }

        Console.WriteLine($"Window created: {_hwnd}"); return true;
    }

    private static IntPtr WindowProcedure(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        Win32Window? window = null;

        if (msg == NativeMethods.WM_NCCREATE)
        {
            var cs = Marshal.PtrToStructure<NativeMethods.CREATESTRUCT>(lParam);
            var handle = GCHandle.FromIntPtr(cs.lpCreateParams);
            window = handle.Target as Win32Window;

            NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, GCHandle.ToIntPtr(handle));
            Console.WriteLine($"WM_NCCREATE: Associated instance with HWND {hWnd}");
        }
        else
        {
            IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA);

            if (ptr != IntPtr.Zero)
            {
                var handle = GCHandle.FromIntPtr(ptr);
                window = handle.Target as Win32Window;
            }
        }

        if (window is null)
        {
            return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
        }

        try
        {
            return window.HandleMessage(hWnd, msg, wParam, lParam);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling msg {msg}: {ex}");
        }

        return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
    }

    protected virtual IntPtr HandleMessage(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        if (_messageHandlers.TryGetValue(msg, out var handler))
        {
            return handler(hWnd, wParam, lParam);
        }
        return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
    }

    private IntPtr Handle_WmPaint(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        OnPaint();
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmSize(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        Width = NativeMethods.LoWord(lParam);
        Height = NativeMethods.HiWord(lParam);
        OnSize(Width, Height);
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmMouseMove(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        OnMouseMove(NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmMouseButton(MouseButton button, IntPtr hWnd, IntPtr wParam, IntPtr lParam, bool isDown)
    {
        if (isDown) NativeMethods.SetCapture(hWnd);
        else NativeMethods.ReleaseCapture();

        if (isDown) OnMouseDown(button, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
        else OnMouseUp(button, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmXMouseButton(IntPtr hWnd, IntPtr wParam, IntPtr lParam, bool isDown)
    {
        short xButton = NativeMethods.HiWord(wParam);
        MouseButton button = (xButton == 1) ? MouseButton.XButton1 : MouseButton.XButton2;

        if (isDown) NativeMethods.SetCapture(hWnd);
        else NativeMethods.ReleaseCapture();

        if (isDown) OnMouseDown(button, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
        else OnMouseUp(button, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmMouseWheel(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        short wheelDelta = NativeMethods.HiWord(wParam);
        OnMouseWheel((float)wheelDelta / 120.0f); // Normalize delta
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmKey(bool isDown, IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        Keys key = (Keys)wParam;
        if (isDown) OnKeyDown(key);
        else OnKeyUp(key);
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmChar(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        OnChar((char)wParam);
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmClose(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        if (OnClose())
        {
            NativeMethods.DestroyWindow(hWnd);
        }
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmDestroy(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        Console.WriteLine($"WM_DESTROY for {_hwnd}.");
        Application.UnregisterWindow(this);
        OnDestroy();

        if (OwnerHandle == IntPtr.Zero)
        {
            Application.Exit();
        }
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmNcDestroy(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        Console.WriteLine($"WM_NCDESTROY: Releasing GCHandle for {hWnd}.");

        IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA);

        if (ptr != IntPtr.Zero)
        {
            var handle = GCHandle.FromIntPtr(ptr);

            if (handle.IsAllocated)
            {
                handle.Free();
            }

            NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, IntPtr.Zero);
        }

        if (_gcHandle.IsAllocated)
        {
            _gcHandle.Free();
            _gcHandle = default;
        }

        _hwnd = IntPtr.Zero;
        return IntPtr.Zero;
    }


    public void Close()
    {
        if (_hwnd == IntPtr.Zero)
        {
            return;
        }

        // Post a close message instead of destroying directly.
        // This is a safer pattern, allowing the window to process the close request
        // through its own message loop, preventing re-entrancy issues if called
        // from within a message handler (like a button click during WM_PAINT).
        NativeMethods.PostMessage(_hwnd, NativeMethods.WM_CLOSE, IntPtr.Zero, IntPtr.Zero);
    }

    public void Invalidate()
    {
        if (_hwnd == IntPtr.Zero)
        {
            return;
        }

        NativeMethods.InvalidateRect(_hwnd, IntPtr.Zero, false);
    }

    public virtual void FrameUpdate()
    {

    }

    internal bool GetWindowRect(out NativeMethods.RECT rect)
    {
        if (Handle == IntPtr.Zero)
        {
            rect = default;
            return false;
        }

        return NativeMethods.GetWindowRect(Handle, out rect);
    }

    protected virtual bool Initialize()
    {
        return true;
    }

    protected abstract void OnPaint();

    protected virtual void OnSize(int width, int height)
    {

    }

    protected virtual void OnMouseDown(MouseButton button, int x, int y)
    {

    }

    protected virtual void OnMouseUp(MouseButton button, int x, int y)
    {

    }

    protected virtual void OnMouseMove(int x, int y)
    {

    }

    protected virtual void OnKeyDown(Keys key)
    {

    }

    protected virtual void OnKeyUp(Keys key)
    {

    }

    protected virtual void OnMouseWheel(float delta)
    {

    }

    protected virtual void OnChar(char c)
    {

    }

    protected virtual bool OnClose()
    {
        return true;
    }

    protected virtual void OnDestroy()
    {

    }

    protected virtual void Cleanup()
    {

    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (_isDisposed)
        {
            return;
        }

        if (disposing)
        {
            Console.WriteLine("Disposing Win32Window (managed)...");
            Cleanup();
        }

        Console.WriteLine("Disposing Win32Window (unmanaged)...");

        if (_hwnd != IntPtr.Zero)
        {
            Console.WriteLine($"Destroying window {_hwnd} during Dispose...");
            NativeMethods.DestroyWindow(_hwnd);
            _hwnd = IntPtr.Zero;
        }
        else
        {
            // If _hwnd is already zero, it means DestroyWindow was likely called via WM_DESTROY/WM_NCDESTROY.
            // In that case, the GCHandle should have already been freed by Handle_WmNcDestroy.
            // Only free it here if it's still allocated and _hwnd is zero, indicating a Dispose() call
            // that didn't go through the full Win32 message loop shutdown for some reason.
            if (_gcHandle.IsAllocated)
            {
                Console.WriteLine("Freeing dangling GCHandle during Dispose (unexpected, but cleaning up).");
                _gcHandle.Free();
                _gcHandle = default;
            }
        }

        _isDisposed = true;

        Console.WriteLine("Win32Window disposed.");
    }

    ~Win32Window()
    {
        Console.WriteLine("Win32Window Finalizer!");
        Dispose(false);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Direct2D\Win32WindowHost.cs">
using DirectUI.Core;
using DirectUI.Input;
using Vortice.Mathematics;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI;

public class Win32WindowHost : Win32Window, IWindowHost, IModalWindowService
{
    private AppServices? appServices;

    private ModalWindow? activeModalWindow;
    private int modalResultCode;
    private Action<int>? onModalClosedCallback;
    private bool _isModalClosing;

    public bool IsModalWindowOpen
    {
        get
        {
            return activeModalWindow is not null
                && activeModalWindow.Handle != IntPtr.Zero;
        }
    }

    public Win32WindowHost(string title = "DirectUI Win32 Host", int width = 800, int height = 600)
        : base(title, width, height)
    {
    }

    public InputManager Input => appServices?.AppEngine.Input ?? new();
    public SizeI ClientSize => GetClientRectSize();

    public bool ShowFpsCounter
    {
        get
        {
            return appServices?.AppEngine.ShowFpsCounter ?? false;
        }

        set
        {
            if (appServices is null)
            {
                return;
            }

            appServices.AppEngine.ShowFpsCounter = value;
        }
    }

    public IModalWindowService ModalWindowService => this;

    public bool Initialize(Action<UIContext> uiDrawCallback, Color4 backgroundColor)
    {
        Console.WriteLine("Win32WindowHost initializing...");

        // Create the window before initializing services, as the window handle is required.
        if (!base.Create())
        {
            Console.WriteLine("Win32WindowHost failed to create its window handle.");
            return false;
        }

        try
        {
            appServices = Win32AppServicesInitializer.Initialize(Handle, GetClientRectSize(), uiDrawCallback, backgroundColor);
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to initialize Win32WindowHost services: {ex.Message}");
            return false;
        }
    }

    void IWindowHost.Cleanup()
    {
        Cleanup();
    }

    protected override void Cleanup()
    {
        if (_isModalClosing)
        {
            return;
        }

        Console.WriteLine("Win32WindowHost cleaning up its resources...");
        appServices?.AppEngine.Cleanup();
        appServices?.TextService.Cleanup();
        (appServices?.Renderer as Backends.Direct2DRenderer)?.Cleanup();
        appServices?.GraphicsDevice.Cleanup();

        appServices = null;
        activeModalWindow = null;

        base.Cleanup();
    }

    public void RunLoop()
    {
        Application.RunMessageLoop();
    }

    protected override void OnPaint()
    {
        if (appServices is null || !appServices.GraphicsDevice.IsInitialized)
        {
            Console.WriteLine("Render services not initialized. Skipping paint.");
            return;
        }

        // The 3D rendering pass has been removed.
        // We now proceed directly to 2D UI rendering.
        appServices.GraphicsDevice.BeginDraw();
        try
        {
            // We now always clear the background for the 2D UI.
            if (appServices.AppEngine is not null && appServices.GraphicsDevice.RenderTarget is not null)
            {
                appServices.GraphicsDevice.RenderTarget.Clear(appServices.AppEngine.BackgroundColor);
            }

            appServices?.AppEngine?.UpdateAndRender(appServices.Renderer, appServices.TextService);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred during drawing: {ex}");
            appServices.GraphicsDevice.Cleanup();
        }
        finally
        {
            appServices.GraphicsDevice.EndDraw();
        }
    }

    public override void FrameUpdate()
    {
        Invalidate();
        HandleModalLifecycle();
    }

    protected override void OnSize(int width, int height)
    {
        appServices?.GraphicsDevice.Resize(new SizeI(width, height));
    }

    protected override void OnMouseMove(int x, int y)
    {
        appServices?.AppEngine.Input.SetMousePosition(x, y);
        Invalidate();
    }

    protected override void OnMouseDown(MouseButton button, int x, int y)
    {
        appServices?.AppEngine.Input.SetMousePosition(x, y);
        appServices?.AppEngine.Input.SetMouseDown(button);
        Invalidate();
    }

    protected override void OnMouseUp(MouseButton button, int x, int y)
    {
        appServices?.AppEngine.Input.SetMousePosition(x, y);
        appServices?.AppEngine.Input.SetMouseUp(button);
        Invalidate();
    }

    protected override void OnMouseWheel(float delta)
    {
        appServices?.AppEngine.Input.AddMouseWheelDelta(delta);
        Invalidate();
    }

    protected override void OnKeyDown(Keys key)
    {
        appServices?.AppEngine.Input.AddKeyPressed(key);

        if (key == Keys.Escape)
        {
            Close();
        }

        if (key == Keys.F3 && appServices?.AppEngine is not null)
        {
            appServices.AppEngine.ShowFpsCounter = !appServices.AppEngine.ShowFpsCounter;
        }

        Invalidate();
    }

    protected override void OnKeyUp(Keys key)
    {
        appServices?.AppEngine.Input.AddKeyReleased(key);
        Invalidate();
    }

    protected override void OnChar(char c)
    {
        appServices?.AppEngine.Input.AddCharacterInput(c);
        Invalidate();
    }

    protected override bool OnClose()
    {
        return true;
    }

    protected override void OnDestroy()
    {
        base.OnDestroy();

        if (activeModalWindow is null || activeModalWindow.Handle == IntPtr.Zero)
        {
            return;
        }

        activeModalWindow.Close();
    }

    private SizeI GetClientRectSize()
    {
        if (Handle == nint.Zero || !NativeMethods.GetClientRect(Handle, out NativeMethods.RECT r))
        {
            return new(Width, Height);
        }

        int width = int.Max(1, r.right - r.left);
        int height = int.Max(1, r.bottom - r.top);

        return new(width, height);
    }

    public void OpenModalWindow(string title, int width, int height, Action<UIContext> drawCallback, Action<int>? onClosedCallback = null)
    {
        if (activeModalWindow is not null && activeModalWindow.Handle != IntPtr.Zero)
        {
            Console.WriteLine("Warning: Cannot open a new modal window while another is already active.");
            return;
        }

        activeModalWindow = new(this, title, width, height, drawCallback);

        if (activeModalWindow.CreateAsModal())
        {
            // FIX: Explicitly assign to the instance field 'this.onModalClosedCallback'
            // to avoid the local variable shadowing it.
            this.onModalClosedCallback = onClosedCallback;
            modalResultCode = -1;
            Console.WriteLine("Modal window opened successfully.");
        }
        else
        {
            Console.WriteLine("Failed to create modal window.");
            activeModalWindow.Dispose();
            activeModalWindow = null;
            onClosedCallback?.Invoke(-1);
        }
    }

    public void CloseModalWindow(int resultCode = 0)
    {
        if (activeModalWindow is null || activeModalWindow.Handle == IntPtr.Zero)
        {
            return;
        }

        modalResultCode = resultCode;
        activeModalWindow.Close();
    }

    /// <summary>
    /// This method is now a fallback for cleanup, but the primary notification
    /// comes from NotifyModalHasClosed.
    /// </summary>
    private void HandleModalLifecycle()
    {
        if (activeModalWindow is null)
        {
            return;
        }

        // If the handle is zero, it means the window was destroyed, but our new
        // notification mechanism might have already handled it. This is a safety net.
        if (activeModalWindow.Handle == IntPtr.Zero && !_isModalClosing)
        {
            Console.WriteLine("[LIFECYCLE-FALLBACK] Cleaning up orphaned modal window.");
            NotifyModalHasClosed();
        }
    }

    /// <summary>
    /// Called directly by the ModalWindow from its OnDestroy method.
    /// This is the new, reliable way to trigger the close callback.
    /// </summary>
    public void NotifyModalHasClosed()
    {
        if (_isModalClosing) return; // Re-entrancy guard
        _isModalClosing = true;

        Console.WriteLine($"Modal window closed. Result: {modalResultCode}");
        onModalClosedCallback?.Invoke(modalResultCode);

        // The modal window is already disposing, so we just clear our references to it.
        activeModalWindow = null;
        onModalClosedCallback = null;
        modalResultCode = 0;
        _isModalClosing = false;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\NewFolder\DwmApi.cs">
using System;
using System.Runtime.InteropServices;

namespace DirectUI.Backends.SkiaSharp;

/// <summary>
/// Contains P/Invoke definitions for the Windows Desktop Window Manager (DWM) API.
/// </summary>
internal static class DwmApi
{
    [DllImport("dwmapi.dll")]
    internal static extern int DwmSetWindowAttribute(IntPtr hwnd, DWMWINDOWATTRIBUTE dwAttribute, ref int pvAttribute, int cbAttribute);

    internal enum DWMWINDOWATTRIBUTE
    {
        DWMWA_USE_IMMERSIVE_DARK_MODE = 20,
        DWMWA_SYSTEMBACKDROP_TYPE = 38,
        DWMWA_WINDOW_CORNER_PREFERENCE = 33
    }

    internal enum DWM_WINDOW_CORNER_PREFERENCE
    {
        DWMWCP_DEFAULT = 0,
        DWMWCP_DONOTROUND = 1,
        DWMWCP_ROUND = 2,
        DWMWCP_ROUNDSMALL = 3
    }

    internal enum DWMSYSTEMBACKDROP_TYPE
    {
        DWMSBT_AUTO = 0,
        DWMSBT_NONE = 1,
        DWMSBT_MAINWINDOW = 2,       // Mica
        DWMSBT_TRANSIENTWINDOW = 3,  // Acrylic
        DWMSBT_TABBEDWINDOW = 4      // Tabbed
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\NewFolder\SilkNetRenderer.cs">
using System;
using System.Collections.Generic;
using System.Numerics;
using DirectUI.Core;
using DirectUI.Drawing;
using SkiaSharp;
using Vortice.Direct2D1;
using Vortice.Mathematics;

namespace DirectUI.Backends.SkiaSharp;

public class SilkNetRenderer : IRenderer
{
    private SKCanvas? _canvas;
    private Vector2 _renderTargetSize;
    private readonly SilkNetTextService _textService;

    public Vector2 RenderTargetSize => _renderTargetSize;

    public SilkNetRenderer(SilkNetTextService textService)
    {
        _textService = textService;
    }

    public void SetCanvas(SKCanvas canvas, Vector2 size)
    {
        _canvas = canvas;
        _renderTargetSize = size;
    }

    public void DrawLine(Vector2 p1, Vector2 p2, Color color, float strokeWidth)
    {
        if (_canvas is null) return;
        using var paint = new SKPaint
        {
            Color = new SKColor(color.R, color.G, color.B, color.A),
            StrokeWidth = strokeWidth,
            IsAntialias = true,
            Style = SKPaintStyle.Stroke
        };
        _canvas.DrawLine(p1.X, p1.Y, p2.X, p2.Y, paint);
    }

    public void DrawBox(Rect rect, BoxStyle style)
    {
        if (_canvas is null || style is null) return;

        var skRect = new SKRect(rect.Left, rect.Top, rect.Right, rect.Bottom);
        float maxRadius = Math.Min(rect.Width, rect.Height) / 2f;
        float radius = Math.Clamp(style.Roundness * maxRadius, 0, maxRadius);

        // Draw fill
        if (style.FillColor.A > 0)
        {
            using var fillPaint = new SKPaint
            {
                Color = new SKColor(style.FillColor.R, style.FillColor.G, style.FillColor.B, style.FillColor.A),
                IsAntialias = true,
                Style = SKPaintStyle.Fill
            };
            _canvas.DrawRoundRect(skRect, radius, radius, fillPaint);
        }

        // Draw border
        if (style.BorderColor.A > 0 && style.BorderLength > 0)
        {
            using var borderPaint = new SKPaint
            {
                Color = new SKColor(style.BorderColor.R, style.BorderColor.G, style.BorderColor.B, style.BorderColor.A),
                IsAntialias = true,
                Style = SKPaintStyle.Stroke,
                StrokeWidth = style.BorderLength
            };
            // Inset the rectangle slightly so the stroke is drawn on the edge, not half-in/half-out
            skRect.Inflate(-style.BorderLength / 2f, -style.BorderLength / 2f);
            _canvas.DrawRoundRect(skRect, radius, radius, borderPaint);
        }
    }

    public void DrawText(Vector2 origin, string text, ButtonStyle style, Alignment alignment, Vector2 maxSize, Color color)
    {
        if (_canvas is null || string.IsNullOrEmpty(text)) return;

        var typeface = _textService.GetOrCreateTypeface(style);
        using var font = new SKFont(typeface, style.FontSize);
        using var paint = new SKPaint(font)
        {
            Color = new SKColor(color.R, color.G, color.B, color.A),
            IsAntialias = true
        };

        var bounds = new SKRect();
        paint.MeasureText(text, ref bounds);

        var textDrawPos = origin;

        // Horizontal alignment
        if (maxSize.X > 0)
        {
            switch (alignment.Horizontal)
            {
                case HAlignment.Center:
                    textDrawPos.X += (maxSize.X - bounds.Width) / 2f - bounds.Left;
                    break;
                case HAlignment.Right:
                    textDrawPos.X += maxSize.X - bounds.Width - bounds.Left;
                    break;
                default: // Left
                    textDrawPos.X -= bounds.Left;
                    break;
            }
        }
        else
        {
            textDrawPos.X -= bounds.Left;
        }


        // Vertical alignment
        if (maxSize.Y > 0)
        {
            switch (alignment.Vertical)
            {
                case VAlignment.Top:
                    textDrawPos.Y -= bounds.Top; // Align top of text bounds to origin.Y
                    break;
                case VAlignment.Center:
                    textDrawPos.Y += (maxSize.Y / 2f) - bounds.MidY;
                    break;
                case VAlignment.Bottom:
                    textDrawPos.Y += maxSize.Y - bounds.Bottom; // Align bottom of text bounds to bottom of layout rect
                    break;
            }
        }
        else
        {
            textDrawPos.Y -= bounds.Top;
        }

        _canvas.DrawText(text, textDrawPos.X, textDrawPos.Y, paint);
    }

    public void PushClipRect(Rect rect, AntialiasMode antialiasMode)
    {
        _canvas?.Save();
        _canvas?.ClipRect(new SKRect(rect.Left, rect.Top, rect.Right, rect.Bottom), SKClipOperation.Intersect, true);
    }

    public void PopClipRect()
    {
        _canvas?.Restore();
    }

    public void Flush()
    {
        _canvas?.Flush();
    }

    public void Cleanup()
    {
        // Canvas is managed by the host
        _canvas = null;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\NewFolder\SilkNetTextLayout.cs">
using System;
using System.Numerics;
using DirectUI.Core;
using SkiaSharp;
using Typography.OpenFont;

namespace DirectUI.Backends.SkiaSharp;

internal class SilkNetTextLayout : ITextLayout
{
    public Vector2 Size { get; }
    public string Text { get; }

    public SilkNetTextLayout(string text, SKTypeface typeface, ButtonStyle style)
    {
        Text = text;
        using var font = new SKFont(typeface, style.FontSize);
        using var paint = new SKPaint(font);
        var rect = new SKRect();
        paint.MeasureText(text, ref rect);
        Size = new Vector2(rect.Width, rect.Height);
    }
    public TextHitTestMetrics HitTestTextPosition(int textPosition, bool isTrailingHit)
    {
        if (string.IsNullOrEmpty(Text)) return new TextHitTestMetrics(Vector2.Zero, Vector2.Zero);

        float approxCharWidth = Size.X / Math.Max(1, Text.Length);
        float x = textPosition * approxCharWidth;
        float width = approxCharWidth;

        if (isTrailingHit) x += approxCharWidth;
        x = Math.Clamp(x, 0, Size.X);

        return new TextHitTestMetrics(new Vector2(x, 0), new Vector2(width, Size.Y));
    }

    public TextHitTestResult HitTestPoint(Vector2 point)
    {
        if (string.IsNullOrEmpty(Text))
        {
            return new TextHitTestResult(0, false, false, new TextHitTestMetrics(Vector2.Zero, Vector2.Zero));
        }

        bool isInside = point.X >= 0 && point.X <= Size.X && point.Y >= 0 && point.Y <= Size.Y;

        float approxCharWidth = (Text.Length > 0) ? Size.X / Text.Length : 0;
        int textPosition = 0;
        bool isTrailingHit = false;

        if (approxCharWidth > 0)
        {
            textPosition = (int)(point.X / approxCharWidth);
            isTrailingHit = (point.X % approxCharWidth) > (approxCharWidth / 2f);
        }

        textPosition = Math.Clamp(textPosition, 0, Text.Length);
        if (isTrailingHit && textPosition < Text.Length)
        {
            textPosition++;
        }
        textPosition = Math.Clamp(textPosition, 0, Text.Length);

        float hitMetricX = (textPosition == 0) ? 0 : (textPosition * approxCharWidth);
        if (isTrailingHit && textPosition > 0) hitMetricX -= approxCharWidth;

        return new TextHitTestResult(textPosition, isTrailingHit, isInside,
            new TextHitTestMetrics(new Vector2(hitMetricX, 0), new Vector2(approxCharWidth, Size.Y)));
    }
    public void Dispose()
    {
        // This class doesn't own unmanaged resources directly
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\NewFolder\SilkNetTextService.cs">
using System;
using System.Collections.Generic;
using System.Numerics;
using DirectUI.Core;
using SkiaSharp;
using Typography.OpenFont;
using Vortice.DirectWrite; // For FontWeight, etc.

namespace DirectUI.Backends.SkiaSharp;

public class SilkNetTextService : ITextService
{
    private readonly Dictionary<FontKey, SKTypeface> _typefaceCache = new();
    private readonly Dictionary<TextLayoutCacheKey, ITextLayout> _textLayoutCache = new();
    private readonly Dictionary<(string, FontKey), Vector2> _textSizeCache = new();

    private readonly struct FontKey : IEquatable<FontKey>
    {
        private readonly string FontName;
        private readonly FontWeight FontWeight;
        private readonly FontStyle FontStyle;

        public FontKey(ButtonStyle style)
        {
            FontName = style.FontName;
            FontWeight = style.FontWeight;
            FontStyle = style.FontStyle;
        }

        public bool Equals(FontKey other) => FontName == other.FontName && FontWeight == other.FontWeight && FontStyle == other.FontStyle;
        public override bool Equals(object? obj) => obj is FontKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(FontName, FontWeight, FontStyle);
    }
    private readonly struct TextLayoutCacheKey : IEquatable<TextLayoutCacheKey>
    {
        private readonly string Text;
        private readonly FontKey FontKey;
        private readonly float FontSize;
        public TextLayoutCacheKey(string text, ButtonStyle style)
        {
            Text = text;
            FontKey = new FontKey(style);
            FontSize = style.FontSize;
        }
        public bool Equals(TextLayoutCacheKey other) => Text == other.Text && FontKey.Equals(other.FontKey) && FontSize.Equals(other.FontSize);
        public override bool Equals(object? obj) => obj is TextLayoutCacheKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(Text, FontKey, FontSize);
    }
    public SKTypeface GetOrCreateTypeface(ButtonStyle style)
    {
        var key = new FontKey(style);
        if (_typefaceCache.TryGetValue(key, out var typeface))
        {
            return typeface;
        }

        SKFontStyleWeight weight = (SKFontStyleWeight)style.FontWeight;
        SKFontStyleSlant slant = style.FontStyle == FontStyle.Italic ? SKFontStyleSlant.Italic : SKFontStyleSlant.Upright;

        typeface = SKTypeface.FromFamilyName(style.FontName, weight, SKFontStyleWidth.Normal, slant);
        _typefaceCache[key] = typeface;
        return typeface;
    }
    public Vector2 MeasureText(string text, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(text)) return Vector2.Zero;

        var typeface = GetOrCreateTypeface(style);
        using var font = new SKFont(typeface, style.FontSize);
        using var paint = new SKPaint(font);
        var rect = new SKRect();
        paint.MeasureText(text, ref rect);
        return new Vector2(rect.Width, rect.Height);
    }

    public ITextLayout GetTextLayout(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment)
    {
        var key = new TextLayoutCacheKey(text, style);
        if (_textLayoutCache.TryGetValue(key, out var layout))
        {
            return layout;
        }

        var typeface = GetOrCreateTypeface(style);
        var newLayout = new SilkNetTextLayout(text, typeface, style);
        _textLayoutCache[key] = newLayout;
        return newLayout;
    }

    public void Cleanup()
    {
        foreach (var typeface in _typefaceCache.Values)
        {
            typeface.Dispose();
        }
        _typefaceCache.Clear();
        _textLayoutCache.Clear();
        _textSizeCache.Clear();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\NewFolder\SilkNetWindowHost.cs">
using System;
using System.Numerics;
using System.Runtime.InteropServices;
using DirectUI.Core;
using DirectUI.Input;
using Silk.NET.Input;
using Silk.NET.Maths;
using Silk.NET.OpenGL;
using Silk.NET.Windowing;
using SkiaSharp;
using Vortice.Mathematics;
using SizeI = Vortice.Mathematics.SizeI;
using Key = Silk.NET.Input.Key;

namespace DirectUI.Backends.SkiaSharp;

public enum WindowBackdropType
{
    Default,
    Mica,
    Acrylic,
    Tabbed,
}

public enum WindowTitleBarTheme
{
    Default,
    Dark,
    Light
}

public class SilkNetWindowHost : Core.IWindowHost, IModalWindowService
{
    private readonly string _title;
    private readonly int _width;
    private readonly int _height;
    private readonly Color4 _backgroundColor;

    // Main window resources
    private IWindow? _window;
    private AppEngine? _appEngine;
    private SilkNetRenderer? _renderer;
    private SilkNetTextService? _textService;
    private GL? _gl;
    private GRContext? _grContext;
    private SKSurface? _skSurface;
    private GRBackendRenderTarget? _renderTarget;
    private IInputContext? _inputContext;
    private bool _isDisposed;

    // Modal window resources and state
    private IWindow? _activeModalIWindow;
    private AppEngine? _modalAppEngine;
    private SilkNetRenderer? _modalRenderer;
    private SilkNetTextService? _modalTextService;
    private IInputContext? _modalInputContext;
    private GL? _modalGl;
    private GRContext? _modalGrContext;
    private SKSurface? _modalSkSurface;
    private GRBackendRenderTarget? _modalRenderTarget;
    private Action<int>? _onModalClosedCallback;
    private int _modalResultCode;

    // P/Invoke for Win32 to enable true modal behavior
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool EnableWindow(IntPtr hWnd, bool bEnable);

    [DllImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool SetForegroundWindow(IntPtr hWnd);

    public IntPtr Handle => _window?.Native.Win32?.Hwnd ?? IntPtr.Zero;
    public InputManager Input => _appEngine?.Input ?? new InputManager();
    public SizeI ClientSize => new(_window?.Size.X ?? 0, _window?.Size.Y ?? 0);
    public bool ShowFpsCounter { get => _appEngine?.ShowFpsCounter ?? false; set { if (_appEngine != null) _appEngine.ShowFpsCounter = value; } }
    public IModalWindowService ModalWindowService => this;
    public bool IsModalWindowOpen => _activeModalIWindow != null;

    public WindowBackdropType BackdropType { get; set; } = WindowBackdropType.Default;
    public WindowTitleBarTheme TitleBarTheme { get; set; } = WindowTitleBarTheme.Dark;

    public SilkNetWindowHost(string title, int width, int height, Color4 backgroundColor)
    {
        _title = title;
        _width = width;
        _height = height;
        _backgroundColor = backgroundColor;
    }

    public bool Initialize(Action<UIContext> uiDrawCallback, Color4 backgroundColor)
    {
        var options = WindowOptions.Default;
        options.Size = new Vector2D<int>(_width, _height);
        options.Title = _title;
        options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.Default, new APIVersion(3, 3));
        options.ShouldSwapAutomatically = false; // Required for our manual render loop

        // On modern Windows, always request a transparent framebuffer to allow for effects like Mica/Acrylic.
        if (OperatingSystem.IsWindowsVersionAtLeast(10, 0, 22000))
        {
            options.TransparentFramebuffer = true;
        }

        _window = Window.Create(options);
        if (_window == null) return false;

        _window.Load += () => OnLoad(uiDrawCallback, backgroundColor);
        _window.Closing += OnClose;
        _window.Resize += OnResize;

        return true;
    }

    public void RunLoop()
    {
        if (_window == null) return;

        _window.Initialize(); // Fires the Load event
        _window.IsVisible = true;

        while (!_window.IsClosing)
        {
            _window.DoEvents(); // Process events for ALL windows on the thread.

            if (IsModalWindowOpen && _activeModalIWindow != null && !_activeModalIWindow.IsClosing)
            {
                // Modal is active. Make its context current before rendering.
                _activeModalIWindow.GLContext?.MakeCurrent();

                _modalGl?.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit | ClearBufferMask.StencilBufferBit);
                if (_modalSkSurface != null && _modalRenderer != null && _modalTextService != null && _modalAppEngine != null)
                {
                    var modalBg = _modalAppEngine.BackgroundColor;
                    _modalSkSurface.Canvas.Clear(new SKColor((byte)(modalBg.R * 255), (byte)(modalBg.G * 255), (byte)(modalBg.B * 255), (byte)(modalBg.A * 255)));
                    _modalRenderer.SetCanvas(_modalSkSurface.Canvas, new Vector2(_activeModalIWindow.Size.X, _activeModalIWindow.Size.Y));
                    _modalAppEngine.UpdateAndRender(_modalRenderer, _modalTextService);
                    _modalSkSurface.Canvas.Flush();
                }
                _activeModalIWindow.SwapBuffers();
            }
            else if (!IsModalWindowOpen)
            {
                // Main window is active. Make its context current before rendering.
                _window.GLContext?.MakeCurrent();
                OnRender(0); // Pass a dummy delta.
                _window.SwapBuffers();
            }

            // Check if a modal that was open is now closing.
            if (IsModalWindowOpen && (_activeModalIWindow == null || _activeModalIWindow.IsClosing))
            {
                HandleModalClose();
            }
        }
    }

    private void HandleModalClose()
    {
        var parentHwnd = Handle;

        // Cleanup modal resources
        _modalAppEngine?.Cleanup();
        _modalRenderer?.Cleanup();
        _modalTextService?.Cleanup();
        _modalSkSurface?.Dispose();
        _modalRenderTarget?.Dispose();
        _modalGrContext?.Dispose();
        _modalGl?.Dispose();
        _modalInputContext?.Dispose();
        _activeModalIWindow?.Dispose();

        // Null out all modal-related fields
        _activeModalIWindow = null;
        _modalAppEngine = null;
        _modalRenderer = null;
        _modalTextService = null;
        _modalInputContext = null;
        _modalGl = null;
        _modalGrContext = null;
        _modalSkSurface = null;
        _modalRenderTarget = null;

        if (parentHwnd != IntPtr.Zero)
        {
            EnableWindow(parentHwnd, true);
            SetForegroundWindow(parentHwnd);
            _window?.Focus();
        }

        Input.HardReset(); // Reset main window input state to prevent stuck keys/buttons

        _onModalClosedCallback?.Invoke(_modalResultCode);
        _onModalClosedCallback = null;
    }

    private void OnLoad(Action<UIContext> uiDrawCallback, Color4 backgroundColor)
    {
        _gl = _window!.CreateOpenGL();

        bool useTransparentBg = BackdropType != WindowBackdropType.Default && OperatingSystem.IsWindowsVersionAtLeast(10, 0, 22621);
        Color4 finalBackgroundColor;

        if (useTransparentBg)
        {
            // DWM compositing for light-themed Mica is buggy and requires a non-black, near-transparent
            // background color to render correctly, otherwise it appears solid white.
            if (TitleBarTheme == WindowTitleBarTheme.Light)
            {
                finalBackgroundColor = new Color4(243 / 255f, 243 / 255f, 243 / 255f, 1 / 255f);
            }
            else // Dark theme
            {
                finalBackgroundColor = new Color4(0, 0, 0, 1 / 255f);
            }
        }
        else
        {
            finalBackgroundColor = backgroundColor;
        }

        _gl.ClearColor(finalBackgroundColor.R, finalBackgroundColor.G, finalBackgroundColor.B, finalBackgroundColor.A);

        var glInterface = GRGlInterface.Create();
        _grContext = GRContext.CreateGl(glInterface);

        _renderTarget = new GRBackendRenderTarget(_width, _height, 0, 8, new GRGlFramebufferInfo(0, (uint)GLEnum.Rgba8));
        _skSurface = SKSurface.Create(_grContext, _renderTarget, GRSurfaceOrigin.BottomLeft, SKColorType.Rgba8888);

        _appEngine = new AppEngine(uiDrawCallback, finalBackgroundColor);
        _textService = new SilkNetTextService();
        _renderer = new SilkNetRenderer(_textService);
        _appEngine.Initialize(_textService, _renderer);

        ApplyWindowStyles(); // Apply styles after window handle is available

        _inputContext = _window.CreateInput();
        foreach (var keyboard in _inputContext.Keyboards)
        {
            keyboard.KeyDown += OnKeyDown;
            keyboard.KeyUp += OnKeyUp;
            keyboard.KeyChar += OnKeyChar;
        }
        foreach (var mouse in _inputContext.Mice)
        {
            mouse.MouseDown += OnMouseDown;
            mouse.MouseUp += OnMouseUp;
            mouse.MouseMove += OnMouseMove;
            mouse.Scroll += OnMouseWheel;
        }
    }

    private void OnRender(double delta)
    {
        _gl?.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit | ClearBufferMask.StencilBufferBit);

        if (_skSurface is null || _renderer is null || _textService is null || _appEngine is null) return;

        var bgColor = _appEngine.BackgroundColor;
        _skSurface.Canvas.Clear(new SKColor((byte)(bgColor.R * 255), (byte)(bgColor.G * 255), (byte)(bgColor.B * 255), (byte)(bgColor.A * 255)));

        _renderer.SetCanvas(_skSurface.Canvas, new Vector2(_window!.Size.X, _window.Size.Y));
        _appEngine.UpdateAndRender(_renderer, _textService);
        _skSurface.Canvas.Flush();
    }

    private void OnResize(Vector2D<int> size)
    {
        _gl?.Viewport(size);

        _renderTarget?.Dispose();
        _skSurface?.Dispose();

        _renderTarget = new GRBackendRenderTarget(size.X, size.Y, 0, 8, new GRGlFramebufferInfo(0, (uint)GLEnum.Rgba8));
        _skSurface = SKSurface.Create(_grContext, _renderTarget, GRSurfaceOrigin.BottomLeft, SKColorType.Rgba8888);
    }

    private void OnClose()
    {
        // The RunLoop will exit when this handler returns.
        // Cleanup is handled by the finally block in ApplicationRunner.
    }

    private void ApplyWindowStyles()
    {
        if (!OperatingSystem.IsWindows()) return;

        var hwnd = _window?.Native.Win32?.Hwnd ?? IntPtr.Zero;
        if (hwnd == IntPtr.Zero) return;

        bool wantsModernBackdrop = BackdropType != WindowBackdropType.Default && OperatingSystem.IsWindowsVersionAtLeast(10, 0, 22621);

        // Set Title Bar Theme (Immersive Dark Mode)
        if (OperatingSystem.IsWindowsVersionAtLeast(10, 0, 17763))
        {
            // A modern backdrop requires a modern title bar.
            // If the user requests a modern backdrop but a default title bar, we must
            // choose a theme for them. Dark is a sensible default.
            bool applyImmersiveTheme = wantsModernBackdrop || TitleBarTheme != WindowTitleBarTheme.Default;

            if (applyImmersiveTheme)
            {
                int useDarkMode = (TitleBarTheme == WindowTitleBarTheme.Light) ? 0 : 1; // Default and Dark map to 1 (dark)
                DwmApi.DwmSetWindowAttribute(hwnd, DwmApi.DWMWINDOWATTRIBUTE.DWMWA_USE_IMMERSIVE_DARK_MODE, ref useDarkMode, sizeof(int));
            }
        }

        // Set Backdrop Type (Mica/Acrylic)
        if (wantsModernBackdrop)
        {
            int backdropValue = BackdropType switch
            {
                WindowBackdropType.Mica => (int)DwmApi.DWMSYSTEMBACKDROP_TYPE.DWMSBT_MAINWINDOW,
                WindowBackdropType.Acrylic => (int)DwmApi.DWMSYSTEMBACKDROP_TYPE.DWMSBT_TRANSIENTWINDOW,
                WindowBackdropType.Tabbed => (int)DwmApi.DWMSYSTEMBACKDROP_TYPE.DWMSBT_TABBEDWINDOW,
                _ => (int)DwmApi.DWMSYSTEMBACKDROP_TYPE.DWMSBT_AUTO
            };

            // DWM BUG WORKAROUND: The DWM has a bug where light-themed Mica fails to render, showing a solid
            // color instead. We can work around this by substituting the more stable Acrylic material, which
            // provides a similar transparent effect.
            if (BackdropType == WindowBackdropType.Mica && TitleBarTheme == WindowTitleBarTheme.Light)
            {
                backdropValue = (int)DwmApi.DWMSYSTEMBACKDROP_TYPE.DWMSBT_TRANSIENTWINDOW; // Use Acrylic instead
                Console.WriteLine("DWM WORKAROUND: Light Mica requested, substituting with Light Acrylic due to DWM rendering bug.");
            }

            DwmApi.DwmSetWindowAttribute(hwnd, DwmApi.DWMWINDOWATTRIBUTE.DWMWA_SYSTEMBACKDROP_TYPE, ref backdropValue, sizeof(int));
        }
    }

    private void OnKeyDown(IKeyboard keyboard, Key key, int scancode) { if (!IsModalWindowOpen) Input.AddKeyPressed(MapKey(key)); }
    private void OnKeyUp(IKeyboard keyboard, Key key, int scancode) { if (!IsModalWindowOpen) Input.AddKeyReleased(MapKey(key)); }
    private void OnKeyChar(IKeyboard keyboard, char c) { if (!IsModalWindowOpen) Input.AddCharacterInput(c); }
    private void OnMouseDown(IMouse mouse, Silk.NET.Input.MouseButton button) { if (!IsModalWindowOpen) Input.SetMouseDown(MapMouseButton(button)); }
    private void OnMouseUp(IMouse mouse, Silk.NET.Input.MouseButton button) { if (!IsModalWindowOpen) Input.SetMouseUp(MapMouseButton(button)); }
    private void OnMouseMove(IMouse mouse, Vector2 position) { if (!IsModalWindowOpen) Input.SetMousePosition((int)position.X, (int)position.Y); }
    private void OnMouseWheel(IMouse mouse, ScrollWheel scroll) { if (!IsModalWindowOpen) Input.AddMouseWheelDelta(scroll.Y); }

    public void OpenModalWindow(string title, int width, int height, Action<UIContext> drawCallback, Action<int>? onClosedCallback = null)
    {
        if (IsModalWindowOpen || _window is null) return;

        _onModalClosedCallback = onClosedCallback;
        _modalResultCode = -1; // Default to canceled/closed

        var parentHwnd = Handle;
        if (parentHwnd != IntPtr.Zero)
        {
            EnableWindow(parentHwnd, false);
        }

        var options = WindowOptions.Default;
        options.Size = new Vector2D<int>(width, height);
        options.Title = title;
        options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.Default, new APIVersion(3, 3));
        options.WindowBorder = WindowBorder.Fixed;
        options.ShouldSwapAutomatically = false;

        if (OperatingSystem.IsWindowsVersionAtLeast(10, 0, 22000))
        {
            options.TransparentFramebuffer = true;
        }

        _activeModalIWindow = Window.Create(options);

        _activeModalIWindow.Load += () =>
        {
            _modalGl = _activeModalIWindow.CreateOpenGL();
            Color4 modalBgColor;
            bool useTransparentModalBg = OperatingSystem.IsWindowsVersionAtLeast(10, 0, 22621);

            if (useTransparentModalBg)
            {
                if (TitleBarTheme == WindowTitleBarTheme.Light)
                {
                    modalBgColor = new Color4(243 / 255f, 243 / 255f, 243 / 255f, 1 / 255f);
                }
                else
                {
                    modalBgColor = new Color4(0, 0, 0, 1 / 255f);
                }

                _modalGl.ClearColor(modalBgColor.R, modalBgColor.G, modalBgColor.B, modalBgColor.A);

                var modalHwnd = _activeModalIWindow.Native.Win32?.Hwnd ?? IntPtr.Zero;
                if (modalHwnd != IntPtr.Zero)
                {
                    // Unify theming logic with ApplyWindowStyles
                    int useDarkMode = (TitleBarTheme == WindowTitleBarTheme.Light) ? 0 : 1; // Default and Dark map to 1 (dark)
                    DwmApi.DwmSetWindowAttribute(modalHwnd, DwmApi.DWMWINDOWATTRIBUTE.DWMWA_USE_IMMERSIVE_DARK_MODE, ref useDarkMode, sizeof(int));

                    int backdropValue = (int)DwmApi.DWMSYSTEMBACKDROP_TYPE.DWMSBT_TRANSIENTWINDOW; // Acrylic for modals
                    DwmApi.DwmSetWindowAttribute(modalHwnd, DwmApi.DWMWINDOWATTRIBUTE.DWMWA_SYSTEMBACKDROP_TYPE, ref backdropValue, sizeof(int));
                }
            }
            else
            {
                modalBgColor = new Color4(60 / 255f, 60 / 255f, 60 / 255f, 1.0f);
                _modalGl.ClearColor(modalBgColor.R, modalBgColor.G, modalBgColor.B, modalBgColor.A);
            }

            var glInterface = GRGlInterface.Create();
            _modalGrContext = GRContext.CreateGl(glInterface);
            _modalRenderTarget = new GRBackendRenderTarget(width, height, 0, 8, new GRGlFramebufferInfo(0, (uint)GLEnum.Rgba8));
            _modalSkSurface = SKSurface.Create(_modalGrContext, _modalRenderTarget, GRSurfaceOrigin.BottomLeft, SKColorType.Rgba8888);

            _modalAppEngine = new AppEngine(drawCallback, modalBgColor);
            _modalTextService = new SilkNetTextService();
            _modalRenderer = new SilkNetRenderer(_modalTextService);
            _modalAppEngine.Initialize(_modalTextService, _modalRenderer);

            _modalInputContext = _activeModalIWindow.CreateInput();
            foreach (var kbd in _modalInputContext.Keyboards)
            {
                kbd.KeyDown += (_, key, _) => _modalAppEngine.Input.AddKeyPressed(MapKey(key));
                kbd.KeyUp += (_, key, _) => _modalAppEngine.Input.AddKeyReleased(MapKey(key));
                kbd.KeyChar += (_, c) => _modalAppEngine.Input.AddCharacterInput(c);
            }
            foreach (var m in _modalInputContext.Mice)
            {
                m.MouseDown += (_, btn) => _modalAppEngine.Input.SetMouseDown(MapMouseButton(btn));
                m.MouseUp += (_, btn) => _modalAppEngine.Input.SetMouseUp(MapMouseButton(btn));
                m.MouseMove += (_, pos) => _modalAppEngine.Input.SetMousePosition((int)pos.X, (int)pos.Y);
                m.Scroll += (_, scroll) => _modalAppEngine.Input.AddMouseWheelDelta(scroll.Y);
            }
        };

        _activeModalIWindow.Initialize();
        _activeModalIWindow.IsVisible = true;
    }

    public void CloseModalWindow(int resultCode = 0)
    {
        if (!IsModalWindowOpen) return;
        _modalResultCode = resultCode;
        _activeModalIWindow?.Close();
    }

    private static Keys MapKey(Key key) => key switch
    {
        Key.Space => Keys.Space,
        Key.Apostrophe => Keys.Unknown,
        Key.Comma => Keys.Unknown,
        Key.Minus => Keys.Unknown,
        Key.Period => Keys.Unknown,
        Key.Slash => Keys.Unknown,
        Key.Number0 => Keys.D0,
        Key.Number1 => Keys.D1,
        Key.Number2 => Keys.D2,
        Key.Number3 => Keys.D3,
        Key.Number4 => Keys.D4,
        Key.Number5 => Keys.D5,
        Key.Number6 => Keys.D6,
        Key.Number7 => Keys.D7,
        Key.Number8 => Keys.D8,
        Key.Number9 => Keys.D9,
        Key.Semicolon => Keys.Unknown,
        Key.Equal => Keys.Unknown,
        Key.A => Keys.A,
        Key.B => Keys.B,
        Key.C => Keys.C,
        Key.D => Keys.D,
        Key.E => Keys.E,
        Key.F => Keys.F,
        Key.G => Keys.G,
        Key.H => Keys.H,
        Key.I => Keys.I,
        Key.J => Keys.J,
        Key.K => Keys.K,
        Key.L => Keys.L,
        Key.M => Keys.M,
        Key.N => Keys.N,
        Key.O => Keys.O,
        Key.P => Keys.P,
        Key.Q => Keys.Q,
        Key.R => Keys.R,
        Key.S => Keys.S,
        Key.T => Keys.T,
        Key.U => Keys.U,
        Key.V => Keys.V,
        Key.W => Keys.W,
        Key.X => Keys.X,
        Key.Y => Keys.Y,
        Key.Z => Keys.Z,
        Key.LeftBracket => Keys.Unknown,
        Key.BackSlash => Keys.Unknown,
        Key.RightBracket => Keys.Unknown,
        Key.GraveAccent => Keys.Unknown,
        Key.World1 => Keys.Unknown,
        Key.World2 => Keys.Unknown,
        Key.Escape => Keys.Escape,
        Key.Enter => Keys.Enter,
        Key.Tab => Keys.Tab,
        Key.Backspace => Keys.Backspace,
        Key.Insert => Keys.Insert,
        Key.Delete => Keys.Delete,
        Key.Right => Keys.RightArrow,
        Key.Left => Keys.LeftArrow,
        Key.Down => Keys.DownArrow,
        Key.Up => Keys.UpArrow,
        Key.PageUp => Keys.PageUp,
        Key.PageDown => Keys.PageDown,
        Key.Home => Keys.Home,
        Key.End => Keys.End,
        Key.CapsLock => Keys.CapsLock,
        Key.ScrollLock => Keys.Unknown,
        Key.NumLock => Keys.Unknown,
        Key.PrintScreen => Keys.Unknown,
        Key.Pause => Keys.Pause,
        Key.F1 => Keys.F1,
        Key.F2 => Keys.F2,
        Key.F3 => Keys.F3,
        Key.F4 => Keys.F4,
        Key.F5 => Keys.F5,
        Key.F6 => Keys.F6,
        Key.F7 => Keys.F7,
        Key.F8 => Keys.F8,
        Key.F9 => Keys.F9,
        Key.F10 => Keys.F10,
        Key.F11 => Keys.F11,
        Key.F12 => Keys.F12,
        Key.Keypad0 => Keys.D0,
        Key.Keypad1 => Keys.D1,
        Key.Keypad2 => Keys.D2,
        Key.Keypad3 => Keys.D3,
        Key.Keypad4 => Keys.D4,
        Key.Keypad5 => Keys.D5,
        Key.Keypad6 => Keys.D6,
        Key.Keypad7 => Keys.D7,
        Key.Keypad8 => Keys.D8,
        Key.Keypad9 => Keys.D9,
        Key.ShiftLeft => Keys.Shift,
        Key.ShiftRight => Keys.Shift,
        Key.ControlLeft => Keys.Control,
        Key.ControlRight => Keys.Control,
        Key.AltLeft => Keys.Alt,
        Key.AltRight => Keys.Alt,
        Key.SuperLeft => Keys.LeftWindows,
        Key.SuperRight => Keys.RightWindows,
        Key.Menu => Keys.Menu,
        _ => Keys.Unknown,
    };

    private static DirectUI.MouseButton MapMouseButton(Silk.NET.Input.MouseButton button) => button switch
    {
        Silk.NET.Input.MouseButton.Left => DirectUI.MouseButton.Left,
        Silk.NET.Input.MouseButton.Right => DirectUI.MouseButton.Right,
        Silk.NET.Input.MouseButton.Middle => DirectUI.MouseButton.Middle,
        Silk.NET.Input.MouseButton.Button4 => DirectUI.MouseButton.XButton1,
        Silk.NET.Input.MouseButton.Button5 => DirectUI.MouseButton.XButton2,
        _ => DirectUI.MouseButton.Left,
    };

    public void Cleanup()
    {
        if (_isDisposed) return;
        HandleModalClose(); // Ensure modal resources are cleaned up if it was open
        _appEngine?.Cleanup();
        _renderer?.Cleanup();
        _textService?.Cleanup();
        _skSurface?.Dispose();
        _renderTarget?.Dispose();
        _grContext?.Dispose();
        _gl?.Dispose();
        _inputContext?.Dispose();
        _window?.Dispose();
        _isDisposed = true;
    }

    public void Dispose()
    {
        Cleanup();
        GC.SuppressFinalize(this);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Raylib\RaylibRenderer.cs">
// DirectUI/Backends/Raylib/RaylibRenderer.cs
using System;
using System.Collections.Generic;
using System.Numerics;
using DirectUI.Core;
using DirectUI.Drawing;
using Vortice.Direct2D1; // For AntialiasMode enum, even if not used by Raylib
using Raylib_cs; // Raylib specific library

namespace DirectUI.Backends;

/// <summary>
/// A rendering backend that uses Raylib to implement the IRenderer interface.
/// </summary>
public class RaylibRenderer : IRenderer
{
    // This factor compensates for the perceptual size difference between DirectWrite and FreeType rendering.
    // DirectWrite text tends to appear slightly larger/bolder for the same point size.
    private const float FONT_SCALE_FACTOR = 1.125f;
    private readonly Stack<Rectangle> _clipRectStack = new();

    public Vector2 RenderTargetSize
    {
        get
        {
            return new(
                Raylib.GetScreenWidth(),
                Raylib.GetScreenHeight());
        }
    }

    public RaylibRenderer()
    {
        // Raylib is typically initialized externally (e.g., in Program.cs or AppHost)
        // No Raylib-specific initialization needed here in the constructor.
    }

    public void DrawLine(Vector2 p1, Vector2 p2, Drawing.Color color, float strokeWidth)
    {
        // Raylib draws lines with thickness 1 by default, or you can use DrawLineEx for thicker lines
        Raylib.DrawLineEx(p1, p2, strokeWidth, color);
    }

    public void DrawBox(Vortice.Mathematics.Rect rect, BoxStyle style)
    {
        Raylib_cs.Color fillColor = style.FillColor;
        Raylib_cs.Color borderColor = style.BorderColor;

        // Round coordinates to align to the pixel grid for sharper rendering.
        float roundedX = MathF.Round(rect.X);
        float roundedY = MathF.Round(rect.Y);
        // Round the right/bottom edges and calculate width/height to avoid shimmering/gaps.
        float roundedWidth = MathF.Round(rect.X + rect.Width) - roundedX;
        float roundedHeight = MathF.Round(rect.Y + rect.Height) - roundedY;

        // Use this rounded rectangle for all drawing operations.
        Raylib_cs.Rectangle rlRect = new(roundedX, roundedY, roundedWidth, roundedHeight);

        // Border
        if (style.BorderColor.A > 0 && (style.BorderLengthTop > 0 || style.BorderLengthRight > 0 || style.BorderLengthBottom > 0 || style.BorderLengthLeft > 0))
        {
            if (style.Roundness > 0)
            {
                // Draw the outer rounded rectangle for the border
                Raylib.DrawRectangleRounded(rlRect, style.Roundness, 0, borderColor);

                // Calculate the inner rectangle for the fill
                var fillRect = new Raylib_cs.Rectangle(
                    rlRect.X + style.BorderLengthLeft,
                    rlRect.Y + style.BorderLengthTop,
                    rlRect.Width - style.BorderLengthLeft - style.BorderLengthRight,
                    rlRect.Height - style.BorderLengthTop - style.BorderLengthBottom
                );

                // Calculate the inner roundness
                float innerRoundness = style.Roundness; // This might need more sophisticated calculation

                // Draw the inner rounded rectangle for the fill color, effectively creating the border
                if (style.FillColor.A > 0 && fillRect.Width > 0 && fillRect.Height > 0)
                {
                    Raylib.DrawRectangleRounded(fillRect, innerRoundness, 0, fillColor);
                }
            }
            else
            {
                // Use original line-by-line drawing for non-rounded rectangles with rounded coordinates
                float right = rlRect.X + rlRect.Width;
                float bottom = rlRect.Y + rlRect.Height;

                // Top border
                if (style.BorderLengthTop > 0) Raylib.DrawLineEx(new Vector2(rlRect.X, rlRect.Y), new Vector2(right, rlRect.Y), style.BorderLengthTop, borderColor);
                // Right border
                if (style.BorderLengthRight > 0) Raylib.DrawLineEx(new Vector2(right, rlRect.Y), new Vector2(right, bottom), style.BorderLengthRight, borderColor);
                // Bottom border
                if (style.BorderLengthBottom > 0) Raylib.DrawLineEx(new Vector2(right, bottom), new Vector2(rlRect.X, bottom), style.BorderLengthBottom, borderColor);
                // Left border
                if (style.BorderLengthLeft > 0) Raylib.DrawLineEx(new Vector2(rlRect.X, bottom), new Vector2(rlRect.X, rlRect.Y), style.BorderLengthLeft, borderColor);

                // Now, draw the fill rectangle inside the borders
                if (style.FillColor.A > 0)
                {
                    var fillRect = new Raylib_cs.Rectangle(
                        rlRect.X + style.BorderLengthLeft,
                        rlRect.Y + style.BorderLengthTop,
                        rlRect.Width - style.BorderLengthLeft - style.BorderLengthRight,
                        rlRect.Height - style.BorderLengthTop - style.BorderLengthBottom
                    );
                    if (fillRect.Width > 0 && fillRect.Height > 0)
                    {
                        Raylib.DrawRectangleRec(fillRect, fillColor);
                    }
                }
            }
        }
        else if (style.FillColor.A > 0) // No border, just fill
        {
            if (style.Roundness > 0)
            {
                Raylib.DrawRectangleRounded(rlRect, style.Roundness, 0, fillColor);
            }
            else
            {
                Raylib.DrawRectangleRec(rlRect, fillColor);
            }
        }
    }

    public void DrawText(Vector2 origin, string text, ButtonStyle style, Alignment alignment, Vector2 maxSize, Drawing.Color color)
    {
        if (string.IsNullOrEmpty(text))
        {
            return;
        }

        float finalFontSize = style.FontSize * FONT_SCALE_FACTOR;
        int atlasSize = (int)Math.Round(finalFontSize);
        if (atlasSize <= 0) atlasSize = 1; // Prevent loading font at size 0.

        Raylib_cs.Color rlColor = color;

        // Use the FontManager to get the appropriate font, loaded at the native resolution and correct weight.
        Font rlFont = FontManager.GetFont(style.FontName, atlasSize, style.FontWeight);

        // The font size passed to Raylib should be the integer size the font atlas was generated with
        // to ensure 1:1 pixel rendering and avoid scaling artifacts.
        Vector2 measuredSize = Raylib.MeasureTextEx(rlFont, text, atlasSize, atlasSize / 10f);

        Vector2 textDrawPos = origin;

        // Apply horizontal alignment
        if (maxSize.X > 0 && measuredSize.X < maxSize.X)
        {
            switch (alignment.Horizontal)
            {
                case HAlignment.Center:
                    textDrawPos.X += (maxSize.X - measuredSize.X) / 2f;
                    break;
                case HAlignment.Right:
                    textDrawPos.X += (maxSize.X - measuredSize.X);
                    break;
            }
        }

        // Apply vertical alignment
        if (maxSize.Y > 0)
        {
            switch (alignment.Vertical)
            {
                case VAlignment.Center:
                    textDrawPos.Y += (maxSize.Y - measuredSize.Y) / 2f;
                    break;
                case VAlignment.Bottom:
                    textDrawPos.Y += (maxSize.Y - measuredSize.Y);
                    break;
            }
        }

        // Round the final position to the nearest whole pixel to prevent sub-pixel "wobble".
        textDrawPos = new Vector2(MathF.Round(textDrawPos.X), MathF.Round(textDrawPos.Y));

        // Draw using the integer atlas size to prevent scaling.
        Raylib.DrawTextEx(rlFont, text, textDrawPos, atlasSize, atlasSize / 10f, rlColor);
    }

    public void PushClipRect(Vortice.Mathematics.Rect rect, AntialiasMode antialiasMode)
    {
        // Store the original float rect on our stack to preserve precision.
        _clipRectStack.Push(new Raylib_cs.Rectangle(rect.X, rect.Y, rect.Width, rect.Height));
        ApplyScissorFromRect(rect);
    }

    public void PopClipRect()
    {
        if (_clipRectStack.Count <= 0)
        {
            return;
        }

        _clipRectStack.Pop();

        if (_clipRectStack.Count > 0)
        {
            // Re-apply the previous clip rect from the stack.
            var prevRect = _clipRectStack.Peek();
            ApplyScissorFromRect(new Vortice.Mathematics.Rect(prevRect.X, prevRect.Y, prevRect.Width, prevRect.Height));
        }
        else
        {
            // If stack is empty, end scissor mode entirely.
            Raylib.EndScissorMode();
        }
    }

    private void ApplyScissorFromRect(Vortice.Mathematics.Rect rect)
    {
        // Raylib's scissor mode is integer-based. To avoid clipping artifacts with
        // fractional coordinates, we calculate an integer-based bounding box that
        // fully contains the desired float-based rectangle.
        int x = (int)MathF.Floor(rect.X);
        int y = (int)MathF.Floor(rect.Y);
        // Add the fractional part of the origin back to the size before ceiling to ensure the rect is fully covered.
        int width = (int)MathF.Ceiling(rect.Width + (rect.X - x));
        int height = (int)MathF.Ceiling(rect.Height + (rect.Y - y));

        Raylib.BeginScissorMode(x, y, width, height);
    }

    public void Flush()
    {
        // Raylib is an immediate-mode API, no flush needed.
    }

    // Raylib specific cleanup (if any resources like fonts were loaded dynamically)
    public void Cleanup()
    {
        // No Raylib-specific font objects to dispose that are loaded here per layout.
        // If fonts were loaded with LoadFontEx, they would need UnloadFont.
        _clipRectStack.Clear();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Raylib\RaylibTextLayout.cs">
// DirectUI/Backends/Raylib/RaylibTextLayout.cs
using System;
using System.Numerics;
using DirectUI.Core;
using Vortice.Mathematics; // For Color4, Rect
using Raylib_cs; // Raylib specific library

namespace DirectUI.Backends;

/// <summary>
/// A Raylib-specific implementation of the ITextLayout interface.
/// This class stores text and provides approximate metrics.
/// </summary>
internal class RaylibTextLayout : ITextLayout
{
    public Vector2 Size { get; }
    public string Text { get; }

    private readonly Font _raylibFont;

    public RaylibTextLayout(string text, Font preloadedFont, int atlasSize)
    {
        Text = text;
        _raylibFont = preloadedFont;

        // Measure using the integer size the font was generated with to ensure 1:1 metrics.
        Size = Raylib.MeasureTextEx(_raylibFont, text, atlasSize, atlasSize / 10f);
    }

    public TextHitTestMetrics HitTestTextPosition(int textPosition, bool isTrailingHit)
    {
        // Raylib doesn't provide fine-grained text metrics per character easily.
        // This is a rough approximation based on overall text width.
        if (string.IsNullOrEmpty(Text)) return new TextHitTestMetrics(Vector2.Zero, Vector2.Zero);

        float approxCharWidth = Size.X / Text.Length;
        float x = textPosition * approxCharWidth;
        float width = approxCharWidth;

        // Adjust x if it's a trailing hit, to measure the position AFTER the character
        if (isTrailingHit) x += approxCharWidth;

        // Clamp to prevent out-of-bounds positions
        x = Math.Clamp(x, 0, Size.X);

        return new TextHitTestMetrics(new Vector2(x, 0), new Vector2(width, Size.Y));
    }

    public TextHitTestResult HitTestPoint(Vector2 point)
    {
        // This is a rough approximation for hit testing in Raylib
        if (string.IsNullOrEmpty(Text))
        {
            return new TextHitTestResult(0, false, false, new TextHitTestMetrics(Vector2.Zero, Vector2.Zero));
        }

        bool isInside = point.X >= 0 && point.X <= Size.X && point.Y >= 0 && point.Y <= Size.Y;

        float approxCharWidth = (Text.Length > 0) ? Size.X / Text.Length : 0;
        int textPosition = 0;
        bool isTrailingHit = false;

        if (approxCharWidth > 0)
        {
            textPosition = (int)(point.X / approxCharWidth);
            isTrailingHit = (point.X % approxCharWidth) > (approxCharWidth / 2f);
        }

        // Caret position can be one past the last character (i.e., at the end of the string).
        textPosition = Math.Clamp(textPosition, 0, Text.Length);
        if (isTrailingHit && textPosition < Text.Length) // If it's a trailing hit and not at the very end
        {
            textPosition++;
        }
        textPosition = Math.Clamp(textPosition, 0, Text.Length); // Final clamp

        // Recalculate metrics for the specific hit position
        float hitMetricX = (textPosition == 0) ? 0 : (textPosition * approxCharWidth);
        if (isTrailingHit && textPosition > 0) hitMetricX -= approxCharWidth; // Adjust if hit is trailing edge

        return new TextHitTestResult(textPosition, isTrailingHit, isInside,
            new TextHitTestMetrics(new Vector2(hitMetricX, 0), new Vector2(approxCharWidth, Size.Y)));
    }

    public void Dispose()
    {
        // This object doesn't own the font resource, so it does not dispose it.
        // FontManager is responsible for unloading fonts.
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Raylib\RaylibTextService.cs">
// DirectUI/Backends/Raylib/RaylibTextService.cs
using System;
using System.Collections.Generic;
using System.Numerics;
using DirectUI.Core;
using DirectUI.Drawing;
using Vortice.Mathematics; // For Color4, Rect
using Raylib_cs; // Raylib specific library

namespace DirectUI.Backends;

/// <summary>
/// An implementation of ITextService that uses Raylib.
/// It manages caches for text layouts.
/// </summary>
public class RaylibTextService : ITextService
{
    // This factor compensates for the perceptual size difference between DirectWrite and FreeType rendering.
    // DirectWrite text tends to appear slightly larger/bolder for the same point size.
    private const float FONT_SCALE_FACTOR = 1.125f;

    private readonly Dictionary<TextLayoutCacheKey, ITextLayout> _textLayoutCache = new();
    private readonly Dictionary<(string, FontKey), Vector2> _textSizeCache = new();

    // Internal cache key structs (re-defined or referenced from a common place)
    internal readonly struct FontKey(ButtonStyle style) : IEquatable<FontKey>
    {
        private readonly string FontName = style.FontName;
        private readonly float FontSize = style.FontSize;
        private readonly Vortice.DirectWrite.FontWeight FontWeight = style.FontWeight;
        private readonly Vortice.DirectWrite.FontStyle FontStyle = style.FontStyle;
        private readonly Vortice.DirectWrite.FontStretch FontStretch = style.FontStretch;
        public bool Equals(FontKey other) => FontName == other.FontName && FontSize.Equals(other.FontSize) && FontWeight == other.FontWeight && FontStyle == other.FontStyle && FontStretch == other.FontStretch;
        public override bool Equals(object? obj) => obj is FontKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(FontName, FontSize, FontWeight, FontStyle, FontStretch);
    }

    internal readonly struct TextLayoutCacheKey(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment) : IEquatable<TextLayoutCacheKey>
    {
        private readonly string Text = text;
        private readonly FontKey FontKey = new(style);
        private readonly Vector2 MaxSize = maxSize;
        private readonly HAlignment HAlign = alignment.Horizontal;
        private readonly VAlignment VAlign = alignment.Vertical;
        public bool Equals(TextLayoutCacheKey other) => Text == other.Text && MaxSize.Equals(other.MaxSize) && HAlign == other.HAlign && VAlign == other.VAlign && FontKey.Equals(other.FontKey);
        public override bool Equals(object? obj) => obj is TextLayoutCacheKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(Text, FontKey, MaxSize, HAlign, VAlign);
    }

    public RaylibTextService()
    {
        // No specific Raylib font factory initialization needed here
    }

    public Vector2 MeasureText(string text, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(text) || style is null) return Vector2.Zero;

        var fontKey = new FontKey(style);
        var cacheKey = (text, fontKey);
        if (_textSizeCache.TryGetValue(cacheKey, out var cachedSize)) return cachedSize;

        float finalFontSize = style.FontSize * FONT_SCALE_FACTOR;
        int atlasSize = (int)Math.Round(finalFontSize);
        if (atlasSize <= 0) atlasSize = 1;

        // Use the FontManager to get the appropriate font at the native resolution and correct weight.
        Font rlFont = FontManager.GetFont(style.FontName, atlasSize, style.FontWeight);

        // Measure using the integer atlas size for accurate, non-scaled metrics.
        Vector2 measuredSize = Raylib.MeasureTextEx(rlFont, text, atlasSize, atlasSize / 10f);
        _textSizeCache[cacheKey] = measuredSize;
        return measuredSize;
    }

    public ITextLayout GetTextLayout(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment)
    {
        var layoutKey = new TextLayoutCacheKey(text, style, maxSize, alignment);
        if (_textLayoutCache.TryGetValue(layoutKey, out var cachedLayout))
        {
            return cachedLayout;
        }

        float finalFontSize = style.FontSize * FONT_SCALE_FACTOR;
        int atlasSize = (int)Math.Round(finalFontSize);
        if (atlasSize <= 0) atlasSize = 1;

        // Fetch the font at the correct, native atlas resolution and weight.
        var font = FontManager.GetFont(style.FontName, atlasSize, style.FontWeight);

        // Pass the pre-loaded font and the integer atlas size to the layout constructor.
        var newLayout = new RaylibTextLayout(text, font, atlasSize);
        _textLayoutCache[layoutKey] = newLayout;
        return newLayout;
    }

    public void Cleanup()
    {
        Console.WriteLine("RaylibTextService Cleanup: Clearing cached resources...");
        foreach (var pair in _textLayoutCache) { pair.Value?.Dispose(); } // Dispose the ITextLayout instances
        _textLayoutCache.Clear();
        _textSizeCache.Clear();
        Console.WriteLine("RaylibTextService Cleanup finished.");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\Raylib\RaylibWindowHost.cs">
// DirectUI/RaylibWindowHost.cs
using System;
using System.Numerics;
using DirectUI.Core; // For IWindowHost, IModalWindowService
using DirectUI.Drawing;
using DirectUI.Input;
using Raylib_cs;
using Vortice.Mathematics;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI;

/// <summary>
/// A concrete implementation of <see cref="IWindowHost"/> for the Raylib backend.
/// </summary>
public class RaylibWindowHost : IWindowHost
{
    private readonly string _title;
    private readonly int _width;
    private readonly int _height;
    private readonly Color4 _backgroundColor;

    private AppEngine? _appEngine;
    private IRenderer? _renderer;
    private ITextService? _textService;
    private bool _isDisposed = false;

    // Raylib doesn't have a native window handle like Win32 or SDL, so this will be IntPtr.Zero.
    public IntPtr Handle => IntPtr.Zero;
    public InputManager Input => _appEngine?.Input ?? new InputManager();
    public SizeI ClientSize => new SizeI(Raylib.GetScreenWidth(), Raylib.GetScreenHeight());

    public bool ShowFpsCounter
    {
        get => _appEngine?.ShowFpsCounter ?? false;
        set { if (_appEngine is not null) _appEngine.ShowFpsCounter = value; }
    }

    public IModalWindowService ModalWindowService { get; } = new RaylibDummyModalWindowService();

    public RaylibWindowHost(string title, int width, int height, Color4 backgroundColor)
    {
        _title = title;
        _width = width;
        _height = height;
        _backgroundColor = backgroundColor;
    }

    public bool Initialize(Action<UIContext> uiDrawCallback, Color4 backgroundColor)
    {
        Console.WriteLine("RaylibWindowHost initializing...");
        try
        {
            Raylib.SetConfigFlags(ConfigFlags.Msaa4xHint);
            Raylib.InitWindow(_width, _height, _title);
            Raylib.SetTargetFPS(60);

            _appEngine = new AppEngine(uiDrawCallback, backgroundColor);
            _renderer = new DirectUI.Backends.RaylibRenderer();
            _textService = new DirectUI.Backends.RaylibTextService();

            // Raylib-specific font initialization and registration
            FontManager.Initialize();
            FontManager.RegisterFontVariant("Segoe UI", Vortice.DirectWrite.FontWeight.Normal, "C:/Windows/Fonts/segoeui.ttf");
            FontManager.RegisterFontVariant("Segoe UI", Vortice.DirectWrite.FontWeight.SemiBold, "C:/Windows/Fonts/seguisb.ttf");
            FontManager.RegisterFontVariant("Consolas", Vortice.DirectWrite.FontWeight.Normal, "C:/Windows/Fonts/consola.ttf");
            FontManager.RegisterFontVariant("Consolas", Vortice.DirectWrite.FontWeight.Bold, "C:/Windows/Fonts/consolab.ttf");

            _appEngine.Initialize(_textService, _renderer);
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to initialize RaylibWindowHost: {ex.Message}");
            Cleanup(); // Ensure partial initialization is cleaned up
            return false;
        }
    }

    public void RunLoop()
    {
        while (!Raylib.WindowShouldClose())
        {
            // Process Raylib input events directly
            _appEngine?.Input.ProcessRaylibInput();

            // Begin drawing
            Raylib.BeginDrawing();
            Raylib.ClearBackground(new Raylib_cs.Color(
                (byte)(_backgroundColor.R * 255),
                (byte)(_backgroundColor.G * 255),
                (byte)(_backgroundColor.B * 255),
                (byte)(_backgroundColor.A * 255)
            ));

            // Update and render the UI through the AppEngine
            if (_renderer is not null && _textService is not null && _appEngine is not null)
            {
                _appEngine.UpdateAndRender(_renderer, _textService);
            }

            // End drawing
            Raylib.EndDrawing();
        }
    }

    public void Cleanup()
    {
        if (_isDisposed) return;
        Console.WriteLine("RaylibWindowHost cleaning up its resources...");
        _appEngine?.Cleanup();
        (_renderer as DirectUI.Backends.RaylibRenderer)?.Cleanup(); // Explicit cast for Cleanup
        (_textService as DirectUI.Backends.RaylibTextService)?.Cleanup(); // Explicit cast for Cleanup
        FontManager.UnloadAll(); // Unload all Raylib fonts

        if (Raylib.IsWindowReady())
        {
            Raylib.CloseWindow();
        }
        _appEngine = null;
        _renderer = null;
        _textService = null;
        _isDisposed = true;
        GC.SuppressFinalize(this);
    }

    public void Dispose()
    {
        Cleanup();
    }

    private class RaylibDummyModalWindowService : IModalWindowService
    {
        public bool IsModalWindowOpen => false;

        public void OpenModalWindow(string title, int width, int height, Action<UIContext> drawCallback, Action<int>? onClosedCallback = null)
        {
            Console.WriteLine($"Modal window '{title}' requested but not supported in Raylib backend.");
            onClosedCallback?.Invoke(-1); // Immediately report as closed/failed
        }

        public void CloseModalWindow(int resultCode = 0)
        {
            // Do nothing as no modal windows are opened.
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\SDL3\SDL3Renderer.cs">
using System.Numerics;
using DirectUI.Core;
using SDL3;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace DirectUI.Backends.SDL3;

public unsafe class SDL3Renderer : IRenderer
{
    private readonly nint _rendererPtr;
    private readonly nint _windowPtr;

    private int _windowWidth;
    private int _windowHeight;

    private readonly Stack<Rect> _clipRectStack = new();
    private readonly Dictionary<TextRenderCacheKey, nint> _textTextureCache = new();

    private const float FONT_SCALE_FACTOR = 1.125f;

    private readonly struct TextRenderCacheKey : IEquatable<TextRenderCacheKey>
    {
        public readonly string Text;
        public readonly float FontSize;
        public readonly FontWeight FontWeight;
        public readonly FontStyle FontStyle;
        public readonly FontStretch FontStretch;
        public readonly Color Color;

        public TextRenderCacheKey(string text, ButtonStyle style, Color color)
        {
            Text = text;
            FontSize = style.FontSize;
            FontWeight = style.FontWeight;
            FontStyle = style.FontStyle;
            FontStretch = style.FontStretch;
            Color = color;
        }

        public bool Equals(TextRenderCacheKey other)
        {
            return Text == other.Text 
                && FontSize.Equals(other.FontSize) 
                && FontWeight == other.FontWeight 
                && FontStyle == other.FontStyle 
                && FontStretch == other.FontStretch 
                && Color.Equals(other.Color);
        }

        public override bool Equals(object? obj)
        {
            return obj is TextRenderCacheKey other && Equals(other);
        }

        public override int GetHashCode()
        {
            return HashCode.Combine(
                Text,
                FontSize,
                FontWeight,
                FontStyle,
                FontStretch,
                Color);
        }
    }

    public Vector2 RenderTargetSize
    {
        get
        {
            SDL.GetWindowSize(_windowPtr, out _windowWidth, out _windowHeight);
            return new(_windowWidth, _windowHeight);
        }
    }

    public SDL3Renderer(nint rendererPtr, nint windowPtr)
    {
        _rendererPtr = rendererPtr;
        _windowPtr = windowPtr;

        SDL.GetWindowSize(_windowPtr, out _windowWidth, out _windowHeight);
    }

    internal void UpdateWindowSize(int width, int height)
    {
        _windowWidth = width;
        _windowHeight = height;
    }

    public void DrawLine(Vector2 p1, Vector2 p2, Drawing.Color color, float strokeWidth)
    {
        SDL.SetRenderDrawColor(_rendererPtr, color.R, color.G, color.B, color.A);

        if (strokeWidth <= 1.0f)
        {
            // Draw 1-pixel thin line
            SDL.RenderLine(_rendererPtr, (int)p1.X, (int)p1.Y, (int)p2.X, (int)p2.Y);
        }
        else
        {
            // For thicker lines, approximate with a filled rectangle.
            // This is a basic approximation, primarily for axis-aligned or near-axis-aligned lines.
            // For general diagonal lines with thickness, more complex geometry (like a rotated rectangle or two triangles)
            // or a dedicated library (e.g., SDL_gfx or custom shader) would be required.

            float halfStroke = strokeWidth / 2f;
            float dx = p2.X - p1.X;
            float dy = p2.Y - p1.Y;

            // If it's more horizontal
            if (Math.Abs(dx) >= Math.Abs(dy))
            {
                SDL.FRect rectangle = new()
                {
                    X = Math.Min(p1.X, p2.X),
                    Y = (p1.Y + p2.Y) / 2f - halfStroke, // Center Y on the line's average Y
                    W = Math.Abs(dx),
                    H = strokeWidth
                };
                SDL.RenderFillRect(_rendererPtr, rectangle);
            }
            // If it's more vertical
            else
            {
                SDL.FRect rectangle = new()
                {
                    X = (p1.X + p2.X) / 2f - halfStroke, // Center X on the line's average X
                    Y = Math.Min(p1.Y, p2.Y),
                    W = strokeWidth,
                    H = Math.Abs(dy)
                };
                SDL.RenderFillRect(_rendererPtr, rectangle);
            }
        }
    }

    public void DrawBox(Vortice.Mathematics.Rect rect, BoxStyle style)
    {
        // Convert Vortice.Mathematics.Rect to SDL.FRect for drawing
        SDL.FRect outerRect = new()
        {
            X = rect.X,
            Y = rect.Y,
            W = rect.Width,
            H = rect.Height
        };

        // 1. Draw the border background (entire rectangle with border color)
        // If border color is transparent or all border lengths are zero, this step effectively does nothing visually.
        if (style.BorderColor.A > 0 && (style.BorderLengthTop > 0 || style.BorderLengthRight > 0 || style.BorderLengthBottom > 0 || style.BorderLengthLeft > 0))
        {
            SDL.SetRenderDrawColor(_rendererPtr, style.BorderColor.R, style.BorderColor.G, style.BorderColor.B, style.BorderColor.A);
            SDL.RenderFillRect(_rendererPtr, outerRect);
        }

        // 2. Draw the inner fill rectangle (inset by border lengths)
        if (style.FillColor.A > 0)
        {
            float fillX = rect.X + style.BorderLengthLeft;
            float fillY = rect.Y + style.BorderLengthTop;
            float fillWidth = Math.Max(0f, rect.Width - style.BorderLengthLeft - style.BorderLengthRight);
            float fillHeight = Math.Max(0f, rect.Height - style.BorderLengthTop - style.BorderLengthBottom);

            if (fillWidth > 0 && fillHeight > 0)
            {
                SDL.FRect fillRect = new()
                {
                    X = fillX,
                    Y = fillY,
                    W = fillWidth,
                    H = fillHeight
                };

                SDL.SetRenderDrawColor(_rendererPtr, style.FillColor.R, style.FillColor.G, style.FillColor.B, style.FillColor.A);
                SDL.RenderFillRect(_rendererPtr, fillRect);
            }
            // Special case: If no border is defined (all lengths 0) and the fill itself is opaque,
            // the above fillRect might be invalid (e.g. if original rect had 0 width/height)
            // In such a scenario, we still want to draw the full outerRect with the fill color if it's visible.
            else if (style.BorderLengthTop == 0 && style.BorderLengthRight == 0 && style.BorderLengthBottom == 0 && style.BorderLengthLeft == 0 && (outerRect.W > 0 && outerRect.H > 0))
            {
                SDL.SetRenderDrawColor(_rendererPtr, style.FillColor.R, style.FillColor.G, style.FillColor.B, style.FillColor.A);
                SDL.RenderFillRect(_rendererPtr, outerRect);
            }
        }
        // Roundness is not natively supported by SDL's basic renderer. It will be drawn as square corners.
    }

    public void DrawText(Vector2 origin, string text, ButtonStyle style, Alignment alignment, Vector2 maxSize, Drawing.Color color)
    {
        if (string.IsNullOrEmpty(text))
        {
            return;
        }

        if (UI.Context.TextService is not SDL3TextService textService)
        {
            Console.WriteLine("Error: SDL3TextService not available for text rendering.");
            return;
        }

        // Get the font
        float effectiveFontSize = style.FontSize * FONT_SCALE_FACTOR;
        nint fontPtr = textService.GetOrCreateFont(style.FontName, (int)Math.Round(effectiveFontSize), style.FontWeight);

        if (fontPtr == nint.Zero)
        {
            Console.WriteLine($"Error: Font '{style.FontName}' could not be loaded.");
            return;
        }

        TextRenderCacheKey cacheKey = new(text, style, color);
        
        if (!_textTextureCache.TryGetValue(cacheKey, out nint textTexture))
        {
            SDL.Color sdlColor = new() { R = color.R, G = color.G, B = color.B, A = color.A };
            nint textSurface = TTF.RenderTextBlended(fontPtr, text, 0, sdlColor);

            if (textSurface == nint.Zero)
            {
                Console.WriteLine($"Error rendering text surface: {SDL.GetError()}");
                return;
            }

            textTexture = SDL.CreateTextureFromSurface(_rendererPtr, textSurface);
            SDL.DestroySurface(textSurface);

            if (textTexture == nint.Zero)
            {
                Console.WriteLine($"Error creating text texture: {SDL.GetError()}");
                return;
            }

            _textTextureCache[cacheKey] = textTexture;
        }

        // ✅ SDL3-compatible way to get texture dimensions

        if (!SDL.GetTextureSize(textTexture, out float texW, out float texH))
        {
            Console.WriteLine($"Error getting texture size: {SDL.GetError()}");
            return;
        }

        Vector2 measuredSize = new(texW, texH);
        Vector2 textDrawPos = origin;

        // Horizontal alignment
        if (maxSize.X > 0 && measuredSize.X < maxSize.X)
        {
            switch (alignment.Horizontal)
            {
                case HAlignment.Center:
                    textDrawPos.X += (maxSize.X - measuredSize.X) / 2f;
                    break;
                case HAlignment.Right:
                    textDrawPos.X += (maxSize.X - measuredSize.X);
                    break;
            }
        }

        // Vertical alignment
        if (maxSize.Y > 0)
        {
            switch (alignment.Vertical)
            {
                case VAlignment.Center:
                    textDrawPos.Y += (maxSize.Y - measuredSize.Y) / 2f;
                    break;
                case VAlignment.Bottom:
                    textDrawPos.Y += (maxSize.Y - measuredSize.Y);
                    break;
            }
        }

        SDL.FRect dstRect = new()
        {
            X = textDrawPos.X,
            Y = textDrawPos.Y,
            W = texW,
            H = texH
        };

        SDL.RenderTexture(_rendererPtr, textTexture, nint.Zero, dstRect);
    }

    public void PushClipRect(Rect rect, AntialiasMode antialiasMode)
    {
        _clipRectStack.Push(rect);
        ApplyClipRect(rect);
    }

    public void PopClipRect()
    {
        if (_clipRectStack.Count <= 0)
        {
            return;
        }

        _clipRectStack.Pop();

        if (_clipRectStack.Count > 0)
        {
            ApplyClipRect(_clipRectStack.Peek());
        }
        else
        {
            // Clear clip rect
            SDL.Rect rect = new()
            {
                X = 0,
                Y = 0,
                W = _windowWidth,
                H = _windowHeight,
            };

            SDL.SetRenderClipRect(_rendererPtr, rect);
        }
    }

    private void ApplyClipRect(Rect rect)
    {
        SDL.Rect clipRect = new()
        {
            X = (int)float.Floor(rect.X),
            Y = (int)float.Floor(rect.Y),
            W = (int)float.Ceiling(rect.Width + (rect.X - float.Floor(rect.X))),
            H = (int)float.Ceiling(rect.Height + (rect.Y - float.Floor(rect.Y)))
        };

        SDL.SetRenderClipRect(_rendererPtr, clipRect);
    }

    public void Flush()
    {
        // SDL's 2D renderer typically renders commands immediately to an internal buffer.
        // The SDL_RenderPresent call (handled by SDL3UIHost) does the actual flush to screen.
    }

    public void Cleanup()
    {
        _clipRectStack.Clear();

        foreach (nint texture in _textTextureCache.Values)
        {
            SDL.DestroyTexture(texture);
        }

        _textTextureCache.Clear();
        // The renderer and window are managed and destroyed by ApplicationRunner.
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\SDL3\SDL3TextLayout.cs">
using System;
using System.Numerics;
using DirectUI.Core;
using SDL3;
using Vortice.DirectWrite; // For FontWeight, etc.

namespace DirectUI.Backends.SDL3;

/// <summary>
/// A minimal implementation of ITextLayout for SDL3.
/// This will be expanded in a later step.
/// </summary>
internal unsafe class SDL3TextLayout : ITextLayout
{
    public Vector2 Size { get; }
    public string Text { get; }

    private readonly nint _fontPtr; // Pointer to the TTF.Font object

    public SDL3TextLayout(string text, nint fontPtr)
    {
        Text = text;
        _fontPtr = fontPtr;

        // SDL3_ttf: Use TTF.GetStringSize instead of deprecated TTF.SizeUTF8
        if (!string.IsNullOrEmpty(text) && fontPtr != nint.Zero)
        {
            if (TTF.GetStringSize(fontPtr, text, 0, out int w, out int h))
            {
                Size = new Vector2(w, h);
            }
            else
            {
                Console.WriteLine($"Error measuring text '{text}': {SDL.GetError()}");
                Size = Vector2.Zero;
            }
        }
        else
        {
            Size = Vector2.Zero;
        }
    }

    public TextHitTestMetrics HitTestTextPosition(int textPosition, bool isTrailingHit)
    {
        // Placeholder implementation as SDL_ttf does not provide direct hit-testing.
        if (string.IsNullOrEmpty(Text)) return new TextHitTestMetrics(Vector2.Zero, Vector2.Zero);

        float approxCharWidth = Size.X / Math.Max(1, Text.Length);
        float x = textPosition * approxCharWidth;
        float width = approxCharWidth;

        // Adjust x if it's a trailing hit, to measure the position AFTER the character
        if (isTrailingHit) x += approxCharWidth;

        // Clamp to prevent out-of-bounds positions
        x = Math.Clamp(x, 0, Size.X);

        return new TextHitTestMetrics(new Vector2(x, 0), new Vector2(width, Size.Y));
    }

    public TextHitTestResult HitTestPoint(Vector2 point)
    {
        // Placeholder implementation as SDL_ttf does not provide direct hit-testing.
        if (string.IsNullOrEmpty(Text))
        {
            return new TextHitTestResult(0, false, false, new TextHitTestMetrics(Vector2.Zero, Vector2.Zero));
        }

        bool isInside = point.X >= 0 && point.X <= Size.X && point.Y >= 0 && point.Y <= Size.Y;

        float approxCharWidth = (Text.Length > 0) ? Size.X / Text.Length : 0;
        int textPosition = 0;
        bool isTrailingHit = false;

        if (approxCharWidth > 0)
        {
            textPosition = (int)(point.X / approxCharWidth);
            isTrailingHit = (point.X % approxCharWidth) > (approxCharWidth / 2f);
        }

        // Caret position can be one past the last character (i.e., at the end of the string).
        textPosition = Math.Clamp(textPosition, 0, Text.Length);
        if (isTrailingHit && textPosition < Text.Length) // If it's a trailing hit and not at the very end
        {
            textPosition++;
        }
        textPosition = Math.Clamp(textPosition, 0, Text.Length); // Final clamp

        // Recalculate metrics for the specific hit position
        float hitMetricX = (textPosition == 0) ? 0 : (textPosition * approxCharWidth);
        if (isTrailingHit && textPosition > 0) hitMetricX -= approxCharWidth; // Adjust if hit is trailing edge

        return new TextHitTestResult(textPosition, isTrailingHit, isInside,
            new TextHitTestMetrics(new Vector2(hitMetricX, 0), new Vector2(approxCharWidth, Size.Y)));
    }

    public void Dispose()
    {
        // This object does not own the font pointer; it's owned by SDL3TextService.
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\SDL3\SDL3TextService.cs">
using System;
using System.Collections.Generic;
using System.IO;
using System.Numerics;
using DirectUI.Core;
using DirectUI.Drawing;
using SDL3;
using Vortice.DirectWrite; // For FontWeight, FontStyle, FontStretch

namespace DirectUI.Backends.SDL3;

public unsafe class SDL3TextService : ITextService
{
    private readonly Dictionary<FontKey, nint> _fontCache = new();
    private readonly Dictionary<TextLayoutCacheKey, ITextLayout> _textLayoutCache = new();
    private readonly Dictionary<(string, FontKey), Vector2> _textSizeCache = new();

    // This factor compensates for the perceptual size difference between DirectWrite and FreeType rendering.
    private const float FONT_SCALE_FACTOR = 1.125f;

    // Internal static dictionary for font file paths for SDL3
    private static readonly Dictionary<string, Dictionary<FontWeight, string>> s_sdlFontFilePaths = new();
    private static bool s_defaultFontsRegistered = false; // Flag to ensure registration happens only once

    // Internal cache key structs
    internal readonly struct FontKey(string fontName, int fontSize, FontWeight fontWeight) : IEquatable<FontKey>
    {
        private readonly string FontName = fontName;
        private readonly int FontSize = fontSize; // Stored as integer atlas size
        private readonly FontWeight FontWeight = fontWeight;
        // FontStyle and FontStretch are not directly supported by TTF.OpenFont,
        // so we omit them from the key or map them to file paths.

        public bool Equals(FontKey other) => FontName == other.FontName && FontSize.Equals(other.FontSize) && FontWeight == other.FontWeight;
        public override bool Equals(object? obj) => obj is FontKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(FontName, FontSize, FontWeight);
    }

    internal readonly struct TextLayoutCacheKey(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment) : IEquatable<TextLayoutCacheKey>
    {
        private readonly string Text = text;
        private readonly FontKey FontKey = new(style.FontName, (int)Math.Round(style.FontSize * FONT_SCALE_FACTOR), style.FontWeight); // Cache by actual font properties
        private readonly Vector2 MaxSize = maxSize;
        private readonly HAlignment HAlign = alignment.Horizontal;
        private readonly VAlignment VAlign = alignment.Vertical;
        public bool Equals(TextLayoutCacheKey other) => Text == other.Text && MaxSize.Equals(other.MaxSize) && HAlign == other.HAlign && VAlign == other.VAlign && FontKey.Equals(other.FontKey);
        public override bool Equals(object? obj) => obj is TextLayoutCacheKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(Text, FontKey, MaxSize, HAlign, VAlign);
    }

    public SDL3TextService()
    {
        // TTF.Init() should be called globally ONCE, not per instance.
        // It's handled by SDL3WindowHost now.
    }

    /// <summary>
    /// Registers default font paths for SDL_ttf. This should be called once globally.
    /// </summary>
    internal static void RegisterDefaultFonts()
    {
        if (s_defaultFontsRegistered) return;

        s_sdlFontFilePaths["Segoe UI"] = new Dictionary<FontWeight, string>
        {
            { FontWeight.Normal, "C:/Windows/Fonts/segoeui.ttf" },
            { FontWeight.SemiBold, "C:/Windows/Fonts/seguisb.ttf" }
        };
        s_sdlFontFilePaths["Consolas"] = new Dictionary<FontWeight, string>
        {
            { FontWeight.Normal, "C:/Windows/Fonts/consola.ttf" },
            { FontWeight.Bold, "C:/Windows/Fonts/consolab.ttf" }
        };
        s_sdlFontFilePaths["Arial"] = new Dictionary<FontWeight, string>
        {
            { FontWeight.Normal, "C:/Windows/Fonts/arial.ttf" }
        };

        s_defaultFontsRegistered = true;
    }

    /// <summary>
    /// Attempts to retrieve the file path for a registered font variant for SDL_ttf.
    /// </summary>
    internal static bool TryGetSdlFontFilePath(string familyName, FontWeight weight, out string? filePath)
    {
        filePath = null;
        if (s_sdlFontFilePaths.TryGetValue(familyName, out var variants))
        {
            if (variants.TryGetValue(weight, out filePath))
            {
                return true;
            }
            // Fallback to Normal weight if specific weight not found
            if (variants.TryGetValue(FontWeight.Normal, out filePath))
            {
                return true;
            }
        }
        // Fallback to Arial if original family not found
        if (s_sdlFontFilePaths.TryGetValue("Arial", out var arialVariants) && arialVariants.TryGetValue(FontWeight.Normal, out filePath))
        {
            Console.WriteLine($"Warning: Font family '{familyName}' (weight {weight}) not found. Falling back to Arial.");
            return true;
        }
        return false;
    }


    public nint GetOrCreateFont(string familyName, int fontSize, FontWeight weight)
    {
        FontKey key = new(familyName, fontSize, weight);

        if (_fontCache.TryGetValue(key, out nint fontPtr))
        {
            return fontPtr;
        }

        if (!TryGetSdlFontFilePath(familyName, weight, out string? filePath))
        {
            Console.WriteLine($"Warning: Could not find font file for family '{familyName}' (weight {weight}) or a fallback. Returning null font pointer.");
            return nint.Zero;
        }

        // Open font using SDL_ttf
        fontPtr = TTF.OpenFont(filePath, fontSize);

        if (fontPtr == nint.Zero)
        {
            Console.WriteLine($"Error opening font '{filePath}' at size {fontSize}: {SDL.GetError()}");
            return nint.Zero;
        }

        _fontCache[key] = fontPtr;
        return fontPtr;
    }

    public Vector2 MeasureText(string text, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(text) || style is null)
            return Vector2.Zero;

        float effectiveFontSize = style.FontSize * FONT_SCALE_FACTOR;
        int atlasSize = Math.Max(1, (int)Math.Round(effectiveFontSize));

        var fontKey = new FontKey(style.FontName, atlasSize, style.FontWeight);
        var cacheKey = (text, fontKey);
        if (_textSizeCache.TryGetValue(cacheKey, out var cachedSize))
            return cachedSize;

        nint fontPtr = GetOrCreateFont(style.FontName, atlasSize, style.FontWeight);
        if (fontPtr == nint.Zero)
            return Vector2.Zero;

        if (TTF.GetStringSize(fontPtr, text, 0, out int w, out int h))
        {
            var measuredSize = new Vector2(w, h);
            _textSizeCache[cacheKey] = measuredSize;
            return measuredSize;
        }
        else
        {
            Console.WriteLine($"Error measuring text '{text}': {SDL.GetError()}");
            return Vector2.Zero;
        }
    }

    public ITextLayout GetTextLayout(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment)
    {
        var layoutKey = new TextLayoutCacheKey(text, style, maxSize, alignment);
        if (_textLayoutCache.TryGetValue(layoutKey, out var cachedLayout))
        {
            return cachedLayout;
        }

        float effectiveFontSize = style.FontSize * FONT_SCALE_FACTOR;
        int atlasSize = (int)Math.Round(effectiveFontSize);
        if (atlasSize <= 0) atlasSize = 1;

        nint fontPtr = GetOrCreateFont(style.FontName, atlasSize, style.FontWeight);
        if (fontPtr == nint.Zero)
        {
            Console.WriteLine($"Error: Font not found for text layout '{text}'");
            return new SDL3TextLayout("", nint.Zero); // Return a dummy layout
        }

        var newLayout = new SDL3TextLayout(text, fontPtr);
        _textLayoutCache[layoutKey] = newLayout;
        return newLayout;
    }

    public void Cleanup()
    {
        Console.WriteLine("SDL3TextService Cleanup: Disposing cached resources...");
        // Close fonts for this specific instance's cache
        foreach (var fontPtr in _fontCache.Values)
        {
            if (fontPtr != nint.Zero)
            {
                TTF.CloseFont(fontPtr);
            }
        }
        _fontCache.Clear();
        _textLayoutCache.Clear();
        _textSizeCache.Clear();

        // TTF.Quit() is now handled globally by SDL3WindowHost
        Console.WriteLine("SDL3TextService Cleanup finished.");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Backends\SDL3\SDL3WindowHost.cs">
using DirectUI.Core;
using DirectUI.Input;
using SDL3;
using Vortice.Mathematics;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI.Backends.SDL3;

public unsafe class SDL3WindowHost : IWindowHost, IModalWindowService
{
    private readonly string _title;
    private readonly int _initialWidth;
    private readonly int _initialHeight;
    private readonly Color4 _backgroundColor;

    private nint _windowPtr;
    private nint _rendererPtr;

    private AppEngine? _appEngine;
    private SDL3Renderer? _renderer;
    private SDL3TextService? _textService;
    private bool _isDisposed;

    private static int s_sdlInitCount = 0;
    private static int s_ttfInitCount = 0;

    private SDL3WindowHost? _activeModalWindow;
    private Action<UIContext>? _modalDrawCallback;
    private Action<int>? _onModalClosedCallback;
    private int _modalResultCode;
    private bool _isModalClosing;

    public IntPtr Handle => _windowPtr;
    public InputManager Input => _appEngine?.Input ?? new();
    public SizeI ClientSize
    {
        get
        {
            SDL.GetWindowSize(_windowPtr, out int w, out int h);
            return new SizeI(w, h);
        }
    }

    public bool ShowFpsCounter
    {
        get
        {
            return _appEngine?.ShowFpsCounter ?? false;
        }

        set
        {
            if (_appEngine is null)
            {
                return;
            }

            _appEngine.ShowFpsCounter = value;
        }
    }

    public IModalWindowService ModalWindowService => this;

    public SDL3WindowHost(string title, int width, int initialHeight, Color4 backgroundColor)
    {
        _title = title;
        _initialWidth = width;
        _initialHeight = initialHeight;
        _backgroundColor = backgroundColor;
    }

    public bool Initialize(Action<UIContext> uiDrawCallback, Color4 backgroundColor)
    {
        Console.WriteLine($"SDL3WindowHost initializing for '{_title}'...");

        try
        {
            Interlocked.Increment(ref s_sdlInitCount);

            if (s_sdlInitCount == 1)
            {
                if (!SDL.Init(SDL.InitFlags.Video))
                {
                    Console.WriteLine($"SDL could not initialize! SDL_Error: {SDL.GetError()}");
                    return false;
                }
            }

            Interlocked.Increment(ref s_ttfInitCount);

            if (s_ttfInitCount == 1)
            {
                if (!TTF.Init())
                {
                    Console.WriteLine($"SDL_ttf could not initialize! SDL_Error: {SDL.GetError()}");
                    return false;
                }
                SDL3TextService.RegisterDefaultFonts();
            }

            _windowPtr = SDL.CreateWindow(_title, _initialWidth, _initialHeight, SDL.WindowFlags.Resizable);

            if (_windowPtr == nint.Zero)
            {
                Console.WriteLine($"Window could not be created! SDL_Error: {SDL.GetError()}");
                return false;
            }

            _rendererPtr = SDL.CreateRenderer(_windowPtr, null);

            if (_rendererPtr == nint.Zero)
            {
                Console.WriteLine($"Renderer could not be created! SDL Error: {SDL.GetError()}");
                SDL.DestroyWindow(_windowPtr);
                return false;
            }

            _appEngine = new(uiDrawCallback, backgroundColor);
            _renderer = new(_rendererPtr, _windowPtr);
            _textService = new();
            _appEngine.Initialize(_textService, _renderer);

            Console.WriteLine($"SDL3WindowHost '{_title}' initialized successfully. (SDL_Init count: {s_sdlInitCount}, TTF_Init count: {s_ttfInitCount})");
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred during SDL3WindowHost initialization: {ex.Message}");
            Cleanup();
            return false;
        }
    }

    public void RunLoop()
    {
        bool running = true;

        while (running)
        {
            if (IsModalWindowOpen && _activeModalWindow is not null)
            {
                _activeModalWindow.ModalRunLoop();
                HandleModalLifecycle();
            }
            else
            {
                while (SDL.PollEvent(out SDL.Event ev))
                {
                    if (ev.Type == (uint)SDL.EventType.Quit)
                    {
                        running = false;
                        break;
                    }

                    Input.ProcessSDL3Event(ev);
                }

                RenderFrame();
            }
        }
    }

    private void ModalRunLoop()
    {
        bool modalRunning = true;

        while (modalRunning)
        {
            while (SDL.PollEvent(out SDL.Event ev))
            {
                if (ev.Type == (uint)SDL.EventType.Quit)
                {
                    modalRunning = false;
                    _modalResultCode = -1;
                    break;
                }
                else if (ev.Type == (uint)SDL.EventType.WindowCloseRequested)
                {
                    if (ev.Window.WindowID == SDL.GetWindowID(_windowPtr))
                    {
                        modalRunning = false;
                        _modalResultCode = -1;
                        break;
                    }
                }

                Input.ProcessSDL3Event(ev);
            }

            if (_isModalClosing)
            {
                modalRunning = false;
            }

            ModalRenderFrame();
        }

        _isModalClosing = true;
    }

    private void RenderFrame()
    {
        SDL.SetRenderDrawColor(_rendererPtr, (byte)(_backgroundColor.R * 255), (byte)(_backgroundColor.G * 255), (byte)(_backgroundColor.B * 255), (byte)(_backgroundColor.A * 255));
        SDL.RenderClear(_rendererPtr);

        if (_renderer is not null && _textService is not null && _appEngine is not null)
        {
            _appEngine.UpdateAndRender(_renderer, _textService);
        }

        SDL.RenderPresent(_rendererPtr);
    }

    private void ModalRenderFrame()
    {
        SDL.SetRenderDrawColor(_rendererPtr, (byte)(_backgroundColor.R * 255), (byte)(_backgroundColor.G * 255), (byte)(_backgroundColor.B * 255), (byte)(_backgroundColor.A * 255));
        SDL.RenderClear(_rendererPtr);

        if (_renderer is not null && _textService is not null && _appEngine is not null && _modalDrawCallback is not null)
        {
            _appEngine.UpdateAndRender(_renderer, _textService);
        }

        SDL.RenderPresent(_rendererPtr);
    }

    public void Cleanup()
    {
        if (_isDisposed) return;
        Console.WriteLine($"SDL3WindowHost cleanup for '{_title}'...");

        _activeModalWindow?.Cleanup();

        _appEngine?.Cleanup();
        _renderer?.Cleanup();
        _textService?.Cleanup();

        if (_rendererPtr != nint.Zero)
        {
            SDL.DestroyRenderer(_rendererPtr);
            _rendererPtr = nint.Zero;
        }

        if (_windowPtr != nint.Zero)
        {
            SDL.DestroyWindow(_windowPtr);
            _windowPtr = nint.Zero;
        }

        Interlocked.Decrement(ref s_ttfInitCount);

        if (s_ttfInitCount == 0)
        {
            Console.WriteLine("Final TTF.Quit().");
            TTF.Quit();
        }

        Interlocked.Decrement(ref s_sdlInitCount);

        if (s_sdlInitCount == 0)
        {
            Console.WriteLine("Final SDL.Quit()..");
            SDL.Quit();
        }

        _isDisposed = true;

        GC.SuppressFinalize(this);
        Console.WriteLine($"SDL3WindowHost '{_title}' cleaned up. (SDL_Init count: {s_sdlInitCount}, TTF_Init count: {s_ttfInitCount})");
    }

    public void Dispose()
    {
        Cleanup();
    }

    public bool IsModalWindowOpen
    {
        get
        {
            return _activeModalWindow is not null;
        }
    }

    public void OpenModalWindow(string title, int width, int height, Action<UIContext> drawCallback, Action<int>? onClosedCallback = null)
    {
        if (_activeModalWindow is not null)
        {
            Console.WriteLine("Warning: Cannot open a new modal window while another is already active.");
            return;
        }

        _activeModalWindow = new SDL3WindowHost(title, width, height, _backgroundColor);
        _activeModalWindow._modalDrawCallback = drawCallback;
        _onModalClosedCallback = onClosedCallback;
        _modalResultCode = -1;

        if (!_activeModalWindow.InitializeModalInternal())
        {
            Console.WriteLine("Failed to initialize modal SDL window.");
            _activeModalWindow.Dispose();
            _activeModalWindow = null;
            onClosedCallback?.Invoke(-1);
            return;
        }

        if (!SDL.SetWindowParent(_activeModalWindow._windowPtr, _windowPtr))
        {
            Console.WriteLine($"Failed to set window parent: {SDL.GetError()}");
            _activeModalWindow.Dispose();
            _activeModalWindow = null;
            onClosedCallback?.Invoke(-1);
            return;
        }

        if (!SDL.SetWindowModal(_activeModalWindow._windowPtr, true))
        {
            Console.WriteLine($"Failed to set modal flag on window: {SDL.GetError()}");
            _activeModalWindow.Dispose();
            _activeModalWindow = null;
            onClosedCallback?.Invoke(-1);
            return;
        }

        Console.WriteLine("Modal window opened successfully.");
    }

    private bool InitializeModalInternal()
    {
        return Initialize(_modalDrawCallback!, _backgroundColor);
    }

    public void CloseModalWindow(int resultCode = 0)
    {
        if (_activeModalWindow is null)
        {
            return;
        }

        _activeModalWindow._modalResultCode = resultCode;
        _activeModalWindow._isModalClosing = true;
    }

    private void HandleModalLifecycle()
    {
        if (_activeModalWindow is null)
        {
            return;
        }

        if (!_activeModalWindow._isModalClosing)
        {
            return;
        }

        Console.WriteLine($"Modal window closed. Result: {_activeModalWindow._modalResultCode}");
        _onModalClosedCallback?.Invoke(_activeModalWindow._modalResultCode);

        if (_windowPtr != nint.Zero)
        {
            SDL.RaiseWindow(_windowPtr);
        }

        _activeModalWindow.Dispose();
        _activeModalWindow = null;
        _onModalClosedCallback = null;
        _modalResultCode = 0;
        _isModalClosing = false;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\Interface\IAppLogic.cs">
namespace DirectUI.Core;

public interface IAppLogic
{
    void DrawUI(UIContext context);
    void SaveState();
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\Interface\ILayoutContainer.cs">
using System.Numerics;

namespace DirectUI;

public interface ILayoutContainer
{
    Vector2 GetCurrentPosition();
    void Advance(Vector2 elementSize);
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\Interface\IModalWindowService.cs">
// DirectUI/Core/IModalWindowService.cs
using System;
using Vortice.Mathematics;

namespace DirectUI.Core;

/// <summary>
/// Defines the contract for a service that can open modal windows.
/// This allows application UI logic to request a modal window without
/// knowing the underlying platform's windowing specifics.
/// </summary>
public interface IModalWindowService
{
    /// <summary>
    /// Opens a modal window with the specified properties.
    /// </summary>
    /// <param name="title">The title of the modal window.</param>
    /// <param name="width">The width of the modal window.</param>
    /// <param name="height">The height of the modal window.</param>
    /// <param name="drawCallback">The UI drawing logic for the content of the modal window.</param>
    /// <param name="onClosedCallback">An action to be invoked when the modal window is closed. Receives a result code (0 for success, non-zero for error/cancel).</param>
    void OpenModalWindow(string title, int width, int height, Action<UIContext> drawCallback, Action<int>? onClosedCallback = null);

    /// <summary>
    /// Closes the currently active modal window, if any, with a specified result code.
    /// </summary>
    /// <param name="resultCode">A code indicating the outcome of the modal interaction (e.g., 0 for OK, 1 for Cancel).</param>
    void CloseModalWindow(int resultCode = 0);

    /// <summary>
    /// Checks if a modal window is currently open.
    /// </summary>
    bool IsModalWindowOpen { get; }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\Interface\IRenderer.cs">
// DirectUI/Core/IRenderer.cs
using System.Numerics;
using DirectUI.Drawing;
using Vortice.Direct2D1; // Required for AntialiasMode
using Vortice.Mathematics;

namespace DirectUI.Core;

/// <summary>
/// Defines the abstract contract for a rendering backend.
/// The UI library uses this interface to issue all drawing commands.
/// </summary>
public interface IRenderer
{
    /// <summary>
    /// Gets the current size of the render target.
    /// </summary>
    Vector2 RenderTargetSize { get; }

    /// <summary>
    /// Draws a line between two points.
    /// </summary>
    void DrawLine(Vector2 p1, Vector2 p2, Color color, float strokeWidth);

    /// <summary>
    /// Draws a box with fill, border, and rounding based on a style.
    /// </summary>
    void DrawBox(Vortice.Mathematics.Rect rect, BoxStyle style);

    /// <summary>
    /// Draws text. The renderer is responsible for its own text layout and caching.
    /// </summary>
    void DrawText(Vector2 origin, string text, ButtonStyle style, Alignment alignment, Vector2 maxSize, Color color);

    /// <summary>
    /// Pushes a clipping rectangle onto the stack. All subsequent drawing will be clipped to this rectangle.
    /// </summary>
    void PushClipRect(Vortice.Mathematics.Rect rect, AntialiasMode antialiasMode = AntialiasMode.PerPrimitive);

    /// <summary>
    /// Pops the last clipping rectangle from the stack.
    /// </summary>
    void PopClipRect();

    /// <summary>
    /// Flushes any batched rendering commands, particularly for text.
    /// </summary>
    void Flush();
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\Interface\ITextLayout.cs">
// DirectUI/Core/ITextLayout.cs
using System;
using System.Numerics;

namespace DirectUI.Core;

/// <summary>
/// Represents a block of text that has been fully processed for layout.
/// This is a backend-agnostic interface.
/// </summary>
public interface ITextLayout : IDisposable
{
    /// <summary>
    /// The final measured size of the laid-out text.
    /// </summary>
    Vector2 Size { get; }

    /// <summary>
    /// The original string content of this layout.
    /// </summary>
    string Text { get; }

    /// <summary>
    /// Retrieves the metrics for a glyph at a specific text position.
    /// </summary>
    /// <param name="textPosition">The zero-based index of the target character.</param>
    /// <param name="isTrailingHit">Indicates whether to measure the leading or trailing edge of the character.</param>
    /// <returns>Metrics describing the position and size of the specified character position.</returns>
    TextHitTestMetrics HitTestTextPosition(int textPosition, bool isTrailingHit);

    /// <summary>
    /// Performs a hit-test to determine which character position is at a given point.
    /// </summary>
    /// <param name="point">The point to test, relative to the layout's origin.</param>
    /// <returns>A result object containing the metrics and character position of the hit.</returns>
    TextHitTestResult HitTestPoint(Vector2 point);
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\Interface\ITextService.cs">
// DirectUI/Core/ITextService.cs
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI.Core;

/// <summary>
/// Defines the abstract contract for text processing services like measurement and layout.
/// The UI library uses this to handle all font-related operations.
/// </summary>
public interface ITextService
{
    /// <summary>
    /// Measures the bounding box of a string given a specific style, without layout constraints.
    /// </summary>
    Vector2 MeasureText(string text, ButtonStyle style);

    /// <summary>
    /// Creates or retrieves a cached, fully formatted text layout object.
    /// </summary>
    ITextLayout GetTextLayout(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment);

    /// <summary>
    /// Cleans up any cached resources managed by the text service.
    /// </summary>
    void Cleanup();
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\DirectUI\Source\Core\Interface\IWindowHost.cs">
// DirectUI/Core/IWindowHost.cs
using System;
using DirectUI.Input;
using Vortice.Mathematics;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI.Core;

/// <summary>
/// Defines the contract for a platform-specific window host that integrates with the DirectUI engine.
/// This interface abstracts window creation, main loop management, and exposes input and modal services.
/// </summary>
public interface IWindowHost : IDisposable
{
    /// <summary>
    /// Gets the native window handle, if applicable. Returns IntPtr.Zero otherwise.
    /// </summary>
    IntPtr Handle { get; }

    /// <summary>
    /// Provides access to the InputManager for the host to feed input events.
    /// </summary>
    InputManager Input { get; }

    /// <summary>
    /// Gets the current client size of the window.
    /// </summary>
    SizeI ClientSize { get; }

    /// <summary>
    /// Gets or sets whether the FPS counter should be displayed.
    /// </summary>
    bool ShowFpsCounter { get; set; }

    /// <summary>
    /// Provides access to a service for opening modal windows specific to this host's platform.
    /// </summary>
    IModalWindowService ModalWindowService { get; }

    /// <summary>
    /// Initializes the window host and the DirectUI engine.
    /// </summary>
    /// <param name="uiDrawCallback">The callback function that contains the application's UI drawing logic.</param>
    /// <param name="backgroundColor">The background color to clear the window with each frame.</param>
    /// <returns>True if initialization was successful, false otherwise.</returns>
    bool Initialize(Action<UIContext> uiDrawCallback, Color4 backgroundColor);

    /// <summary>
    /// Runs the platform-specific main message/event loop for the application.
    /// </summary>
    void RunLoop();

    /// <summary>
    /// Cleans up resources owned by the window host.
    /// </summary>
    void Cleanup();
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Sonorize\Source\Program.cs">
using DirectUI;

namespace Sonorize;

public static class Program
{
    [STAThread]
    public static void Main()
    {
        var backend = GraphicsBackend.SkiaSharp;
        ApplicationRunner.Run(backend, host => new SonorizeLogic(host));
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Sonorize\Source\SonorizeLogic.cs">
using System.Numerics;
using System.Text.Json;
using DirectUI;
using DirectUI.Backends.SkiaSharp;
using DirectUI.Core;
using Sonorize.Audio;

namespace Sonorize;

public class SonorizeLogic : IAppLogic
{
    private readonly IWindowHost _host;
    private readonly Settings _settings;
    private readonly string _settingsFilePath = "settings.json";

    private readonly MenuBar _menuBar;
    private readonly SettingsWindow _settingsWindow;
    private readonly MusicLibrary _musicLibrary = new();
    private readonly AudioPlayer _audioPlayer;

    private int _selectedTrackIndex = -1;
    private int _previousSelectedTrackIndex = -1;
    private readonly DataGridColumn[] _columns;


    public SonorizeLogic(IWindowHost host)
    {
        _host = host;
        _settings = LoadState();

        ConfigureWindowStyles(host);

        _menuBar = new(OpenSettingsModal);
        _settingsWindow = new(_settings, _host);
        _audioPlayer = new AudioPlayer();

        _columns =
        [
            new DataGridColumn("Title", 350, nameof(MusicFile.Title)),
            new DataGridColumn("Artist", 250, nameof(MusicFile.Artist)),
            new DataGridColumn("Album", 250, nameof(MusicFile.Album)),
            new DataGridColumn("Duration", 100, nameof(MusicFile.Duration)),
            new DataGridColumn("Genre", 150, nameof(MusicFile.Genre)),
            new DataGridColumn("Year", 80, nameof(MusicFile.Year))
        ];

        // Start scanning for music files
        _musicLibrary.ScanDirectoriesAsync(_settings.Directories);
    }

    private Settings LoadState()
    {
        try
        {
            if (File.Exists(_settingsFilePath))
            {
                string json = File.ReadAllText(_settingsFilePath);
                return JsonSerializer.Deserialize<Settings>(json) ?? new Settings();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading settings: {ex.Message}");
        }

        return new();
    }

    public void SaveState()
    {
        try
        {
            JsonSerializerOptions options = new()
            {
                WriteIndented = true
            };

            string json = JsonSerializer.Serialize(_settings, options);
            File.WriteAllText(_settingsFilePath, json);
            Console.WriteLine($"Settings saved to {_settingsFilePath}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving settings: {ex.Message}");
        }
        finally
        {
            _audioPlayer.Dispose();
        }
    }

    private static void ConfigureWindowStyles(IWindowHost host)
    {
        if (host is not SilkNetWindowHost silkHost)
        {
            return;
        }

        // ========================================================================
        // == CONFIGURING WINDOW BACKDROP AND TITLE BAR (WINDOWS 11+)           ==
        // ========================================================================
        // This example enables a modern Mica window with a dark title bar.
        // It requires Windows 11 (Build 22621 or newer). On older systems,
        // it will fall back to a standard solid color window.
        silkHost.BackdropType = WindowBackdropType.Default;
        silkHost.TitleBarTheme = WindowTitleBarTheme.Dark;
    }

    public void DrawUI(UIContext context)
    {
        _menuBar.Draw(context);

        float menuBarHeight = 30f;
        float playbackControlsHeight = 40f; // Space for the slider
        float padding = 10f;
        var gridPos = new Vector2(padding, menuBarHeight + padding);
        var gridSize = new Vector2(
            context.Renderer.RenderTargetSize.X - (padding * 2),
            context.Renderer.RenderTargetSize.Y - menuBarHeight - playbackControlsHeight - (padding * 2)
        );

        if (gridSize.X > 0 && gridSize.Y > 0)
        {
            UI.DataGrid<MusicFile>(
                "musicGrid",
                _musicLibrary.Files,
                _columns,
                ref _selectedTrackIndex,
                gridSize,
                gridPos,
                autoSizeColumns: true,
                trimCellText: true
            );
        }

        // Check for selection change to play music
        if (_selectedTrackIndex != _previousSelectedTrackIndex)
        {
            if (_selectedTrackIndex >= 0 && _selectedTrackIndex < _musicLibrary.Files.Count)
            {
                var trackToPlay = _musicLibrary.Files[_selectedTrackIndex];
                _audioPlayer.Play(trackToPlay.FilePath);
            }
            _previousSelectedTrackIndex = _selectedTrackIndex;
        }

        DrawPlaybackControls(context);
    }

    private void DrawPlaybackControls(UIContext context)
    {
        float playbackControlsHeight = 40f;
        float padding = 10f;
        var windowSize = context.Renderer.RenderTargetSize;

        var controlsY = windowSize.Y - playbackControlsHeight;
        var controlsRect = new Vortice.Mathematics.Rect(0, controlsY, windowSize.X, playbackControlsHeight);

        // Draw a background for the controls area
        var bgStyle = new BoxStyle
        {
            FillColor = new(0.1f, 0.1f, 0.1f, 1.0f),
            BorderColor = new(0.05f, 0.05f, 0.05f, 1.0f),
            BorderLengthTop = 1f,
            BorderLengthBottom = 0,
            BorderLengthLeft = 0,
            BorderLengthRight = 0,
            Roundness = 0
        };
        context.Renderer.DrawBox(controlsRect, bgStyle);

        // Get audio state
        double currentPosition = _audioPlayer.GetPosition();
        double totalDuration = _audioPlayer.GetLength();
        bool isAudioLoaded = totalDuration > 0;

        // Use a container to position the slider
        var sliderAreaHeight = 20f;
        var sliderAreaY = controlsY + (playbackControlsHeight - sliderAreaHeight) / 2f;
        UI.BeginVBoxContainer("playbackControls", new Vector2(padding, sliderAreaY));
        {
            var sliderWidth = windowSize.X - (padding * 2);
            var sliderSize = new Vector2(sliderWidth, sliderAreaHeight);

            float sliderValue = (float)currentPosition;

            float newSliderValue = UI.HSlider(
                id: "seekSlider",
                currentValue: sliderValue,
                minValue: 0f,
                maxValue: isAudioLoaded ? (float)totalDuration : 1.0f,
                size: sliderSize,
                disabled: !isAudioLoaded
            );

            // If user dragged the slider (and audio is loaded), seek to new position.
            // Check for a meaningful change to avoid seeking due to float precision issues.
            if (isAudioLoaded && Math.Abs(newSliderValue - sliderValue) > 0.01f)
            {
                _audioPlayer.Seek(newSliderValue);
            }
        }
        UI.EndVBoxContainer();
    }

    private void OpenSettingsModal()
    {
        _host.ModalWindowService.OpenModalWindow("Settings", 500, 400, _settingsWindow.Draw, resultCode =>
        {
            // After settings window is closed, rescan library if OK was pressed.
            if (resultCode == 0)
            {
                _musicLibrary.ScanDirectoriesAsync(_settings.Directories);
            }
        });
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Sonorize\Source\Audio\AudioPlayer.cs">
using System;
using ManagedBass;

namespace Sonorize.Audio;

public class AudioPlayer : IDisposable
{
    private int _stream;
    private bool _isDisposed;

    public bool IsPlaying => Bass.ChannelIsActive(_stream) == PlaybackState.Playing;

    public AudioPlayer()
    {
        if (!Bass.Init())
            throw new Exception("Failed to initialize audio device.");
    }

    /// <summary>
    /// Loads an audio file (M4A, MP3, WAV, etc.) and starts playback.
    /// </summary>
    public void Play(string filePath)
    {
        if (_isDisposed) throw new ObjectDisposedException(nameof(AudioPlayer));
        if (!System.IO.File.Exists(filePath)) throw new ArgumentException("File does not exist", nameof(filePath));

        StopInternal();

        _stream = Bass.CreateStream(filePath, 0, 0, BassFlags.Default);
        if (_stream == 0)
            throw new Exception($"Failed to create audio stream: {Bass.LastError}");

        Bass.ChannelPlay(_stream);
    }

    public void Pause()
    {
        if (_isDisposed) throw new ObjectDisposedException(nameof(AudioPlayer));
        if (_stream != 0)
            Bass.ChannelPause(_stream);
    }

    public void Resume()
    {
        if (_isDisposed) throw new ObjectDisposedException(nameof(AudioPlayer));
        if (_stream != 0)
            Bass.ChannelPlay(_stream);
    }

    public void Stop()
    {
        if (_isDisposed) throw new ObjectDisposedException(nameof(AudioPlayer));
        StopInternal();
    }

    /// <summary>
    /// Seeks to the specified position in seconds.
    /// </summary>
    public void Seek(double seconds)
    {
        if (_isDisposed) throw new ObjectDisposedException(nameof(AudioPlayer));
        if (_stream != 0)
        {
            long pos = Bass.ChannelSeconds2Bytes(_stream, seconds);
            Bass.ChannelSetPosition(_stream, pos);
        }
    }

    /// <summary>
    /// Gets the current playback position in seconds.
    /// </summary>
    public double GetPosition()
    {
        if (_isDisposed) throw new ObjectDisposedException(nameof(AudioPlayer));
        return _stream != 0 ? Bass.ChannelBytes2Seconds(_stream, Bass.ChannelGetPosition(_stream)) : 0;
    }

    /// <summary>
    /// Gets the total length of the current stream in seconds.
    /// </summary>
    public double GetLength()
    {
        if (_isDisposed) throw new ObjectDisposedException(nameof(AudioPlayer));
        return _stream != 0 ? Bass.ChannelBytes2Seconds(_stream, Bass.ChannelGetLength(_stream)) : 0;
    }

    private void StopInternal()
    {
        if (_stream != 0)
        {
            Bass.ChannelStop(_stream);
            Bass.StreamFree(_stream);
            _stream = 0;
        }
    }

    public void Dispose()
    {
        if (_isDisposed) return;

        StopInternal();
        Bass.Free();
        _isDisposed = true;
        GC.SuppressFinalize(this);
    }

    ~AudioPlayer()
    {
        Dispose();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Sonorize\Source\Data\MusicFile.cs">
// Sonorize/Source/Data/MusicFile.cs
namespace Sonorize;

public class MusicFile
{
    public string Title { get; set; } = string.Empty;
    public string Artist { get; set; } = string.Empty;
    public string Album { get; set; } = string.Empty;
    public string Genre { get; set; } = string.Empty;
    public uint Year { get; set; }
    public TimeSpan Duration { get; set; }
    public string FilePath { get; set; } = string.Empty;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Sonorize\Source\Data\MusicLibrary.cs">
// Sonorize/Source/Data/MusicLibrary.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using TagLib;

namespace Sonorize;

public class MusicLibrary
{
    private List<MusicFile> _files = new();
    private readonly object _lock = new();

    public IReadOnlyList<MusicFile> Files
    {
        get
        {
            lock (_lock)
            {
                // Return a copy to prevent collection modified exceptions if the background task updates it during a render.
                return new List<MusicFile>(_files);
            }
        }
    }

    private static readonly string[] SupportedExtensions = { ".mp3", ".flac", ".m4a", ".ogg", ".wav", ".wma", ".aac" };
    private Task? _scanTask;

    public void ScanDirectoriesAsync(IEnumerable<string> directories)
    {
        // Don't start a new scan if one is already running
        if (_scanTask is not null && !_scanTask.IsCompleted) return;

        var dirsToScan = directories.ToList(); // Create a copy

        _scanTask = Task.Run(() =>
        {
            Console.WriteLine("Starting library scan...");
            var foundFiles = new List<MusicFile>();
            foreach (var dir in dirsToScan)
            {
                if (!Directory.Exists(dir)) continue;

                try
                {
                    var filesInDir = Directory.EnumerateFiles(dir, "*.*", SearchOption.AllDirectories)
                        .Where(f => SupportedExtensions.Contains(Path.GetExtension(f).ToLowerInvariant()));

                    foreach (var filePath in filesInDir)
                    {
                        try
                        {
                            using var tagFile = TagLib.File.Create(filePath);
                            var musicFile = new MusicFile
                            {
                                Title = string.IsNullOrEmpty(tagFile.Tag.Title) ? Path.GetFileNameWithoutExtension(filePath) : tagFile.Tag.Title,
                                Artist = tagFile.Tag.FirstPerformer ?? "Unknown Artist",
                                Album = tagFile.Tag.Album ?? "Unknown Album",
                                Genre = tagFile.Tag.FirstGenre ?? string.Empty,
                                Year = tagFile.Tag.Year,
                                Duration = tagFile.Properties.Duration,
                                FilePath = filePath
                            };
                            foundFiles.Add(musicFile);
                        }
                        catch (CorruptFileException) { /* ignore */ }
                        catch (UnsupportedFormatException) { /* ignore */ }
                        catch (Exception ex) { Console.WriteLine($"Could not read tag for {filePath}: {ex.Message}"); }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error scanning directory {dir}: {ex.Message}");
                }
            }

            var sortedFiles = foundFiles
                .OrderBy(f => f.Artist)
                .ThenBy(f => f.Album)
                .ThenBy(f => f.Title)
                .ToList();

            lock (_lock)
            {
                _files = sortedFiles;
            }
            Console.WriteLine($"Scan complete. Found {_files.Count} files.");
        });
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Sonorize\Source\Settings\Settings.cs">
using System.Collections.Generic;

namespace Sonorize;

public class Settings
{
    public List<string> Directories { get; set; } = new();
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Sonorize\Source\UI\MenuBar.cs">
// Sonorize/Source/UI/MenuBar.cs
using System;
using System.Numerics;
using DirectUI;
using DirectUI.Core;

namespace Sonorize;

public class MenuBar
{
    private readonly Action _onOpenSettings;
    private bool _isFileMenuOpen = false;
    private readonly int _fileMenuPopupId;

    public MenuBar(Action onOpenSettings)
    {
        _onOpenSettings = onOpenSettings ?? throw new ArgumentNullException(nameof(onOpenSettings));
        _fileMenuPopupId = "fileMenuPopup".GetHashCode();
    }

    public void Draw(UIContext context)
    {
        var menuBarBg = new BoxStyle
        {
            FillColor = new(0.1f, 0.1f, 0.1f, 1.0f),
            BorderColor = new(0.05f, 0.05f, 0.05f, 1.0f),
            BorderLengthBottom = 1f,
            BorderLengthTop = 0,
            BorderLengthLeft = 0,
            BorderLengthRight = 0,
            Roundness = 0
        };
        context.Renderer.DrawBox(new Vortice.Mathematics.Rect(0, 0, context.Renderer.RenderTargetSize.X, 30), menuBarBg);

        UI.BeginHBoxContainer("menuBar", new Vector2(5, 4), 5);

        var fileButtonPos = context.Layout.GetCurrentPosition();
        var fileButtonSize = new Vector2(50, 22);

        if (_isFileMenuOpen && UI.State.ActivePopupId != _fileMenuPopupId)
        {
            _isFileMenuOpen = false;
        }

        if (UI.Button("fileMenu", "File", fileButtonSize, isActive: _isFileMenuOpen))
        {
            _isFileMenuOpen = !_isFileMenuOpen;
            if (_isFileMenuOpen)
            {
                OpenMenuPopup(fileButtonPos, fileButtonSize);
            }
            else
            {
                UI.State.ClearActivePopup();
            }
        }
        UI.EndHBoxContainer();
    }

    private void OpenMenuPopup(Vector2 buttonPos, Vector2 buttonSize)
    {
        var popupPosition = new Vector2(buttonPos.X, buttonPos.Y + buttonSize.Y + 2);
        var popupSize = new Vector2(150, 30);
        var popupBounds = new Vortice.Mathematics.Rect(popupPosition.X, popupPosition.Y, popupSize.X, popupSize.Y);

        Action<UIContext> drawCallback = (ctx) =>
        {
            var popupStyle = new BoxStyle { FillColor = DefaultTheme.NormalFill, BorderColor = DefaultTheme.FocusBorder, BorderLength = 1f, Roundness = 0.1f };
            ctx.Renderer.DrawBox(popupBounds, popupStyle);

            var itemTheme = new ButtonStylePack { Roundness = 0f, BorderLength = 0f };
            itemTheme.Normal.FillColor = DefaultTheme.Transparent;
            itemTheme.Hover.FillColor = DefaultTheme.HoverFill;
            itemTheme.Pressed.FillColor = DefaultTheme.Accent;

            UI.BeginVBoxContainer("popupContent", popupBounds.TopLeft);
            if (UI.Button("settingsBtn", "Settings", new Vector2(popupBounds.Width, popupBounds.Height), itemTheme, textAlignment: new Alignment(HAlignment.Left, VAlignment.Center), textMargin: new Vector2(5, 0)))
            {
                UI.State.ClearActivePopup();
                _isFileMenuOpen = false;
                _onOpenSettings();
            }
            UI.EndVBoxContainer();
        };
        UI.State.SetActivePopup(_fileMenuPopupId, drawCallback, popupBounds);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Sonorize\Source\UI\SettingsWindow.cs">
using DirectUI;
using DirectUI.Core;
using System.Numerics;
using TinyDialogsNet;

namespace Sonorize;

public class SettingsWindow
{
    private readonly Settings _settings;
    private readonly IWindowHost _host;
    private int _selectedDirectoryIndex = -1;

    public SettingsWindow(Settings settings, IWindowHost host)
    {
        _settings = settings;
        _host = host;
    }

    public void Draw(UIContext context)
    {
        UI.BeginVBoxContainer("settingsVBox", new Vector2(10, 10), 10);

        UI.Text("settingsTitle", "Settings", style: new ButtonStyle { FontSize = 18 });
        UI.Separator(480, verticalPadding: 2);

        UI.Text("dirsHeader", "Directories");

        DrawDirectoriesList();
        DrawActionButtons();
        DrawOkButton();

        UI.EndVBoxContainer();
    }

    private void DrawDirectoriesList()
    {
        UI.BeginScrollableRegion("dirsScroll", new Vector2(480, 200), out float innerWidth);
        {
            ButtonStylePack selectedStyle = new();
            selectedStyle.Active.FillColor = DefaultTheme.Accent;
            selectedStyle.ActiveHover.FillColor = DefaultTheme.Accent;
            selectedStyle.Normal.FillColor = new(0.15f, 0.15f, 0.15f, 1.0f);

            for (int i = 0; i < _settings.Directories.Count; i++)
            {
                bool isSelected = i == _selectedDirectoryIndex;

                if (!UI.Button($"dir_{i}", _settings.Directories[i], new Vector2(innerWidth, 24), theme: selectedStyle, textAlignment: new Alignment(HAlignment.Left, VAlignment.Center), textMargin: new Vector2(5, 0), isActive: isSelected))
                {
                    continue;
                }

                _selectedDirectoryIndex = i;
            }
        }

        UI.EndScrollableRegion();
    }

    private void DrawActionButtons()
    {
        UI.BeginHBoxContainer("dirsButtons", UI.Context.Layout.GetCurrentPosition(), 5);
        {
            if (UI.Button("addDir", "Add", new Vector2(80, 24)))
            {
                var selectedPath = TinyDialogs.SelectFolderDialog("Select a folder to add to Sonorize");

                if (!string.IsNullOrWhiteSpace(selectedPath.Path) && !_settings.Directories.Contains(selectedPath.Path))
                {
                    _settings.Directories.Add(selectedPath.Path);
                }
            }
            if (UI.Button("removeDir", "Remove", new Vector2(80, 24), disabled: _selectedDirectoryIndex < 0))
            {
                if (_selectedDirectoryIndex >= 0 && _selectedDirectoryIndex < _settings.Directories.Count)
                {
                    _settings.Directories.RemoveAt(_selectedDirectoryIndex);
                    _selectedDirectoryIndex = -1; // Deselect
                }
            }
        }
        UI.EndHBoxContainer();
    }

    private void DrawOkButton()
    {
        // Position at the bottom right.
        float modalHeight = 400;
        float modalWidth = 500;
        float buttonHeight = 24;
        float buttonWidth = 80;
        float padding = 10;

        float buttonY = modalHeight - buttonHeight - padding;
        float buttonX = modalWidth - buttonWidth - padding;

        UI.BeginVBoxContainer("okButtonContainer", new Vector2(buttonX, buttonY));
        if (UI.Button("okSettings", "OK", new Vector2(buttonWidth, buttonHeight)))
        {
            _host.ModalWindowService.CloseModalWindow(0);
        }
        UI.EndVBoxContainer();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\AnchorPreset.cs">
namespace Cherris;

public enum AnchorPreset
{
    None,
    TopLeft,
    TopCenter,
    TopRight,
    CenterLeft,
    Center,
    CenterRight,
    BottomLeft,
    BottomCenter,
    BottomRight
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\BoxStyle.cs">
using Vortice.Mathematics;

namespace Cherris;

public class BoxStyle
{
    public float Roundness { get; set; } = 0.2f;
    public Color4 FillColor { get; set; } = DefaultTheme.NormalFill;
    public Color4 BorderColor { get; set; } = DefaultTheme.NormalBorder;

    public float BorderLengthTop { get; set; } = 1.0f;
    public float BorderLengthRight { get; set; } = 1.0f;
    public float BorderLengthBottom { get; set; } = 1.0f;
    public float BorderLengthLeft { get; set; } = 1.0f;

    public float BorderLength
    {
        set
        {
            BorderLengthTop = value;
            BorderLengthRight = value;
            BorderLengthBottom = value;
            BorderLengthLeft = value;
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\ButtonStyle.cs">
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace Cherris;

public class ButtonStyle : BoxStyle
{
    public Font? Font { get; set; } = null;
    public Color4 FontColor { get; set; } = DefaultTheme.Text;

    public string FontName { get; set; } = "Roboto Mono";
    public float FontSize { get; set; } = 16.0f;
    public FontWeight FontWeight { get; set; } = FontWeight.Normal;
    public FontStyle FontStyle { get; set; } = FontStyle.Normal;
    public FontStretch FontStretch { get; set; } = FontStretch.Normal;
    public WordWrapping WordWrapping { get; set; } = WordWrapping.WholeWord;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\ButtonStylePack.cs">
using System;
using System.Collections.Generic;
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace Cherris;

public sealed class ButtonStylePack
{
    public ButtonStyle Current { get; set; } = new();
    public ButtonStyle Normal { get; set; } = new();
    public ButtonStyle Hover { get; set; } = new();
    public ButtonStyle Pressed { get; set; } = new();
    public ButtonStyle Disabled { get; set; } = new();
    public ButtonStyle Focused { get; set; } = new();

    private IEnumerable<ButtonStyle> AllStyles => [Current, Normal, Hover, Pressed, Disabled, Focused];

    public ButtonStylePack()
    {
        Hover.FillColor = DefaultTheme.HoverFill;

        Pressed.FillColor = DefaultTheme.Accent;

        Disabled.FillColor = DefaultTheme.DisabledFill;
        Disabled.BorderColor = DefaultTheme.DisabledBorder;
        Disabled.FontColor = DefaultTheme.DisabledText;

        Focused.BorderColor = DefaultTheme.FocusBorder;
        Focused.BorderLength = 1;
    }

    public float FontSize
    {
        get;
        set
        {
            field = value;
            SetAll(s => s.FontSize = value);
        }
    } = 0;

    public Font Font
    {
        set => SetAll(s => s.Font = value);
    }

    public Color FontColor
    {
        set => SetAll(s => s.FontColor = value);
    }

    public float Roundness
    {
        set => SetAll(s => s.Roundness = value);
    }

    public float BorderLength
    {
        set => SetAll(s => s.BorderLength = value);
    }

    public Color FillColor
    {
        set => SetAll(s => s.FillColor = value);
    }

    public Color BorderColor
    {
        set => SetAll(s => s.BorderColor = value);
    }

    public float BorderLengthTop
    {
        set => SetAll(s => s.BorderLengthTop = value);
    }

    public float BorderLengthBottom
    {
        set => SetAll(s => s.BorderLengthBottom = value);
    }

    public WordWrapping WordWrapping
    {
        set => SetAll(s => s.WordWrapping = value);
    }

    private void SetAll(Action<ButtonStyle> setter)
    {
        foreach (ButtonStyle style in AllStyles)
        {
            setter(style);
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\ClickServer.cs">
namespace Cherris;

public sealed class ClickServer
{
    public static ClickServer Instance { get; } = new();

    public int MinLayer = -1;

    private readonly List<Clickable> clickables = [];
    private const bool Debug = false;

    private ClickServer() { }

    public void Register(Clickable clickable)
    {
        clickables.Add(clickable);
    }

    public void Unregister(Clickable clickable)
    {
        clickables.Remove(clickable);
    }

    public void Process()
    {
        if (Input.IsMouseButtonPressed(MouseButtonCode.Left))
        {
            SignalClick(MouseButtonCode.Left);
        }

        if (Input.IsMouseButtonPressed(MouseButtonCode.Right))
        {
            SignalClick(MouseButtonCode.Right);
        }
    }

    public int GetHighestLayer()
    {
        int highestLayer = MinLayer;

        foreach (Clickable clickable in clickables)
        {
            if (clickable.Layer <= highestLayer)
            {
                continue;
            }

            highestLayer = clickable.Layer;
        }

        return highestLayer;
    }

    private void SignalClick(MouseButtonCode mouseButton)
    {
        List<Clickable> viableClickables = GetViableClickables();

        if (viableClickables.Count <= 0)
        {
            return;
        }

        Clickable? topClickable = GetTopClickable(viableClickables);

        if (topClickable is null)
        {
            return;
        }

        if (mouseButton == MouseButtonCode.Left)
        {
            topClickable.OnTopLeft = true;
            Log.Info($"'{topClickable.Name}' has been left clicked.", Debug);
        }
        else
        {
            topClickable.OnTopRight = true;
            Log.Info($"'{topClickable.Name}' has been right clicked.", Debug);
        }
    }

    private List<Clickable> GetViableClickables()
    {
        List<Clickable> viableClickables = [];

        foreach (Clickable clickable in clickables)
        {
            if (!IsMouseOverNode2D(clickable))
            {
                continue;
            }

            viableClickables.Add(clickable);
        }

        Log.Info($"{viableClickables.Count} viable clickables.", Debug);

        return viableClickables;
    }

    private Clickable? GetTopClickable(List<Clickable> viableClickables)
    {
        Clickable? topClickable = null;
        int highestLayer = MinLayer;

        foreach (Clickable clickable in viableClickables)
        {
            if (clickable.Layer < highestLayer)
            {
                continue;
            }

            highestLayer = clickable.Layer;
            topClickable = clickable;
        }

        Log.Info($"The highest layer is {viableClickables.Count}.", Debug);

        return topClickable;
    }

    private static bool IsMouseOverNode2D(Node2D node)
    {
        Vector2 mousePosition = Input.WorldMousePosition;

        bool isMouseOver =
            mousePosition.X > node.GlobalPosition.X - node.Origin.X &&
            mousePosition.X < node.GlobalPosition.X + node.ScaledSize.X - node.Origin.X &&
            mousePosition.Y > node.GlobalPosition.Y - node.Origin.Y &&
            mousePosition.Y < node.GlobalPosition.Y + node.ScaledSize.Y - node.Origin.Y;

        return isMouseOver;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Configuration.cs">
namespace Cherris;

public class Configuration
{
    public int Width { get; set; } = 0;
    public int Height { get; set; } = 0;
    public int MinWidth { get; set; } = 0;
    public int MinHeight { get; set; } = 0;
    public int MaxWidth { get; set; } = 0;
    public int MaxHeight { get; set; } = 0;
    public string Title { get; set; } = "Cherris";
    public bool ResizableWindow { get; set; } = true;
    public bool AntiAliasing { get; set; } = true;
    public string MainScenePath { get; set; } = "";
    public string Backend { get; set; } = "Raylib";
    public SystemBackdropType BackdropType { get; set; } = SystemBackdropType.MicaAlt;
    public bool VSync { get; set; } = true;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\DefaultTheme.cs">
using Vortice.Mathematics;

namespace Cherris;
public static class DefaultTheme
{
    public static readonly Color4 White = Colors.White;
    public static readonly Color4 Black = Colors.Black;
    public static readonly Color4 Transparent = Colors.Transparent;
    public static readonly Color4 NormalFill = new Color4(0.25f, 0.25f, 0.3f, 1.0f);
    public static readonly Color4 NormalBorder = new Color4(0.4f, 0.4f, 0.45f, 1.0f);

    public static readonly Color4 HoverFill = new Color4(0.35f, 0.35f, 0.4f, 1.0f);
    public static readonly Color4 HoverBorder = new Color4(0.5f, 0.5f, 0.55f, 1.0f);

    public static readonly Color4 Accent = new Color4(0.2f, 0.4f, 0.8f, 1.0f);    public static readonly Color4 AccentBorder = new Color4(0.3f, 0.5f, 0.9f, 1.0f);
    public static readonly Color4 DisabledFill = new Color4(0.2f, 0.2f, 0.2f, 0.8f);
    public static readonly Color4 DisabledBorder = new Color4(0.3f, 0.3f, 0.3f, 0.8f);
    public static readonly Color4 DisabledText = new Color4(0.5f, 0.5f, 0.5f, 1.0f);

    public static readonly Color4 FocusBorder = Colors.LightSkyBlue;
    public static readonly Color4 Text = Colors.WhiteSmoke;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Direct2DAppWindow.cs">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using SharpGen.Runtime;
using Vortice.DCommon;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.DXGI;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;
using D2DFactoryType = Vortice.Direct2D1.FactoryType;
using DW = Vortice.DirectWrite;
using Rect = Vortice.Mathematics.Rect;
using SizeI = Vortice.Mathematics.SizeI;

namespace Cherris;

public abstract class Direct2DAppWindow : Win32Window
{
    protected ID2D1Factory1? d2dFactory;
    protected IDWriteFactory? dwriteFactory;
    protected ID2D1HwndRenderTarget? renderTarget;

    protected Color4 backgroundColor = Colors.Black;
    protected bool graphicsInitialized = false;

    private Stopwatch fpsTimer = new();
    private long lastFpsUpdateTimeTicks = 0;
    private int frameCountSinceUpdate = 0;
    private const long FpsUpdateIntervalTicks = TimeSpan.TicksPerSecond / 2;
    private ID2D1SolidColorBrush? fpsTextBrush;
    private IDWriteTextFormat? fpsTextFormat;
    private readonly Color4 fpsTextColor = DefaultTheme.Text;
    private readonly string fpsFontName = "Consolas";
    private readonly float fpsFontSize = 14.0f;

    private Dictionary<Color4, ID2D1SolidColorBrush> brushCache = new();
    private Dictionary<string, IDWriteTextFormat> textFormatCache = new();

    public float CurrentFps { get; private set; } = 0.0f;
    public IDWriteFactory? DWriteFactory => dwriteFactory;


    public Direct2DAppWindow(string title = "Vortice DirectUI Base Window", int width = 800, int height = 600)
        : base(title, width, height)
    { }

    protected override bool Initialize()
    {
        Log.Info($"Direct2DAppWindow '{Title}' initializing Vortice Graphics...");
        return InitializeGraphics();
    }

    protected override void Cleanup()
    {
        Log.Info($"Direct2DAppWindow '{Title}' cleaning up its resources...");
        CleanupGraphics();
    }

    public override void RenderFrame()
    {
        if (!fpsTimer.IsRunning)
        {
            fpsTimer.Start();
            lastFpsUpdateTimeTicks = fpsTimer.ElapsedTicks;
            frameCountSinceUpdate = 0;
        }

        frameCountSinceUpdate++;
        long elapsedTicks = fpsTimer.ElapsedTicks;
        long timeSinceLastUpdate = elapsedTicks - lastFpsUpdateTimeTicks;

        if (timeSinceLastUpdate >= FpsUpdateIntervalTicks)
        {
            float secondsElapsed = (float)timeSinceLastUpdate / TimeSpan.TicksPerSecond;
            CurrentFps = (secondsElapsed > 0.001f) ? (frameCountSinceUpdate / secondsElapsed) : 0.0f;
            frameCountSinceUpdate = 0;
            lastFpsUpdateTimeTicks = elapsedTicks;
        }

        if (!graphicsInitialized || renderTarget is null || dwriteFactory is null)
        {
            if (!graphicsInitialized && Handle != nint.Zero && IsOpen)
            {
                Log.Warning($"Graphics not initialized in RenderFrame for '{Title}', attempting reinitialization.");
                InitializeGraphics();
                if (!graphicsInitialized || renderTarget is null || dwriteFactory is null)
                {
                    Log.Error($"Reinitialization failed in RenderFrame for '{Title}'.");
                    return;
                }
            }
            else
            {
                Log.Warning($"RenderFrame skipped for '{Title}': Graphics not ready or window closed.");
                return;
            }
        }

        try
        {
            renderTarget.BeginDraw();
            renderTarget.Clear(backgroundColor);

            var drawingContext = new DrawingContext(renderTarget, dwriteFactory, this);

            DrawUIContent(drawingContext);

            if (fpsTextBrush is not null && fpsTextFormat is not null)
            {
                string fpsText = $"FPS: {CurrentFps:F1}";
                Rect fpsLayoutRect = new Rect(5f, 5f, 150f, 30f);
                renderTarget.DrawText(fpsText, fpsTextFormat, fpsLayoutRect, fpsTextBrush);
            }

            Result endDrawResult = renderTarget.EndDraw();

            if (endDrawResult.Failure)
            {
                Log.Error($"EndDraw failed for '{Title}': {endDrawResult.Description}");
                if (endDrawResult.Code == D2D.ResultCode.RecreateTarget.Code)
                {
                    Log.Warning($"Render target needs recreation for '{Title}' (Detected in EndDraw).");
                    graphicsInitialized = false;
                    CleanupGraphics();
                    InitializeGraphics();
                }
            }
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
        {
            Log.Error($"Render target needs recreation for '{Title}' (Caught SharpGenException in RenderFrame): {ex.Message}");
            graphicsInitialized = false;
            CleanupGraphics();
            InitializeGraphics();
        }
        catch (Exception ex)
        {
            Log.Error($"Rendering Error in RenderFrame for '{Title}': {ex}");
            graphicsInitialized = false;
            CleanupGraphics();
            InitializeGraphics();
        }
    }

    protected abstract void DrawUIContent(DrawingContext context);

    protected override void OnSize(int width, int height)
    {
        if (graphicsInitialized && renderTarget is not null && width > 0 && height > 0)
        {
            Log.Info($"Window '{Title}' resized to {width}x{height}. Resizing render target...");
            try
            {
                var newPixelSize = new SizeI(width, height);

                CleanupDeviceSpecificResources();

                renderTarget.Resize(newPixelSize);

                RecreateDeviceSpecificResources();

                Log.Info($"Successfully resized render target for '{Title}'.");
                Invalidate();
            }
            catch (SharpGenException ex)
            {
                Log.Error($"Failed to resize Render Target for '{Title}' (SharpGenException): {ex.Message} HRESULT: {ex.ResultCode}");
                if (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
                {
                    Log.Warning($"Render target needs recreation for '{Title}' (Detected in Resize Exception).");
                    graphicsInitialized = false;
                    CleanupGraphics();
                    InitializeGraphics();
                }
            }
            catch (Exception ex)
            {
                Log.Error($"Failed to resize Render Target for '{Title}' (General Exception): {ex}");
                graphicsInitialized = false;
                CleanupGraphics();
                InitializeGraphics();
            }
        }
        else if (!graphicsInitialized && Handle != nint.Zero && IsOpen && width > 0 && height > 0)
        {
            Log.Warning($"OnSize called for '{Title}' but graphics not initialized. Attempting initialization.");
            InitializeGraphics();
        }
        else if (width <= 0 || height <= 0)
        {
            Log.Warning($"Ignoring OnSize call for '{Title}' with invalid dimensions: {width}x{height}");
        }
    }

    protected override void OnMouseMove(int x, int y) { }
    protected override void OnMouseDown(MouseButton button, int x, int y) { }
    protected override void OnMouseUp(MouseButton button, int x, int y) { }
    protected override void OnKeyDown(int keyCode) { }
    protected override void OnKeyUp(int keyCode) { }
    protected override void OnMouseWheel(short delta) { }

    protected virtual bool InitializeGraphics()
    {
        if (graphicsInitialized) return true;
        if (Handle == nint.Zero || !IsOpen)
        {
            Log.Warning($"InitializeGraphics skipped for '{Title}': Invalid handle or window not open.");
            return false;
        }

        Log.Info($"Attempting Graphics Initialization for '{Title}' HWND {Handle}...");

        try
        {
            CleanupGraphics();

            Result factoryResult = D2D1.D2D1CreateFactory(D2DFactoryType.SingleThreaded, out d2dFactory);
            factoryResult.CheckError();
            if (d2dFactory is null) throw new InvalidOperationException($"D2D Factory creation failed silently for '{Title}'.");

            Result dwriteResult = DWrite.DWriteCreateFactory(DW.FactoryType.Shared, out dwriteFactory);
            dwriteResult.CheckError();
            if (dwriteFactory is null) throw new InvalidOperationException($"DWrite Factory creation failed silently for '{Title}'.");

            var clientRectSize = GetClientRectSize();
            if (clientRectSize.Width <= 0 || clientRectSize.Height <= 0)
            {
                Log.Warning($"Invalid client rect size ({clientRectSize.Width}x{clientRectSize.Height}) for '{Title}'. Aborting graphics initialization.");
                CleanupGraphics();
                return false;
            }

            var dxgiPixelFormat = new PixelFormat(Format.B8G8R8A8_UNorm, Vortice.DCommon.AlphaMode.Premultiplied);
            var renderTargetProperties = new RenderTargetProperties(dxgiPixelFormat);
            var hwndRenderTargetProperties = new HwndRenderTargetProperties
            {
                Hwnd = Handle,
                PixelSize = new SizeI(clientRectSize.Width, clientRectSize.Height),
                PresentOptions = VSyncEnabled ? PresentOptions.None : PresentOptions.Immediately
            };

            renderTarget = d2dFactory.CreateHwndRenderTarget(renderTargetProperties, hwndRenderTargetProperties);
            if (renderTarget is null) throw new InvalidOperationException($"Render target creation returned null unexpectedly for '{Title}'.");

            renderTarget.TextAntialiasMode = D2D.TextAntialiasMode.Cleartype;

            brushCache = new Dictionary<Color4, ID2D1SolidColorBrush>();
            textFormatCache = new Dictionary<string, IDWriteTextFormat>();

            RecreateDeviceSpecificResources();

            frameCountSinceUpdate = 0;
            CurrentFps = 0;
            lastFpsUpdateTimeTicks = 0;
            fpsTimer.Restart();

            Log.Info($"Vortice Graphics initialized successfully for '{Title}' HWND {Handle}.");
            graphicsInitialized = true;
            return true;
        }
        catch (SharpGenException ex)
        {
            Log.Error($"Graphics Initialization failed for '{Title}' (SharpGenException): {ex.Message} HRESULT: {ex.ResultCode}");
            CleanupGraphics(); graphicsInitialized = false; return false;
        }
        catch (Exception ex)
        {
            Log.Error($"Graphics Initialization failed for '{Title}' (General Exception): {ex}");
            CleanupGraphics(); graphicsInitialized = false; return false;
        }
    }

    private void RecreateDeviceSpecificResources()
    {
        if (renderTarget is null || dwriteFactory is null) return;

        try
        {
            fpsTextFormat?.Dispose();
            fpsTextFormat = dwriteFactory.CreateTextFormat(fpsFontName, null, FontWeight.Normal, FontStyle.Normal, FontStretch.Normal, fpsFontSize, "en-us");
            fpsTextFormat.TextAlignment = DW.TextAlignment.Leading;
            fpsTextFormat.ParagraphAlignment = ParagraphAlignment.Near;

            fpsTextBrush?.Dispose();
            fpsTextBrush = renderTarget.CreateSolidColorBrush(fpsTextColor);

            Log.Info($"Recreated FPS drawing resources for '{Title}'.");
        }
        catch (Exception ex)
        {
            Log.Error($"Warning: Failed to recreate device-specific resources for '{Title}': {ex.Message}");
            CleanupDeviceSpecificResources();
        }
    }

    private void CleanupDeviceSpecificResources()
    {
        fpsTextBrush?.Dispose(); fpsTextBrush = null;
        fpsTextFormat?.Dispose(); fpsTextFormat = null;

        foreach (var brush in brushCache.Values) brush?.Dispose();
        brushCache.Clear();
        foreach (var format in textFormatCache.Values) format?.Dispose();
        textFormatCache.Clear();
        Log.Info($"Cleaned device-specific resources (brushes, formats) for '{Title}'.");
    }

    protected virtual void CleanupGraphics()
    {
        bool resourcesExisted = d2dFactory is not null || renderTarget is not null || dwriteFactory is not null;
        if (resourcesExisted) Log.Info($"Cleaning up Vortice Graphics resources for '{Title}'...");

        fpsTimer.Stop();

        CleanupDeviceSpecificResources();

        renderTarget?.Dispose(); renderTarget = null;
        dwriteFactory?.Dispose(); dwriteFactory = null;
        d2dFactory?.Dispose(); d2dFactory = null;
        graphicsInitialized = false;

        if (resourcesExisted) Log.Info($"Finished cleaning graphics resources for '{Title}'.");
    }

    protected SizeI GetClientRectSize()
    {
        if (Handle != nint.Zero && NativeMethods.GetClientRect(Handle, out NativeMethods.RECT r))
        {
            int width = Math.Max(1, r.right - r.left);
            int height = Math.Max(1, r.bottom - r.top);
            return new SizeI(width, height);
        }

        int baseWidth = Math.Max(1, Width);
        int baseHeight = Math.Max(1, Height);
        if (Handle != nint.Zero)
        {
            Log.Warning($"GetClientRect failed for '{Title}'. Falling back to stored size: {baseWidth}x{baseHeight}");
        }
        return new SizeI(baseWidth, baseHeight);
    }

    public ID2D1SolidColorBrush? GetOrCreateBrush(Color4 color)
    {
        if (renderTarget is null)
        {
            Log.Warning($"GetOrCreateBrush called on '{Title}' with null RenderTarget.");
            return null;
        }

        if (brushCache.TryGetValue(color, out ID2D1SolidColorBrush? brush) && brush is not null)
        {
            return brush;
        }
        else if (brushCache.ContainsKey(color))
        {
            brushCache.Remove(color);
        }

        try
        {
            brush = renderTarget.CreateSolidColorBrush(color);
            if (brush is not null)
            {
                brushCache[color] = brush;
            }
            return brush;
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
        {
            Log.Warning($"Recreate target detected in GetOrCreateBrush for color {color} on '{Title}'.");
            CleanupDeviceSpecificResources();
            return null;
        }
        catch (Exception ex)
        {
            Log.Error($"Error creating brush for color {color} on '{Title}': {ex.Message}");
            return null;
        }
    }

    public IDWriteTextFormat? GetOrCreateTextFormat(ButtonStyle style)
    {
        if (dwriteFactory is null || style is null)
        {
            Log.Warning($"GetOrCreateTextFormat called on '{Title}' with null DWriteFactory or null style.");
            return null;
        }

        string cacheKey = $"{style.FontName}_{style.FontSize}_{style.FontWeight}_{style.FontStyle}_{style.FontStretch}_{style.WordWrapping}";

        if (textFormatCache.TryGetValue(cacheKey, out IDWriteTextFormat? format) && format is not null)
        {
            return format;
        }
        else if (textFormatCache.ContainsKey(cacheKey))
        {
            textFormatCache.Remove(cacheKey);
        }

        try
        {
            format = dwriteFactory.CreateTextFormat(
                style.FontName,
                null,
                style.FontWeight,
                style.FontStyle,
                style.FontStretch,
                style.FontSize,
                "en-us"
            );

            if (format is not null)
            {
                format.WordWrapping = style.WordWrapping;
                textFormatCache[cacheKey] = format;
            }
            return format;
        }
        catch (Exception ex)
        {
            Log.Error($"Error creating text format for key {cacheKey} on '{Title}': {ex.Message}");
            return null;
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\DisplayServer.cs">
namespace Cherris;

public sealed class DisplayServer
{
    private static DisplayServer? _instance;
    public static DisplayServer Instance => _instance ??= new();

    public DisplayServer()
    {
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\DrawingContext.cs">
using Vortice.Direct2D1;
using Vortice.DirectWrite;

namespace Cherris;


public readonly struct DrawingContext
{
    public readonly ID2D1HwndRenderTarget RenderTarget;
    public readonly IDWriteFactory DWriteFactory;
    public readonly Direct2DAppWindow OwnerWindow;


    public DrawingContext(ID2D1HwndRenderTarget renderTarget, IDWriteFactory dwriteFactory, Direct2DAppWindow ownerWindow)
    {
        RenderTarget = renderTarget;
        DWriteFactory = dwriteFactory;
        OwnerWindow = ownerWindow;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\FileLoader.cs">
using Cherris;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

public static class FileLoader
{
    private static readonly IDeserializer _deserializer = new DeserializerBuilder()
        .WithNamingConvention(PascalCaseNamingConvention.Instance)
        .Build();

    public static T Load<T>(string filePath) where T : new()
    {
        string yamlContent = File.ReadAllText(filePath);
        object data = _deserializer.Deserialize<object>(yamlContent);

        T instance = new();
        List<(Node, string, object)>? deferredAssignments = null;
        if (instance is Node)
        {
            deferredAssignments = new List<(Node, string, object)>();
        }

        ProcessYamlData(instance, data, "", deferredAssignments);
        return instance;
    }

    private static void ProcessYamlData(object target, object yamlData, string currentPath, List<(Node, string, object)>? deferredNodeAssignments)
    {
        switch (yamlData)
        {
            case Dictionary<object, object> dict:
                foreach (KeyValuePair<object, object> entry in dict)
                {
                    string key = entry.Key.ToString()!;
                    string newPath = string.IsNullOrEmpty(currentPath)
                        ? key
                        : $"{currentPath}/{key}";

                    ProcessYamlData(target, entry.Value, newPath, deferredNodeAssignments);
                }
                break;

            case List<object> list:
                NodePropertySetter.SetNestedMember(target, currentPath, list, deferredNodeAssignments);
                break;

            default:                NodePropertySetter.SetNestedMember(target, currentPath, yamlData, deferredNodeAssignments);
                break;
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\GlobalSuppressions.cs">

using System.Diagnostics.CodeAnalysis;

[assembly: SuppressMessage("Style", "IDE0130:Namespace does not match folder structure", Justification = "<Pending>", Scope = "namespace", Target = "~N:Cherris")]
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\GlobalUsings.cs">
global using Color = Vortice.Mathematics.Color4;
global using Vector2 = System.Numerics.Vector2;
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\HAlignment.cs">
namespace Cherris;

public enum OriginPreset
{
    None,
    Center,
    CenterLeft,
    CenterRight,
    TopLeft,
    TopCenter,
    TopRight,
    BottomCenter,
    BottomLeft,
    BottomRight,
}

public enum HAlignment
{
    Left,
    Center,
    Right,
    None
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\HideFromInspectorAttribute.cs">
namespace Cherris;

[AttributeUsage(AttributeTargets.Property)]
public class HideFromInspectorAttribute : Attribute
{
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Input.cs">
namespace Cherris;

public static class Input
{
    private static Vector2 _currentMousePosition = Vector2.Zero;
    private static readonly HashSet<MouseButtonCode> _currentMouseButtonsDown = [];
    private static readonly HashSet<MouseButtonCode> _previousMouseButtonsDown = [];
    private static readonly HashSet<KeyCode> _currentKeysDown = [];
    private static readonly HashSet<KeyCode> _previousKeysDown = [];
    private static float _mouseWheelMovement = 0f;

    private static readonly Dictionary<string, KeyCode> _positiveXActions = [];
    private static readonly Dictionary<string, KeyCode> _negativeXActions = [];
    private static readonly Dictionary<string, KeyCode> _positiveYActions = [];
    private static readonly Dictionary<string, KeyCode> _negativeYActions = [];
    private static readonly Queue<char> _typedCharQueue = new();


    public static void Update()
    {
        _previousMouseButtonsDown.Clear();
        foreach (var button in _currentMouseButtonsDown)
        {
            _previousMouseButtonsDown.Add(button);
        }

        _previousKeysDown.Clear();
        foreach (var key in _currentKeysDown)
        {
            _previousKeysDown.Add(key);
        }

        _mouseWheelMovement = 0f;
    }

    internal static void UpdateMouseButton(MouseButtonCode button, bool isDown)
    {
        if (isDown)
        {
            _currentMouseButtonsDown.Add(button);
        }
        else
        {
            _currentMouseButtonsDown.Remove(button);
        }
    }

    internal static void UpdateKey(KeyCode key, bool isDown)
    {
        if (isDown)
        {
            _currentKeysDown.Add(key);
        }
        else
        {
            _currentKeysDown.Remove(key);
        }
    }

    internal static void UpdateMousePosition(Vector2 position)
    {
        _currentMousePosition = position;
    }

    internal static void UpdateMouseWheel(float delta)
    {
        _mouseWheelMovement = delta;
    }
    internal static void AddTypedCharacter(char c)
    {
        if (!char.IsControl(c) || c == '\t')        {
            _typedCharQueue.Enqueue(c);
        }
    }
    public static char? ConsumeNextTypedChar()
    {
        if (_typedCharQueue.Count > 0)
        {
            return _typedCharQueue.Dequeue();
        }
        return null;
    }


    public static bool IsActionDown(string actionName)
    {
        if (_positiveXActions.TryGetValue(actionName, out var posXKey) && IsKeyDown(posXKey)) return true;
        if (_negativeXActions.TryGetValue(actionName, out var negXKey) && IsKeyDown(negXKey)) return true;
        if (_positiveYActions.TryGetValue(actionName, out var posYKey) && IsKeyDown(posYKey)) return true;
        if (_negativeYActions.TryGetValue(actionName, out var negYKey) && IsKeyDown(negYKey)) return true;

        return false;
    }

    public static bool IsActionPressed(string actionName)
    {
        if (_positiveXActions.TryGetValue(actionName, out var posXKey) && IsKeyPressed(posXKey)) return true;
        if (_negativeXActions.TryGetValue(actionName, out var negXKey) && IsKeyPressed(negXKey)) return true;
        if (_positiveYActions.TryGetValue(actionName, out var posYKey) && IsKeyPressed(posYKey)) return true;
        if (_negativeYActions.TryGetValue(actionName, out var negYKey) && IsKeyPressed(negYKey)) return true;
        return false;
    }


    public static bool IsKeyPressed(KeyCode keyboardKey)
    {
        return _currentKeysDown.Contains(keyboardKey) && !_previousKeysDown.Contains(keyboardKey);
    }

    public static bool IsKeyReleased(KeyCode keyboardKey)
    {
        return !_currentKeysDown.Contains(keyboardKey) && _previousKeysDown.Contains(keyboardKey);
    }

    public static bool IsKeyDown(KeyCode keyboardKey)
    {
        return _currentKeysDown.Contains(keyboardKey);
    }


    public static bool IsMouseButtonPressed(MouseButtonCode button)
    {
        return _currentMouseButtonsDown.Contains(button) && !_previousMouseButtonsDown.Contains(button);
    }

    public static bool IsMouseButtonReleased(MouseButtonCode button)
    {
        return !_currentMouseButtonsDown.Contains(button) && _previousMouseButtonsDown.Contains(button);
    }

    public static bool IsMouseButtonDown(MouseButtonCode button)
    {
        return _currentMouseButtonsDown.Contains(button);
    }

    public static float GetMouseWheelMovement()
    {
        return _mouseWheelMovement;
    }

    public static Vector2 MousePosition => _currentMousePosition;

    public static Vector2 WorldMousePosition => _currentMousePosition;

    public static Vector2 GetVector(string negativeX, string positiveX, string negativeY, string positiveY, float deadzone = -1.0f)
    {
        float x = 0.0f;
        float y = 0.0f;

        if (_positiveXActions.TryGetValue(positiveX, out var posXKey) && IsKeyDown(posXKey)) x += 1.0f;
        if (_negativeXActions.TryGetValue(negativeX, out var negXKey) && IsKeyDown(negXKey)) x -= 1.0f;
        if (_positiveYActions.TryGetValue(positiveY, out var posYKey) && IsKeyDown(posYKey)) y += 1.0f;
        if (_negativeYActions.TryGetValue(negativeY, out var negYKey) && IsKeyDown(negYKey)) y -= 1.0f;

        var vector = new Vector2(x, y);

        if (deadzone < 0.0f)
        {
            return vector.LengthSquared() > 0 ? Vector2.Normalize(vector) : Vector2.Zero;
        }
        else
        {
            float length = vector.Length();
            if (length < deadzone)
            {
                return Vector2.Zero;
            }
            else
            {
                var normalized = vector / length;
                float mappedLength = (length - deadzone) / (1.0f - deadzone);
                return normalized * mappedLength;
            }
        }
    }

    public static void AddActionKey(string actionName, KeyCode key, bool isPositiveX = false, bool isNegativeX = false, bool isPositiveY = false, bool isNegativeY = false)
    {
        if (isPositiveX) _positiveXActions[actionName] = key;
        if (isNegativeX) _negativeXActions[actionName] = key;
        if (isPositiveY) _positiveYActions[actionName] = key;
        if (isNegativeY) _negativeYActions[actionName] = key;
    }

    public static void SetupDefaultActions()
    {
        AddActionKey("UiUp", KeyCode.UpArrow, isNegativeY: true);
        AddActionKey("UiUp", KeyCode.W, isNegativeY: true);
        AddActionKey("UiDown", KeyCode.DownArrow, isPositiveY: true);
        AddActionKey("UiDown", KeyCode.S, isPositiveY: true);
        AddActionKey("UiLeft", KeyCode.LeftArrow, isNegativeX: true);
        AddActionKey("UiLeft", KeyCode.A, isNegativeX: true);
        AddActionKey("UiRight", KeyCode.RightArrow, isPositiveX: true);
        AddActionKey("UiRight", KeyCode.D, isPositiveX: true);
        AddActionKey("UiAccept", KeyCode.Enter, isPositiveX: true);
        AddActionKey("UiAccept", KeyCode.Space, isPositiveX: true);
        AddActionKey("UiCancel", KeyCode.Escape, isPositiveX: true);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\KeyCode.cs">
namespace Cherris;

public enum KeyCode
{
    Unknown = 0,

    Space = 0x20,
    Apostrophe = 222,
    Comma = 188,
    Minus = 189,
    Period = 190,
    Slash = 191,
    Alpha0 = 48,
    Alpha1 = 49,
    Alpha2 = 50,
    Alpha3 = 51,
    Alpha4 = 52,
    Alpha5 = 53,
    Alpha6 = 54,
    Alpha7 = 55,
    Alpha8 = 56,
    Alpha9 = 57,
    Semicolon = 186,
    Equal = 187,
    A = 65,
    B = 66,
    C = 67,
    D = 68,
    E = 69,
    F = 70,
    G = 71,
    H = 72,
    I = 73,
    J = 74,
    K = 75,
    L = 76,
    M = 77,
    N = 78,
    O = 79,
    P = 80,
    Q = 81,
    R = 82,
    S = 83,
    T = 84,
    U = 85,
    V = 86,
    W = 87,
    X = 88,
    Y = 89,
    Z = 90,
    LeftBracket = 219,
    Backslash = 220,
    RightBracket = 221,
    GraveAccent = 192,

    Escape = 0x1B,
    Enter = 0x0D,    Tab = 0x09,    Backspace = 0x08,    Insert = 0x2D,    Delete = 0x2E,    RightArrow = 0x27,    LeftArrow = 0x25,    DownArrow = 0x28,    UpArrow = 0x26,    PageUp = 0x21,    PageDown = 0x22,    Home = 0x24,    End = 0x23,    CapsLock = 0x14,    ScrollLock = 0x91,    NumLock = 0x90,    PrintScreen = 0x2C,    Pause = 0x13,    F1 = 0x70,    F2 = 0x71,
    F3 = 0x72,
    F4 = 0x73,
    F5 = 0x74,
    F6 = 0x75,
    F7 = 0x76,
    F8 = 0x77,
    F9 = 0x78,
    F10 = 0x79,
    F11 = 0x7A,
    F12 = 0x7B,
    Numpad0 = 0x60,    Numpad1 = 0x61,
    Numpad2 = 0x62,
    Numpad3 = 0x63,
    Numpad4 = 0x64,
    Numpad5 = 0x65,
    Numpad6 = 0x66,
    Numpad7 = 0x67,
    Numpad8 = 0x68,
    Numpad9 = 0x69,
    NumpadDecimal = 0x6E,    NumpadDivide = 0x6F,    NumpadMultiply = 0x6A,    NumpadSubtract = 0x6D,    NumpadAdd = 0x6B,    NumpadEnter = 0x6C,    LeftShift = 0xA0,    LeftControl = 0xA2,    LeftAlt = 0xA4,    LeftSuper = 0x5B,    RightShift = 0xA1,    RightControl = 0xA3,    RightAlt = 0xA5,    RightSuper = 0x5C,    Menu = 0x5D}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Log.cs">
namespace Cherris;

using System;
using System.IO;
using System.Runtime.CompilerServices;

public class Log
{
    private readonly static string LogFilePath = "Res/Log.txt";
    private readonly static ConsoleColor infoColor = ConsoleColor.DarkGray;
    private readonly static ConsoleColor warningColor = ConsoleColor.Yellow;
    private readonly static ConsoleColor errorColor = ConsoleColor.Red;

    public static void Info(string message, [CallerLineNumber] int lineNumber = 0, [CallerFilePath] string filePath = "")
    {
        string fullMessage = $"[{DateTime.Now:HH:mm:ss}] [INFO] [{Path.GetFileName(filePath)}:{lineNumber}] {message}";
        Console.ForegroundColor = infoColor;
        Console.WriteLine(fullMessage);
        Console.ResetColor();
        File.AppendAllText(LogFilePath, Environment.NewLine + fullMessage);
    }

    public static void Info(string message, bool condition, [CallerLineNumber] int lineNumber = 0, [CallerFilePath] string filePath = "")
    {
        if (!condition)
        {
            return;
        }

        Console.ForegroundColor = infoColor;
        Console.WriteLine($"[{DateTime.Now:HH:mm:ss}] [INFO] [{Path.GetFileName(filePath)}:{lineNumber}] {message}");
        Console.ResetColor();
    }

    public static void Warning(string message, [CallerLineNumber] int lineNumber = 0, [CallerFilePath] string filePath = "")
    {
        string fullMessage = $"[{DateTime.Now:HH:mm:ss}] [WARNING] [{Path.GetFileName(filePath)}:{lineNumber}] {message}";
        Console.ForegroundColor = warningColor;
        Console.WriteLine(fullMessage);
        Console.ResetColor();
        File.AppendAllText(LogFilePath, Environment.NewLine + fullMessage);
    }

    public static void Warning(string message, bool condition, [CallerLineNumber] int lineNumber = 0, [CallerFilePath] string filePath = "")
    {
        if (!condition)
        {
            return;
        }

        Console.ForegroundColor = warningColor;
        Console.WriteLine($"[{DateTime.Now:HH:mm:ss}] [WARNING] [{Path.GetFileName(filePath)}:{lineNumber}] {message}");
        Console.ResetColor();
    }

    public static void Error(string message, [CallerLineNumber] int lineNumber = 0, [CallerFilePath] string filePath = "")
    {
        string fullMessage = $"[{DateTime.Now:HH:mm:ss}] [ERROR] - {Path.GetFileName(filePath)}:{lineNumber} - {message}";
        Console.ForegroundColor = errorColor;
        Console.WriteLine(fullMessage);
        Console.ResetColor();
        File.AppendAllText(LogFilePath, Environment.NewLine + fullMessage);
    }

    public static void Error(string message, bool condition, [CallerLineNumber] int lineNumber = 0, [CallerFilePath] string filePath = "")
    {
        if (!condition)
        {
            return;
        }

        Console.ForegroundColor = errorColor;
        Console.WriteLine($"[{DateTime.Now:HH:mm:ss}] [ERROR] - [{Path.GetFileName(filePath)}:{lineNumber}] - {message}");
        Console.ResetColor();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\MainAppWindow.cs">
namespace Cherris;

public class MainAppWindow : Direct2DAppWindow
{
    public event Action? Closed;
    private bool _firstDrawLogged = false;
    private Vector2 _mainCurrentMousePosition = Vector2.Zero;

    public MainAppWindow(string title = "My DirectUI App", int width = 800, int height = 600)
        : base(title, width, height)
    {
        Input.SetupDefaultActions();
    }

    public Vector2 GetLocalMousePosition() => _mainCurrentMousePosition;

    protected override void DrawUIContent(DrawingContext context)
    {
        if (!_firstDrawLogged)
        {
            Log.Info($"MainAppWindow.DrawUIContent called for '{Title}'. Rendering SceneTree.");
            _firstDrawLogged = true;
        }

        SceneTree.Instance.RenderScene(context);
    }

    protected override bool OnClose()
    {
        Log.Info("MainAppWindow OnClose called.");
        Closed?.Invoke();
        return base.OnClose();
    }

    protected override void Cleanup()
    {
        Log.Info("MainAppWindow Cleanup starting.");
        base.Cleanup();
        Log.Info("MainAppWindow Cleanup finished.");
    }

    protected override IntPtr HandleMessage(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {

        switch (msg)
        {
            case NativeMethods.WM_MOUSEMOVE:
                int x = NativeMethods.GET_X_LPARAM(lParam);
                int y = NativeMethods.GET_Y_LPARAM(lParam);
                _mainCurrentMousePosition = new Vector2(x, y);
                Input.UpdateMousePosition(_mainCurrentMousePosition);                return base.HandleMessage(hWnd, msg, wParam, lParam);

            case NativeMethods.WM_LBUTTONDOWN:
                Input.UpdateMouseButton(MouseButtonCode.Left, true);
                break;
            case NativeMethods.WM_LBUTTONUP:
                Input.UpdateMouseButton(MouseButtonCode.Left, false);
                break;

            case NativeMethods.WM_RBUTTONDOWN:
                Input.UpdateMouseButton(MouseButtonCode.Right, true);
                break;
            case NativeMethods.WM_RBUTTONUP:
                Input.UpdateMouseButton(MouseButtonCode.Right, false);
                break;

            case NativeMethods.WM_MBUTTONDOWN:
                Input.UpdateMouseButton(MouseButtonCode.Middle, true);
                break;
            case NativeMethods.WM_MBUTTONUP:
                Input.UpdateMouseButton(MouseButtonCode.Middle, false);
                break;

            case NativeMethods.WM_XBUTTONDOWN:
                int xButton1 = NativeMethods.GET_XBUTTON_WPARAM(wParam);
                if (xButton1 == NativeMethods.XBUTTON1) Input.UpdateMouseButton(MouseButtonCode.Side, true);
                if (xButton1 == NativeMethods.XBUTTON2) Input.UpdateMouseButton(MouseButtonCode.Extra, true);
                break;
            case NativeMethods.WM_XBUTTONUP:
                int xButton2 = NativeMethods.GET_XBUTTON_WPARAM(wParam);
                if (xButton2 == NativeMethods.XBUTTON1) Input.UpdateMouseButton(MouseButtonCode.Side, false);
                if (xButton2 == NativeMethods.XBUTTON2) Input.UpdateMouseButton(MouseButtonCode.Extra, false);
                break;

            case NativeMethods.WM_MOUSEWHEEL:
                short wheelDelta = NativeMethods.GET_WHEEL_DELTA_WPARAM(wParam);
                Input.UpdateMouseWheel((float)wheelDelta / NativeMethods.WHEEL_DELTA);
                break;

            case NativeMethods.WM_KEYDOWN:
            case NativeMethods.WM_SYSKEYDOWN:
                int vkCodeDown = (int)wParam;
                if (Enum.IsDefined(typeof(KeyCode), vkCodeDown))
                {
                    Input.UpdateKey((KeyCode)vkCodeDown, true);
                }
                return base.HandleMessage(hWnd, msg, wParam, lParam);

            case NativeMethods.WM_KEYUP:
            case NativeMethods.WM_SYSKEYUP:
                int vkCodeUp = (int)wParam;
                if (Enum.IsDefined(typeof(KeyCode), vkCodeUp))
                {
                    Input.UpdateKey((KeyCode)vkCodeUp, false);
                }
                break;

            case NativeMethods.WM_CHAR:
                char typedChar = (char)wParam;
                Input.AddTypedCharacter(typedChar);
                return IntPtr.Zero;        }

        return base.HandleMessage(hWnd, msg, wParam, lParam);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\ModalSecondaryWindow.cs">
namespace Cherris;

public class ModalSecondaryWindow : SecondaryWindow
{
    private readonly IntPtr ownerHwnd;

    public ModalSecondaryWindow(string title, int width, int height, WindowNode ownerNode, IntPtr ownerHandle)
        : base(title, width, height, ownerNode)
    {
        ownerHwnd = ownerHandle;
    }


    public override bool TryCreateWindow(IntPtr ownerHwndOverride = default, uint? styleOverride = null)
    {

        uint defaultModalStyle = NativeMethods.WS_POPUP
                               | NativeMethods.WS_CAPTION
                               | NativeMethods.WS_SYSMENU
                               | NativeMethods.WS_VISIBLE
                               | NativeMethods.WS_THICKFRAME;


        return base.TryCreateWindow(ownerHwnd, styleOverride ?? defaultModalStyle);
    }

    public override void ShowWindow()
    {

        if (ownerHwnd != IntPtr.Zero)
        {
            NativeMethods.EnableWindow(ownerHwnd, false);
        }
        base.ShowWindow();
    }

    protected override void OnDestroy()
    {

        if (ownerHwnd != IntPtr.Zero)
        {
            NativeMethods.EnableWindow(ownerHwnd, true);
        }
        base.OnDestroy();
    }


    protected override bool OnClose()
    {
        Log.Info($"ModalSecondaryWindow '{Title}' OnClose called.");

        if (ownerHwnd != IntPtr.Zero)
        {
            NativeMethods.EnableWindow(ownerHwnd, true);
        }


        return base.OnClose();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\ModalWindowNode.cs">
namespace Cherris;

public class ModalWindowNode : WindowNode
{
    private ModalSecondaryWindow? modalWindow;

    public override void Make()
    {
        InitializeModalWindow();
    }

    private void InitializeModalWindow()
    {
        if (modalWindow is not null)
        {
            Log.Warning($"ModalWindowNode '{Name}' already has an associated window. Skipping creation.");
            return;
        }

        var ownerHandle = ApplicationServer.Instance.GetMainWindowHandle();
        if (ownerHandle == IntPtr.Zero)
        {
            Log.Error($"ModalWindowNode '{Name}' could not get the main window handle. Cannot create modal window.");
            return;
        }

        try
        {
            modalWindow = new ModalSecondaryWindow(Title, Width, Height, this, ownerHandle);
            this.secondaryWindow = modalWindow;

            if (!modalWindow.TryCreateWindow())
            {
                Log.Error($"ModalWindowNode '{Name}' failed to create its modal window.");
                modalWindow = null;
                this.secondaryWindow = null;
                return;
            }

            modalWindow.BackdropType = this.BackdropType;

            if (!modalWindow.InitializeWindowAndGraphics())
            {
                Log.Error($"ModalWindowNode '{Name}' failed to initialize modal window graphics.");
                modalWindow.Dispose();
                modalWindow = null;
                this.secondaryWindow = null;
                return;
            }

            modalWindow.ShowWindow();
            Log.Info($"ModalWindowNode '{Name}' successfully created and initialized its modal window.");
        }
        catch (Exception ex)
        {
            Log.Error($"Error during ModalWindowNode '{Name}' initialization: {ex.Message}");
            modalWindow?.Dispose();
            modalWindow = null;
            this.secondaryWindow = null;
        }
    }

    protected override void FreeInternal()
    {
        Log.Info($"Freeing ModalWindowNode '{Name}' and its associated modal window.");

        modalWindow?.Close();
        modalWindow = null;

        this.secondaryWindow = null;

        base.FreeInternal();
    }

    public override void Process()
    {
        if (this.isQueuedForFree)
        {
            this.FreeInternal();
        }
        else
        {
            base.Process();
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\MouseButtonCode.cs">
namespace Cherris;

public enum MouseButtonCode
{
    Left = 0,
    Right = 1,
    Middle = 2,    Side = 3,    Extra = 4,    Forward = 5,
    Back = 6
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\NativeMethods.cs">
using System.Runtime.InteropServices;

namespace Cherris;

public static class NativeMethods
{
    public const uint CS_HREDRAW = 0x0002;
    public const uint CS_VREDRAW = 0x0001;
    public const uint CS_OWNDC = 0x0020;

    public const uint WS_OVERLAPPED = 0x00000000;
    public const uint WS_CAPTION = 0x00C00000;
    public const uint WS_SYSMENU = 0x00080000;
    public const uint WS_THICKFRAME = 0x00040000;
    public const uint WS_MINIMIZEBOX = 0x00020000;
    public const uint WS_MAXIMIZEBOX = 0x00010000;
    public const uint WS_OVERLAPPEDWINDOW = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
    public const uint WS_VISIBLE = 0x10000000;
    public const uint WS_POPUP = 0x80000000;
    public const uint WS_BORDER = 0x00800000;
    public const uint WS_DLGFRAME = 0x00400000;

    public const int WM_NCCREATE = 0x0081;
    public const int WM_CREATE = 0x0001;
    public const int WM_NCDESTROY = 0x0082;
    public const int WM_PAINT = 0x000F;
    public const int WM_DESTROY = 0x0002;
    public const int WM_SIZE = 0x0005;
    public const int WM_CLOSE = 0x0010;
    public const int WM_KEYDOWN = 0x0100;
    public const int WM_KEYUP = 0x0101;
    public const int WM_SYSKEYDOWN = 0x0104;
    public const int WM_SYSKEYUP = 0x0105;
    public const int WM_CHAR = 0x0102;    public const int WM_LBUTTONDOWN = 0x0201;
    public const int WM_LBUTTONUP = 0x0202;
    public const int WM_RBUTTONDOWN = 0x0204;
    public const int WM_RBUTTONUP = 0x0205;
    public const int WM_MBUTTONDOWN = 0x0207;
    public const int WM_MBUTTONUP = 0x0208;
    public const int WM_XBUTTONDOWN = 0x020B;
    public const int WM_XBUTTONUP = 0x020C;
    public const int WM_MOUSEMOVE = 0x0200;
    public const int WM_MOUSEWHEEL = 0x020A;
    public const int WM_QUIT = 0x0012;
    public const int WM_PARENTNOTIFY = 0x0210;
    public const int WM_ENTERIDLE = 0x0121;
    public const int WM_DWMCOMPOSITIONCHANGED = 0x031E;

    public const int CW_USEDEFAULT = unchecked((int)0x80000000);
    public const int SW_SHOWNORMAL = 1;
    public const int VK_ESCAPE = 0x1B;
    public const int GWLP_USERDATA = -21;
    public const int GCLP_HBRBACKGROUND = -10;
    public const int GWL_STYLE = -16;

    public const int IDI_APPLICATION = 32512;
    public const int IDC_ARROW = 32512;

    public const int WHEEL_DELTA = 120;
    public const int XBUTTON1 = 0x0001;
    public const int XBUTTON2 = 0x0002;

    public const uint PM_REMOVE = 0x0001;

    public enum DWMWINDOWATTRIBUTE
    {
        DWMWA_USE_IMMERSIVE_DARK_MODE = 20,
        DWMWA_SYSTEMBACKDROP_TYPE = 38,
        DWMWA_MICA_EFFECT = 1029
    }

    public enum DWMSBT
    {
        DWMSBT_AUTO = 0,
        DWMSBT_NONE = 1,
        DWMSBT_MAINWINDOW = 2,
        DWMSBT_TRANSIENTWINDOW = 3,
        DWMSBT_TABBEDWINDOW = 4
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
    public struct WNDCLASSEX
    {
        public int cbSize;
        public uint style;
        public WndProc lpfnWndProc;
        public int cbClsExtra;
        public int cbWndExtra;
        public IntPtr hInstance;
        public IntPtr hIcon;
        public IntPtr hCursor;
        public IntPtr hbrBackground;
        [MarshalAs(UnmanagedType.LPTStr)]
        public string lpszMenuName;
        [MarshalAs(UnmanagedType.LPTStr)]
        public string lpszClassName;
        public IntPtr hIconSm;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct MSG
    {
        public IntPtr hwnd;
        public uint message;
        public IntPtr wParam;
        public IntPtr lParam;
        public uint time;
        public POINT pt;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct POINT
    {
        public int X;
        public int Y;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct RECT
    {
        public int left;
        public int top;
        public int right;
        public int bottom;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
    public struct CREATESTRUCT
    {
        public IntPtr lpCreateParams;
        public IntPtr hInstance;
        public IntPtr hMenu;
        public IntPtr hwndParent;
        public int cy;
        public int cx;
        public int y;
        public int x;
        public int style;
        public string lpszName;
        public string lpszClass;
        public uint dwExStyle;
    }

    public delegate IntPtr WndProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam);

    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern ushort RegisterClassEx([In] ref WNDCLASSEX lpwcx);

    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern IntPtr CreateWindowEx(
       uint dwExStyle,
       string lpClassName,
       string lpWindowName,
       uint dwStyle,
       int x,
       int y,
       int nWidth,
       int nHeight,
       IntPtr hWndParent,
       IntPtr hMenu,
       IntPtr hInstance,
       IntPtr lpParam);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool UpdateWindow(IntPtr hWnd);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool DestroyWindow(IntPtr hWnd);

    [DllImport("user32.dll", CharSet = CharSet.Auto)]
    public static extern IntPtr DefWindowProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam);

    [DllImport("user32.dll")]
    public static extern void PostQuitMessage(int nExitCode);

    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool PostMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

    [DllImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool GetMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax);

    [DllImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool PeekMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax, uint wRemoveMsg);

    [DllImport("user32.dll")]
    public static extern bool TranslateMessage([In] ref MSG lpMsg);

    [DllImport("user32.dll")]
    public static extern IntPtr DispatchMessage([In] ref MSG lpmsg);

    [DllImport("user32.dll")]
    public static extern bool GetClientRect(IntPtr hWnd, out RECT lpRect);

    [DllImport("user32.dll")]
    public static extern bool ValidateRect(IntPtr hWnd, IntPtr lpRect);

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern IntPtr GetModuleHandle(string lpModuleName);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool InvalidateRect(IntPtr hWnd, IntPtr lpRect, bool bErase);

    [DllImport("user32.dll")]
    public static extern IntPtr LoadCursor(IntPtr hInstance, int lpCursorName);

    [DllImport("user32.dll")]
    public static extern IntPtr LoadIcon(IntPtr hInstance, IntPtr lpIconName);

    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool EnableWindow(IntPtr hWnd, bool bEnable);

    [DllImport("user32.dll")]
    public static extern IntPtr GetParent(IntPtr hWnd);
    [DllImport("dwmapi.dll", SetLastError = true)]
    public static extern int DwmSetWindowAttribute(IntPtr hwnd, DWMWINDOWATTRIBUTE dwAttribute, ref int pvAttribute, int cbAttribute);

    [DllImport("user32.dll", EntryPoint = "SetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr SetWindowLongPtr64(IntPtr hWnd, int nIndex, IntPtr dwNewLong);

    [DllImport("user32.dll", EntryPoint = "SetWindowLongW", SetLastError = true)]
    private static extern IntPtr SetWindowLong32(IntPtr hWnd, int nIndex, IntPtr dwNewLong);

    [DllImport("user32.dll", EntryPoint = "GetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr GetWindowLongPtr64(IntPtr hWnd, int nIndex);

    [DllImport("user32.dll", EntryPoint = "GetWindowLongW", SetLastError = true)]
    private static extern IntPtr GetWindowLong32(IntPtr hWnd, int nIndex);

    public static IntPtr SetWindowLongPtr(IntPtr hWnd, int nIndex, IntPtr dwNewLong)
    {
        if (IntPtr.Size == 8)
            return SetWindowLongPtr64(hWnd, nIndex, dwNewLong);
        else
            return SetWindowLong32(hWnd, nIndex, dwNewLong);
    }

    public static IntPtr GetWindowLongPtr(IntPtr hWnd, int nIndex)
    {
        if (IntPtr.Size == 8)
            return GetWindowLongPtr64(hWnd, nIndex);
        else
            return GetWindowLong32(hWnd, nIndex);
    }

    public static int GET_X_LPARAM(IntPtr lParam) => LOWORD(lParam);
    public static int GET_Y_LPARAM(IntPtr lParam) => HIWORD(lParam);
    public static short GET_WHEEL_DELTA_WPARAM(IntPtr wParam) => HIWORD(wParam);
    public static short GET_XBUTTON_WPARAM(IntPtr wParam) => HIWORD(wParam);

    public static int LOWORD(IntPtr ptr) => unchecked((short)(long)ptr);
    public static short HIWORD(IntPtr ptr) => unchecked((short)((long)ptr >> 16));
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\NodeEmoji.cs">
namespace Cherris;

public static class NodeEmoji
{
    public static string GetEmojiForNodeType(Node node)
    {
        return node switch
        {
            _ => "⭕",
        };
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\RenderServer.cs">
using Raylib_cs;

namespace Cherris;

public sealed class RenderServer
{
    private static RenderServer? _instance;
    public static RenderServer Instance => _instance ??= new();

    public Camera? Camera;
    public Shader? PostProcessingShader { get; set; }

    private readonly List<DrawCommand> drawCommands = [];
    public RenderTexture2D RenderTexture { get; private set; }

    private RenderServer()
    {
        var mainWin = ApplicationServer.Instance.GetMainAppWindow();
        Vector2 windowSize = mainWin != null ? new Vector2(mainWin.Width, mainWin.Height) : new Vector2(800, 600);
        RenderTexture = Raylib.LoadRenderTexture((int)windowSize.X, (int)windowSize.Y);
    }

    public void WindowSizeChanged(Vector2 newSize)
    {
        Raylib.UnloadRenderTexture(RenderTexture);
        RenderTexture = Raylib.LoadRenderTexture(
            (int)newSize.X,
            (int)newSize.Y);
    }

    public void Process()
    {
        RenderScene();

        BeginShaderMode(PostProcessingShader);
        EndShaderMode();
    }

    public void RenderScene()
    {
        Raylib.BeginTextureMode(RenderTexture);
        BeginCameraMode();
        ProcessDrawCommands();
        EndCameraMode();
        Raylib.EndTextureMode();
    }

    public void Process2()
    {
    }

    public void Submit(Action drawAction, int layer)
    {
        drawCommands.Add(new(drawAction, layer));
    }

    public Vector2 GetScreenToWorld(Vector2 position)
    {
        return Camera is null
            ? position
            : Raylib.GetScreenToWorld2D(position, Camera);
    }

    public Vector2 GetWorldToScreen(Vector2 position)
    {
        return Camera is null
            ? position
            : Raylib.GetWorldToScreen2D(position, Camera);
    }

    public static void BeginScissorMode(Vector2 position, Vector2 size)
    {
        Raylib.BeginScissorMode(
            (int)position.X,
            (int)position.Y,
            (int)size.X,
            (int)size.Y);
    }

    public static void EndScissorMode()
    {
        Raylib.EndScissorMode();
    }

    public void SetCamera(Camera camera)
    {
        Camera = camera;
    }

    private void BeginCameraMode()
    {
        if (Camera is null)
        {
            return;
        }
        Vector2 windowSize = Camera.GetWindowSizeV2();

        Camera2D cam = new()
        {
            Target = Camera.GlobalPosition,
            Offset = windowSize / 2,
            Zoom = Camera.Zoom,
        };

        Raylib.BeginMode2D(cam);
    }

    private void EndCameraMode()
    {
        if (Camera is null)
        {
            return;
        }

        Raylib.EndMode2D();
    }

    public static void BeginShaderMode(Shader? shader)
    {
        if (shader is null)
        {
            return;
        }

        Raylib.BeginShaderMode(shader);
    }

    public static void EndShaderMode()
    {
        Raylib.EndShaderMode();
    }

    private void ProcessDrawCommands()
    {
        foreach (DrawCommand command in drawCommands.OrderBy(c => c.Layer))
        {
            command.DrawAction.Invoke();
        }

        drawCommands.Clear();
    }

    private class DrawCommand(Action drawAction, int layer)
    {
        public Action DrawAction { get; } = drawAction;
        public int Layer { get; } = layer;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\ResourceLoader.cs">
namespace Cherris;

public sealed class ResourceLoader
{
    public static T? Load<T>(string path)
    {
        return typeof(T) switch
        {
            var t when t == typeof(AudioStream) => (T)(object)AudioStreamCache.Instance.Get(path)!,
            var t when t == typeof(Texture) => (T)(object)TextureCache.Instance.Get(path),
            var t when t == typeof(Font) => (T)(object)FontCache.Instance.Get(path),
            var t when t == typeof(Sound) => (T)(object)SoundCache.Instance.Get(path),
            var t when t == typeof(Animation) => (T)(object)AnimationCache.Instance.Get(path),
            _ => throw new InvalidOperationException($"Unsupported resource type: {typeof(T)}")
        };
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\SecondaryWindow.cs">
namespace Cherris;

public class SecondaryWindow : Direct2DAppWindow
{
    private readonly WindowNode ownerNode;
    private Vector2 currentMousePosition = Vector2.Zero;

    public SecondaryWindow(string title, int width, int height, WindowNode owner)
        : base(title, width, height)
    {
        ownerNode = owner ?? throw new ArgumentNullException(nameof(owner));
        ApplicationServer.Instance.RegisterSecondaryWindow(this);
    }

    protected override void DrawUIContent(DrawingContext context)
    {
        ownerNode?.RenderChildren(context);
    }

    protected override bool OnClose()
    {
        Log.Info($"SecondaryWindow '{Title}' OnClose called.");
        ownerNode?.QueueFree();
        return base.OnClose();
    }

    protected override void Cleanup()
    {
        Log.Info($"SecondaryWindow '{Title}' Cleanup starting.");
        base.Cleanup();
        Log.Info($"SecondaryWindow '{Title}' Cleanup finished.");
    }

    protected override IntPtr HandleMessage(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        int xPos = NativeMethods.GET_X_LPARAM(lParam);
        int yPos = NativeMethods.GET_Y_LPARAM(lParam);
        Vector2 mousePos = new Vector2(xPos, yPos);

        currentMousePosition = mousePos;
        switch (msg)
        {
            case NativeMethods.WM_MOUSEMOVE:
                Input.UpdateMousePosition(currentMousePosition);                return base.HandleMessage(hWnd, msg, wParam, lParam);

            case NativeMethods.WM_LBUTTONDOWN:
                Input.UpdateMouseButton(MouseButtonCode.Left, true);
                break;
            case NativeMethods.WM_LBUTTONUP:
                Input.UpdateMouseButton(MouseButtonCode.Left, false);
                break;

            case NativeMethods.WM_RBUTTONDOWN:
                Input.UpdateMouseButton(MouseButtonCode.Right, true);
                break;
            case NativeMethods.WM_RBUTTONUP:
                Input.UpdateMouseButton(MouseButtonCode.Right, false);
                break;

            case NativeMethods.WM_MBUTTONDOWN:
                Input.UpdateMouseButton(MouseButtonCode.Middle, true);
                break;
            case NativeMethods.WM_MBUTTONUP:
                Input.UpdateMouseButton(MouseButtonCode.Middle, false);
                break;

            case NativeMethods.WM_XBUTTONDOWN:
                int xButton1 = NativeMethods.GET_XBUTTON_WPARAM(wParam);
                if (xButton1 == NativeMethods.XBUTTON1) Input.UpdateMouseButton(MouseButtonCode.Side, true);
                if (xButton1 == NativeMethods.XBUTTON2) Input.UpdateMouseButton(MouseButtonCode.Extra, true);
                break;
            case NativeMethods.WM_XBUTTONUP:
                int xButton2 = NativeMethods.GET_XBUTTON_WPARAM(wParam);
                if (xButton2 == NativeMethods.XBUTTON1) Input.UpdateMouseButton(MouseButtonCode.Side, false);
                if (xButton2 == NativeMethods.XBUTTON2) Input.UpdateMouseButton(MouseButtonCode.Extra, false);
                break;

            case NativeMethods.WM_MOUSEWHEEL:
                short wheelDelta = NativeMethods.GET_WHEEL_DELTA_WPARAM(wParam);
                Input.UpdateMouseWheel((float)wheelDelta / NativeMethods.WHEEL_DELTA);
                break;

            case NativeMethods.WM_KEYDOWN:
            case NativeMethods.WM_SYSKEYDOWN:
                int vkCodeDown = (int)wParam;
                if (Enum.IsDefined(typeof(KeyCode), vkCodeDown))
                {
                    Input.UpdateKey((KeyCode)vkCodeDown, true);
                }
                return base.HandleMessage(hWnd, msg, wParam, lParam);

            case NativeMethods.WM_KEYUP:
            case NativeMethods.WM_SYSKEYUP:
                int vkCodeUp = (int)wParam;
                if (Enum.IsDefined(typeof(KeyCode), vkCodeUp))
                {
                    Input.UpdateKey((KeyCode)vkCodeUp, false);
                }
                return IntPtr.Zero;
        }

        return base.HandleMessage(hWnd, msg, wParam, lParam);
    }

    public Vector2 GetLocalMousePosition() => currentMousePosition;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\SystemBackdropType.cs">
namespace Cherris;

public enum SystemBackdropType
{
    None,
    Mica,
    Acrylic,
    MicaAlt
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Time.cs">
namespace Cherris;

public class Time
{
    public static float Delta { get; internal set; } = 1f / 60f;}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Tween.cs">
using System.Reflection;

namespace Cherris;

public class Tween(Node creatorNode, Node.ProcessMode processMode = Node.ProcessMode.Inherit)
{
    public bool Active = true;

    private readonly List<TweenStep> steps = [];
    private readonly Node creatorNode = creatorNode;
    private readonly Node.ProcessMode processMode = processMode;

    private static readonly bool debug = false;

    public bool Stopped { get; private set; }

    public void Stop()
    {
        Stopped = true;
        Active = false;
    }

    public void TweenProperty(Node node, string propertyPath, float targetValue, float duration)
    {
        try
        {
            ArgumentNullException.ThrowIfNull(node);

            if (string.IsNullOrEmpty(propertyPath))
            {
                throw new ArgumentException("Property path cannot be null or empty.", nameof(propertyPath));
            }

            Log.Info($"[Tween] Starting tween on {node.Name} for {propertyPath}", debug);

            float startValue = GetFloatValue(node, propertyPath);

            Log.Info($"[Tween] Start value: {startValue} ➔ Target: {targetValue} ({duration}s)", debug);

            steps.Add(new TweenStep(node, propertyPath, startValue, targetValue, duration));
        }
        catch (Exception ex)
        {
            Log.Error($"[Tween] Error starting tween: {ex}");
            Active = false;
        }
    }

    public void Update(float delta)
    {
        if (!Active || Stopped)
        {
            return;
        }

        foreach (TweenStep step in steps.ToList())
        {
            step.Elapsed += delta;
            float t = Math.Clamp(step.Elapsed / step.Duration, 0, 1);
            float currentValue = step.StartValue + (step.EndValue - step.StartValue) * t;

            Log.Info($"[Tween] Updating {step.Node.Name}.{step.PropertyPath} {currentValue:0.00} ({t:P0})", debug);

            SetFloatValueDirect(step.Node, step.PropertyPath, currentValue);

            if (step.Elapsed >= step.Duration)
            {
                Log.Info($"[Tween] Completed {step.Node.Name}.{step.PropertyPath}", debug);
                steps.Remove(step);
            }
        }

        if (steps.Count == 0)
        {
            Log.Info("[Tween] All steps completed", debug);
            Active = false;
        }
    }

    public bool ShouldProcess(bool treePaused)
    {
        var effectiveMode = processMode == Node.ProcessMode.Inherit
            ? GetEffectiveProcessMode(creatorNode)
            : processMode;

        return effectiveMode switch
        {
            Node.ProcessMode.Disabled => false,
            Node.ProcessMode.Always => true,
            Node.ProcessMode.Pausable => !treePaused,
            Node.ProcessMode.WhenPaused => treePaused,
            _ => false
        };
    }

    private static Node.ProcessMode GetEffectiveProcessMode(Node node)
    {
        Node? current = node;

        while (current != null)
        {
            if (current.ProcessingMode != Node.ProcessMode.Inherit)
            {
                return current.ProcessingMode;
            }

            current = current.Parent;
        }

        return Node.ProcessMode.Pausable;
    }

    private static float GetFloatValue(Node node, string propertyPath)
    {
        object? current = node;

        foreach (string part in propertyPath.Split('/'))
        {
            if (current is null)
            {
                throw new InvalidOperationException(
                    $"Intermediate value is null in path '{propertyPath}' on node {node.Name}");
            }

            Type type = current.GetType();
            PropertyInfo? property = type.GetProperty(part);
            FieldInfo? field = type.GetField(part);

            MemberInfo? member = property ?? (MemberInfo?)field
                ?? throw new ArgumentException($"Property or field '{part}' not found in {type.Name}");

            current = member is PropertyInfo prop
                ? prop.GetValue(current)
                : ((FieldInfo)member).GetValue(current);
        }

        return current is not null
            ? (float)current
            : throw new InvalidOperationException($"Value for path '{propertyPath}' is null on node {node.Name}");
    }

    private static void SetFloatValueDirect(Node node, string propertyPath, float value)
    {
        string[] parts = propertyPath.Split('/');
        object? current = node;

        for (int i = 0; i < parts.Length - 1; i++)
        {
            if (current is null)
            {
                throw new InvalidOperationException(
                    $"Intermediate value is null in path '{propertyPath}' on node {node.Name}");
            }

            Type type = current.GetType();
            PropertyInfo? property = type.GetProperty(parts[i]);
            FieldInfo? field = type.GetField(parts[i]);

            MemberInfo? member = property ?? (MemberInfo?)field
                ?? throw new ArgumentException($"Property or field '{parts[i]}' not found in {type.Name}");

            current = member is PropertyInfo prop
                ? prop.GetValue(current)
                : ((FieldInfo)member).GetValue(current);
        }

        if (current is null)
        {
            throw new InvalidOperationException(
                $"Final target is null in path '{propertyPath}' on node {node.Name}");
        }

        Type finalType = current.GetType();
        string finalPart = parts[^1];
        PropertyInfo? finalProperty = finalType.GetProperty(finalPart);
        FieldInfo? finalField = finalType.GetField(finalPart);

        MemberInfo finalMember = finalProperty ?? (MemberInfo?)finalField
            ?? throw new ArgumentException($"Property or field '{finalPart}' not found in {finalType.Name}");

        if (finalMember is PropertyInfo targetProp)
        {
            targetProp.SetValue(current, value);
        }
        else if (finalMember is FieldInfo targetField)
        {
            targetField.SetValue(current, value);
        }
    }

    private record TweenStep(Node Node, string PropertyPath, float StartValue, float EndValue, float Duration)
    {
        public float Elapsed { get; set; }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\VerticalAlignment.cs">
namespace Cherris;

public enum VAlignment
{
    Top,
    Center,
    Bottom,
    None
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\VisualItem.cs">
using SharpGen.Runtime;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;
using DW = Vortice.DirectWrite;

namespace Cherris;

public abstract class VisualItem : Node
{
    private bool fieldVisible = true;
    private int fieldLayer = 0;


    public bool Visible
    {
        get => fieldVisible;
        set
        {
            if (fieldVisible == value)
            {
                return;
            }

            fieldVisible = value;
            VisibleChanged?.Invoke(this, fieldVisible);
        }
    }

    public int Layer
    {
        get => fieldLayer;
        set
        {
            if (fieldLayer == value)
            {
                return;
            }

            fieldLayer = value;
            LayerChanged?.Invoke(this, fieldLayer);
        }
    }

    public delegate void VisibleEvent(VisualItem sender, bool visible);
    public delegate void LayerEvent(VisualItem sender, int layer);

    public event VisibleEvent? VisibleChanged;
    public event LayerEvent? LayerChanged;

    public virtual void Draw(DrawingContext context) { }


    protected void DrawStyledRectangle(DrawingContext context, Rect bounds, BoxStyle style)
    {
        if (context.OwnerWindow is null || context.RenderTarget is null || style is null || bounds.Width <= 0 || bounds.Height <= 0)
        {
            return;
        }

        try
        {
            DrawBoxStyleHelper(context, bounds, style);
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
        {
            Log.Warning("Recreate target detected in DrawStyledRectangle.");
        }
        catch (Exception ex)
        {
            Log.Error($"Error drawing styled rectangle: {ex.Message}");
        }
    }

    protected void DrawFormattedText(DrawingContext context, string text, Rect layoutRect, ButtonStyle style, HAlignment hAlignment, VAlignment vAlignment)
    {
        if (string.IsNullOrEmpty(text) || context.OwnerWindow is null || context.RenderTarget is null || style is null || layoutRect.Width <= 0 || layoutRect.Height <= 0)
        {
            return;
        }

        ID2D1SolidColorBrush? textBrush = context.OwnerWindow.GetOrCreateBrush(style.FontColor);
        IDWriteTextFormat? textFormat = context.OwnerWindow.GetOrCreateTextFormat(style);

        if (textBrush is null || textFormat is null)
        {

            return;
        }

        try
        {
            textFormat.TextAlignment = hAlignment switch
            {
                HAlignment.Left => DW.TextAlignment.Leading,
                HAlignment.Center => DW.TextAlignment.Center,
                HAlignment.Right => DW.TextAlignment.Trailing,
                _ => DW.TextAlignment.Leading
            };
            textFormat.ParagraphAlignment = vAlignment switch
            {
                VAlignment.Top => DW.ParagraphAlignment.Near,
                VAlignment.Center => DW.ParagraphAlignment.Center,
                VAlignment.Bottom => DW.ParagraphAlignment.Far,
                _ => DW.ParagraphAlignment.Near
            };

            context.RenderTarget.DrawText(
                text,
                textFormat,
                layoutRect,
                textBrush,
                D2D.DrawTextOptions.Clip
            );
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
        {
            Log.Warning("Recreate target detected in DrawFormattedText.");


        }
        catch (Exception ex)
        {
            Log.Error($"Error drawing formatted text '{text}': {ex.Message}");
        }
    }


    private static void DrawBoxStyleHelper(DrawingContext context, Rect bounds, BoxStyle style)
    {
        ID2D1HwndRenderTarget? renderTarget = context.RenderTarget;
        Direct2DAppWindow? ownerWindow = context.OwnerWindow;
        if (renderTarget is null || ownerWindow is null || style is null || bounds.Width <= 0 || bounds.Height <= 0)
        {
            return;
        }

        ID2D1SolidColorBrush? fillBrush = ownerWindow.GetOrCreateBrush(style.FillColor);
        ID2D1SolidColorBrush? borderBrush = ownerWindow.GetOrCreateBrush(style.BorderColor);

        float borderTop = Math.Max(0f, style.BorderLengthTop);
        float borderRight = Math.Max(0f, style.BorderLengthRight);
        float borderBottom = Math.Max(0f, style.BorderLengthBottom);
        float borderLeft = Math.Max(0f, style.BorderLengthLeft);

        bool hasVisibleFill = style.FillColor.A > 0 && fillBrush is not null;
        bool hasVisibleBorder = style.BorderColor.A > 0 && borderBrush is not null && (borderTop > 0 || borderRight > 0 || borderBottom > 0 || borderLeft > 0);

        if (!hasVisibleFill && !hasVisibleBorder) return;

        if (style.Roundness > 0.0f)
        {
            float maxRadius = Math.Min(bounds.Width * 0.5f, bounds.Height * 0.5f);
            float radius = Math.Max(0f, maxRadius * float.Clamp(style.Roundness, 0.0f, 1.0f));

            if (float.IsFinite(radius) && radius >= 0)
            {
                if (hasVisibleBorder && borderBrush is not null)
                {
                    System.Drawing.RectangleF outerRectF = new(bounds.X, bounds.Y, bounds.Width, bounds.Height);
                    RoundedRectangle outerRoundedRect = new(outerRectF, radius, radius);
                    renderTarget.FillRoundedRectangle(outerRoundedRect, borderBrush);
                }

                if (hasVisibleFill && fillBrush is not null)
                {
                    float fillX = bounds.X + borderLeft;
                    float fillY = bounds.Y + borderTop;
                    float fillWidth = Math.Max(0f, bounds.Width - borderLeft - borderRight);
                    float fillHeight = Math.Max(0f, bounds.Height - borderTop - borderBottom);

                    if (fillWidth > 0 && fillHeight > 0)
                    {
                        float avgBorderX = (borderLeft + borderRight) * 0.5f;
                        float avgBorderY = (borderTop + borderBottom) * 0.5f;
                        float innerRadiusX = Math.Max(0f, radius - avgBorderX);
                        float innerRadiusY = Math.Max(0f, radius - avgBorderY);

                        System.Drawing.RectangleF fillRectF = new(fillX, fillY, fillWidth, fillHeight);
                        RoundedRectangle fillRoundedRect = new(fillRectF, innerRadiusX, innerRadiusY);
                        renderTarget.FillRoundedRectangle(fillRoundedRect, fillBrush);
                    }
                    else if (!hasVisibleBorder)
                    {
                        System.Drawing.RectangleF outerRectF = new(bounds.X, bounds.Y, bounds.Width, bounds.Height);
                        RoundedRectangle outerRoundedRect = new(outerRectF, radius, radius);
                        renderTarget.FillRoundedRectangle(outerRoundedRect, fillBrush);
                    }
                }
                return;
            }
        }

        if (hasVisibleBorder && borderBrush is not null)
        {
            renderTarget.FillRectangle(bounds, borderBrush);
        }

        if (hasVisibleFill && fillBrush is not null)
        {
            float fillX = bounds.X + borderLeft;
            float fillY = bounds.Y + borderTop;
            float fillWidth = Math.Max(0f, bounds.Width - borderLeft - borderRight);
            float fillHeight = Math.Max(0f, bounds.Height - borderTop - borderBottom);

            if (fillWidth > 0 && fillHeight > 0)
            {
                renderTarget.FillRectangle(new Rect(fillX, fillY, fillWidth, fillHeight), fillBrush);
            }
            else if (!hasVisibleBorder)
            {

                renderTarget.FillRectangle(bounds, fillBrush);
            }
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Win32Window.cs">
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace Cherris;

public abstract class Win32Window : IDisposable
{
    private readonly string _windowClassName;
    private readonly string _windowTitle;
    private readonly int _initialWidth;
    private readonly int _initialHeight;
    private IntPtr _hwnd = IntPtr.Zero;
    private IntPtr _hInstance = IntPtr.Zero;
    private NativeMethods.WndProc _wndProcDelegate;
    private bool _isDisposed = false;
    private static readonly HashSet<string> RegisteredClassNames = new HashSet<string>();
    private GCHandle _gcHandle;

    public IntPtr Handle => _hwnd;
    public string Title => _windowTitle;
    public int Width { get; protected set; }
    public int Height { get; protected set; }
    public bool IsOpen { get; private set; } = false;
    public SystemBackdropType BackdropType { get; set; } = SystemBackdropType.None;
    public bool VSyncEnabled { get; set; } = true;

    protected Win32Window(string title, int width, int height, string className = null)
    {
        _windowTitle = title ?? "Win32 Window";
        _initialWidth = width > 0 ? width : 800;
        _initialHeight = height > 0 ? height : 600;
        Width = _initialWidth;
        Height = _initialHeight;
        _windowClassName = className ?? ("Win32Window_" + Guid.NewGuid().ToString("N"));
        _wndProcDelegate = WindowProcedure;
    }

    public virtual bool TryCreateWindow(IntPtr ownerHwnd = default, uint? styleOverride = null)
    {
        if (_hwnd != IntPtr.Zero)
        {
            Log.Warning("Window handle already exists. Creation skipped.");
            return true;
        }

        _hInstance = NativeMethods.GetModuleHandle(null);
        if (_hInstance == IntPtr.Zero)
        {
            _hInstance = Process.GetCurrentProcess().Handle;
        }

        lock (RegisteredClassNames)
        {
            if (!RegisteredClassNames.Contains(_windowClassName))
            {
                var wndClass = new NativeMethods.WNDCLASSEX
                {
                    cbSize = Marshal.SizeOf(typeof(NativeMethods.WNDCLASSEX)),
                    style = NativeMethods.CS_HREDRAW | NativeMethods.CS_VREDRAW | NativeMethods.CS_OWNDC,
                    lpfnWndProc = _wndProcDelegate,
                    cbClsExtra = 0,
                    cbWndExtra = 0,
                    hInstance = _hInstance,
                    hIcon = NativeMethods.LoadIcon(IntPtr.Zero, (IntPtr)NativeMethods.IDI_APPLICATION),
                    hCursor = NativeMethods.LoadCursor(IntPtr.Zero, NativeMethods.IDC_ARROW),
                    hbrBackground = IntPtr.Zero,
                    lpszMenuName = null,
                    lpszClassName = _windowClassName,
                    hIconSm = NativeMethods.LoadIcon(IntPtr.Zero, (IntPtr)NativeMethods.IDI_APPLICATION)
                };

                if (NativeMethods.RegisterClassEx(ref wndClass) == 0)
                {
                    Log.Error($"RegisterClassEx failed: {Marshal.GetLastWin32Error()}");
                    return false;
                }
                RegisteredClassNames.Add(_windowClassName);
                Log.Info($"Class '{_windowClassName}' registered.");
            }
        }

        _gcHandle = GCHandle.Alloc(this);

        uint windowStyle = styleOverride ?? NativeMethods.WS_OVERLAPPEDWINDOW;

        _hwnd = NativeMethods.CreateWindowEx(
            0,
            _windowClassName,
            _windowTitle,
            windowStyle,
            NativeMethods.CW_USEDEFAULT, NativeMethods.CW_USEDEFAULT,
            _initialWidth, _initialHeight,
            ownerHwnd,
            IntPtr.Zero,
            _hInstance,
            GCHandle.ToIntPtr(_gcHandle));

        if (_hwnd == IntPtr.Zero)
        {
            Log.Error($"CreateWindowEx failed: {Marshal.GetLastWin32Error()}");
            if (_gcHandle.IsAllocated) _gcHandle.Free();
            return false;
        }

        Log.Info($"Window '{_windowTitle}' created with HWND: {_hwnd}");
        IsOpen = true;

        return true;
    }

    protected virtual NativeMethods.DWMSBT GetSystemBackdropType()
    {
        return BackdropType switch
        {
            SystemBackdropType.Mica => NativeMethods.DWMSBT.DWMSBT_MAINWINDOW,
            SystemBackdropType.Acrylic => NativeMethods.DWMSBT.DWMSBT_TRANSIENTWINDOW,
            SystemBackdropType.MicaAlt => NativeMethods.DWMSBT.DWMSBT_TABBEDWINDOW,
            SystemBackdropType.None => NativeMethods.DWMSBT.DWMSBT_NONE,
            _ => NativeMethods.DWMSBT.DWMSBT_AUTO
        };
    }

    public void ApplySystemBackdrop()
    {
        if (_hwnd == IntPtr.Zero || !IsOpen) return;

        var backdropTypeEnum = GetSystemBackdropType();
        if (backdropTypeEnum == NativeMethods.DWMSBT.DWMSBT_NONE)
        {
            Log.Info($"Skipping backdrop application for '{Title}' (Type: None).");
            return;
        }

        var osVersion = Environment.OSVersion.Version;
        int requiredBuild = 22621;

        if (osVersion.Major < 10 || (osVersion.Major == 10 && osVersion.Build < requiredBuild))
        {
            Log.Warning($"System backdrop type {BackdropType} ({backdropTypeEnum}) requires Windows 11 Build {requiredBuild} or later. Current: {osVersion}");
            return;
        }

        try
        {
            int backdropTypeValue = (int)backdropTypeEnum;
            int result = NativeMethods.DwmSetWindowAttribute(
                _hwnd,
                NativeMethods.DWMWINDOWATTRIBUTE.DWMWA_SYSTEMBACKDROP_TYPE,
                ref backdropTypeValue,
                sizeof(int));

            if (result != 0)
            {
                Log.Error($"DwmSetWindowAttribute failed for {NativeMethods.DWMWINDOWATTRIBUTE.DWMWA_SYSTEMBACKDROP_TYPE} with HRESULT: 0x{result:X8} on HWND {_hwnd} ('{_windowTitle}').");
                return;
            }
            Log.Info($"Applied system backdrop type {BackdropType} ({backdropTypeEnum}) to HWND {_hwnd} ('{_windowTitle}').");

            int useDarkMode = 1;
            result = NativeMethods.DwmSetWindowAttribute(
                _hwnd,
                NativeMethods.DWMWINDOWATTRIBUTE.DWMWA_USE_IMMERSIVE_DARK_MODE,
                ref useDarkMode,
                sizeof(int));

            if (result != 0)
            {
                Log.Warning($"DwmSetWindowAttribute failed for {NativeMethods.DWMWINDOWATTRIBUTE.DWMWA_USE_IMMERSIVE_DARK_MODE} with HRESULT: 0x{result:X8} on HWND {_hwnd} ('{_windowTitle}'). This might be expected on some builds.");
            }
            else
            {
                Log.Info($"Applied {NativeMethods.DWMWINDOWATTRIBUTE.DWMWA_USE_IMMERSIVE_DARK_MODE}=TRUE to HWND {_hwnd} ('{_windowTitle}').");
            }
        }
        catch (Exception ex)
        {
            Log.Error($"Exception applying system backdrop/theme attributes to HWND {_hwnd} ('{_windowTitle}'): {ex.Message}");
        }
    }

    public virtual void ShowWindow()
    {
        if (_hwnd != IntPtr.Zero && IsOpen)
        {
            NativeMethods.ShowWindow(_hwnd, NativeMethods.SW_SHOWNORMAL);
            NativeMethods.UpdateWindow(_hwnd);
        }
        else
        {
            Log.Warning($"Cannot show window '{Title}': Handle is zero or window is not open.");
        }
    }

    public bool InitializeWindowAndGraphics()
    {
        if (_hwnd == IntPtr.Zero || !IsOpen)
        {
            Log.Error($"Cannot initialize '{Title}': Window handle is invalid or window is closed.");
            return false;
        }

        ApplySystemBackdrop();

        if (!Initialize())
        {
            Log.Error($"Custom initialization failed for '{Title}'.");
            return false;
        }

        return true;
    }

    private static IntPtr WindowProcedure(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        Win32Window? window = null;

        if (msg == NativeMethods.WM_NCCREATE)
        {
            try
            {
                var cs = Marshal.PtrToStructure<NativeMethods.CREATESTRUCT>(lParam);
                var handle = GCHandle.FromIntPtr(cs.lpCreateParams);
                window = handle.Target as Win32Window;
                if (window != null)
                {
                    NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, GCHandle.ToIntPtr(handle));
                }
                else
                {
                    Log.Warning($"WM_NCCREATE: Failed to get window instance from GCHandle for HWND {hWnd}");
                }
            }
            catch (Exception ex)
            {
                Log.Error($"Error during WM_NCCREATE: {ex}");
            }
        }
        else
        {
            IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA);
            if (ptr != IntPtr.Zero)
            {
                try
                {
                    var handle = GCHandle.FromIntPtr(ptr);
                    if (handle.IsAllocated && handle.Target != null)
                    {
                        window = handle.Target as Win32Window;
                    }
                }
                catch (InvalidOperationException)
                {
                    NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, IntPtr.Zero);
                }
                catch (Exception ex)
                {
                    Log.Error($"Error retrieving GCHandle: {ex}");
                }
            }
        }

        if (window != null)
        {
            try
            {
                return window.HandleMessage(hWnd, msg, wParam, lParam);
            }
            catch (Exception ex)
            {
                Log.Error($"Error handling message {msg} for HWND {hWnd} ('{window.Title}'): {ex}");
            }
        }

        return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
    }

    protected virtual IntPtr HandleMessage(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        int xPos = NativeMethods.GET_X_LPARAM(lParam);
        int yPos = NativeMethods.GET_Y_LPARAM(lParam);

        switch (msg)
        {
            case NativeMethods.WM_PAINT:
                RenderFrame();
                NativeMethods.ValidateRect(hWnd, IntPtr.Zero);
                return IntPtr.Zero;

            case NativeMethods.WM_SIZE:
                Width = NativeMethods.LOWORD(lParam);
                Height = NativeMethods.HIWORD(lParam);
                OnSize(Width, Height);
                return IntPtr.Zero;

            case NativeMethods.WM_MOUSEMOVE:
                OnMouseMove(xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_LBUTTONDOWN:
                OnMouseDown(MouseButton.Left, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_LBUTTONUP:
                OnMouseUp(MouseButton.Left, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_RBUTTONDOWN:
                OnMouseDown(MouseButton.Right, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_RBUTTONUP:
                OnMouseUp(MouseButton.Right, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_MBUTTONDOWN:
                OnMouseDown(MouseButton.Middle, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_MBUTTONUP:
                OnMouseUp(MouseButton.Middle, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_XBUTTONDOWN:
                int xButton1 = NativeMethods.GET_XBUTTON_WPARAM(wParam);
                OnMouseDown(xButton1 == NativeMethods.XBUTTON1 ? MouseButton.XButton1 : MouseButton.XButton2, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_XBUTTONUP:
                int xButton2 = NativeMethods.GET_XBUTTON_WPARAM(wParam);
                OnMouseUp(xButton2 == NativeMethods.XBUTTON1 ? MouseButton.XButton1 : MouseButton.XButton2, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_MOUSEWHEEL:
                short wheelDelta = NativeMethods.GET_WHEEL_DELTA_WPARAM(wParam);
                OnMouseWheel(wheelDelta);
                return IntPtr.Zero;

            case NativeMethods.WM_KEYDOWN:
            case NativeMethods.WM_SYSKEYDOWN:
                int vkCodeDown = (int)wParam;
                OnKeyDown(vkCodeDown);

                if (vkCodeDown == NativeMethods.VK_ESCAPE && !IsKeyDownHandled(vkCodeDown))
                {
                    Close();
                }
                return IntPtr.Zero;

            case NativeMethods.WM_KEYUP:
            case NativeMethods.WM_SYSKEYUP:
                int vkCodeUp = (int)wParam;
                OnKeyUp(vkCodeUp);
                return IntPtr.Zero;

            case NativeMethods.WM_DWMCOMPOSITIONCHANGED:
                Log.Info($"WM_DWMCOMPOSITIONCHANGED received for {hWnd} ('{Title}'). Reapplying backdrop.");
                ApplySystemBackdrop();
                break;

            case NativeMethods.WM_CLOSE:
                if (OnClose())
                {
                    NativeMethods.DestroyWindow(hWnd);
                }
                return IntPtr.Zero;

            case NativeMethods.WM_DESTROY:
                Log.Info($"WM_DESTROY for {hWnd} ('{Title}').");
                OnDestroy();

                if (this is MainAppWindow)
                {
                    Log.Info("Main window destroyed, posting quit message.");
                    NativeMethods.PostQuitMessage(0);
                }
                else if (this is SecondaryWindow secWin)
                {
                    ApplicationServer.Instance.UnregisterSecondaryWindow(secWin);
                }
                return IntPtr.Zero;

            case NativeMethods.WM_NCDESTROY:
                Log.Info($"WM_NCDESTROY: Releasing GCHandle for {hWnd} ('{Title}').");
                IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA);
                if (ptr != IntPtr.Zero)
                {
                    try
                    {
                        var handle = GCHandle.FromIntPtr(ptr);
                        if (handle.IsAllocated)
                        {
                            handle.Free();
                        }
                    }
                    catch (Exception ex)
                    {
                        Log.Error($"Error freeing GCHandle on NCDESTROY: {ex.Message}");
                    }
                    NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, IntPtr.Zero);
                }

                if (_gcHandle.IsAllocated && GCHandle.ToIntPtr(_gcHandle) == ptr)
                {
                    _gcHandle = default;
                }
                _hwnd = IntPtr.Zero;
                IsOpen = false;
                break;
        }

        return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
    }

    public void Close()
    {
        if (_hwnd != IntPtr.Zero && IsOpen)
        {
            Log.Info($"Programmatically closing window {_hwnd} ('{Title}').");
            NativeMethods.PostMessage(_hwnd, NativeMethods.WM_CLOSE, IntPtr.Zero, IntPtr.Zero);
        }
    }

    public void Invalidate()
    {
        if (_hwnd != IntPtr.Zero && IsOpen)
        {
            NativeMethods.InvalidateRect(_hwnd, IntPtr.Zero, false);
        }
    }

    protected abstract bool Initialize();
    public abstract void RenderFrame();
    protected virtual void OnSize(int width, int height) { }
    protected virtual void OnMouseDown(MouseButton button, int x, int y) { }
    protected virtual void OnMouseUp(MouseButton button, int x, int y) { }
    protected virtual void OnMouseMove(int x, int y) { }
    protected virtual void OnKeyDown(int virtualKeyCode) { }
    protected virtual void OnKeyUp(int virtualKeyCode) { }
    protected virtual void OnMouseWheel(short delta) { }
    protected virtual bool IsKeyDownHandled(int virtualKeyCode) { return false; }
    protected virtual bool OnClose() { return true; }
    protected virtual void OnDestroy() { }
    protected abstract void Cleanup();

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!_isDisposed)
        {
            if (disposing)
            {
                Log.Info($"Disposing Win32Window '{Title}' (managed)...");
                Cleanup();
            }

            Log.Info($"Disposing Win32Window '{Title}' (unmanaged)...");
            if (_hwnd != IntPtr.Zero)
            {
                Log.Info($"Requesting destroy for window {_hwnd} ('{Title}') during Dispose...");
                NativeMethods.DestroyWindow(_hwnd);
            }
            else
            {
                if (_gcHandle.IsAllocated)
                {
                    Log.Warning($"Freeing potentially dangling GCHandle for '{Title}' during Dispose (window handle was already zero)...");
                    try { _gcHandle.Free(); } catch (Exception ex) { Log.Error($"Error freeing GCHandle: {ex.Message}"); }
                }
            }

            _isDisposed = true;
            IsOpen = false;
            Log.Info($"Win32Window '{Title}' dispose initiated.");
        }
    }

    ~Win32Window()
    {
        Log.Warning($"Win32Window Finalizer called for '{Title}'! Ensure Dispose() was called.");
        Dispose(disposing: false);
    }
}

public enum MouseButton { Left, Right, Middle, XButton1, XButton2 }
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\AudioPlayer.cs">
namespace Cherris;

public class AudioPlayer : Node
{
    public string Audio { get; set; } = string.Empty;
    public bool AutoPlay { get; set; } = false;
    public string Bus { get; set; } = "Master";
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\Camera.cs">
using Raylib_cs;

namespace Cherris;

public class Camera : Node2D
{
    public float Zoom { get; set; } = 1;

    public void SetAsActive()
    {
        RenderServer.Instance.SetCamera(this);
    }

    public static implicit operator Camera2D(Camera camera)
    {
        Vector2 windowSize = camera.GetWindowSizeV2();

        return new()
        {
            Target = camera.GlobalPosition,
            Offset = windowSize / 2,
            Zoom = camera.Zoom,
        };
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\Clickable.cs">
namespace Cherris;

public abstract class Clickable : Node2D
{
    public bool OnTopLeft = false;
    public bool OnTopRight = false;

    public Clickable()
    {
        ClickServer.Instance.Register(this);
    }

    public override void Free()
    {
        ClickServer.Instance.Unregister(this);
        base.Free();
    }

    public abstract bool IsMouseOver();
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\ClickableRectangle.cs">
namespace Cherris;

public abstract class ClickableRectangle : Clickable
{
    public override bool IsMouseOver()
    {
        var owningWindowNode = GetOwningWindowNode();
        Vector2 mousePosition;

        if (owningWindowNode != null)
        {
            mousePosition = owningWindowNode.LocalMousePosition;
        }
        else
        {
            var mainAppWindow = ApplicationServer.Instance.GetMainAppWindow();
            if (mainAppWindow != null)
            {
                mousePosition = mainAppWindow.GetLocalMousePosition();
            }
            else
            {
                Log.Warning($"ClickableRectangle '{Name}': MainAppWindow not found for mouse position query. Using global Input.MousePosition as fallback.");
                mousePosition = Input.MousePosition;
            }
        }

        var globalPos = GlobalPosition;
        var origin = Origin;
        var size = ScaledSize;

        float left = globalPos.X - origin.X;
        float top = globalPos.Y - origin.Y;
        float right = left + size.X;
        float bottom = top + size.Y;

        bool isMouseOver =
            mousePosition.X >= left &&
            mousePosition.X < right &&
            mousePosition.Y >= top &&
            mousePosition.Y < bottom;

        return isMouseOver;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\Control.cs">
namespace Cherris;

public class Control : ClickableRectangle
{
    public bool Focusable { get; set; } = true;
    public bool Navigable { get; set; } = true;
    public bool RapidNavigation { get; set; } = true;
    public string? FocusNeighborTop { get; set; }
    public string? FocusNeighborBottom { get; set; }
    public string? FocusNeighborLeft { get; set; }
    public string? FocusNeighborRight { get; set; }
    public string? FocusNeighborNext { get; set; }
    public string? FocusNeighborPrevious { get; set; }
    public string AudioBus { get; set; } = "Master";
    public Sound? FocusGainedSound { get; set; }

    private bool wasFocusedLastFrame = false;
    private readonly Dictionary<string, float> actionHoldTimes = [];
    private const float InitialDelay = 0.5f;
    private const float RepeatInterval = 0.1f;

    public bool Disabled
    {
        get;
        set
        {
            if (value == field)
            {
                return;
            }

            field = value;
            WasDisabled?.Invoke(this);
        }
    } = false;

    public bool Focused
    {
        get;
        set
        {
            if (field == value)
            {
                return;
            }
            field = value;
            FocusChanged?.Invoke(this);

            if (field)
            {
                FocusGained?.Invoke(this);

                if (FocusGainedSound is not null)
                {
                    FocusGainedSound?.Play(AudioBus);
                }
            }
        }
    } = false;

    public string ThemeFile
    {
        set
        {
            OnThemeFileChanged(value);
        }
    }

    public delegate void Event(Control control);
    public event Event? FocusChanged;
    public event Event? FocusGained;
    public event Event? WasDisabled;
    public event Event? ClickedOutside;

    public override void Process()
    {
        base.Process();

        if (Navigable && Focused && wasFocusedLastFrame)
        {
            HandleArrowNavigation();
        }

        UpdateFocusOnOutsideClicked();
        wasFocusedLastFrame = Focused;
    }

    private void HandleArrowNavigation()
    {
        var actions = new (string Action, string? Path)[]
        {
            ("UiLeft", FocusNeighborLeft),
            ("UiUp", FocusNeighborTop),
            ("UiRight", FocusNeighborRight),
            ("UiDown", FocusNeighborBottom),
            ("UiNext", FocusNeighborNext),
            ("UiPrevious", FocusNeighborPrevious)
        };

        foreach (var entry in actions)
        {
            if (string.IsNullOrEmpty(entry.Path)) continue;

            if (RapidNavigation)
            {
                if (Input.IsActionDown(entry.Action))
                {
                    if (!actionHoldTimes.ContainsKey(entry.Action))
                    {
                        actionHoldTimes[entry.Action] = 0f;
                    }

                    actionHoldTimes[entry.Action] += Time.Delta;
                    float holdTime = actionHoldTimes[entry.Action];

                    bool shouldNavigate = (holdTime <= Time.Delta + float.Epsilon) ||
                        (holdTime >= InitialDelay && (holdTime - InitialDelay) % RepeatInterval < Time.Delta);

                    if (shouldNavigate)
                    {
                        NavigateToControl(entry.Path, entry.Action, holdTime);
                    }
                }
                else
                {
                    actionHoldTimes[entry.Action] = 0f;
                }
            }
            else
            {
                if (Input.IsActionPressed(entry.Action))
                {
                    NavigateToControl(entry.Path, entry.Action, 0f);
                }
            }
        }
    }

    private void NavigateToControl(string controlPath, string action, float holdTime)
    {
        var neighbor = GetNodeOrNull<Control>(controlPath);

        if (neighbor is null)
        {
            Log.Error($"[Control] [{Name}] NavigateToControl: Could not find '{controlPath}'.");
            return;
        }

        if (neighbor.Disabled)
        {
            return;
        }

        if (RapidNavigation)
        {
            neighbor.actionHoldTimes[action] = holdTime;
        }

        neighbor.Focused = true;
        Focused = false;
    }

    private void UpdateFocusOnOutsideClicked()
    {
        if (!IsMouseOver() && Input.IsMouseButtonPressed(MouseButtonCode.Left))
        {
            Focused = false;
            ClickedOutside?.Invoke(this);
        }
    }

    protected virtual void HandleClickFocus()
    {
        if (Focusable && IsMouseOver())
        {
            Focused = true;
        }
    }

    protected virtual void OnThemeFileChanged(string themeFile) { }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\Node.cs">
using Spectre.Console;

namespace Cherris;

public class Node
{
    public enum ProcessMode
    {
        Inherit,
        Pausable,
        WhenPaused,
        Disabled,
        Always
    }

    public static Node RootNode => SceneTree.Instance.RootNode!;
    public static SceneTree Tree => SceneTree.Instance;

    public ProcessMode ProcessingMode = ProcessMode.Inherit;

    [HideFromInspector]
    public string Name { get; set; } = "";

    [HideFromInspector]
    public Node? Parent { get; set; } = null;

    [HideFromInspector]
    public List<Node> Children { get; set; } = [];

    [HideFromInspector]
    public bool Active
    {
        get;

        set
        {
            if (field == value)
            {
                return;
            }

            field = value;
            ActiveChanged?.Invoke(this, field);
        }
    } = true;

    [HideFromInspector]
    public string AbsolutePath
    {
        get
        {
            if (Parent is null)
            {
                return "/root/";
            }

            Stack<string> pathStack = new();
            Node? current = this;

            while (current is not null && current.Parent is not null)
            {
                pathStack.Push(current.Name);
                current = current.Parent;
            }

            return $"/root/{string.Join("/", pathStack)}";
        }
    }

    public delegate void ActiveEvent(Node sender, bool active);
    public delegate void ChildEvent(Node sender, Node child);
    public event ActiveEvent? ActiveChanged;
    public event ChildEvent? ChildAdded;

    public virtual void Make() { }

    public virtual void Start() { }

    public virtual void Ready() { }

    public virtual void Free()
    {
        List<Node> childrenToDestroy = new(Children);

        foreach (Node child in childrenToDestroy)
        {
            child.Free();
        }

        Parent?.Children.Remove(this);
    }

    public virtual void ProcessBegin() { }

    public virtual void Process() { }

    public virtual void ProcessEnd() { }

    public void PrintChildren()
    {
        Console.OutputEncoding = System.Text.Encoding.UTF8;

        string rootEmoji = NodeEmoji.GetEmojiForNodeType(this);
        Tree root = new($"{rootEmoji} [green]{Name}[/]");

        AddChildrenToTree(this, root);

        AnsiConsole.Write(root);
    }

    private static void AddChildrenToTree(Node node, IHasTreeNodes parentNode)
    {
        foreach (Node child in node.Children)
        {
            string childEmoji = NodeEmoji.GetEmojiForNodeType(child);
            TreeNode childNode = parentNode.AddNode($"{childEmoji} [blue]{child.Name}[/]");
            AddChildrenToTree(child, childNode);
        }
    }

    public virtual void Activate()
    {
        Active = true;

        foreach (Node child in Children)
        {
            child.Activate();
        }
    }

    public virtual void Deactivate()
    {
        Active = false;

        foreach (Node child in Children)
        {
            child.Deactivate();
        }
    }

    public T GetParent<T>() where T : Node
    {
        if (Parent is not null)
        {
            return (T)Parent;
        }

        return (T)this;
    }

    public T GetNode<T>(string path) where T : Node
    {
        if (string.IsNullOrEmpty(path))
        {
            throw new ArgumentException("Path cannot be null or empty.", nameof(path));
        }

        Node? currentNode;

        if (path.StartsWith("/root"))
        {
            path = path["/root".Length..];
            currentNode = SceneTree.Instance.RootNode;

            if (path.StartsWith('/'))
            {
                path = path.Substring(1);
            }

            if (!string.IsNullOrEmpty(path))
            {
                string[] nodeNames = path.Split('/');
                foreach (var name in nodeNames)
                {
                    if (name == "..")
                    {

                        currentNode = currentNode?.Parent;
                    }
                    else
                    {
                        currentNode = currentNode?.GetChild(name);
                    }

                    if (currentNode == null)
                    {
                        throw new InvalidOperationException($"Node '{name}' not found in the scene tree.");
                    }
                }
            }
        }
        else
        {
            currentNode = this;
            string[] nodeNames = path.Split('/');
            foreach (var name in nodeNames)
            {
                if (name == "..")
                {

                    currentNode = currentNode?.Parent;
                }
                else if (name != "")
                {
                    currentNode = currentNode?.GetChild(name);
                }

                if (currentNode == null)
                {
                    throw new InvalidOperationException($"Node '{name}' not found in the scene tree.");
                }
            }
        }

        return currentNode as T ?? 
            throw new InvalidOperationException("Node is not of the expected type.");
    }

    public T? GetNodeOrNull<T>(string path) where T : Node
    {
        if (string.IsNullOrEmpty(path))
        {
            return null;
        }

        Node? currentNode;

        if (path.StartsWith("/root"))
        {
            path = path.Substring("/root".Length);
            currentNode = SceneTree.Instance.RootNode;

            if (path.StartsWith("/"))
            {
                path = path.Substring(1);
            }

            if (!string.IsNullOrEmpty(path))
            {
                string[] nodeNames = path.Split('/');
                foreach (var name in nodeNames)
                {
                    if (name == "..")
                    {

                        currentNode = currentNode?.Parent;
                    }
                    else
                    {
                        currentNode = currentNode?.GetChildOrNull(name);
                    }

                    if (currentNode == null)
                    {
                        return null;
                    }
                }
            }
        }
        else
        {
            currentNode = this;
            string[] nodeNames = path.Split('/');
            foreach (var name in nodeNames)
            {
                if (name == "..")
                {

                    currentNode = currentNode?.Parent;
                }
                else if (name != "")
                {
                    currentNode = currentNode?.GetChildOrNull(name);
                }

                if (currentNode == null)
                {
                    return null;
                }
            }
        }

        return currentNode as T;
    }

    public T? GetChild<T>(string name) where T : Node
    {
        foreach (Node child in Children)
        {
            if (child.Name == name)
            {
                return (T)child;
            }
        }

        return null;
    }

    public T? GetChild<T>() where T : Node
    {
        foreach (Node child in Children)
        {
            if (child.GetType() == typeof(T))
            {
                return (T)child;
            }
        }

        return null;
    }

    public Node GetChild(string name)
    {
        foreach (Node child in Children)
        {
            if (child.Name == name)
            {
                return child;
            }
        }

        SceneTree.Instance.RootNode?.PrintChildren();

        throw new InvalidOperationException($"Child node with name '{name}' not found.");
    }

    public Node? GetChildOrNull(string name)
    {
        foreach (Node child in Children)
        {
            if (child.Name == name)
            {
                return child;
            }
        }

        return null;
    }

    public Node AddChild(Node node)
    {
        node.Parent = this;

        node.Make();

        Children.Add(node);
        ChildAdded?.Invoke(this, node);

        return node;
    }

    public Node AddChild(Node node, string name)
    {
        node.Parent = this;
        node.Name = name;

        node.Make();

        Children.Add(node);
        ChildAdded?.Invoke(this, node);

        return node;
    }

    public WindowNode? GetOwningWindowNode()
    {
        Node? current = this;
        while (current != null)
        {
            if (current is WindowNode windowNode)
            {
                return windowNode;
            }
            current = current.Parent;
        }
        return null;
    }

    public Win32Window? GetOwningWindow()
    {
        Node? current = this;
        while (current != null)
        {
            if (current is WindowNode windowNode)
            {
                return windowNode.GetWindowHandle();
            }
            current = current.Parent;
        }
        return ApplicationServer.Instance.GetMainAppWindow();
    }

    public Vector2 GetWindowSizeV2()
    {
        var window = GetOwningWindow();
        if (window != null)
        {
            return new Vector2(window.Width, window.Height);
        }
        return new Vector2(800, 600);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\Node2D.cs">
namespace Cherris;

public class Node2D : VisualItem
{
    public Vector2 Position { get; set; } = Vector2.Zero;
    public virtual float Rotation { get; set; } = 0;
    public OriginPreset OriginPreset { get; set; } = OriginPreset.Center;    public bool InheritScale { get; set; } = true;
    public HAlignment HAlignment { get; set; } = HAlignment.Center;
    public VAlignment VAlignment { get; set; } = VAlignment.Center;
    public AnchorPreset AnchorPreset { get; set; } = AnchorPreset.None;

    public float MarginLeft { get; set; } = 0f;
    public float MarginTop { get; set; } = 0f;
    public float MarginRight { get; set; } = 0f;
    public float MarginBottom { get; set; } = 0f;

    public float RelativeWidth { get; set; } = 0f;    public float RelativeHeight { get; set; } = 0f;
    public Vector2 ScaledSize => Size * Scale;

    public virtual Vector2 Size
    {
        get
        {
            float finalWidth;
            float finalHeight;
            Vector2 parentSizeForRelative = Vector2.Zero;
            if (RelativeWidth > 0f && RelativeWidth <= 1f)
            {
                if (parentSizeForRelative == Vector2.Zero)
                    parentSizeForRelative = (Parent is Node2D p) ? p.Size : GetWindowSizeV2();
                finalWidth = parentSizeForRelative.X * RelativeWidth;
            }
            else if (_explicitSize.X != 0f)
            {
                finalWidth = _explicitSize.X;
            }
            else
            {
                finalWidth = ComputeAutoSize().X;
            }
            if (RelativeHeight > 0f && RelativeHeight <= 1f)
            {
                if (parentSizeForRelative == Vector2.Zero)
                    parentSizeForRelative = (Parent is Node2D p) ? p.Size : GetWindowSizeV2();
                finalHeight = parentSizeForRelative.Y * RelativeHeight;
            }
            else if (_explicitSize.Y != 0f)
            {
                finalHeight = _explicitSize.Y;
            }
            else
            {
                finalHeight = ComputeAutoSize().Y;
            }

            return new Vector2(finalWidth, finalHeight);
        }
        set
        {
            if (_explicitSize == value) return;
            _explicitSize = value;
            SizeChanged?.Invoke(this, Size);
        }
    }

    public virtual Vector2 Scale
    {
        get => InheritScale && Parent is Node2D node2DParent ? node2DParent.Scale : fieldScale;        set;    } = new(1, 1);

    [HideFromInspector]
    public virtual Vector2 GlobalPosition
    {
        get
        {
            Vector2 parentGlobalTopLeft;
            Vector2 parentSize;

            if (Parent is Node2D parentNode)
            {
                parentGlobalTopLeft = parentNode.GlobalPosition - parentNode.Origin;
                parentSize = parentNode.Size;
            }
            else
            {
                parentGlobalTopLeft = Vector2.Zero;
                parentSize = GetWindowSizeV2();
            }

            float calculatedGlobalOriginX;
            float calculatedGlobalOriginY;

            if (AnchorPreset == AnchorPreset.None)
            {
                Vector2 parentOriginGlobal = (Parent is Node2D pNode) ? pNode.GlobalPosition : Vector2.Zero;
                calculatedGlobalOriginX = parentOriginGlobal.X + Position.X;
                calculatedGlobalOriginY = parentOriginGlobal.Y + Position.Y;
            }
            else
            {
                float targetGlobalAnchorX = AnchorPreset switch
                {
                    AnchorPreset.TopLeft or AnchorPreset.CenterLeft or AnchorPreset.BottomLeft
                        => parentGlobalTopLeft.X + MarginLeft,
                    AnchorPreset.TopCenter or AnchorPreset.Center or AnchorPreset.BottomCenter
                        => parentGlobalTopLeft.X + (parentSize.X * 0.5f) + MarginLeft - MarginRight,
                    _
                        => parentGlobalTopLeft.X + parentSize.X - MarginRight,
                };

                float targetGlobalAnchorY = AnchorPreset switch
                {
                    AnchorPreset.TopLeft or AnchorPreset.TopCenter or AnchorPreset.TopRight
                        => parentGlobalTopLeft.Y + MarginTop,
                    AnchorPreset.CenterLeft or AnchorPreset.Center or AnchorPreset.CenterRight
                        => parentGlobalTopLeft.Y + (parentSize.Y * 0.5f) + MarginTop - MarginBottom,
                    _
                        => parentGlobalTopLeft.Y + parentSize.Y - MarginBottom,
                };

                calculatedGlobalOriginX = targetGlobalAnchorX;
                calculatedGlobalOriginY = targetGlobalAnchorY;

                calculatedGlobalOriginX += Position.X;
                calculatedGlobalOriginY += Position.Y;
            }

            return new(calculatedGlobalOriginX, calculatedGlobalOriginY);
        }
    }

    public Vector2 Offset { get; set; }

    public Vector2 Origin
    {
        get
        {
            float x = HAlignment switch
            {
                HAlignment.Center => Size.X / 2f,
                HAlignment.Left => 0,
                HAlignment.Right => Size.X,
                HAlignment.None => 0,
                _ => 0
            };

            float y = VAlignment switch
            {
                VAlignment.Center => Size.Y / 2f,
                VAlignment.Top => 0,
                VAlignment.Bottom => Size.Y,
                VAlignment.None => 0,
                _ => 0
            };

            Vector2 alignmentOffset = new(x, y);
            return alignmentOffset + Offset;
        }
    }

    protected Vector2 _explicitSize = Vector2.Zero;
    private Vector2 fieldScale = new(1, 1);

    public event EventHandler<Vector2>? SizeChanged;

    protected virtual Vector2 ComputeAutoSize()
    {
        return Vector2.Zero;    }

    public void LookAt(Vector2 targetPosition)
    {
        Vector2 originPoint = GlobalPosition;
        Vector2 direction = targetPosition - originPoint;
        var angle = float.Atan2(direction.Y, direction.X) * 57.29578f;
        Rotation = angle;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\ParticleEmitter.cs">
namespace Cherris;

public class ParticleEmitter : Node2D
{

}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\TextureRectangle.cs">
namespace Cherris;

public class TextureRectangle : Node2D
{
    public string Texture { get; set; } = string.Empty;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\VideoPlayer.cs">
using System.Drawing;
using System.Runtime.InteropServices;
using System.Text;
using LibVLCSharp.Shared;
using SharpGen.Runtime;
using Vortice.Direct2D1;
using Vortice.DXGI;
using Vortice.Mathematics;

namespace Cherris;

public class VideoPlayer : Node2D, IDisposable
{
    private static bool _isLibVlcInitialized = false;
    private static readonly object _initLock = new();
    private static readonly object _frameLock = new();

    private LibVLC? _libVLC;
    private MediaPlayer? _mediaPlayer;
    private Media? _media;
    private bool _isDisposed = false;

    private ID2D1Bitmap? _videoBitmap;
    private byte[]? _latestFrameDataRaw;
    private uint _videoWidth = 0;
    private uint _videoHeight = 0;
    private bool _newFrameAvailable = false;
    private bool _formatConfigured = false;

    private uint _receivedChroma = 0;
    private uint _receivedPitch = 0;
    private uint _bufferSize = 0;

    private byte[]? _conversionBufferBGRA32;

    private static readonly uint FourCC_RV32 = CalculateFourCC("RV32");
    private static readonly uint FourCC_RV24 = CalculateFourCC("RV24");

    private MediaPlayer.LibVLCVideoFormatCb? _videoFormatCallbackDelegate;
    private MediaPlayer.LibVLCVideoLockCb? _videoLockCallbackDelegate;
    private MediaPlayer.LibVLCVideoUnlockCb? _videoUnlockCallbackDelegate;
    private MediaPlayer.LibVLCVideoDisplayCb? _videoDisplayCallbackDelegate;
    private MediaPlayer.LibVLCVideoCleanupCb? _videoCleanupCallbackDelegate;
    
    public bool AutoPlay { get; set; } = false;
    public bool IsPlaying => _mediaPlayer?.IsPlaying ?? false;
    public long DurationMilliseconds => _mediaPlayer?.Length ?? 0;
    public bool SuppressPositionRatioChangedEvent { get; set; } = false;

    public override Vector2 Size
    {
        get
        {
            lock (_frameLock)
            {
                return _videoWidth > 0 && _videoHeight > 0
                    ? new(_videoWidth, _videoHeight)
                    : base.Size;            }
        }
        set
        {
            base.Size = value;
        }
    }

    private bool _loop = false;
    public bool Loop
    {
        get => _loop;
        set
        {
            if (_loop == value) return;
            _loop = value;
        }
    }

    private float _volume = 100f;
    public float Volume
    {
        get => _volume;
        set
        {
            _volume = Math.Clamp(value, 0f, 100f);

            if (_mediaPlayer != null)
            {
                _mediaPlayer.Volume = (int)_volume;
            }
        }
    }

    public float PositionRatio
    {
        get => _mediaPlayer?.Position ?? 0f;

        set
        {
            if (_mediaPlayer is null)
            {
                return;
            }

            _mediaPlayer.Position = float.Clamp(value, 0f, 1f);
        }
    }

    private string _filePath = "";
    public string FilePath
    {
        get => _filePath;

        set
        {
            if (_filePath == value)
            {
                return;
            }

            _filePath = value;

            if (_mediaPlayer is not null && _libVLC is not null)
            {
                LoadMedia();
            }
            lock (_frameLock)
            {
                _videoBitmap?.Dispose();
                _videoBitmap = null;
                _videoWidth = 0;
                _videoHeight = 0;
                _receivedChroma = 0;                _receivedPitch = 0;
                _bufferSize = 0;
                _latestFrameDataRaw = null;
                _conversionBufferBGRA32 = null;
                _newFrameAvailable = false;
                _formatConfigured = false;
            }
        }
    }

    public float PlaybackSpeed
    {
        get;
        set
        {
            float newSpeed = float.Clamp(value, 0.25f, 4f);            
            if (float.Abs(field - newSpeed) <= float.Epsilon)            {
                return;
            }

            field = newSpeed;
            _mediaPlayer?.SetRate(PlaybackSpeed);
        }
    } = 1.0f;

    public event EventHandler? PlaybackStarted;
    public event EventHandler? PlaybackPaused;
    public event EventHandler? PlaybackStopped;
    public event EventHandler? PlaybackEnded;
    public event EventHandler<string>? PlaybackError;
    public event Action<float>? PositionRatioChanged;

    public override void Make()
    {
        base.Make();
        InitializeLibVLC();
    }

    public override void Ready()
    {
        base.Ready();

        if (!AutoPlay || _mediaPlayer == null || _media == null || _mediaPlayer.IsPlaying)
        {
            return;
        }

        Play();
    }

    public override void Free()
    {
        Dispose();
        base.Free();
    }

    public override void Draw(DrawingContext context)
    {
        if (!Visible || context.RenderTarget == null || _isDisposed) return;

        bool bitmapNeedsRecreation = false;
        bool frameNeedsProcessing = false;        uint currentWidth = 0;
        uint currentHeight = 0;
        uint currentChroma = 0;
        uint currentPitch = 0;
        bool isNewFrameAvailableInLock = false;
        lock (_frameLock)
        {
            currentWidth = _videoWidth;
            currentHeight = _videoHeight;
            currentChroma = _receivedChroma;            currentPitch = _receivedPitch;            isNewFrameAvailableInLock = _newFrameAvailable;
            if ((_videoBitmap == null || _videoBitmap.PixelSize.Width != currentWidth || _videoBitmap.PixelSize.Height != currentHeight)
                && currentWidth > 0 && currentHeight > 0)
            {
                bitmapNeedsRecreation = true;
            }
            if (isNewFrameAvailableInLock && _formatConfigured && _videoBitmap != null && _latestFrameDataRaw != null && currentChroma != 0)
            {
                if (_videoBitmap.PixelSize.Width == currentWidth && _videoBitmap.PixelSize.Height == currentHeight)
                {
                    frameNeedsProcessing = true;
                }
                else                {
                    Log.Warning($"Draw: Bitmap dimensions ({_videoBitmap?.PixelSize.Width}x{_videoBitmap?.PixelSize.Height}) mismatch current video dimensions ({currentWidth}x{currentHeight}). Forcing recreation.");

                    if (currentWidth > 0 && currentHeight > 0)
                    {
                        bitmapNeedsRecreation = true;                    }

                    frameNeedsProcessing = false;                }
            }
        }        if (bitmapNeedsRecreation)
        {
            ID2D1Bitmap? oldBitmap = null;
            lock (_frameLock) { oldBitmap = _videoBitmap; _videoBitmap = null; }
            oldBitmap?.Dispose();
            lock (_frameLock)
            {
                if (!_formatConfigured || _videoWidth == 0 || _videoHeight == 0)
                {
                    Log.Warning($"Draw: Cannot recreate bitmap. Format Configured: {_formatConfigured}, Dimensions: {_videoWidth}x{_videoHeight}."); return;
                }
            }

            try
            {
                var bitmapProperties = new BitmapProperties(new Vortice.DCommon.PixelFormat(Format.B8G8R8A8_UNorm, Vortice.DCommon.AlphaMode.Ignore));
                var newBitmap = context.RenderTarget.CreateBitmap(new SizeI((int)currentWidth, (int)currentHeight), bitmapProperties);

                lock (_frameLock) { _videoBitmap = newBitmap; }
                Log.Info($"Draw: BGRA32 Bitmap recreated successfully ({currentWidth}x{currentHeight}).");
                lock (_frameLock)
                {
                    if (_formatConfigured && isNewFrameAvailableInLock && _latestFrameDataRaw != null && currentChroma != 0 &&
                       _videoBitmap != null && _videoBitmap.PixelSize.Width == currentWidth && _videoBitmap.PixelSize.Height == currentHeight)
                    {
                        frameNeedsProcessing = true;                    }
                    else { frameNeedsProcessing = false; /*Log.Info("Draw: Frame processing not ready after bitmap recreation.");*/ }
                }
            }
            catch (SharpGenException sgex) when (sgex.ResultCode.Code == Vortice.Direct2D1.ResultCode.RecreateTarget.Code)
            { Log.Warning($"Draw: Render target needs recreation during Bitmap creation."); lock (_frameLock) { _videoBitmap = null; } return; }
            catch (Exception ex) { Log.Error($"Failed to create ID2D1Bitmap: {ex.Message}"); lock (_frameLock) { _videoBitmap = null; } return; }
        }
        if (frameNeedsProcessing)
        {
            byte[]? rawData = null;
            byte[]? bgraData = null;            ID2D1Bitmap? bitmapForCopy = null;
            uint widthForUpdate = 0;
            uint heightForUpdate = 0;
            uint chromaForUpdate = 0;
            uint pitchForUpdate = 0;            lock (_frameLock)
            {
                if (_formatConfigured && _videoBitmap != null && _latestFrameDataRaw != null && _newFrameAvailable && _receivedChroma != 0 &&
                    _videoBitmap.PixelSize.Width == currentWidth && _videoBitmap.PixelSize.Height == currentHeight)
                {
                    widthForUpdate = currentWidth;
                    heightForUpdate = currentHeight;
                    chromaForUpdate = _receivedChroma;                    pitchForUpdate = _receivedPitch;                    rawData = _latestFrameDataRaw;
                    bitmapForCopy = _videoBitmap;
                    uint bgraSize = widthForUpdate * heightForUpdate * 4;
                    if (_conversionBufferBGRA32 == null || _conversionBufferBGRA32.Length != bgraSize)
                    {
                        try { _conversionBufferBGRA32 = new byte[bgraSize]; }
                        catch (Exception ex) { Log.Error($"Failed to allocate BGRA buffer: {ex.Message}"); _conversionBufferBGRA32 = null; }
                    }
                    bgraData = _conversionBufferBGRA32;
                }
                else { /* Conditions no longer met */ rawData = null; bgraData = null; bitmapForCopy = null; }
            }
            bool processedSuccessfully = false;
            if (rawData != null && bgraData != null && bitmapForCopy != null && widthForUpdate > 0 && heightForUpdate > 0)
            {
                try
                {
                    if (chromaForUpdate == FourCC_RV32)                    {
                        uint expectedBgraPitch = widthForUpdate * 4;
                        if (pitchForUpdate == expectedBgraPitch)
                        {
                            bitmapForCopy.CopyFromMemory(new Rectangle(0, 0, (int)widthForUpdate, (int)heightForUpdate), rawData, pitchForUpdate);
                            processedSuccessfully = true;
                        }
                        else
                        {
                            Log.Warning($"RV32 pitch mismatch (Expected {expectedBgraPitch}, Got {pitchForUpdate}). Using intermediate buffer copy.");
                            CopyMemoryWithPitch(rawData, pitchForUpdate, bgraData, expectedBgraPitch, widthForUpdate * 4, heightForUpdate);
                            bitmapForCopy.CopyFromMemory(new Rectangle(0, 0, (int)widthForUpdate, (int)heightForUpdate), bgraData, expectedBgraPitch);
                            processedSuccessfully = true;
                        }
                    }
                    else
                    {
                        Log.Error($"Draw: Skipping frame processing. Unexpected video format received in buffer (Expected RV32): {FourCCToString(chromaForUpdate)} (0x{chromaForUpdate:X8})");
                    }

                    if (processedSuccessfully)
                    {
                        lock (_frameLock) { _newFrameAvailable = false; }
                    }

                }
                catch (SharpGenException sgex) when (sgex.ResultCode.Code == Vortice.Direct2D1.ResultCode.RecreateTarget.Code)
                { Log.Warning($"Draw: Render target needs recreation during CopyFromMemory."); lock (_frameLock) { _videoBitmap?.Dispose(); _videoBitmap = null; _newFrameAvailable = false; } return; }
                catch (Exception ex) { Log.Error($"Failed during frame processing/copy: {ex.Message}"); lock (_frameLock) { _videoBitmap?.Dispose(); _videoBitmap = null; _newFrameAvailable = false; } }
            }
            else if (frameNeedsProcessing) { Log.Warning($"Draw: Skipped frame processing. HasBitmap={bitmapForCopy != null}, HasRawData={rawData != null}, HasBGRAData={bgraData != null}, Chroma={chromaForUpdate}, W={widthForUpdate}, H={heightForUpdate}"); }
        }
        ID2D1Bitmap? bitmapToDraw = null;
        lock (_frameLock) { bitmapToDraw = _videoBitmap; }

        if (bitmapToDraw != null && currentWidth > 0 && currentHeight > 0)        {
            try
            {
                var position = GlobalPosition - Origin;
                var size = ScaledSize;
                var destRect = new RectangleF(position.X, position.Y, size.X, size.Y);
                var sourceRect = new RectangleF(0, 0, bitmapToDraw.PixelSize.Width, bitmapToDraw.PixelSize.Height);
                context.RenderTarget.DrawBitmap(bitmapToDraw, destRect, 1.0f, BitmapInterpolationMode.Linear, sourceRect);
            }
            catch (SharpGenException sgex) when (sgex.ResultCode.Code == Vortice.Direct2D1.ResultCode.RecreateTarget.Code)
            { Log.Warning($"Draw: Render target needs recreation during DrawBitmap."); lock (_frameLock) { _videoBitmap?.Dispose(); _videoBitmap = null; } return; }
            catch (ObjectDisposedException) { Log.Warning($"Draw: Bitmap was disposed before DrawBitmap."); lock (_frameLock) { _videoBitmap = null; } }
            catch (Exception ex) { Log.Error($"Failed to draw video bitmap: {ex.Message}"); lock (_frameLock) { _videoBitmap?.Dispose(); _videoBitmap = null; } }
        }
        else if (Visible) { DrawPlaceholder(context, GlobalPosition - Origin, base.Size); }    }

    private void InitializeLibVLC()
    {
        lock (_initLock)
        {
            if (!_isLibVlcInitialized)
            {
                try
                {
                    Core.Initialize();
                    _isLibVlcInitialized = true;
                    Log.Info("LibVLC Core initialized.");
                }
                catch (Exception ex)
                {
                    Log.Error($"Failed to initialize LibVLC Core: {ex.Message}");
                    PlaybackError?.Invoke(this, $"Failed to initialize LibVLC Core: {ex.Message}");
                    return;
                }
            }
        }

        try
        {
            List<string> libvlcOptions =
            [
                "--no-osd",
                "--avcodec-hw=none"
            ];

            _libVLC = new(libvlcOptions.ToArray());

            Log.Info($"LibVLC instance created with options: {string.Join(" ", libvlcOptions)}");

            _mediaPlayer = new MediaPlayer(_libVLC);

            _videoFormatCallbackDelegate = new(VideoFormatCallback);
            _videoCleanupCallbackDelegate = new(VideoCleanupCallback);
            _videoLockCallbackDelegate = new(VideoLockCallback);
            _videoUnlockCallbackDelegate = new(VideoUnlockCallback);
            _videoDisplayCallbackDelegate = new(VideoDisplayCallback);

            _mediaPlayer.SetVideoFormatCallbacks(_videoFormatCallbackDelegate, _videoCleanupCallbackDelegate);
            _mediaPlayer.SetVideoCallbacks(_videoLockCallbackDelegate, _videoUnlockCallbackDelegate, _videoDisplayCallbackDelegate);

            _mediaPlayer.Playing += OnPlaying;
            _mediaPlayer.Paused += OnPaused;
            _mediaPlayer.Stopped += OnStopped;
            _mediaPlayer.EndReached += OnEndReached;
            _mediaPlayer.EncounteredError += OnEncounteredError;
            _mediaPlayer.PositionChanged += OnPositionChanged;

            _mediaPlayer.Volume = (int)Volume;
            _mediaPlayer.SetRate(PlaybackSpeed);


            if (!string.IsNullOrEmpty(FilePath))
            {
                LoadMedia();
            }
        }
        catch (Exception ex)
        {
            Log.Error($"Failed to create LibVLC instance or MediaPlayer: {ex.Message}");
            PlaybackError?.Invoke(this, $"Failed to create LibVLC/MediaPlayer: {ex.Message}");
            DisposeVlcResources();
        }
    }

    private static uint CalculateFourCC(string code)
    {
        if (code is null || code.Length != 4)
        {
            throw new ArgumentException("FourCC code must be 4 characters long.", nameof(code));
        }

        byte[] bytes = Encoding.ASCII.GetBytes(code);

        if (BitConverter.IsLittleEndian)
        {
            return BitConverter.ToUInt32(bytes, 0);
        }

        Array.Reverse(bytes);

        return BitConverter.ToUInt32(bytes, 0);
    }

    private static string FourCCToString(uint fourCC)
    {
        byte[] bytes = BitConverter.GetBytes(fourCC);

        if (!BitConverter.IsLittleEndian)
        {
            Array.Reverse(bytes);
        }

        bool isAsciiPrintable = bytes.All(b => b >= 32 && b <= 126);

        return isAsciiPrintable
            ? Encoding.ASCII.GetString(bytes)
            : $"0x{fourCC:X8}";
    }

    private uint VideoFormatCallback(ref nint opaque, nint chroma, ref uint width, ref uint height, ref uint pitches, ref uint lines)
    {
        uint currentChromaInt = 0;
        try
        {
            if (IntPtr.Size == 4) currentChromaInt = (uint)chroma.ToInt32();
            else currentChromaInt = (uint)chroma.ToInt64();
        }
        catch (OverflowException ex)
        {
            Log.Error($"VideoFormatCallback: Chroma IntPtr value overflows uint32. {ex.Message}");
            return 0;        }

        string currentChromaStr = FourCCToString(currentChromaInt);

        Log.Info($"VideoFormatCallback: Received Format='{currentChromaStr}' (0x{currentChromaInt:X8}), Dimensions={width}x{height}, Pitch={pitches}, Lines={lines}");
        if (width == 0 || height == 0)
        {
            Log.Error($"VideoFormatCallback: Rejecting format due to invalid dimensions (W:{width}, H:{height}).");
            lock (_frameLock)
            {
                ResetFormatState_Locked();
            }
            return 0;        }
        uint targetChroma = FourCC_RV32;
        uint targetPitch = width * 4;        uint targetLines = height;
        string targetChromaStr = FourCCToString(targetChroma);

        lock (_frameLock)
        {
            bool dimensionsChanged = (_videoWidth != width || _videoHeight != height);

            if (dimensionsChanged || !_formatConfigured)
            {
                Log.Info($"VideoFormatCallback: Configuring/Updating format - Size: {width}x{height}. Forcing Chroma: {targetChromaStr}, Pitch: {targetPitch}, Lines: {targetLines}. Previously Configured: {_formatConfigured}");
                if (dimensionsChanged)
                {
                    _videoBitmap?.Dispose(); _videoBitmap = null;
                    _latestFrameDataRaw = null; _conversionBufferBGRA32 = null;
                    _newFrameAvailable = false;
                }
                _receivedChroma = targetChroma;                _videoWidth = width;
                _videoHeight = height;
                _receivedPitch = targetPitch;                _bufferSize = targetPitch * targetLines;
                _formatConfigured = true;                Log.Info($"Calculated buffer size for forced BGRA32: {_bufferSize} bytes");
            }
            Marshal.WriteInt32(chroma, (int)targetChroma);            pitches = targetPitch;
            lines = targetLines;
        }

        return targetLines;    }

    private void VideoCleanupCallback(ref nint opaque)
    {
        Log.Info("VideoCleanupCallback called.");
    }

    private nint VideoLockCallback(nint opaque, nint planes)
    {
        lock (_frameLock)
        {
            if (!_formatConfigured || _bufferSize == 0 || _receivedPitch == 0)
            {
                Log.Warning($"VideoLockCallback: Cannot lock, format not fully configured yet (Configured={_formatConfigured}, Size={_bufferSize}, Pitch={_receivedPitch}).");
                return nint.Zero;
            }
            if (_latestFrameDataRaw == null || _latestFrameDataRaw.Length != _bufferSize)
            {
                try
                {
                    _latestFrameDataRaw = new byte[_bufferSize];
                    Log.Info($"Allocated raw frame buffer: {_bufferSize} bytes for format {FourCCToString(_receivedChroma)}");
                }
                catch (Exception ex)
                {
                    Log.Error($"VideoLockCallback: Exception allocating raw buffer of size {_bufferSize}. {ex.Message}");
                    _latestFrameDataRaw = null;
                    ResetFormatState_Locked();                    return nint.Zero;
                }
            }
            if (_latestFrameDataRaw == null)
            {
                Log.Error("VideoLockCallback: Raw Frame buffer is null after allocation check.");
                return nint.Zero;
            }
            var handle = GCHandle.Alloc(_latestFrameDataRaw, GCHandleType.Pinned);
            var bufferPtr = handle.AddrOfPinnedObject();

            if (planes == IntPtr.Zero)
            {
                Log.Error("VideoLockCallback: Received null planes pointer.");
                handle.Free();
                return nint.Zero;
            }
            Marshal.WriteIntPtr(planes, 0, bufferPtr);
            return GCHandle.ToIntPtr(handle);        }
    }

    private void VideoUnlockCallback(nint opaque, nint picture, nint planes)
    {
        lock (_frameLock)
        {
            if (picture == IntPtr.Zero)
            {
                Log.Warning("VideoUnlockCallback: Received null picture handle.");
                return;
            }

            _newFrameAvailable = true;
            try
            {
                var handle = GCHandle.FromIntPtr(picture);
                if (handle.IsAllocated) handle.Free();
                else Log.Warning("VideoUnlockCallback: GCHandle was not allocated?");
            }
            catch (Exception ex)
            {
                Log.Error($"VideoUnlockCallback: Exception freeing GCHandle {picture}. {ex.Message}");
            }
        }
    }

    private void VideoDisplayCallback(nint opaque, nint picture)
    {
    }

    private void LoadMedia()
    {
        if (_libVLC == null || _mediaPlayer == null || string.IsNullOrEmpty(FilePath))
        {
            Log.Warning($"Cannot load media: LibVLC/MediaPlayer not ready or FilePath is empty for node '{Name}'.");
            return;
        }

        if (_mediaPlayer.IsPlaying) _mediaPlayer.Stop();

        lock (_frameLock)
        {
            _media?.Dispose(); _media = null;
            _videoBitmap?.Dispose(); _videoBitmap = null;
            _latestFrameDataRaw = null;
            _conversionBufferBGRA32 = null;
            _videoWidth = 0; _videoHeight = 0;
            _receivedChroma = 0; _receivedPitch = 0; _bufferSize = 0;
            _newFrameAvailable = false;
            Log.Info($"Cleared previous media state for node '{Name}'.");
            _formatConfigured = false;
        }


        string absolutePath;
        try { absolutePath = Path.GetFullPath(FilePath); }
        catch (Exception ex) { Log.Error($"Error getting full path '{FilePath}': {ex.Message}"); PlaybackError?.Invoke(this, $"Invalid path: {ex.Message}"); return; }

        if (!File.Exists(absolutePath)) { Log.Error($"Video file not found: {absolutePath}"); PlaybackError?.Invoke(this, $"Video file not found: {absolutePath}"); return; }
        List<string> mediaOptions = new List<string> { ":no-video-title-show" };

        try
        {
            _media = new Media(_libVLC, new Uri(absolutePath), mediaOptions.ToArray());
            _mediaPlayer.Media = _media;
            Log.Info($"Loaded media: {absolutePath} for node '{Name}'.");
            if (_mediaPlayer != null)
            {
                _mediaPlayer.SetRate(PlaybackSpeed);
            }
        }
        catch (Exception ex)
        {
            Log.Error($"Error loading media '{absolutePath}': {ex.Message}");
            PlaybackError?.Invoke(this, $"Error loading media: {ex.Message}");
            _media?.Dispose(); _media = null;
        }
        lock (_frameLock) { _formatConfigured = false; }
    }

    public void Play()
    {
        if (_mediaPlayer != null && _media != null)
        {
            if (_mediaPlayer.State == VLCState.Error) { Log.Warning($"Cannot play node '{Name}', player state is Error."); PlaybackError?.Invoke(this, $"Player state is Error"); return; }
            _mediaPlayer.SetRate(PlaybackSpeed);

            if (!_mediaPlayer.IsPlaying)
            {
                Log.Info($"Playing media: {FilePath} for node '{Name}' at speed: {PlaybackSpeed}x.");
                if (!_mediaPlayer.Play())
                {
                    Log.Error($"MediaPlayer.Play() returned false for node '{Name}'. State: {_mediaPlayer.State}");
                    PlaybackError?.Invoke(this, "Play() failed.");
                }
            }
        }
        else { Log.Warning($"Cannot play: MediaPlayer or Media not ready for node '{Name}'."); }
    }

    public void Pause()
    {
        if (_mediaPlayer?.CanPause ?? false) { _mediaPlayer.Pause(); }
        else { Log.Warning($"Cannot pause node '{Name}'."); }
    }

    public void Stop()
    {
        if (_mediaPlayer != null) { _mediaPlayer.Stop(); }
        else { Log.Warning($"Cannot stop node '{Name}'."); }
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    private static void ConvertBGR24ToBGRA32(byte[] bgr24Data, byte[] bgra32Data, uint width, uint height, uint bgrPitch)
    {
        uint bgraPitch = width * 4;
        int numPixelsWidth = (int)width;

        ulong requiredBgraSize = (ulong)height * bgraPitch;
        ulong requiredBgrSize = (ulong)height * bgrPitch;

        if ((ulong)bgra32Data.LongLength < requiredBgraSize || (ulong)bgr24Data.LongLength < requiredBgrSize)
        {
            Log.Error($"Buffer size mismatch in ConvertBGR24ToBGRA32 (Pitched). BGR:{bgr24Data.Length}, BGRA:{bgra32Data.Length}, Expected BGR:{requiredBgrSize}, Expected BGRA:{requiredBgraSize}");
            return;
        }

        for (int y = 0; y < height; y++)
        {
            int bgrRowStart = (int)(y * bgrPitch);
            int bgraRowStart = (int)(y * bgraPitch);

            for (int x = 0; x < numPixelsWidth; x++)
            {
                int bgrIndex = bgrRowStart + x * 3;
                int bgraIndex = bgraRowStart + x * 4;

                if (bgrIndex + 2 >= bgr24Data.Length || bgraIndex + 3 >= bgra32Data.Length)
                {
                    Log.Error($"Index out of bounds during BGR->BGRA conversion at x={x}, y={y}.");
                    return;
                }

                byte b = bgr24Data[bgrIndex + 0];
                byte g = bgr24Data[bgrIndex + 1];
                byte r = bgr24Data[bgrIndex + 2];

                bgra32Data[bgraIndex + 0] = b;
                bgra32Data[bgraIndex + 1] = g;
                bgra32Data[bgraIndex + 2] = r;
                bgra32Data[bgraIndex + 3] = 255;
            }
        }
    }

    private static unsafe void CopyMemoryWithPitch(byte[] source, uint sourcePitch, byte[] destination, uint destPitch, uint bytesPerRow, uint rowCount)
    {
        if (source is null || destination is null || bytesPerRow == 0 || rowCount == 0)
        {
            return;
        }

        var requiredSourceSize = (ulong)(rowCount - 1) * sourcePitch + bytesPerRow;
        var requiredDestSize = (ulong)(rowCount - 1) * destPitch + bytesPerRow;

        if (bytesPerRow > sourcePitch || bytesPerRow > destPitch)
        {
            Log.Error("CopyMemoryWithPitch: bytesPerRow exceeds pitch.");
            return;
        }

        if (requiredSourceSize > (ulong)source.LongLength || requiredDestSize > (ulong)destination.LongLength)
        {
            Log.Error($"CopyMemoryWithPitch: Calculated size exceeds buffer length. Source Required: " +
                $"{requiredSourceSize}" +
                $"vs Actual: {source.LongLength}." +
                $"Dest Required: {requiredDestSize}" +
                $"vs Actual: {destination.LongLength}");

            return;
        }

        fixed (byte* pSource = source, pDest = destination)
        {
            byte* pSrcRow = pSource;
            byte* pDstRow = pDest;

            for (uint i = 0; i < rowCount; i++)
            {
                Buffer.MemoryCopy(pSrcRow, pDstRow, bytesPerRow, bytesPerRow);

                pSrcRow += sourcePitch;
                pDstRow += destPitch;
            }
        }
    }

    private static void DrawPlaceholder(DrawingContext context, Vector2 position, Vector2 size)
    {
        Rect placeholderRect = new(position.X, position.Y, size.X, size.Y);
        ID2D1SolidColorBrush? brush = context.OwnerWindow?.GetOrCreateBrush(Colors.DarkGray);

        if (brush == null || context.RenderTarget == null)
        {
            return;
        }

        context.RenderTarget.FillRectangle(placeholderRect, brush);
    }

    private void OnPlaying(object? sender, EventArgs e)
    {
        PlaybackStarted?.Invoke(this, EventArgs.Empty);
    }

    private void OnPaused(object? sender, EventArgs e)
    {
        PlaybackPaused?.Invoke(this, EventArgs.Empty);
    }

    private void OnStopped(object? sender, EventArgs e)
    {
        PlaybackStopped?.Invoke(this, EventArgs.Empty);

        lock (_frameLock)
        {
            _newFrameAvailable = false;
        }
    }

    private void OnEndReached(object? sender, EventArgs e)
    {
        PlaybackEnded?.Invoke(this, EventArgs.Empty); lock (_frameLock) { _newFrameAvailable = false; }
        if (Loop && _mediaPlayer != null && _media != null && !_isDisposed) { _mediaPlayer.Stop(); _mediaPlayer.Play(); }
    }

    private void OnEncounteredError(object? sender, EventArgs e)
    {
        Log.Error($"LibVLCSharp error for node '{Name}'. State: {_mediaPlayer?.State}");
        PlaybackError?.Invoke(this, "LibVLCSharp error. Check logs.");

        lock (_frameLock)
        {
            _newFrameAvailable = false;
        }
    }
    private void OnPositionChanged(object? sender, MediaPlayerPositionChangedEventArgs e)
    {
        if (SuppressPositionRatioChangedEvent)        {
            return;
        }

        PositionRatioChanged?.Invoke(e.Position);
    }

    private void ResetFormatState_Locked()
    {
        _videoBitmap?.Dispose(); _videoBitmap = null;
        _latestFrameDataRaw = null; _conversionBufferBGRA32 = null;
        _newFrameAvailable = false; _videoWidth = 0; _videoHeight = 0;
        _receivedChroma = 0; _receivedPitch = 0; _bufferSize = 0;
        _formatConfigured = false;    }

    protected virtual void Dispose(bool disposing)
    {
        if (_isDisposed)
        {
            return;
        }

        _isDisposed = true;

        Log.Info($"Disposing VideoPlayer '{Name}' (disposing={disposing})...");

        try
        {
            if (_mediaPlayer != null && _mediaPlayer.IsPlaying)
            {
                _mediaPlayer.Stop();
            }
        }
        catch (Exception ex)
        {
            Log.Warning($"Exception stopping MediaPlayer during dispose: {ex.Message}");
        }

        if (disposing)
        {
            if (_mediaPlayer != null)
            {
                _mediaPlayer.Playing -= OnPlaying;
                _mediaPlayer.Paused -= OnPaused;
                _mediaPlayer.Stopped -= OnStopped;
                _mediaPlayer.EndReached -= OnEndReached;
                _mediaPlayer.EncounteredError -= OnEncounteredError;
                _mediaPlayer.PositionChanged -= OnPositionChanged;

                try
                {
                    _mediaPlayer.SetVideoFormatCallbacks(null, null);
                    _mediaPlayer.SetVideoCallbacks(null, null, null);
                }
                catch (Exception ex)
                {
                    Log.Warning($"Exception detaching callbacks: {ex.Message}");
                }
            }

            try
            {
                _media?.Dispose();
            }
            catch (Exception ex)
            {
                Log.Warning($"Exception disposing Media: {ex.Message}");
            }
            finally
            {
                _media = null;
            }

            try
            {
                _mediaPlayer?.Dispose();
            }
            catch (Exception ex)
            {
                Log.Warning($"Exception disposing MediaPlayer: {ex.Message}");
            }
            finally
            {
                _mediaPlayer = null;
            }

            try
            {
                _libVLC?.Dispose();
            }
            catch (Exception ex)
            {
                Log.Warning($"Exception disposing LibVLC: {ex.Message}");
            }
            finally
            {
                _libVLC = null;
            }

            _videoFormatCallbackDelegate = null;
            _videoCleanupCallbackDelegate = null;
            _videoLockCallbackDelegate = null;
            _videoUnlockCallbackDelegate = null;
            _videoDisplayCallbackDelegate = null;
        }

        ID2D1Bitmap? bitmapToDispose = null;

        lock (_frameLock)
        {
            bitmapToDispose = _videoBitmap; _videoBitmap = null;
            _latestFrameDataRaw = null;            _conversionBufferBGRA32 = null;            _newFrameAvailable = false;
            _videoWidth = 0;
            _videoHeight = 0;
            _receivedChroma = 0;
            _receivedPitch = 0;
            _bufferSize = 0;
        }

        _formatConfigured = false;        bitmapToDispose?.Dispose();

        Log.Info($"VideoPlayer '{Name}' disposed.");
    }

    private void DisposeVlcResources()
    {
        Log.Warning($"DisposeVlcResources called directly for '{Name}'. Use Dispose().");
        Dispose(true);
    }

    ~VideoPlayer()
    {
        Dispose(false);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\WindowNode.cs">
namespace Cherris;

public class WindowNode : Node2D
{
    protected SecondaryWindow? secondaryWindow;
    private string windowTitle = "Cherris Window";
    private int windowWidth = 640;
    private int windowHeight = 480;
    private SystemBackdropType backdropType = SystemBackdropType.None;

    protected bool isQueuedForFree = false;

    public string Title
    {
        get => windowTitle;
        set
        {
            if (windowTitle == value) return;
            windowTitle = value;
        }
    }

    public int Width
    {
        get => windowWidth;
        set
        {
            if (windowWidth == value) return;
            windowWidth = value;
        }
    }

    public int Height
    {
        get => windowHeight;
        set
        {
            if (windowHeight == value) return;
            windowHeight = value;
        }
    }

    public SystemBackdropType BackdropType
    {
        get => backdropType;
        set
        {
            if (backdropType == value) return;
            backdropType = value;
            secondaryWindow?.ApplySystemBackdrop();
        }
    }

    public override void Make()
    {
        base.Make();
        InitializeWindow();
    }

    public override void Process()
    {
        base.Process();

        if (isQueuedForFree)
        {
            FreeInternal();
        }
    }

    private void InitializeWindow()
    {
        if (secondaryWindow is not null)
        {
            Log.Warning($"WindowNode '{Name}' already has an associated window. Skipping creation.");
            return;
        }

        try
        {
            secondaryWindow = new SecondaryWindow(Title, this.Width, this.Height, this);

            if (!secondaryWindow.TryCreateWindow())
            {
                Log.Error($"WindowNode '{Name}' failed to create its window.");
                secondaryWindow = null;
                return;
            }

            secondaryWindow.BackdropType = this.BackdropType;

            if (!secondaryWindow.InitializeWindowAndGraphics())
            {
                Log.Error($"WindowNode '{Name}' failed to initialize window graphics.");
                secondaryWindow.Dispose();
                secondaryWindow = null;
                return;
            }

            secondaryWindow.ShowWindow();
            Log.Info($"WindowNode '{Name}' successfully created and initialized its window.");
        }
        catch (Exception ex)
        {
            Log.Error($"Error during WindowNode '{Name}' initialization: {ex.Message}");
            secondaryWindow?.Dispose();
            secondaryWindow = null;
        }
    }

    public void QueueFree()
    {
        isQueuedForFree = true;
    }

    protected virtual void FreeInternal()
    {
        Log.Info($"Freeing WindowNode '{Name}' and its associated window.");
        secondaryWindow?.Close();
        secondaryWindow = null;
        base.Free();
    }

    public override void Free()
    {
        if (!isQueuedForFree)
        {
            Log.Warning($"Direct call to Free() on WindowNode '{Name}' detected. Use QueueFree() instead.");
            QueueFree();
        }
    }

    internal void RenderChildren(DrawingContext context)
    {
        foreach (Node child in Children)
        {
            RenderNodeRecursive(child, context);
        }
    }

    private static void RenderNodeRecursive(Node node, DrawingContext context)
    {
        if (node is WindowNode)
        {
            return;
        }

        if (node is VisualItem { Visible: true } visualItem)
        {
            visualItem.Draw(context);
        }

        var childrenToRender = new List<Node>(node.Children);
        foreach (Node child in childrenToRender)
        {
            RenderNodeRecursive(child, context);
        }
    }

    public SecondaryWindow? GetWindowHandle() => secondaryWindow;

    public Vector2 LocalMousePosition => secondaryWindow?.GetLocalMousePosition() ?? Input.MousePosition;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Resources\Animation.cs">
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Cherris;

public class Animation
{
    public List<Keyframe> Keyframes { get; set; } = new();

    public class Keyframe
    {
        [YamlMember(Alias = "T")]
        public float Time { get; set; }

        public Dictionary<string, Dictionary<string, float>> Nodes { get; set; } = [];
    }

    public Animation() { }

    public Animation(string filePath)
    {
        var deserializer = new DeserializerBuilder()
            .WithNamingConvention(PascalCaseNamingConvention.Instance)
            .Build();

        Keyframes = deserializer.Deserialize<List<Keyframe>>(File.ReadAllText(filePath));
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Resources\AudioStream.cs">
namespace Cherris;

public class AudioStream
{
    public static AudioStream? Load(string filePath)
    {
        return null;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Resources\Font.cs">
using Raylib_cs;

namespace Cherris;

public class Font
{
    public string Name = "";
    public int Size = 0;

    private Raylib_cs.Font raylibFont;

    public Vector2 Dimensions
    {
        get
        {
            return Raylib.MeasureTextEx(raylibFont, " ", Size, 0);
        }
    }

    public Font(string filePath, int size)
    {
        Size = size;
        Name = Path.GetFileNameWithoutExtension(filePath);

        int[] codepoints = new int[255 - 32 + 1];
        for (int i = 0; i < codepoints.Length; i++)
        {
            codepoints[i] = 32 + i;
        }

        raylibFont = Raylib.LoadFontEx(filePath, size, codepoints, codepoints.Length);
        Raylib.SetTextureFilter(raylibFont.Texture, TextureFilter.Bilinear);
    }

    public static implicit operator Raylib_cs.Font(Font textFont) => textFont.raylibFont;

    public static Vector2 MeasureText(Font font, string text, int size, float spacing)
    {
        Vector2 measurements = Raylib.MeasureTextEx(
            font,
            text,
            size,
            spacing);

        return measurements;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Resources\Shader.cs">
namespace Cherris;

public class Shader
{
    private Raylib_cs.Shader raylibShader;

    private Shader(Raylib_cs.Shader shader)
    {
        raylibShader = shader;
    }

    public static Shader? Load(string? vertexShaderPath, string? fragmentShaderPath)
    {
        Raylib_cs.Shader shader = Raylib_cs.Raylib.LoadShader(vertexShaderPath, fragmentShaderPath);

        if (!Raylib_cs.Raylib.IsShaderValid(shader))
        {
            Log.Error($"Failed to load shader: {vertexShaderPath},{fragmentShaderPath}");
            return null;
        }

        return new(shader);
    }

    public static implicit operator Raylib_cs.Shader(Shader shader)
    {
        return shader.raylibShader;
    }

    public void SetValue(int loc, float[] values, ShaderUniformDataType uniformType)
    {
        Raylib_cs.Raylib.SetShaderValue(
            this,
            loc,
            values,
            (Raylib_cs.ShaderUniformDataType)uniformType);
    }

    public int GetLocation(string uniformName)
    {
        return Raylib_cs.Raylib.GetShaderLocation(this, uniformName);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Resources\ShaderUniformDataType.cs">
namespace Cherris;

public enum ShaderUniformDataType
{
    Float = 0,
    Vec2,
    Vec3,
    Vec4,
    Int,
    IVec2,
    IVec3,
    IVec4,
    Sampler2D
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Resources\Sound.cs">
namespace Cherris;

public class Sound
{
    public string Path { get; private set; } = "";

    private Raylib_cs.Sound raylibSound;

    public static implicit operator Raylib_cs.Sound(Sound sound) => sound.raylibSound;

    private Sound(Raylib_cs.Sound sound, string filePath)
    {
        raylibSound = sound;
        Path = filePath;
    }

    public static Sound? Load(string filePath)
    {
        Raylib_cs.Sound sound = Raylib_cs.Raylib.LoadSound(filePath);

        if (sound.FrameCount == 0)
        {
            return null;
        }

        return new(sound, filePath);
    }

    public void Play(string bus = "Master")
    {
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Resources\Texture.cs">
using Raylib_cs;

namespace Cherris;

public class Texture
{
    public Vector2 Size { get; private set; } = Vector2.Zero;
    private Texture2D raylibTexture;

    public Texture(string filePath)
    {
        string pngPath =
            Path.GetExtension(filePath).ToLower() == ".png" ?
            filePath :
            GetPngPath(filePath);

        raylibTexture = Raylib.LoadTexture(pngPath);
        Size = new(raylibTexture.Width, raylibTexture.Height);

        if (pngPath != filePath)
        {
            File.Delete(pngPath);
        }
    }

    public Texture()
    {
    }

    public static implicit operator Texture2D(Texture texture) => texture.raylibTexture;

    private static string GetPngPath(string imagePath)
    {
        if (!Directory.Exists("Res/Cherris/Temporary"))
        {
            Directory.CreateDirectory("Res/Temporary");
        }

        string pngPath = $"Res/Cherris/Temporary/{Path.GetFileNameWithoutExtension(imagePath)}.png";

        if (!File.Exists(pngPath))
        {
        }

        return pngPath;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Scene\NodePropertySetter.cs">
using System.Reflection;

namespace Cherris;

public static class NodePropertySetter
{
    private static readonly string[] SpecialProperties = { "type", "name", "path", "children", "Node" };

    public static void SetProperties(Node node, Dictionary<string, object> element, List<(Node, string, object)>? deferredNodeAssignments = null)
    {
        foreach ((string key, object value) in element)
        {
            if (SpecialProperties.Contains(key, StringComparer.OrdinalIgnoreCase))
            {
                continue;
            }

            SetNestedMember(node, key, value, deferredNodeAssignments);
        }
    }

    public static void SetNestedMember(object rootInstance, string fullMemberPath, object value, List<(Node, string, object)>? deferredNodeAssignments = null)
    {
        string[] pathParts = fullMemberPath.Split('/');
        object currentObject = rootInstance;
        for (var i = 0; i < pathParts.Length; i++)
        {
            var memberName = pathParts[i];
            var memberInfo = ReflectionUtils.GetMemberInfo(currentObject.GetType(), memberName);
            bool isFinalSegment = i == pathParts.Length - 1;

            if (isFinalSegment)
            {

                Type memberType = ReflectionUtils.GetMemberType(memberInfo);
                if (value is Dictionary<object, object> dictValue && IsComplexObjectType(memberType))
                {
                    object? existingMemberInstance = ReflectionUtils.GetMemberValue(currentObject, memberInfo);
                    if (existingMemberInstance == null)
                    {
                        existingMemberInstance = Activator.CreateInstance(memberType) ?? throw new InvalidOperationException($"Failed to create instance of {memberType.Name}");
                        ReflectionUtils.SetMemberValue(currentObject, memberInfo, existingMemberInstance);
                    }
                    foreach (KeyValuePair<object, object> entry in dictValue)
                    {
                        string subKey = entry.Key.ToString()!;
                        object subValue = entry.Value;
                        string subPropertyFullPath = fullMemberPath + "/" + subKey;
                        SetNestedMember(rootInstance, subPropertyFullPath, subValue, deferredNodeAssignments);
                    }
                }
                else if (ShouldDeferAssignment(memberType, value))
                {
                    if (rootInstance is Node nodeForDeferral)
                    {
                        deferredNodeAssignments?.Add((nodeForDeferral, fullMemberPath, value));
                    }
                    else
                    {
                        if (deferredNodeAssignments != null)                        {
                            Log.Warning($"Cannot defer assignment for non-Node root target: {rootInstance.GetType().Name} for path {fullMemberPath}. This may be normal if loading non-Node configurations.");
                        }
                        var convertedNonDeferredValue = ValueConversionUtils.ConvertValue(memberType, value);
                        ReflectionUtils.SetMemberValue(currentObject, memberInfo, convertedNonDeferredValue);
                    }
                }
                else
                {
                    var convertedValue = ValueConversionUtils.ConvertValue(memberType, value);
                    ReflectionUtils.SetMemberValue(currentObject, memberInfo, convertedValue);
                }
                return;            }
            else            {
                object? nextObject = ReflectionUtils.GetMemberValue(currentObject, memberInfo);
                if (nextObject == null)
                {
                    nextObject = ReflectionUtils.CreateMemberInstance(memberInfo);
                    ReflectionUtils.SetMemberValue(currentObject, memberInfo, nextObject);
                }
                currentObject = nextObject;
            }
        }
    }

    private static bool ShouldDeferAssignment(Type memberType, object value)
    {
        return memberType.IsSubclassOf(typeof(Node)) && value is string;
    }

    private static bool IsComplexObjectType(Type type)
    {
        if (type.IsEnum || type == typeof(string) || type.IsPrimitive || type == typeof(decimal))
            return false;
        if (type.IsSubclassOf(typeof(Node)))
            return false;
        if (type == typeof(AudioStream) || type == typeof(Sound) || type == typeof(Animation) || type == typeof(Texture) || type == typeof(Font))
            return false;
        if (type == typeof(Vector2) || type == typeof(Color)) return false;        if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(List<>)) return false;        if (type.IsClass) return true;
        if (type.IsValueType && !type.IsEnum && !type.IsPrimitive && type != typeof(decimal) && type != typeof(Vector2) && type != typeof(Color))
            return true;

        return false;    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Scene\PackedScene.cs">
using System.Reflection;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;
using System.Linq;
namespace Cherris;

public sealed class PackedScene(string path)
{
    private readonly string _path = path;
    private static readonly IDeserializer _deserializer = new DeserializerBuilder()
        .WithNamingConvention(PascalCaseNamingConvention.Instance)        .Build();

    public T Instantiate<T>() where T : Node
    {
        var deferredNodeAssignments = new List<(Node, string, object)>();
        var namedNodes = new Dictionary<string, Node>();

        string yamlContent = File.ReadAllText(_path);
        var rootElement = _deserializer.Deserialize<Dictionary<string, object>>(yamlContent);
        Node rootNode = (T)ParseNode(rootElement, null, deferredNodeAssignments, namedNodes);
        AssignDeferredNodes(deferredNodeAssignments, namedNodes);
        return (T)rootNode;
    }

    private Node ParseNode(Dictionary<string, object> element, Node? parent, List<(Node, string, object)> deferredNodeAssignments, Dictionary<string, Node> namedNodes)
    {
        var node = CreateNodeInstance(element);
        ProcessNestedScene(element, ref node);
        SetNodeProperties(element, node, deferredNodeAssignments);
        AddToParent(parent, node);
        RegisterNode(node, namedNodes);
        ProcessChildNodes(element, node, deferredNodeAssignments, namedNodes);
        return node;
    }

    private static Node CreateNodeInstance(Dictionary<string, object> element)
    {
        if (!element.TryGetValue("Node", out var nodeDescriptorObj))
            throw new KeyNotFoundException("Element is missing the 'Node' key.");
        var nodeDescriptor = (string)nodeDescriptorObj;
        var parts = nodeDescriptor.Split(["::"], StringSplitOptions.None);
        if (parts.Length != 2)
            throw new FormatException($"Invalid Node descriptor '{nodeDescriptor}'. Expected 'Type::Name'.");

        var typeNameToResolve = parts[0];        var nodeInstanceName = parts[1];
        Type? nodeType = FindTypeByNameInRelevantAssemblies(typeNameToResolve);

        if (nodeType == null)
        {
            try
            {
                nodeType = TypeResolverUtils.ResolveType(typeNameToResolve);
            }
            catch (Exception ex)
            {
            }
        }

        if (nodeType == null)
        {
            throw new InvalidOperationException($"Type '{typeNameToResolve}' not found. Searched entry assembly, core assembly, all loaded assemblies, and via TypeResolverUtils.");
        }

        var node = (Node)Activator.CreateInstance(nodeType)!;
        node.Name = nodeInstanceName;
        return node;
    }

    private static Type? FindTypeByNameInRelevantAssemblies(string simpleOrFullName)
    {
        Type? foundType = Type.GetType(simpleOrFullName, throwOnError: false, ignoreCase: true);
        if (foundType != null) return foundType;
        Assembly? entryAssembly = Assembly.GetEntryAssembly();
        if (entryAssembly != null)
        {
            try
            {
                foundType = entryAssembly.GetTypes().FirstOrDefault(t => t.Name.Equals(simpleOrFullName, StringComparison.OrdinalIgnoreCase) || (t.FullName != null && t.FullName.Equals(simpleOrFullName, StringComparison.OrdinalIgnoreCase)));
                if (foundType != null) return foundType;
            }
            catch (ReflectionTypeLoadException) { /* Ignore assembly if types cannot be loaded */ }
        }
        Assembly coreAssembly = typeof(Node).Assembly;
        if (coreAssembly != entryAssembly)        {
            try
            {
                foundType = coreAssembly.GetTypes().FirstOrDefault(t => t.Name.Equals(simpleOrFullName, StringComparison.OrdinalIgnoreCase) || (t.FullName != null && t.FullName.Equals(simpleOrFullName, StringComparison.OrdinalIgnoreCase)));
                if (foundType != null) return foundType;
            }
            catch (ReflectionTypeLoadException) { /* Ignore assembly if types cannot be loaded */ }
        }
        foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
        {
            if (assembly == entryAssembly || assembly == coreAssembly) continue;
            try
            {
                foundType = assembly.GetTypes().FirstOrDefault(t => t.Name.Equals(simpleOrFullName, StringComparison.OrdinalIgnoreCase) || (t.FullName != null && t.FullName.Equals(simpleOrFullName, StringComparison.OrdinalIgnoreCase)));
                if (foundType != null) return foundType;
            }
            catch (ReflectionTypeLoadException)
            {
            }
        }
        return null;    }


    private static void ProcessNestedScene(Dictionary<string, object> element, ref Node node)
    {
        if (element.TryGetValue("path", out var pathValue))
        {
            if (!element.TryGetValue("Node", out var nodeDescriptorObj))
                throw new KeyNotFoundException("Element with 'path' is missing the 'Node' key.");
            var nodeDescriptor = (string)nodeDescriptorObj;
            var parts = nodeDescriptor.Split(new[] { "::" }, StringSplitOptions.None);
            if (parts.Length != 2)
                throw new FormatException($"Invalid Node descriptor '{nodeDescriptor}'. Expected 'Type::Name'.");
            var nodeName = parts[1];

            var scenePath = (string)pathValue;
            var nestedScene = new PackedScene(scenePath);
            node = nestedScene.Instantiate<Node>();
            node.Name = nodeName;
        }
    }

    private static void SetNodeProperties(Dictionary<string, object> element, Node node, List<(Node, string, object)> deferredNodeAssignments)
    {
        Dictionary<string, object> properties = element
            .Where(kvp => !IsReservedKey(kvp.Key))
            .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);

        NodePropertySetter.SetProperties(node, properties, deferredNodeAssignments);
    }

    private static bool IsReservedKey(string key)
    {
        return key is "children" or "Node" or "path";
    }

    private static void AddToParent(Node? parent, Node node)
    {
        parent?.AddChild(node, node.Name);
    }

    private static void RegisterNode(Node node, Dictionary<string, Node> namedNodes)
    {
        namedNodes[node.Name] = node;
    }

    private void ProcessChildNodes(Dictionary<string, object> element, Node parentNode, List<(Node, string, object)> deferredNodeAssignments, Dictionary<string, Node> namedNodes)
    {
        if (!element.TryGetValue("children", out var childrenObj)) return;
        var children = ConvertChildrenToList(childrenObj);
        foreach (var child in children)
        {
            if (child is Dictionary<object, object> childDict)
            {
                var convertedChild = ConvertChildDictionary(childDict);
                ParseNode(convertedChild, parentNode, deferredNodeAssignments, namedNodes);
            }
        }
    }

    private static List<object> ConvertChildrenToList(object childrenObj)
    {
        return childrenObj is List<object> list ? list : [];
    }

    private static Dictionary<string, object> ConvertChildDictionary(Dictionary<object, object> childDict)
    {
        return childDict.ToDictionary(kvp => kvp.Key.ToString()!, kvp => kvp.Value);
    }

    private void AssignDeferredNodes(List<(Node, string, object)> deferredNodeAssignments, Dictionary<string, Node> namedNodes)
    {
        foreach (var (targetNode, memberPath, nodePath) in deferredNodeAssignments)
        {
            AssignDeferredNode(targetNode, memberPath, nodePath, namedNodes);
        }
    }

    private void AssignDeferredNode(Node targetNode, string memberPath, object nodePath, Dictionary<string, Node> namedNodes)
    {
        string[] pathParts = memberPath.Split('/');
        object currentObject = targetNode;

        for (int i = 0; i < pathParts.Length; i++)
        {
            string part = pathParts[i];
            Type currentType = currentObject.GetType();
            (MemberInfo? memberInfo, object? nextObject) = GetMemberAndNextObject(currentType, part, currentObject);
            if (i == pathParts.Length - 1)
            {
                AssignNodeToMember(memberInfo, currentObject, nodePath, targetNode, namedNodes);
            }
            else
            {
                currentObject = nextObject!;
            }
        }
    }

    private static (MemberInfo?, object?) GetMemberAndNextObject(Type type, string memberName, object currentObject)
    {
        PropertyInfo? propertyInfo = type.GetProperty(memberName, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
        if (propertyInfo != null)
        {
            object? nextObject = propertyInfo.GetValue(currentObject) ?? Activator.CreateInstance(propertyInfo.PropertyType);
            propertyInfo.SetValue(currentObject, nextObject);
            return (propertyInfo, nextObject);
        }

        FieldInfo? fieldInfo = type.GetField(memberName, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
        if (fieldInfo != null)
        {
            object? nextObject = fieldInfo.GetValue(currentObject) ?? Activator.CreateInstance(fieldInfo.FieldType);
            fieldInfo.SetValue(currentObject, nextObject);
            return (fieldInfo, nextObject);
        }

        throw new Exception($"Member '{memberName}' not found on type '{type.Name}'.");
    }

    private static void AssignNodeToMember(MemberInfo? memberInfo, object targetObject, object nodePath, Node targetNode, Dictionary<string, Node> namedNodes)
    {
        if (memberInfo is PropertyInfo propertyInfo && propertyInfo.PropertyType.IsSubclassOf(typeof(Node)))
        {
            Node referencedNode = ResolveNodePath(nodePath, namedNodes, targetNode);
            propertyInfo.SetValue(targetObject, referencedNode);
        }
        else if (memberInfo is FieldInfo fieldInfo && fieldInfo.FieldType.IsSubclassOf(typeof(Node)))
        {
            Node referencedNode = ResolveNodePath(nodePath, namedNodes, targetNode);
            fieldInfo.SetValue(targetObject, referencedNode);
        }
        else
        {
            throw new Exception($"Member '{memberInfo?.Name}' is not a Node-derived type.");
        }
    }

    private static Node ResolveNodePath(object nodePath, Dictionary<string, Node> namedNodes, Node targetNode)
    {
        if (nodePath is string pathString)
        {
            return namedNodes.TryGetValue(pathString, out Node? node)
                ? node
                : targetNode.GetNode<Node>(pathString);
        }

        throw new Exception($"Unsupported node path type: {nodePath.GetType()}");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Scene\PackedSceneXml.cs">
using System.Xml.Linq;
using System.Reflection;
using System.Globalization;

namespace Cherris;

public sealed class PackedSceneXml(string path)
{
    private readonly string _path = path;

    public T Instantiate<T>() where T : Node
    {
        var doc = XDocument.Load(_path);
        var rootElement = doc.Root;

        if (rootElement == null || rootElement.Name != "Node")
            throw new Exception($"Invalid root element in scene file '{_path}'");

        var rootNode = (T)LoadNode(rootElement);
        return rootNode;
    }

    private Node LoadNode(XElement element)
    {
        string nodeName = element.Attribute("name")?.Value
            ?? throw new Exception($"Missing 'name' attribute on element <{element.Name}>");
        string nodeType = element.Name.LocalName;

        var node = CreateNodeInstance(nodeType);
        node.Name = nodeName;
        foreach (var childElement in element.Elements())
        {
            if (IsPropertyElement(childElement.Name.LocalName))
            {
                SetNodeProperty(node, childElement);
            }
            else
            {
                var childNode = LoadNode(childElement);
                node.AddChild(childNode, childNode.Name);
            }
        }

        return node;
    }

    private static bool IsPropertyElement(string elementName)
    {
        return elementName == "Position" ||
               elementName == "Scale" ||
               elementName == "Size" ||
               elementName == "FilePath" ||
               elementName == "AutoPlay" ||
               elementName == "Text";
    }

    private void SetNodeProperty(Node node, XElement element)
    {
        string propertyName = element.Name.LocalName;
        var propertyInfo = node.GetType().GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance);

        if (propertyInfo == null)
            return;
        if (propertyInfo.PropertyType == typeof(Vector2))
        {
            float x = float.Parse(element.Attribute("x")?.Value ?? "0", CultureInfo.InvariantCulture);
            float y = float.Parse(element.Attribute("y")?.Value ?? "0", CultureInfo.InvariantCulture);
            propertyInfo.SetValue(node, new Vector2(x, y));
        }
        else if (propertyInfo.PropertyType == typeof(bool))
        {
            propertyInfo.SetValue(node, bool.Parse(element.Value));
        }
        else if (propertyInfo.PropertyType == typeof(string))
        {
            propertyInfo.SetValue(node, element.Value);
        }
        else
        {
            object converted = Convert.ChangeType(element.Value, propertyInfo.PropertyType, CultureInfo.InvariantCulture);
            propertyInfo.SetValue(node, converted);
        }
    }

    private static Node CreateNodeInstance(string typeName)
    {
        if (!typeName.Contains('.'))
        {
            typeName = "Cherris." + typeName;
        }

        var type = Type.GetType(typeName)
                   ?? throw new Exception($"Unknown node type: '{typeName}'");

        return Activator.CreateInstance(type) as Node
               ?? throw new Exception($"Could not create instance of type '{typeName}'");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Scene\ReflectionUtils.cs">
using System.Reflection;

namespace Cherris;

public static class ReflectionUtils
{
    private const BindingFlags MemberBindingFlags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;

    public static MemberInfo GetMemberInfo(Type type, string memberName)
    {
        MemberInfo[] allMembers = type.GetMember(memberName, MemberBindingFlags | BindingFlags.IgnoreCase);

        if (allMembers.Length == 0)
        {
            throw new InvalidOperationException($"Member '{memberName}' not found on type '{type.Name}'");
        }

        if (allMembers.Length > 1)
        {
            var property = allMembers.OfType<PropertyInfo>().FirstOrDefault();
            if (property is not null)
            {
                return property;
            }

            var field = allMembers.OfType<FieldInfo>().FirstOrDefault();
            if (field != null)
            {
                return field;
            }

            Log.Error($"[GetMemberInfo] Ambiguity detected for member '{memberName}' on type '{type.Name}'. Found {allMembers.Length} members:");
            foreach (MemberInfo m in allMembers)
            {
                string memberTypeName = m switch { PropertyInfo p => p.PropertyType.Name, FieldInfo f => f.FieldType.Name, _ => m.MemberType.ToString() };
                Log.Error($"  - Name: {m.Name}, Kind: {m.MemberType}, Type: {memberTypeName}, Declared by: {m.DeclaringType?.FullName}");
            }

            throw new AmbiguousMatchException($"Ambiguous match found for member '{memberName}' on type '{type.Name}'.");
        }

        return allMembers[0];
    }

    public static Type GetMemberType(MemberInfo memberInfo)
    {
        return memberInfo switch
        {
            PropertyInfo p => p.PropertyType,
            FieldInfo f => f.FieldType,
            _ => throw new InvalidOperationException($"Unsupported member type '{memberInfo?.GetType().Name}' for member '{memberInfo?.Name}'")
        };
    }

    public static object? GetMemberValue(object target, MemberInfo memberInfo)
    {
        return memberInfo switch
        {
            PropertyInfo p => p.GetValue(target),
            FieldInfo f => f.GetValue(target),
            _ => throw new InvalidOperationException($"Unsupported member type '{memberInfo?.GetType().Name}' for member '{memberInfo?.Name}'")
        };
    }

    public static void SetMemberValue(object target, MemberInfo memberInfo, object value)
    {
        switch (memberInfo)
        {
            case PropertyInfo p:
                try
                {
                    p.SetValue(target, value);
                }
                catch (Exception ex)
                {
                    Log.Error($"Failed setting property '{p.Name}' on '{target.GetType().Name}': {ex.Message}");
                    throw;
                }
                break;

            case FieldInfo f:
                try
                {
                    f.SetValue(target, value);
                }
                catch (Exception ex)
                {
                    Log.Error($"Failed setting field '{f.Name}' on '{target.GetType().Name}': {ex.Message}");
                    throw;
                }
                break;

            default:
                throw new InvalidOperationException($"Unsupported member type '{memberInfo?.GetType().Name}' for member '{memberInfo?.Name}'");
        }
    }

    public static object CreateMemberInstance(MemberInfo memberInfo)
    {
        Type typeToCreate = memberInfo switch
        {
            PropertyInfo p => p.PropertyType,
            FieldInfo f => f.FieldType,
            _ => throw new InvalidOperationException($"Unsupported member type '{memberInfo?.GetType().Name}' for member '{memberInfo?.Name}'")
        };

        return Activator.CreateInstance(typeToCreate) ?? throw new InvalidOperationException($"Failed to create instance of {typeToCreate.Name}");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Scene\SceneTree.cs">
using System.Runtime.CompilerServices;

namespace Cherris;

public sealed class SceneTree
{
    public static SceneTree Instance { get; } = new();

    public Node? RootNode { get; set; }
    public bool Paused { get; set; }

    private readonly ConditionalWeakTable<Node, object> readyNodes = [];
    private readonly List<SceneTreeTimer> timers = [];
    private readonly List<Tween> activeTweens = [];

    private SceneTree() { }

    public void Process()
    {
        if (RootNode is null)
        {
            return;
        }

        ProcessNode(RootNode);

        ProcessTweens();

        if (!Paused)
        {
            ProcessTimers();
        }
    }

    public void RenderScene(DrawingContext context)
    {
        if (RootNode is null)
        {
            return;
        }

        RenderNode(RootNode, context);
    }

    private void ProcessNode(Node node)
    {
        if (node is null || !node.Active)
        {
            return;
        }

        Node.ProcessMode effectiveMode = ComputeEffectiveProcessMode(node);
        bool shouldProcess = ShouldProcess(effectiveMode);

        if (shouldProcess)
        {
            EnsureNodeReady(node);
            node.ProcessBegin();
            node.Process();
        }


        var childrenToProcess = new List<Node>(node.Children);
        foreach (Node child in childrenToProcess)
        {
            ProcessNode(child);
        }

        if (shouldProcess)
        {
            node.ProcessEnd();
        }
    }

    private void EnsureNodeReady(Node node)
    {
        if (!readyNodes.TryGetValue(node, out _))
        {
            node.Ready();
            readyNodes.Add(node, null);
        }
    }

    private static Node.ProcessMode ComputeEffectiveProcessMode(Node node)
    {
        if (node.ProcessingMode != Node.ProcessMode.Inherit)
        {
            return node.ProcessingMode;
        }

        Node? current = node.Parent;

        while (current != null)
        {
            if (current.ProcessingMode != Node.ProcessMode.Inherit)
            {
                return current.ProcessingMode;
            }

            current = current.Parent;
        }

        return Node.ProcessMode.Pausable;
    }

    private bool ShouldProcess(Node.ProcessMode mode) => mode switch
    {
        Node.ProcessMode.Disabled => false,
        Node.ProcessMode.Always => true,
        Node.ProcessMode.Pausable => !Paused,
        Node.ProcessMode.WhenPaused => Paused,
        _ => false
    };

    private static void RenderNode(Node node, DrawingContext context)
    {

        if (node is WindowNode)
        {

            return;
        }

        if (node is VisualItem { Visible: true } visualItem)
        {
            visualItem.Draw(context);
        }


        var childrenToRender = new List<Node>(node.Children);
        foreach (Node child in childrenToRender)
        {
            RenderNode(child, context);
        }
    }

    public SceneTreeTimer CreateTimer(float time)
    {
        SceneTreeTimer timer = new(time);
        timers.Add(timer);
        return timer;
    }

    public void RemoveTimer(SceneTreeTimer timer)
    {
        timers.Remove(timer);
    }

    private void ProcessTimers()
    {
        var timersToProcess = new List<SceneTreeTimer>(timers);
        foreach (SceneTreeTimer timer in timersToProcess)
        {
            timer.Process();
        }
    }

    public void ChangeScene(Node node)
    {
        RootNode?.Free();
        RootNode = node;
        readyNodes.Clear();
    }

    public Tween CreateTween(Node creatorNode, Node.ProcessMode processMode = Node.ProcessMode.Inherit)
    {
        Tween tween = new(creatorNode, processMode);
        activeTweens.Add(tween);
        return tween;
    }

    private void ProcessTweens()
    {
        var tweensToProcess = new List<Tween>(activeTweens);
        foreach (Tween tween in tweensToProcess)
        {
            if (!tween.Active)
            {
                activeTweens.Remove(tween);
                continue;
            }

            if (tween.ShouldProcess(Paused))
            {
                tween.Update(Time.Delta);
            }

            if (!tween.Active)
            {
                activeTweens.Remove(tween);
            }
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Scene\SceneTreeTimer.cs">
namespace Cherris;

public class SceneTreeTimer(float waitTime)
{
    public float WaitTime { get; set; } = waitTime;
    private float timePassed = 0;

    public delegate void TimerEventHandler();
    public event TimerEventHandler? Timeout;

    public void Process()
    {

        if (timePassed >= WaitTime)
        {
            Timeout?.Invoke();
            SceneTree.Instance.RemoveTimer(this);
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Scene\StringExtensions.cs">
namespace Cherris;

public static class StringExtensions
{
    public static string TrimQuotes(this string input)
    {
        if (input is null || input.Length < 2)
        {
            return input ?? "";
        }

        if ((input[0] == '"' && input[^1] == '"') || (input[0] == '\'' && input[^1] == '\''))
        {
            return input[1..^1];
        }

        return input;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Scene\TypeResolverUtils.cs">
using System.Reflection;

namespace Cherris;

public static class TypeResolverUtils
{
    public static Type ResolveType(string typeName)
    {
        Type? foundType = null;

        foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
        {
            foundType = assembly.GetType(typeName, false, true);

            if (foundType is not null)
            {
                break;
            }

            if (typeName.Contains('.'))
            {
                continue;
            }

            foundType = assembly.GetType($"Cherris.{typeName}", false, true);

            if (foundType != null)
            {
                break;
            }
        }

        return foundType ?? throw new TypeLoadException($"Type '{typeName}' not found in any loaded assembly.");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Scene\ValueConversionUtils.cs">
using System.Collections;
using System.Globalization;

namespace Cherris;

public static class ValueConversionUtils
{
    public static object ConvertValue(Type targetType, object value)
    {
        return value switch
        {
            Dictionary<object, object> dict => ConvertNestedObject(targetType, dict),
            IList list => ConvertList(targetType, list),
            _ => ConvertPrimitive(targetType, value)
        };
    }

    private static object ConvertNestedObject(Type targetType, Dictionary<object, object> dict)
    {
        object instance = Activator.CreateInstance(targetType)
            ?? throw new InvalidOperationException($"Failed to create {targetType.Name} instance");

        foreach (var (key, val) in dict)
        {
            string memberName = key.ToString() ?? throw new InvalidDataException("Dictionary key cannot be null");
            var memberInfo = ReflectionUtils.GetMemberInfo(targetType, memberName);
            var memberActualType = ReflectionUtils.GetMemberType(memberInfo);
            var convertedValue = ConvertValue(memberActualType, val);
            ReflectionUtils.SetMemberValue(instance, memberInfo, convertedValue);
        }

        return instance;
    }

    private static object ConvertList(Type targetType, IList list)
    {
        if (targetType == typeof(List<int>))
        {
            return list.Cast<object>().Select(Convert.ToInt32).ToList();
        }

        if (targetType == typeof(Vector2))
        {
            return ParseVector2(list);
        }

        if (targetType == typeof(Color))
        {
            return ParseColor(list);
        }

        if (targetType.IsGenericType && targetType.GetGenericTypeDefinition() == typeof(List<>))
        {
            Type itemType = targetType.GetGenericArguments()[0];
            var genericList = (IList)Activator.CreateInstance(targetType)!;

            foreach (object? item in list)
            {
                genericList.Add(Convert.ChangeType(item, itemType, CultureInfo.InvariantCulture));
            }

            return genericList;
        }

        throw new NotSupportedException($"Unsupported list conversion to type {targetType}");
    }

    private static object ConvertPrimitive(Type targetType, object value)
    {
        string stringValue = value?.ToString()?.TrimQuotes().Trim() ?? "";
        if (targetType.IsEnum)
        {
            if (targetType.Name == "AnchorPreset")            {
                string currentValidNames = string.Join(", ", Enum.GetNames(targetType));
                Log.Info($"[ValueConversionUtils] Attempting to parse for enum '{targetType.FullName}' (from Assembly: '{targetType.Assembly.FullName}'): Value='{stringValue}', Available Enum Names: [{currentValidNames}]");
            }

            try
            {
                return Enum.Parse(targetType, stringValue, true);
            }
            catch (ArgumentException ex)            {
                string validNames = string.Join(", ", Enum.GetNames(targetType));
                string assemblyName = targetType.Assembly.FullName ?? "Unknown Assembly";
                Log.Error($"[ValueConversionUtils] ArgumentException during Enum.Parse. Target Enum: '{targetType.FullName}' (from Assembly: '{assemblyName}'), Value: '{stringValue}', Message: '{ex.Message}'. Valid names for this enum: [{validNames}]");
                throw new InvalidOperationException($"Failed to parse enum '{targetType.FullName}' (from Assembly: '{assemblyName}') from value '{stringValue}'. Valid values are: [{validNames}]. Ensure no extra whitespace and correct casing (ignored).", ex);
            }
            catch (Exception ex)            {
                string validNames = string.Join(", ", Enum.GetNames(targetType));
                string assemblyName = targetType.Assembly.FullName ?? "Unknown Assembly";
                Log.Error($"[ValueConversionUtils] Generic Exception during Enum.Parse. Target Enum: '{targetType.FullName}' (from Assembly: '{assemblyName}'), Value: '{stringValue}', Message: '{ex.Message}'. Valid names for this enum: [{validNames}]");
                throw new InvalidOperationException($"An unexpected error occurred while parsing enum '{targetType.FullName}' (from Assembly: '{assemblyName}') from value '{stringValue}'. Valid values are: [{validNames}].", ex);
            }
        }

        TypeCode typeCode = Type.GetTypeCode(targetType);

        try
        {
            switch (typeCode)
            {
                case TypeCode.Int32:
                    return int.Parse(stringValue, CultureInfo.InvariantCulture);

                case TypeCode.UInt32:
                    return uint.Parse(stringValue, CultureInfo.InvariantCulture);

                case TypeCode.Single:
                    return float.Parse(stringValue, CultureInfo.InvariantCulture);

                case TypeCode.Double:
                    return double.Parse(stringValue, CultureInfo.InvariantCulture);

                case TypeCode.Boolean:
                    return bool.Parse(stringValue);

                case TypeCode.String:
                    return stringValue;            }
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException($"Failed to convert primitive value '{stringValue}' to type {targetType.Name}.", ex);
        }

        if (targetType == typeof(AudioStream))
        {
            return ResourceLoader.Load<AudioStream>(stringValue)!;
        }

        if (targetType == typeof(Sound))
        {
            return ResourceLoader.Load<Sound>(stringValue)!;
        }

        if (targetType == typeof(Animation))
        {
            return ResourceLoader.Load<Animation>(stringValue)!;
        }

        if (targetType == typeof(Texture))
        {
            return ResourceLoader.Load<Texture>(stringValue)!;
        }

        if (targetType == typeof(Font))
        {
            return ResourceLoader.Load<Font>(stringValue)!;
        }

        try
        {
            return Convert.ChangeType(stringValue, targetType, CultureInfo.InvariantCulture);
        }
        catch (Exception ex)
        {
            throw new NotSupportedException($"Unsupported primitive/resource type conversion from '{value?.GetType().Name ?? "null"}' to '{targetType.Name}' for value '{stringValue}'.", ex);
        }
    }

    private static Vector2 ParseVector2(IList list)
    {
        if (list.Count != 2)
        {
            throw new ArgumentException($"Vector2 requires exactly 2 elements, got {list.Count}");
        }

        try
        {
            var x = Convert.ToSingle(list[0], CultureInfo.InvariantCulture);
            var y = Convert.ToSingle(list[1], CultureInfo.InvariantCulture);
            return new Vector2(x, y);
        }
        catch (Exception ex)
        {
            throw new ArgumentException($"Failed to parse Vector2 elements: {ex.Message}", ex);
        }
    }

    private static Color ParseColor(IList list)
    {
        if (list.Count < 3 || list.Count > 4)
        {
            throw new ArgumentException($"Color requires 3 or 4 elements (R, G, B, [A]), got {list.Count}");
        }

        try
        {
            float r = ConvertToFloatColor(list[0]);
            float g = ConvertToFloatColor(list[1]);
            float b = ConvertToFloatColor(list[2]);
            float a = list.Count > 3 ? ConvertToFloatColor(list[3]) : 1.0f;

            return new Color(r, g, b, a);
        }
        catch (Exception ex)
        {
            throw new ArgumentException($"Failed to parse Color elements: {ex.Message}", ex);
        }
    }

    private static float ConvertToFloatColor(object component)
    {
        float value = Convert.ToSingle(component, CultureInfo.InvariantCulture);

        return value > 1.0f && value <= 255.0f
            ? value / 255.0f
            : float.Clamp(value, 0.0f, 1.0f);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Servers\ApplicationServer.cs">
using System.Diagnostics;
using System.Reflection;
using YamlDotNet.Serialization;

namespace Cherris;

public sealed class ApplicationServer
{
    private static readonly Lazy<ApplicationServer> lazyInstance = new(() => new ApplicationServer());
    private MainAppWindow? mainWindow;
    private Configuration? applicationConfig;
    private readonly List<SecondaryWindow> secondaryWindows = new();

    private const string ConfigFilePath = "Res/Cherris/Config.yaml";
    private const string LogFilePath = "Res/Cherris/Log.txt";

    public static ApplicationServer Instance => lazyInstance.Value;

    private readonly Stopwatch deltaTimeStopwatch = new();
    private long lastDeltaTimeTicks = 0;
    private const float MAX_DELTA_TIME = 1f / 30f;
    private ApplicationServer()
    {

    }

    public IntPtr GetMainWindowHandle()
    {
        return mainWindow?.Handle ?? IntPtr.Zero;
    }

    public MainAppWindow? GetMainAppWindow()
    {
        return mainWindow;
    }

    public void Run()
    {
        if (!Start())
        {
            Log.Error("ApplicationCore failed to start.");
            return;
        }

        if (mainWindow is null)
        {
            Log.Error("Main window was not initialized.");
            return;
        }

        deltaTimeStopwatch.Start();
        lastDeltaTimeTicks = deltaTimeStopwatch.ElapsedTicks;

        MainLoop();

        Log.Info("Main loop exited. Application exiting.");
        Cleanup();
    }

    private bool Start()
    {
        CreateLogFile();
        SetCurrentDirectory();

        applicationConfig = LoadConfig();
        if (applicationConfig is null)
        {
            Log.Error("Failed to load configuration.");
            return false;
        }

        try
        {
            mainWindow = new MainAppWindow(
                applicationConfig.Title,
                applicationConfig.Width,
                applicationConfig.Height);

            if (!mainWindow.TryCreateWindow())
            {
                Log.Error("Failed to create main window.");
                return false;
            }

            mainWindow.Closed += OnMainWindowClosed;

            if (mainWindow != null && applicationConfig != null)
            {
                mainWindow.VSyncEnabled = applicationConfig.VSync;
                mainWindow.BackdropType = applicationConfig.BackdropType;
            }

            if (!mainWindow.InitializeWindowAndGraphics())
            {
                Log.Error("Failed to initialize main window graphics.");
                return false;
            }

            ApplyConfig();

            mainWindow.ShowWindow();
        }
        catch (Exception ex)
        {
            Log.Error($"Error during window initialization: {ex.Message}");
            return false;
        }

        return true;
    }

    private void MainLoop()
    {
        while (mainWindow != null && mainWindow.IsOpen)
        {
            long currentTicks = deltaTimeStopwatch.ElapsedTicks;
            long elapsedFrameTicks = currentTicks - lastDeltaTimeTicks;

            float rawDeltaTime = (float)elapsedFrameTicks / TimeSpan.TicksPerSecond;
            Time.Delta = Math.Max(0.0f, rawDeltaTime);
            Time.Delta = Math.Min(Time.Delta, MAX_DELTA_TIME);

            lastDeltaTimeTicks = currentTicks;

            ProcessSystemMessages();

            ClickServer.Instance.Process();
            SceneTree.Instance.Process();

            mainWindow.RenderFrame();
            RenderSecondaryWindows();

            Input.Update();
        }
    }

    private void ProcessSystemMessages()
    {
        while (NativeMethods.PeekMessage(out NativeMethods.MSG msg, IntPtr.Zero, 0, 0, NativeMethods.PM_REMOVE))
        {
            if (msg.message == NativeMethods.WM_QUIT)
            {
                Log.Info("WM_QUIT received, signaling application close.");
                mainWindow?.Close();
                break;
            }

            NativeMethods.TranslateMessage(ref msg);
            NativeMethods.DispatchMessage(ref msg);
        }
    }

    private void RenderSecondaryWindows()
    {
        List<SecondaryWindow> windowsToRender = new(secondaryWindows);

        foreach (SecondaryWindow window in windowsToRender)
        {
            if (window.IsOpen)
            {
                window.RenderFrame();
            }
            else
            {
                secondaryWindows.Remove(window);
            }
        }
    }

    private void OnMainWindowClosed()
    {
        Log.Info("Main window closed signal received. Closing secondary windows.");
        CloseAllSecondaryWindows();
    }

    private void Cleanup()
    {
        Log.Info("ApplicationCore Cleanup starting.");
        CloseAllSecondaryWindows();
        mainWindow?.Dispose();
        mainWindow = null;
        deltaTimeStopwatch.Stop();
        Log.Info("ApplicationCore Cleanup finished.");
    }

    private void CloseAllSecondaryWindows()
    {
        var windowsToClose = new List<SecondaryWindow>(secondaryWindows);
        foreach (var window in windowsToClose)
        {
            window.Close();
        }
    }

    internal void RegisterSecondaryWindow(SecondaryWindow window)
    {
        if (!secondaryWindows.Contains(window))
        {
            secondaryWindows.Add(window);
            Log.Info($"Registered secondary window: {window.Title}");
        }
    }

    internal void UnregisterSecondaryWindow(SecondaryWindow window)
    {
        if (secondaryWindows.Remove(window))
        {
            Log.Info($"Unregistered secondary window: {window.Title}");
        }
    }

    private static void SetRootNodeFromConfig(string scenePath)
    {
        if (string.IsNullOrEmpty(scenePath))
        {
            Log.Warning("MainScenePath is not defined in the configuration.");
            return;
        }

        try
        {
            var packedScene = new PackedScene(scenePath);
            SceneTree.Instance.RootNode = packedScene.Instantiate<Node>();
            Log.Info($"Loaded main scene: {scenePath}");
        }
        catch (Exception ex)
        {
            Log.Error($"Failed to load main scene '{scenePath}': {ex.Message}");
            SceneTree.Instance.RootNode = new Node { Name = "ErrorRoot" };
        }
    }

    private static void CreateLogFile()
    {
        try
        {
            string? logDirectory = Path.GetDirectoryName(LogFilePath);
            if (!string.IsNullOrEmpty(logDirectory) && !Directory.Exists(logDirectory))
            {
                Directory.CreateDirectory(logDirectory);
            }

            if (File.Exists(LogFilePath))
            {
                File.Delete(LogFilePath);
            }

            using (File.Create(LogFilePath)) { }
            Log.Info($"Log file created at {Path.GetFullPath(LogFilePath)}");
        }
        catch (Exception ex)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine($"[FATAL] Failed to create log file: {ex.Message}");
            Console.ResetColor();
        }
    }

    private static void SetCurrentDirectory()
    {
        try
        {
            string? assemblyLocation = Assembly.GetEntryAssembly()?.Location;
            if (string.IsNullOrEmpty(assemblyLocation))
            {
                Log.Warning("Could not get assembly location.");
                return;
            }

            string? directoryName = Path.GetDirectoryName(assemblyLocation);
            if (string.IsNullOrEmpty(directoryName))
            {
                Log.Warning($"Could not get directory name from assembly location: {assemblyLocation}");
                return;
            }

            Environment.CurrentDirectory = directoryName;
            Log.Info($"Current directory set to: {directoryName}");
        }
        catch (Exception ex)
        {
            Log.Error($"Failed to set current directory: {ex.Message}");
        }
    }

    private Configuration? LoadConfig()
    {
        if (!File.Exists(ConfigFilePath))
        {
            Log.Error($"Configuration file not found: {ConfigFilePath}");
            return null;
        }

        try
        {
            var deserializer = new DeserializerBuilder().Build();
            string yaml = File.ReadAllText(ConfigFilePath);
            var config = deserializer.Deserialize<Configuration>(yaml);
            Log.Info("Configuration loaded successfully.");
            return config;
        }
        catch (Exception ex)
        {
            Log.Error($"Failed to load or parse configuration file '{ConfigFilePath}': {ex.Message}");
            return null;
        }
    }

    private void ApplyConfig()
    {
        if (applicationConfig is null)
        {
            Log.Error("Cannot apply configuration because it was not loaded.");
            return;
        }
        SetRootNodeFromConfig(applicationConfig.MainScenePath);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\Ui\Button.cs">
using Vortice.Mathematics;

namespace Cherris;

public class Button : Control
{
    public enum ActionMode { Release, Press }
    public enum ClickBehavior { Left, Right, Both }

    private bool pressedLeft = false;
    private bool pressedRight = false;
    private bool wasHovered = false;
    private string displayedText = "";

    public Vector2 TextOffset { get; set; } = Vector2.Zero;
    public HAlignment TextHAlignment { get; set; } = HAlignment.Center;
    public VAlignment TextVAlignment { get; set; } = VAlignment.Center;
    public ButtonStylePack Styles { get; set; } = new();
    public ActionMode LeftClickActionMode { get; set; } = ActionMode.Release;
    public ActionMode RightClickActionMode { get; set; } = ActionMode.Release;
    public ClickBehavior Behavior { get; set; } = ClickBehavior.Left;
    public float AvailableWidth { get; set; } = 0;
    public bool StayPressed { get; set; } = false;
    public bool ClipText { get; set; } = false;
    public bool AutoWidth { get; set; } = false;
    public Vector2 TextMargin { get; set; } = new(2, 2);
    public string Ellipsis { get; set; } = "...";
    public Texture? Icon { get; set; } = null;
    public float IconMargin { get; set; } = 12;
    public Sound? ClickSound { get; set; }
    public Sound? HoverSound { get; set; }

    public string Text
    {
        get => displayedText;
        set
        {
            if (displayedText == value)            {
                return;
            }

            displayedText = value;        }
    }

    public event Action? LeftClicked;
    public event Action? RightClicked;
    public event Action? MouseEntered;
    public event Action? MouseExited;

    public Button()
    {
        Size = new(100, 26);
        Offset = Vector2.Zero;
        OriginPreset = OriginPreset.None;

        WasDisabled += (button) =>
        {
            Styles.Current = Disabled
            ? Styles.Disabled
            : Styles.Normal;
        };
    }

    public override void Process()
    {
        base.Process();

        if (Disabled)
        {
            return;
        }

        HandleClicks();
        HandleKeyboardInput();
    }

    protected virtual void OnEnterPressed() { }

    private void HandleKeyboardInput()
    {
        bool enterPressed = Input.IsKeyPressed(KeyCode.Enter);

        if (!Focused || !enterPressed)
        {
            return;
        }

        bool invoked = false;
        if (Behavior == ClickBehavior.Left || Behavior == ClickBehavior.Both)
        {
            LeftClicked?.Invoke();
            invoked = true;
        }

        if (Behavior == ClickBehavior.Right || Behavior == ClickBehavior.Both)
        {
            RightClicked?.Invoke();
            invoked = true;
        }

        if (invoked)
        {
            ClickSound?.Play(AudioBus);
            OnEnterPressed();
        }
    }

    private void HandleClicks()
    {
        bool isMouseOver = IsMouseOver();
        bool leftClickInvoked = false;
        bool rightClickInvoked = false;

        if (Behavior == ClickBehavior.Left || Behavior == ClickBehavior.Both)
        {
            leftClickInvoked = HandleSingleClick(
                ref pressedLeft,
                MouseButtonCode.Left,
                LeftClickActionMode,
                LeftClicked);
        }

        if (Behavior == ClickBehavior.Right || Behavior == ClickBehavior.Both)
        {
            rightClickInvoked = HandleSingleClick(
                ref pressedRight,
                MouseButtonCode.Right,
                RightClickActionMode,
                RightClicked);
        }

        HandleHover(isMouseOver);
        UpdateTheme(isMouseOver, pressedLeft || pressedRight);
    }

    private bool HandleSingleClick(ref bool pressedState, MouseButtonCode button, ActionMode mode, Action? handler)
    {
        bool invoked = false;
        bool mouseOver = IsMouseOver();
        bool buttonPressedThisFrame = Input.IsMouseButtonPressed(button);
        bool buttonReleasedThisFrame = Input.IsMouseButtonReleased(button);

        if (mouseOver && buttonPressedThisFrame && !Disabled)
        {
            pressedState = true;
            HandleClickFocus();

            if (mode == ActionMode.Press)
            {
                handler?.Invoke();
                ClickSound?.Play(AudioBus);
                invoked = true;
            }
        }

        if (!buttonReleasedThisFrame || !pressedState)
        {
            return invoked;
        }

        if (!Disabled && mouseOver && mode == ActionMode.Release)
        {
            handler?.Invoke();
            ClickSound?.Play(AudioBus);
            invoked = true;
        }

        if (!StayPressed)
        {
            pressedState = false;
        }
        else if (!mouseOver && mode == ActionMode.Release)
        {
            pressedState = false;
        }
        else if (mode == ActionMode.Press && !mouseOver)
        {
            pressedState = false;
        }

        return invoked;
    }

    private void HandleHover(bool isMouseOver)
    {
        if (Disabled)
        {
            if (wasHovered)
            {
                wasHovered = false;
                MouseExited?.Invoke();
            }

            return;
        }

        if (isMouseOver && !wasHovered)
        {
            MouseEntered?.Invoke();
            HoverSound?.Play(AudioBus);
            wasHovered = true;
        }
        else if (wasHovered && !isMouseOver)        {
            wasHovered = false;
            MouseExited?.Invoke();
        }
    }

    private void UpdateTheme(bool isMouseOver, bool isPressedForStayPressed)
    {
        if (Disabled)
        {
            Styles.Current = Styles.Disabled;
            return;
        }

        bool isLeftDown = (Behavior == ClickBehavior.Left || Behavior == ClickBehavior.Both) && Input.IsMouseButtonDown(MouseButtonCode.Left);
        bool isRightDown = (Behavior == ClickBehavior.Right || Behavior == ClickBehavior.Both) && Input.IsMouseButtonDown(MouseButtonCode.Right);

        bool isPhysicallyHeldDown = isMouseOver && (isLeftDown || isRightDown);

        if (isPressedForStayPressed && StayPressed)
        {
            Styles.Current = Styles.Pressed;
        }
        else if (isPhysicallyHeldDown)
        {
            Styles.Current = Styles.Pressed;
        }
        else if (Focused)
        {
            Styles.Current = isMouseOver ? Styles.Hover : Styles.Focused;
        }
        else if (isMouseOver)
        {
            Styles.Current = Styles.Hover;
        }
        else
        {
            Styles.Current = Styles.Normal;
        }
    }

    protected override void OnThemeFileChanged(string themeFile)
    {
        Log.Warning($"OnThemeFileChanged not fully implemented for Button: {themeFile}");
    }

    public override void Draw(DrawingContext context)
    {
        if (!Visible)
        {
            return;
        }

        DrawButtonBackground(context);
        DrawIcon(context);        DrawButtonText(context);
    }

    protected virtual void DrawButtonBackground(DrawingContext context)
    {
        Vector2 position = GlobalPosition - Origin;
        Vector2 size = ScaledSize;
        Rect bounds = new(position.X, position.Y, size.X, size.Y);

        DrawStyledRectangle(context, bounds, Styles.Current);
    }

    private void DrawIcon(DrawingContext context)    {
        if (Icon is null || context.RenderTarget is null)
        {
            return;
        }

        Log.Warning("DrawIcon is not implemented.");
    }

    protected virtual void DrawButtonText(DrawingContext context)
    {
        if (Styles.Current is null || string.IsNullOrEmpty(displayedText))        {
            return;
        }

        Vector2 position = GlobalPosition - Origin;
        Vector2 size = ScaledSize;
        float textStartX = position.X + TextMargin.X + TextOffset.X;
        float textAvailableWidth = Math.Max(0, size.X - TextMargin.X * 2);

        if (Icon != null)
        {
            Log.Warning("Button.DrawButtonText icon adjustment not fully implemented.");
        }


        var textLayoutRect = new Rect(
            textStartX,
            position.Y + TextMargin.Y + TextOffset.Y,
            textAvailableWidth,
            Math.Max(0, size.Y - TextMargin.Y * 2)
        );

        DrawFormattedText(
            context,
            displayedText,            textLayoutRect,
            Styles.Current,
            TextHAlignment,
            TextVAlignment
        );
    }

    private void ResizeToFitText()
    {
        if (!AutoWidth || Styles?.Current is null)
        {
            return;
        }

        Log.Warning("ResizeToFitText requires DirectWrite implementation.");
    }

    private void ClipDisplayedText()
    {
        if (!ClipText || string.IsNullOrEmpty(Text) || Styles?.Current is null)
        {
            return;
        }

        Log.Warning("ClipDisplayedText requires DirectWrite implementation.");
    }

    private string GetTextClippedWithEllipsis(string input)
    {
        if (input.Length > Ellipsis.Length)
        {
            return input.Substring(0, input.Length - Ellipsis.Length) + Ellipsis;
        }
        return input;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\Ui\HBoxContainer.cs">
using System.Linq;
using System.Numerics;

namespace Cherris;

public class HBoxContainer : Node2D
{
    public float Separation { get; set; } = 4f;
    public HAlignment ContentHAlignment { get; set; } = HAlignment.Center;

    public override void Process()
    {
        base.Process();
        UpdateLayout();
    }

    protected override Vector2 ComputeAutoSize()
    {
        var visibleNode2DChildren = Children.OfType<Node2D>().Where(c => c.Visible).ToList();
        float requiredWidth = 0;
        float maxHeight = 0;

        if (visibleNode2DChildren.Any())
        {
            foreach (Node2D child in visibleNode2DChildren)
            {
                requiredWidth += child.Size.X;
                maxHeight = Math.Max(maxHeight, child.Size.Y);
            }
            requiredWidth += (visibleNode2DChildren.Count - 1) * Separation;
        }
        return new Vector2(requiredWidth, maxHeight);
    }

    private void UpdateLayout()
    {
        var visibleNode2DChildren = Children.OfType<Node2D>().Where(c => c.Visible).ToList();

        float containerWidth = this.Size.X;
        float containerHeight = this.Size.Y;

        float totalRequiredContentWidth = 0;
        if (visibleNode2DChildren.Any())
        {
            foreach (Node2D child in visibleNode2DChildren)
            {
                totalRequiredContentWidth += child.Size.X;
            }
            totalRequiredContentWidth += (visibleNode2DChildren.Count - 1) * Separation;
        }

        float visualLeftLocalX = 0f;
        if (this.HAlignment == HAlignment.Center)
        {
            visualLeftLocalX = -containerWidth / 2f;
        }
        else if (this.HAlignment == HAlignment.Right)
        {
            visualLeftLocalX = -containerWidth;
        }

        float childVisualStartX_local;
        switch (this.ContentHAlignment)
        {
            case HAlignment.Left:
                childVisualStartX_local = visualLeftLocalX;
                break;
            case HAlignment.Center:
                childVisualStartX_local = visualLeftLocalX + (containerWidth - totalRequiredContentWidth) / 2f;
                break;
            case HAlignment.Right:
                childVisualStartX_local = visualLeftLocalX + containerWidth - totalRequiredContentWidth;
                break;
            case HAlignment.None:
            default:
                childVisualStartX_local = visualLeftLocalX;
                break;
        }

        float currentVisualX = childVisualStartX_local;
        foreach (Node2D child in visibleNode2DChildren)
        {
            float visualTopLocalY = 0f;
            if (this.VAlignment == VAlignment.Center) visualTopLocalY = -containerHeight / 2f;
            else if (this.VAlignment == VAlignment.Bottom) visualTopLocalY = -containerHeight;

            float childVisualTargetY_local;            switch (child.VAlignment)
            {
                case VAlignment.Top:
                    childVisualTargetY_local = visualTopLocalY;
                    break;
                case VAlignment.Center:
                    childVisualTargetY_local = visualTopLocalY + (containerHeight - child.Size.Y) / 2f;
                    break;
                case VAlignment.Bottom:
                    childVisualTargetY_local = visualTopLocalY + containerHeight - child.Size.Y;
                    break;
                case VAlignment.None:
                default:
                    childVisualTargetY_local = visualTopLocalY;
                    break;
            }
            child.Position = new Vector2(currentVisualX + child.Origin.X, childVisualTargetY_local + child.Origin.Y);

            currentVisualX += child.Size.X;
            if (visibleNode2DChildren.IndexOf(child) < visibleNode2DChildren.Count - 1)
            {
                currentVisualX += Separation;
            }
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Resources\Cache\AnimationCache.cs">
namespace Cherris;

public class AnimationCache
{
    private static AnimationCache? _instance;
    public static AnimationCache Instance => _instance ??= new AnimationCache();

    private readonly Dictionary<string, Animation> animations = [];

    private AnimationCache() { }

    public Animation Get(string animationPath)
    {
        if (animations.TryGetValue(animationPath, out Animation? animation))
        {
            return animation;
        }

        Animation newAnimation = new(animationPath);
        return newAnimation;
    }

    public void Dispose()
    {
        animations.Clear();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Resources\Cache\AudioStreamCache.cs">
namespace Cherris;

public class AudioStreamCache
{
    public static AudioStreamCache? Instance => field ??= new();

    private readonly Dictionary<string, AudioStream?> audioStreams = [];

    private AudioStreamCache() { }

    public AudioStream? Get(string filePath)
    {
        if (audioStreams.TryGetValue(filePath, out AudioStream? audio))
        {
            return audio;
        }

        AudioStream? newAudio = AudioStream.Load(filePath);

        if (newAudio is null)
        {
            Log.Error($"Could not load audio stream: {filePath}");
            return null;
        }

        audioStreams[filePath] = newAudio;
        return newAudio;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Resources\Cache\FontCache.cs">
namespace Cherris;

public sealed class FontCache
{
    public static FontCache? Instance => field ??= new();

    private readonly Dictionary<string, Font> fonts = [];

    private FontCache() { }

    public Font Get(string fontKey)
    {
        if (fonts.TryGetValue(fontKey, out Font? font))
        {
            return font;
        }

        (string fontPath, int fontSize) = ParseFontKey(fontKey);
        Font newFont = new(fontPath, fontSize);
        fonts.Add(fontKey, newFont);

        return newFont;
    }

    private static (string fontPath, int fontSize) ParseFontKey(string fontKey)
    {
        int colonIndex = fontKey.LastIndexOf(':');

        if (colonIndex == -1)
        {
            throw new ArgumentException($"Invalid font key format: {fontKey}. Expected format: 'FontPath:WindowSize'.");
        }

        string fontPath = fontKey[..colonIndex];
        string sizeString = fontKey[(colonIndex + 1)..];

        if (!int.TryParse(sizeString, out int fontSize))
        {
            throw new ArgumentException($"Invalid font size in: {fontKey}. WindowSize must be a valid integer.");
        }

        return (fontPath, fontSize);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Resources\Cache\ShaderCache.cs">
/*
namespace Cherris;

public class ShaderCache
{
    public static ShaderCache Instance { get; } = new();

    private readonly Dictionary<string, Shader?> shaders = [];

    private ShaderCache() { }

    public Shader? Get(string key)
    {
        if (shaders.TryGetValue(key, out Shader? shader))
        {
            return shader;
        }

        var newSound = Shad.Load(key);

        if (newSound is null)
        {
            Log.Error($"[SoundCache] Could not load sound: {key}");
        }

        shaders[key] = newSound;
        return newSound;
    }
}
*/
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Resources\Cache\SoundCache.cs">
namespace Cherris;

public class SoundCache
{
    public static SoundCache? Instance => field ??= new();

    private readonly Dictionary<string, Sound?> soundEffects = [];

    private SoundCache() { }

    public Sound? Get(string soundKey)
    {
        if (soundEffects.TryGetValue(soundKey, out Sound? soundEffect))
        {
            return soundEffect;
        }

        Sound? newSound = Sound.Load(soundKey);

        if (newSound is null)
        {
            Log.Error($"Could not load sound: {soundKey}");
        }

        soundEffects[soundKey] = newSound;
        return newSound;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Resources\Cache\TextureCache.cs">
namespace Cherris;

public sealed class TextureCache
{
    public static TextureCache? Instance => field ??= new();

    private readonly Dictionary<string, Texture> textures = [];

    private TextureCache() { }

    public Texture Get(string path)
    {
        if (textures.TryGetValue(path, out Texture? value))
        {
            return value;
        }

        Texture textureWrapper = new(path);
        textures[path] = textureWrapper;

        return textureWrapper;
    }

    public void Remove(string path)
    {
        if (textures.TryGetValue(path, out Texture? value))
        {
            textures.Remove(path);

            string pngPath = GetPngPath(path);

            if (pngPath != path && File.Exists(pngPath))
            {
                File.Delete(pngPath);
            }
        }
    }

    private string GetPngPath(string path)
    {
        string pngPath =
            Path.GetExtension(path).ToLower() == ".png" ?
            path :
            $"Res/Temporary/{Path.GetFileNameWithoutExtension(path)}.png";

        return pngPath;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\Ui\LineEdit\CharacterSet.cs">
namespace Cherris;

public static class CharacterSet
{
    public static readonly List<char> Numbers = new(new[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' });
    public static readonly List<char> Mathematics = new(new[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-', '*', '/', '(', ')', '.' });
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\Ui\LineEdit\LineEdit.BaseText.cs">
using Vortice.Mathematics;

namespace Cherris;

public partial class LineEdit
{
    private abstract class BaseText : VisualItem
    {
        protected LineEdit parentLineEdit;
        private Vector2 _textOffset = Vector2.Zero;
        public BaseText(LineEdit parent)
        {
            parentLineEdit = parent;
            Visible = false;
        }

        public Vector2 TextOffset
        {
            get => _textOffset;
            set => _textOffset = value;
        }

        public override void Draw(DrawingContext context)
        {
            if (!parentLineEdit.Visible || ShouldSkipDrawing() || string.IsNullOrEmpty(GetTextToDisplay()))
            {
                return;
            }

            Rect layoutRect = GetLayoutRect();

            parentLineEdit.DrawFormattedText(
                context,
                GetTextToDisplay(),
                layoutRect,
                parentLineEdit.Styles.Current,                HAlignment.Left,                VAlignment.Center);        }

        protected Rect GetLayoutRect()
        {
            Vector2 lineEditVisualTopLeft = parentLineEdit.GlobalPosition - parentLineEdit.Origin;
            Vector2 lineEditSize = parentLineEdit.Size;
            float textRenderAreaX = lineEditVisualTopLeft.X + parentLineEdit.TextOrigin.X + TextOffset.X;
            float textRenderAreaY = lineEditVisualTopLeft.Y + parentLineEdit.TextOrigin.Y + TextOffset.Y;
            float textRenderAreaWidth = lineEditSize.X - parentLineEdit.TextOrigin.X * 2;            float textRenderAreaHeight = lineEditSize.Y - parentLineEdit.TextOrigin.Y * 2;

            return new Rect(textRenderAreaX, textRenderAreaY, Math.Max(0, textRenderAreaWidth), Math.Max(0, textRenderAreaHeight));
        }

        protected abstract string GetTextToDisplay();
        protected abstract bool ShouldSkipDrawing();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\Ui\LineEdit\LineEdit.Caret.cs">
using System.Globalization;using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace Cherris;

public partial class LineEdit
{
    protected class Caret : VisualItem
    {
        public float MaxTime { get; set; } = 0.5f;
        private const byte MinAlphaByte = 0;
        private const byte MaxAlphaByte = 255;
        private float _timer = 0;
        private float _alpha = 1.0f;        private LineEdit _parentLineEdit;

        private float _arrowKeyTimer = 0f;
        private const float ArrowKeyDelay = 0.4f;
        private const float ArrowKeySpeed = 0.04f;
        private bool _movingRight = false;
        private int _caretDisplayPositionX;        public int CaretDisplayPositionX
        {
            get => _caretDisplayPositionX;
            set
            {
                var maxVisibleChars = Math.Max(0, Math.Min(_parentLineEdit.GetDisplayableCharactersCount(), _parentLineEdit.Text.Length - _parentLineEdit.TextStartIndex));
                _caretDisplayPositionX = Math.Clamp(value, 0, maxVisibleChars);
                _alpha = 1.0f;                _timer = 0f;            }
        }

        public Caret(LineEdit parent)
        {
            _parentLineEdit = parent;
            Visible = false;        }

        public void UpdateLogic()        {
            if (!_parentLineEdit.Selected || !_parentLineEdit.Editable) return;

            HandleKeyboardInput();
            HandleMouseInput();
            UpdateAlpha();
        }

        public override void Draw(DrawingContext context)
        {
            if (!_parentLineEdit.Selected || !_parentLineEdit.Editable || !Visible || _alpha <= 0.01f)
            {
                return;
            }

            Rect layoutRect = GetCaretLayoutRect(context);
            if (layoutRect.Width <= 0 || layoutRect.Height <= 0) return;

            ButtonStyle caretStyle = new ButtonStyle
            {
                FontName = _parentLineEdit.Styles.Current.FontName,
                FontSize = _parentLineEdit.Styles.Current.FontSize,
                FontWeight = _parentLineEdit.Styles.Current.FontWeight,
                FontStyle = _parentLineEdit.Styles.Current.FontStyle,
                FontStretch = _parentLineEdit.Styles.Current.FontStretch,
                FontColor = new Color4(_parentLineEdit.Styles.Current.FontColor.R, _parentLineEdit.Styles.Current.FontColor.G, _parentLineEdit.Styles.Current.FontColor.B, _alpha),
                WordWrapping = WordWrapping.NoWrap
            };

            _parentLineEdit.DrawFormattedText(
                context,
                "|",
                layoutRect,
                caretStyle,
                HAlignment.Left,
                VAlignment.Center);
        }

        private void HandleKeyboardInput()
        {
            bool rightPressed = Input.IsKeyPressed(KeyCode.RightArrow);
            bool leftPressed = Input.IsKeyPressed(KeyCode.LeftArrow);

            if (rightPressed || leftPressed)
            {
                _movingRight = rightPressed;
                _arrowKeyTimer = 0f;
                MoveCaret(_movingRight ? 1 : -1);
            }
            else if (Input.IsKeyDown(KeyCode.RightArrow) || Input.IsKeyDown(KeyCode.LeftArrow))
            {
                if (Input.IsKeyDown(KeyCode.RightArrow)) _movingRight = true;
                else if (Input.IsKeyDown(KeyCode.LeftArrow)) _movingRight = false;

                _arrowKeyTimer += Time.Delta;
                if (_arrowKeyTimer >= ArrowKeyDelay)
                {
                    if ((_arrowKeyTimer - ArrowKeyDelay) % ArrowKeySpeed < Time.Delta)                    {
                        MoveCaret(_movingRight ? 1 : -1);
                    }
                }
            }
            else            {
                _arrowKeyTimer = 0f;
            }
        }

        private void HandleMouseInput()
        {
            if (Input.IsMouseButtonPressed(MouseButtonCode.Left))
            {
                Vector2 localMousePos = _parentLineEdit.GetLocalMousePosition();                Vector2 lineEditVisualTopLeft = _parentLineEdit.GlobalPosition - _parentLineEdit.Origin;
                Rect lineEditBounds = new Rect(
                    lineEditVisualTopLeft.X, lineEditVisualTopLeft.Y,
                    _parentLineEdit.Size.X, _parentLineEdit.Size.Y);

                if (lineEditBounds.Contains(localMousePos.X, localMousePos.Y))
                {
                    MoveCaretToMousePosition(localMousePos);
                }
            }
        }


        private void MoveCaret(int direction)
        {

            int newLogicalPos = _parentLineEdit.CaretLogicalPosition + direction;
            _parentLineEdit.CaretLogicalPosition = Math.Clamp(newLogicalPos, 0, _parentLineEdit.Text.Length);
            _parentLineEdit.UpdateCaretDisplayPositionAndStartIndex();
        }

        public void MoveCaretToMousePosition(Vector2 localMousePos)        {
            if (_parentLineEdit.Text.Length == 0)
            {
                _parentLineEdit.CaretLogicalPosition = 0;
                _parentLineEdit.UpdateCaretDisplayPositionAndStartIndex();
                return;
            }

            Direct2DAppWindow? owningWindow = _parentLineEdit.GetOwningWindow() as Direct2DAppWindow;
            if (owningWindow == null || owningWindow.DWriteFactory == null) return;            IDWriteFactory dwriteFactory = owningWindow.DWriteFactory;
            Vector2 lineEditVisualTopLeft = _parentLineEdit.GlobalPosition - _parentLineEdit.Origin;
            Vector2 textRenderAreaVisualTopLeft = lineEditVisualTopLeft + _parentLineEdit.TextOrigin;
            float mouseXInTextRenderArea = localMousePos.X - textRenderAreaVisualTopLeft.X;


            string visibleText = _parentLineEdit.Text.Substring(
                _parentLineEdit.TextStartIndex,
                Math.Min(_parentLineEdit.GetDisplayableCharactersCount(), _parentLineEdit.Text.Length - _parentLineEdit.TextStartIndex)
            );

            if (string.IsNullOrEmpty(visibleText))
            {
                _parentLineEdit.CaretLogicalPosition = (mouseXInTextRenderArea < 0 && _parentLineEdit.TextStartIndex > 0) ? _parentLineEdit.TextStartIndex : _parentLineEdit.TextStartIndex;
                _parentLineEdit.UpdateCaretDisplayPositionAndStartIndex();
                return;
            }

            IDWriteTextFormat? textFormat = owningWindow.GetOrCreateTextFormat(_parentLineEdit.Styles.Current);
            if (textFormat == null) return;

            using IDWriteTextLayout textLayout = dwriteFactory.CreateTextLayout(
                visibleText,
                textFormat,
                _parentLineEdit.Size.X,
                _parentLineEdit.Size.Y
            );

            textLayout.WordWrapping = WordWrapping.NoWrap;

            textLayout.HitTestPoint(mouseXInTextRenderArea, 0, out var isTrailingHit, out var isInside, out var metrics);

            int newCaretIndexInVisibleText = (int)metrics.TextPosition;
            if (isTrailingHit) newCaretIndexInVisibleText = (int)metrics.TextPosition + (int)metrics.Length;


            _parentLineEdit.CaretLogicalPosition = _parentLineEdit.TextStartIndex + Math.Clamp(newCaretIndexInVisibleText, 0, visibleText.Length);
            _parentLineEdit.UpdateCaretDisplayPositionAndStartIndex();
        }


        private Rect GetCaretLayoutRect(DrawingContext context)
        {
            Vector2 lineEditVisualTopLeft = _parentLineEdit.GlobalPosition - _parentLineEdit.Origin;
            Vector2 textRenderAreaVisualTopLeft = lineEditVisualTopLeft + _parentLineEdit.TextOrigin;

            float caretXOffset = 0;

            if (CaretDisplayPositionX > 0 && _parentLineEdit.Text.Length > 0)
            {
                int lengthOfTextBeforeCaretInVisiblePortion = Math.Min(CaretDisplayPositionX, _parentLineEdit.Text.Length - _parentLineEdit.TextStartIndex);

                if (lengthOfTextBeforeCaretInVisiblePortion > 0)                {
                    string textBeforeCaret = _parentLineEdit.Text.Substring(
                        _parentLineEdit.TextStartIndex,
                        lengthOfTextBeforeCaretInVisiblePortion
                    );

                    if (!string.IsNullOrEmpty(textBeforeCaret))                    {
                        var dwriteFactory = context.DWriteFactory;
                        var owningWindow = context.OwnerWindow;
                        IDWriteTextFormat? textFormat = owningWindow?.GetOrCreateTextFormat(_parentLineEdit.Styles.Current);

                        if (textFormat != null)
                        {
                            textFormat.WordWrapping = WordWrapping.NoWrap;
                            using IDWriteTextLayout textLayout = dwriteFactory.CreateTextLayout(
                                textBeforeCaret,
                                textFormat,
                                float.MaxValue,
                                _parentLineEdit.Size.Y);
                            caretXOffset = textLayout.Metrics.WidthIncludingTrailingWhitespace;                        }
                    }
                }
            }

            float caretWidth = _parentLineEdit.MeasureSingleCharWidth(context, "|", _parentLineEdit.Styles.Current);
            if (caretWidth <= 0) caretWidth = 2;

            float caretRectX = textRenderAreaVisualTopLeft.X + caretXOffset - caretWidth / 2f;
            float caretRectY = textRenderAreaVisualTopLeft.Y;
            float caretRectHeight = _parentLineEdit.Size.Y - _parentLineEdit.TextOrigin.Y * 2;


            return new Rect(
                caretRectX,
                caretRectY,
                caretWidth,
                Math.Max(0, caretRectHeight)
            );
        }


        private void UpdateAlpha()
        {
            _timer += Time.Delta;
            if (_timer > MaxTime)
            {
                _alpha = (_alpha == 1.0f) ? 0.0f : 1.0f;
                _timer = 0;
            }
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\Ui\LineEdit\LineEdit.cs">
using System.Globalization;
using SharpGen.Runtime;
using Vortice.DirectWrite;

namespace Cherris;

public partial class LineEdit : Button
{
    public static readonly Vector2 DefaultLineEditSize = new(200, 28);

    public new string Text
    {
        get;
        set
        {
            if (field == value) return;

            string oldText = field;
            field = value ?? "";

            if (field.Length > MaxCharacters)
            {
                field = field.Substring(0, MaxCharacters);
            }

            UpdateCaretDisplayPositionAndStartIndex();
            TextChanged?.Invoke(this, field);

            if (oldText.Length == 0 && field.Length > 0)
            {
                FirstCharacterEntered?.Invoke(this, EventArgs.Empty);
            }

            if (oldText.Length > 0 && field.Length == 0)
            {
                Cleared?.Invoke(this, EventArgs.Empty);
            }
        }
    } = "";

    public string PlaceholderText { get; set; } = "";
    public Vector2 TextOrigin { get; set; } = new(6, 0);
    public int MaxCharacters { get; set; } = int.MaxValue;
    public List<char> ValidCharacters { get; set; } = [];

    public bool Selected
    {
        get;
        set
        {
            if (field == value)
            {
                return;
            }

            field = value;
            _caret.Visible = field && Editable;
            
            if (!field)
            {
                _caret.CaretDisplayPositionX = 0;
            }
        }
    } = false;

    public bool Editable { get; set; } = true;
    public bool ExpandWidthToText { get; set; } = false;
    public bool Secret { get; set; } = false;
    public char SecretCharacter { get; set; } = '*';
    public bool AutoScrollToShowFullText { get; set; } = true;

    public int TextStartIndex { get; internal set; } = 0;

    internal int CaretLogicalPosition { get; set; } = 0;

    public event EventHandler? FirstCharacterEntered;
    public event EventHandler? Cleared;
    public event EventHandler<string>? TextChanged;
    public event EventHandler<string>? Confirmed;

    private readonly Caret _caret;
    private readonly TextDisplayer TextDisplayerSub;
    private readonly PlaceholderTextDisplayer _placeholderTextDisplayer;

    private const float BackspaceDelay = 0.5f;
    private const float BackspaceSpeed = 0.05f;
    private const float UndoDelay = 0.5f;
    private const float UndoSpeed = 0.05f;

    private float _backspaceTimer = 0f;
    private bool _backspaceHeld = false;
    private float _undoTimer = 0f;
    private bool _undoHeld = false;
    private bool _backspaceCtrlHeld = false;

    private readonly Stack<LineEditState> _undoStack = new();
    private readonly Stack<LineEditState> _redoStack = new();
    private const int HistoryLimit = 50;

    private char? _pendingCharInput = null;

    public LineEdit()
    {
        _caret = new Caret(this);
        TextDisplayerSub = new TextDisplayer(this);
        _placeholderTextDisplayer = new PlaceholderTextDisplayer(this);

        Visible = true;
        Size = DefaultLineEditSize;
        TextHAlignment = HAlignment.Left;
        TextVAlignment = VAlignment.Center;

        Text = "Type here...";

        Styles.Normal.BorderLength = 1;
        Styles.Focused.BorderLength = 1;
        Styles.Focused.BorderColor = DefaultTheme.FocusBorder;
        Styles.WordWrapping = WordWrapping.NoWrap;
        FocusChanged += OnFocusChangedHandler;
        LeftClicked += OnLeftClickedHandler;
        ClickedOutside += OnClickedOutsideHandler;
        LayerChanged += OnLayerChangedHandler;
        SizeChanged += OnSizeChangedHandler;
    }

    public override void Process()
    {
        base.Process();
        CaptureCharInput();

        if (Editable && Selected)
        {
            HandleCharacterInput();
            HandleBackspace();
            HandleDelete();
            HandleHomeEndKeys();
            HandleClipboardPaste();
            HandleUndoRedo();
            ConfirmOnEnter();
        }
        _caret.UpdateLogic();
        UpdateSizeToFitTextIfEnabled();
    }

    public override void Draw(DrawingContext context)
    {
        base.Draw(context);
        _placeholderTextDisplayer.Draw(context);
        TextDisplayerSub.Draw(context);

        if (Selected && Editable)
        {
            _caret.Visible = true;
            _caret.Draw(context);
        }
        else
        {
            _caret.Visible = false;
        }
    }

    private void CaptureCharInput()
    {
        if (_pendingCharInput == null)
        {
            _pendingCharInput = Input.ConsumeNextTypedChar();
        }
    }

    protected override void OnEnterPressed()
    {
        if (Editable)
        {
            ConfirmAction();
        }
    }

    private void OnFocusChangedHandler(Control control)
    {
        Selected = control.Focused;
    }

    private void OnLeftClickedHandler()
    {
        if (Editable)
        {
            Selected = true;
        }
    }

    private void OnClickedOutsideHandler(Control control)
    {
        if (Selected)
        {
            Selected = false;
        }
    }

    private void OnLayerChangedHandler(VisualItem sender, int layer)
    {
    }

    private void OnSizeChangedHandler(object? sender, Vector2 newSize)
    {
        TextStartIndex = 0;
        UpdateCaretDisplayPositionAndStartIndex();
    }

    private void UpdateSizeToFitTextIfEnabled()
    {
        if (!ExpandWidthToText || !Visible) return;

        var owningWindow = GetOwningWindow() as Direct2DAppWindow;
        if (owningWindow == null || owningWindow.DWriteFactory == null) return;
        IDWriteFactory dwriteFactory = owningWindow.DWriteFactory;

        string textToMeasure = string.IsNullOrEmpty(Text) ? PlaceholderText : Text;
        if (string.IsNullOrEmpty(textToMeasure))
        {
            Size = new Vector2(TextOrigin.X * 2 + 20, Size.Y);
            return;
        }

        float measuredWidth = MeasureTextWidth(dwriteFactory, textToMeasure, Styles.Current);
        Size = new Vector2(measuredWidth + TextOrigin.X * 2, Size.Y);
    }

    internal float MeasureTextWidth(IDWriteFactory dwriteFactory, string text, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(text)) return 0f;

        using IDWriteTextFormat textFormat = dwriteFactory.CreateTextFormat(
            style.FontName, null, style.FontWeight, style.FontStyle, style.FontStretch, style.FontSize, CultureInfo.CurrentCulture.Name);
        textFormat.WordWrapping = WordWrapping.NoWrap;

        using IDWriteTextLayout textLayout = dwriteFactory.CreateTextLayout(text, textFormat, float.MaxValue, float.MaxValue);
        return textLayout.Metrics.WidthIncludingTrailingWhitespace;
    }

    internal float MeasureSingleCharWidth(DrawingContext context, string character, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(character)) return 0f;
        IDWriteFactory dwriteFactory = context.DWriteFactory;
        if (dwriteFactory == null) return 0f;

        using IDWriteTextFormat textFormat = dwriteFactory.CreateTextFormat(
            style.FontName, null, style.FontWeight, style.FontStyle, style.FontStretch, style.FontSize, CultureInfo.CurrentCulture.Name);
        textFormat.WordWrapping = WordWrapping.NoWrap;

        using IDWriteTextLayout textLayout = dwriteFactory.CreateTextLayout(character, textFormat, float.MaxValue, float.MaxValue);
        return textLayout.Metrics.Width;
    }

    public void Insert(string textToInsert)
    {
        if (!Editable || string.IsNullOrEmpty(textToInsert)) return;

        PushStateForUndo();
        foreach (char c in textToInsert)
        {
            InsertCharacterLogic(c);
        }
    }

    private void HandleCharacterInput()
    {
        if (!_pendingCharInput.HasValue)
        {
            return;
        }

        char typedChar = _pendingCharInput.Value;
        _pendingCharInput = null;

        if (Text.Length >= MaxCharacters)
        {
            return;
        }

        if (ValidCharacters.Count != 0 && !ValidCharacters.Contains(typedChar))
        {
            return;
        }

        PushStateForUndo();
        InsertCharacterLogic(typedChar);
    }

    private void InsertCharacterLogic(char c)
    {
        if (Text.Length >= MaxCharacters) return;

        Text = Text.Insert(CaretLogicalPosition, c.ToString());
        CaretLogicalPosition++;
        UpdateCaretDisplayPositionAndStartIndex();
    }

    private void HandleBackspace()
    {
        bool ctrlHeld = Input.IsKeyDown(KeyCode.LeftControl) || Input.IsKeyDown(KeyCode.RightControl);

        if (Input.IsKeyPressed(KeyCode.Backspace))
        {
            _backspaceHeld = true;
            _backspaceTimer = 0f;
            _backspaceCtrlHeld = ctrlHeld;
            PerformBackspaceAction(_backspaceCtrlHeld);
        }
        else if (Input.IsKeyDown(KeyCode.Backspace) && _backspaceHeld)
        {
            _backspaceTimer += Time.Delta;
            if (_backspaceTimer >= BackspaceDelay)
            {
                if ((_backspaceTimer - BackspaceDelay) % BackspaceSpeed < Time.Delta)
                {
                    PerformBackspaceAction(_backspaceCtrlHeld);
                }
            }
        }
        else if (Input.IsKeyReleased(KeyCode.Backspace))
        {
            _backspaceHeld = false;
            _backspaceTimer = 0f;
        }
    }

    private void PerformBackspaceAction(bool isCtrlHeld)
    {
        if (Text.Length == 0 || CaretLogicalPosition == 0) return;

        PushStateForUndo();
        if (isCtrlHeld)
        {
            int originalCaretPos = CaretLogicalPosition;
            int wordStart = FindPreviousWordStart(Text, originalCaretPos);
            Text = Text.Remove(wordStart, originalCaretPos - wordStart);
            CaretLogicalPosition = wordStart;
        }
        else
        {
            Text = Text.Remove(CaretLogicalPosition - 1, 1);
            CaretLogicalPosition--;
        }
        UpdateCaretDisplayPositionAndStartIndex();
    }

    private int FindPreviousWordStart(string text, int currentPos)
    {
        if (currentPos == 0) return 0;
        int pos = currentPos - 1;
        while (pos > 0 && char.IsWhiteSpace(text[pos])) pos--;
        while (pos > 0 && !char.IsWhiteSpace(text[pos - 1])) pos--;
        return pos;
    }

    private void HandleDelete()
    {
        if (Input.IsKeyPressed(KeyCode.Delete))
        {
            if (CaretLogicalPosition < Text.Length)
            {
                PushStateForUndo();
                Text = Text.Remove(CaretLogicalPosition, 1);
                UpdateCaretDisplayPositionAndStartIndex();
            }
        }
    }

    private void HandleHomeEndKeys()
    {
        if (Input.IsKeyPressed(KeyCode.Home))
        {
            CaretLogicalPosition = 0;
            UpdateCaretDisplayPositionAndStartIndex();
        }
        else if (Input.IsKeyPressed(KeyCode.End))
        {
            CaretLogicalPosition = Text.Length;
            UpdateCaretDisplayPositionAndStartIndex();
        }
    }

    private void HandleClipboardPaste()
    {
        if ((Input.IsKeyDown(KeyCode.LeftControl) || Input.IsKeyDown(KeyCode.RightControl)) && Input.IsKeyPressed(KeyCode.V))
        {
            try
            {
                string clipboardText = "";
                Log.Warning("Clipboard.GetText() is currently disabled. Project setup required for System.Windows.Forms.");

                if (!string.IsNullOrEmpty(clipboardText))
                {
                    clipboardText = clipboardText.Replace("\r\n", " ").Replace("\n", " ").Replace("\r", " ");
                    Insert(clipboardText);
                }
            }
            catch (Exception ex)
            {
                Log.Error($"Error pasting from clipboard: {ex.Message}");
            }
        }
    }

    private void HandleUndoRedo()
    {
        bool ctrlHeld = Input.IsKeyDown(KeyCode.LeftControl) || Input.IsKeyDown(KeyCode.RightControl);

        if (ctrlHeld && Input.IsKeyPressed(KeyCode.Z))
        {
            _undoHeld = true;
            _undoTimer = 0f;
            Undo();
        }
        else if (ctrlHeld && Input.IsKeyDown(KeyCode.Z) && _undoHeld)
        {
            _undoTimer += Time.Delta;
            if (_undoTimer >= UndoDelay)
            {
                if ((_undoTimer - UndoDelay) % UndoSpeed < Time.Delta)
                {
                    Undo();
                }
            }
        }
        else if (Input.IsKeyReleased(KeyCode.Z))
        {
            _undoHeld = false;
            _undoTimer = 0f;
        }

        if (ctrlHeld && Input.IsKeyPressed(KeyCode.Y))
        {
            Redo();
        }
    }

    private void ConfirmOnEnter()
    {
        if (Input.IsKeyPressed(KeyCode.Enter))
        {
            ConfirmAction();
        }
    }

    private void ConfirmAction()
    {
        Selected = false;
        Confirmed?.Invoke(this, Text);
    }

    internal IDWriteFactory? GetDWriteFactory()
    {
        var owningWindow = GetOwningWindow() as Direct2DAppWindow;
        return owningWindow?.DWriteFactory;
    }

    internal int GetDisplayableCharactersCount()
    {
        if (Size.X <= TextOrigin.X * 2) return 0;

        float availableWidth = Size.X - TextOrigin.X * 2;
        if (availableWidth <= 0) return 0;

        IDWriteFactory? dwriteFactory = GetDWriteFactory();
        if (dwriteFactory == null)
        {
            Log.Warning("LineEdit.GetDisplayableCharactersCount: DWriteFactory not available. Falling back to rough estimate.");
            return (int)(availableWidth / 8);
        }

        if (TextStartIndex >= Text.Length && Text.Length > 0)
        {
            return 0;
        }
        if (Text.Length == 0) return 0;

        string textToMeasure = Text.Substring(TextStartIndex);
        if (string.IsNullOrEmpty(textToMeasure)) return 0;

        IDWriteTextFormat? textFormat = (GetOwningWindow() as Direct2DAppWindow)?.GetOrCreateTextFormat(Styles.Current);
        if (textFormat == null)
        {
            Log.Warning("LineEdit.GetDisplayableCharactersCount: Could not get TextFormat. Falling back to rough estimate.");
            return (int)(availableWidth / 8);
        }
        textFormat.WordWrapping = WordWrapping.NoWrap;

        using IDWriteTextLayout textLayout = dwriteFactory.CreateTextLayout(
            textToMeasure,
            textFormat,
            float.MaxValue,
            Size.Y
        );

        ClusterMetrics[] clusterMetricsBuffer = new ClusterMetrics[textToMeasure.Length];
        Result result = textLayout.GetClusterMetrics(clusterMetricsBuffer, out uint actualClusterCount);

        if (result.Failure)
        {
            Log.Error($"LineEdit.GetDisplayableCharactersCount: GetClusterMetrics failed with HRESULT {result.Code}");
            return (int)(availableWidth / 8);
        }

        if (actualClusterCount == 0) return 0;

        float currentCumulativeWidth = 0;
        int displayableCharacterLengthInSubstring = 0;

        for (int i = 0; i < actualClusterCount; i++)
        {
            ClusterMetrics cluster = clusterMetricsBuffer[i];
            if (currentCumulativeWidth + cluster.Width <= availableWidth)
            {
                currentCumulativeWidth += cluster.Width;
                displayableCharacterLengthInSubstring += (int)cluster.Length;
            }
            else
            {
                break;
            }
        }
        return displayableCharacterLengthInSubstring;
    }

    internal void UpdateCaretDisplayPositionAndStartIndex()
    {
        if (Text.Length == 0)
        {
            TextStartIndex = 0;
            _caret.CaretDisplayPositionX = 0;
            CaretLogicalPosition = 0;
            return;
        }

        float availableWidth = Size.X - TextOrigin.X * 2;
        if (availableWidth <= 0)
        {
            TextStartIndex = 0;
            _caret.CaretDisplayPositionX = 0;
            return;
        }

        if (AutoScrollToShowFullText)
        {
            IDWriteFactory? dwriteFactory = GetDWriteFactory();
            if (dwriteFactory != null)
            {
                float fullTextWidth = MeasureTextWidth(dwriteFactory, Text, Styles.Current);
                if (fullTextWidth <= availableWidth)
                {
                    TextStartIndex = 0;
                    _caret.CaretDisplayPositionX = CaretLogicalPosition;
                    return;
                }
            }
        }

        int displayableChars = GetDisplayableCharactersCount();
        if (displayableChars <= 0 && Text.Length > 0)
        {
            TextStartIndex = CaretLogicalPosition;
            _caret.CaretDisplayPositionX = 0;
            TextStartIndex = Math.Clamp(TextStartIndex, 0, Text.Length);
            return;
        }

        if (AutoScrollToShowFullText)
        {
            int maxVisibleChars = GetDisplayableCharactersCount(0);
            if (maxVisibleChars > displayableChars && TextStartIndex > 0)
            {
                int charactersToShow = maxVisibleChars - displayableChars;
                TextStartIndex = Math.Max(0, TextStartIndex - charactersToShow);
                displayableChars = GetDisplayableCharactersCount();
            }
        }

        if (CaretLogicalPosition < TextStartIndex)
        {
            TextStartIndex = CaretLogicalPosition;
        }
        else if (CaretLogicalPosition >= TextStartIndex + displayableChars)
        {
            TextStartIndex = CaretLogicalPosition - displayableChars + 1;
        }

        TextStartIndex = Math.Max(0, TextStartIndex);
        if (TextStartIndex + displayableChars > Text.Length && displayableChars > 0)
        {
            TextStartIndex = Math.Max(0, Text.Length - displayableChars);
        }
        TextStartIndex = Math.Clamp(TextStartIndex, 0, Math.Max(0, Text.Length - 1));

        _caret.CaretDisplayPositionX = CaretLogicalPosition - TextStartIndex;
        _caret.CaretDisplayPositionX = Math.Clamp(_caret.CaretDisplayPositionX, 0, displayableChars > 0 ? displayableChars : 0);
    }

    private int GetDisplayableCharactersCount(int startIndex)
    {
        if (Size.X <= TextOrigin.X * 2) return 0;

        float availableWidth = Size.X - TextOrigin.X * 2;
        if (availableWidth <= 0) return 0;

        IDWriteFactory? dwriteFactory = GetDWriteFactory();
        if (dwriteFactory == null)
        {
            Log.Warning("LineEdit.GetDisplayableCharactersCount: DWriteFactory not available. Falling back to rough estimate.");
            return (int)(availableWidth / 8);
        }

        if (startIndex >= Text.Length && Text.Length > 0) return 0;
        if (Text.Length == 0) return 0;

        string textToMeasure = Text.Substring(startIndex);
        if (string.IsNullOrEmpty(textToMeasure)) return 0;

        IDWriteTextFormat? textFormat = (GetOwningWindow() as Direct2DAppWindow)?.GetOrCreateTextFormat(Styles.Current);
        if (textFormat == null)
        {
            Log.Warning("LineEdit.GetDisplayableCharactersCount: Could not get TextFormat. Falling back to rough estimate.");
            return (int)(availableWidth / 8);
        }
        textFormat.WordWrapping = WordWrapping.NoWrap;

        using IDWriteTextLayout textLayout = dwriteFactory.CreateTextLayout(
            textToMeasure,
            textFormat,
            float.MaxValue,
            Size.Y
        );

        ClusterMetrics[] clusterMetricsBuffer = new ClusterMetrics[textToMeasure.Length];
        Result result = textLayout.GetClusterMetrics(clusterMetricsBuffer, out uint actualClusterCount);

        if (result.Failure)
        {
            Log.Error($"LineEdit.GetDisplayableCharactersCount: GetClusterMetrics failed with HRESULT {result.Code}");
            return (int)(availableWidth / 8);
        }

        if (actualClusterCount == 0) return 0;

        float currentCumulativeWidth = 0;
        int displayableCharacterLengthInSubstring = 0;

        for (int i = 0; i < actualClusterCount; i++)
        {
            ClusterMetrics cluster = clusterMetricsBuffer[i];
            if (currentCumulativeWidth + cluster.Width <= availableWidth)
            {
                currentCumulativeWidth += cluster.Width;
                displayableCharacterLengthInSubstring += (int)cluster.Length;
            }
            else
            {
                break;
            }
        }
        return displayableCharacterLengthInSubstring;
    }

    private void PushStateForUndo()
    {
        if (_undoStack.Count > 0 && _undoStack.Peek().Text == Text && _undoStack.Peek().CaretPosition == CaretLogicalPosition)
        {
            return;
        }
        if (_undoStack.Count >= HistoryLimit)
        {
            var tempList = _undoStack.ToList();
            tempList.RemoveAt(0);
            _undoStack.Clear();
            foreach (var state in tempList.AsEnumerable().Reverse())
            {
                _undoStack.Push(state);
            }
        }
        _undoStack.Push(new LineEditState(Text, CaretLogicalPosition, TextStartIndex));
        _redoStack.Clear();
    }

    public void Undo()
    {
        if (_undoStack.Count > 0)
        {
            LineEditState currentState = new LineEditState(Text, CaretLogicalPosition, TextStartIndex);
            _redoStack.Push(currentState);
            if (_redoStack.Count > HistoryLimit)
            {
                var tempList = _redoStack.ToList();
                tempList.RemoveAt(0);
                _redoStack.Clear();
                foreach (var state in tempList.AsEnumerable().Reverse())
                {
                    _redoStack.Push(state);
                }
            }

            LineEditState previousState = _undoStack.Pop();
            Text = previousState.Text;
            CaretLogicalPosition = previousState.CaretPosition;
            TextStartIndex = previousState.TextStartIndex;

            TextChanged?.Invoke(this, Text);
            UpdateCaretDisplayPositionAndStartIndex();
        }
    }

    public void Redo()
    {
        if (_redoStack.Count > 0)
        {
            LineEditState currentState = new LineEditState(Text, CaretLogicalPosition, TextStartIndex);
            _undoStack.Push(currentState);
            if (_undoStack.Count > HistoryLimit)
            {
                var tempList = _undoStack.ToList();
                tempList.RemoveAt(0);
                _undoStack.Clear();
                foreach (var state in tempList.AsEnumerable().Reverse())
                {
                    _undoStack.Push(state);
                }
            }

            LineEditState nextState = _redoStack.Pop();
            Text = nextState.Text;
            CaretLogicalPosition = nextState.CaretPosition;
            TextStartIndex = nextState.TextStartIndex;

            TextChanged?.Invoke(this, Text);
            UpdateCaretDisplayPositionAndStartIndex();
        }
    }

    protected record LineEditState(string Text, int CaretPosition, int TextStartIndex);

    protected Vector2 GetLocalMousePosition()
    {
        var owningWindowNode = GetOwningWindowNode();
        if (owningWindowNode != null)
        {
            return owningWindowNode.LocalMousePosition;
        }

        var mainAppWindow = ApplicationServer.Instance.GetMainAppWindow();
        if (mainAppWindow != null)
        {
            return mainAppWindow.GetLocalMousePosition();
        }

        Log.Warning($"LineEdit '{Name}': Could not determine owning window for local mouse position. Using global Input.MousePosition.");
        return Input.MousePosition;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\Ui\LineEdit\LineEdit.PlaceholderTextDisplayer.cs">
namespace Cherris;

public partial class LineEdit
{
    private class PlaceholderTextDisplayer : BaseText
    {
        public PlaceholderTextDisplayer(LineEdit parent) : base(parent)
        {
        }

        protected override string GetTextToDisplay()
        {
            return parentLineEdit.PlaceholderText;
        }

        protected override bool ShouldSkipDrawing()
        {
            return !string.IsNullOrEmpty(parentLineEdit.Text);
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\Ui\LineEdit\LineEdit.TextDisplayer.cs">
namespace Cherris;

public partial class LineEdit
{
    private class TextDisplayer : BaseText
    {
        public TextDisplayer(LineEdit parent) : base(parent)
        {
        }

        protected override string GetTextToDisplay()
        {
            if (string.IsNullOrEmpty(parentLineEdit.Text))
            {
                return "";
            }

            string textToDisplay = parentLineEdit.Text;

            if (parentLineEdit.Secret)
            {
                textToDisplay = new string(parentLineEdit.SecretCharacter, textToDisplay.Length);
            }
            int startIndex = Math.Clamp(parentLineEdit.TextStartIndex, 0, textToDisplay.Length);
            int availableLengthFromStartIndex = textToDisplay.Length - startIndex;
            int count = Math.Min(parentLineEdit.GetDisplayableCharactersCount(), availableLengthFromStartIndex);

            if (count <= 0) return "";
            return textToDisplay.Substring(startIndex, count);
        }

        protected override bool ShouldSkipDrawing()
        {
            return string.IsNullOrEmpty(parentLineEdit.Text);
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\Ui\Slider\HSlider.cs">
using Vortice.Mathematics;
namespace Cherris;

public class HSlider : Slider
{
    public HSliderDirection Direction { get; set; } = HSliderDirection.LeftToRight;

    protected override void CalculateTrackBounds()
    {
        Vector2 sliderVisualTopLeft = GlobalPosition - Origin;
        this.trackPosition = sliderVisualTopLeft;        trackMin = sliderVisualTopLeft.X;        trackMax = sliderVisualTopLeft.X + Size.X;    }

    protected override void UpdateHoverStates()
    {
        Vector2 mousePos = GetLocalMousePosition();        Vector2 visualSliderTopLeft = this.trackPosition;        trackHovered = mousePos.X >= visualSliderTopLeft.X &&
                       mousePos.X <= visualSliderTopLeft.X + Size.X &&
                       mousePos.Y >= visualSliderTopLeft.Y &&
                       mousePos.Y <= visualSliderTopLeft.Y + Size.Y;
        Vector2 grabberTopLeftPos = CalculateGrabberPosition();
        grabberHovered = mousePos.X >= grabberTopLeftPos.X &&
                         mousePos.X <= grabberTopLeftPos.X + GrabberSize.X &&
                         mousePos.Y >= grabberTopLeftPos.Y &&
                         mousePos.Y <= grabberTopLeftPos.Y + GrabberSize.Y;
    }

    protected override void HandleInput()
    {
        HandleMousePress();
        HandleMouseDrag();
        HandleMouseWheel();
    }

    private void HandleMousePress()
    {
        if (Input.IsMouseButtonPressed(MouseButtonCode.Left))
        {
            if (trackHovered)            {
                float localMouseX = GetLocalMousePosition().X;                float clampedMouseXOnTrack = Math.Clamp(localMouseX, this.trackPosition.X, this.trackPosition.X + Size.X);
                Value = ConvertPositionToValue(clampedMouseXOnTrack);
                grabberPressed = true;
                PlaySound();
            }
        }
        else if (Input.IsMouseButtonReleased(MouseButtonCode.Left))
        {
            grabberPressed = false;
        }
    }

    private void HandleMouseDrag()
    {
        if (!grabberPressed) return;

        if (Input.IsMouseButtonReleased(MouseButtonCode.Left))
        {
            grabberPressed = false;
            return;
        }

        float localMouseX = GetLocalMousePosition().X;
        float clampedMouseXOnTrack = Math.Clamp(localMouseX, this.trackPosition.X, this.trackPosition.X + Size.X);
        Value = ConvertPositionToValue(clampedMouseXOnTrack);
    }

    private void HandleMouseWheel()
    {
        if (!trackHovered && !grabberHovered) return;

        float wheelDelta = Input.GetMouseWheelMovement();
        if (wheelDelta == 0) return;

        Value = ApplyStep(Value + (wheelDelta * Step * (Direction == HSliderDirection.LeftToRight ? 1 : -1)));
        PlaySound();
    }

    protected override float ConvertPositionToValue(float positionOnTrackInWindowSpace)
    {
        float visualTrackLeftEdge = this.trackPosition.X;        float effectiveTrackWidth = Size.X;

        if (effectiveTrackWidth <= 0) return MinValue;

        float normalized = (positionOnTrackInWindowSpace - visualTrackLeftEdge) / effectiveTrackWidth;
        normalized = Math.Clamp(normalized, 0f, 1f);

        if (Direction == HSliderDirection.RightToLeft)
        {
            normalized = 1f - normalized;
        }

        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return ApplyStep(rawValue);
    }

    protected override void DrawForeground(DrawingContext context)
    {
        Vector2 sliderVisualTopLeft = GlobalPosition - Origin;
        float range = MaxValue - MinValue;
        float fillRatio = (range == 0) ? 0.0f : (this.Value - MinValue) / range;
        fillRatio = Math.Clamp(fillRatio, 0f, 1f);

        float foregroundWidth = Size.X * fillRatio;
        Rect foregroundRect;

        if (Direction == HSliderDirection.RightToLeft)
        {
            foregroundRect = new Rect(
                sliderVisualTopLeft.X + Size.X - foregroundWidth,
                sliderVisualTopLeft.Y,
                foregroundWidth,
                Size.Y
            );
        }
        else        {
            foregroundRect = new Rect(
                sliderVisualTopLeft.X,
                sliderVisualTopLeft.Y,
                foregroundWidth,
                Size.Y
            );
        }

        if (foregroundRect.Width > 0 && foregroundRect.Height > 0)
        {
            DrawStyledRectangle(context, foregroundRect, Style.Foreground);
        }
    }

    protected override Vector2 CalculateGrabberPosition()
    {
        Vector2 sliderVisualTopLeft = GlobalPosition - Origin;
        float range = MaxValue - MinValue;
        float normalizedValue = (range == 0) ? 0.0f : (this.Value - MinValue) / range;
        normalizedValue = Math.Clamp(normalizedValue, 0f, 1f);

        if (Direction == HSliderDirection.RightToLeft)
        {
            normalizedValue = 1f - normalizedValue;
        }
        float grabberCenterX_relativeToSliderLeft = normalizedValue * Size.X;
        float grabberLeftX_relativeToSliderLeft = grabberCenterX_relativeToSliderLeft - GrabberSize.X / 2f;
        grabberLeftX_relativeToSliderLeft = Math.Clamp(grabberLeftX_relativeToSliderLeft, 0, Size.X - GrabberSize.X);
        float finalGrabberLeftX_global = sliderVisualTopLeft.X + grabberLeftX_relativeToSliderLeft;
        float grabberTopY_relativeToSliderTop = (Size.Y / 2f) - GrabberSize.Y / 2f;
        float finalGrabberTopY_global = sliderVisualTopLeft.Y + grabberTopY_relativeToSliderTop;

        return new Vector2(finalGrabberLeftX_global, finalGrabberTopY_global);
    }

    protected override void UpdateGrabberThemeVisuals()
    {
        if (Disabled)
        {
            Style.Grabber.Current = Style.Grabber.Disabled;
            return;
        }

        if (grabberPressed)
        {
            Style.Grabber.Current = Style.Grabber.Pressed;
        }
        else if (Focused)
        {
            Style.Grabber.Current = grabberHovered ? Style.Grabber.Hover : Style.Grabber.Focused;
        }
        else if (grabberHovered)
        {
            Style.Grabber.Current = Style.Grabber.Hover;
        }
        else
        {
            Style.Grabber.Current = Style.Grabber.Normal;
        }
    }

    protected override void HandleKeyboardNavigation()
    {
        if (Input.IsActionPressed("UiLeft"))
        {
            Value = ApplyStep(Value - Step * (Direction == HSliderDirection.LeftToRight ? 1 : -1));
            PlaySound();
        }
        else if (Input.IsActionPressed("UiRight"))
        {
            Value = ApplyStep(Value + Step * (Direction == HSliderDirection.LeftToRight ? 1 : -1));
            PlaySound();
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\Ui\Slider\HSliderDirection.cs">
namespace Cherris;

public enum HSliderDirection
{
    LeftToRight,
    RightToLeft
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\Ui\Slider\Slider.cs">
using Vortice.Mathematics;
namespace Cherris;

public abstract class Slider : Control
{
    public bool SuppressValueChangedEvent { get; set; } = false;

    private float _value = 0.5f;
    public float Value
    {
        get => _value;
        set
        {
            float newValue = ApplyStep(value);
            if (_value == newValue)
            {
                return;
            }

            _value = newValue;

            if (SuppressValueChangedEvent)            {
                return;
            }

            ValueChanged?.Invoke(_value);        }
    }

    public float MinValue { get; set; } = 0f;
    public float MaxValue { get; set; } = 1f;
    public Sound? MoveSound { get; set; }
    public SliderStyle Style { get; set; } = new();
    public Vector2 GrabberSize { get; set; } = new(12, 24);

    protected bool grabberPressed;
    protected bool grabberHovered;
    protected bool trackHovered;
    protected Vector2 trackPosition;    protected float trackMin;    protected float trackMax;
    private float _step = 0.01f;
    public float Step
    {
        get => _step;
        set => _step = Math.Max(value, 0f);
    }

    public event Action<float>? ValueChanged;
    public Slider()
    {
        Size = new(200, 16);
        Focusable = true;
        Navigable = true;

        Style.Foreground.FillColor = DefaultTheme.Accent;
        Style.Foreground.Roundness = 0.2f;
        Style.Background.Roundness = 0.2f;
        Style.Grabber.Roundness = 0.5f;
        Style.Grabber.BorderLength = 1f;
        Style.Grabber.Normal.FillColor = DefaultTheme.NormalFill;
        Style.Grabber.Hover.FillColor = DefaultTheme.HoverFill;
        Style.Grabber.Pressed.FillColor = DefaultTheme.Accent;
        Style.Grabber.Focused.BorderColor = DefaultTheme.FocusBorder;
    }

    public override void Process()
    {
        base.Process();

        if (Disabled)
        {
            grabberPressed = false;
            UpdateGrabberThemeVisuals();
            return;
        }

        CalculateTrackBounds();
        UpdateHoverStates();

        if (Input.IsMouseButtonPressed(MouseButtonCode.Left))
        {
            HandleClickFocus();
        }

        HandleInput();

        if (Focused)
        {
            HandleKeyboardNavigation();
            OnFocusLost();
        }

        UpdateGrabberThemeVisuals();
    }

    protected Vector2 GetLocalMousePosition()
    {
        var owningWindowNode = GetOwningWindowNode();
        return owningWindowNode?.LocalMousePosition ?? Input.MousePosition;
    }

    protected abstract void HandleKeyboardNavigation();

    protected virtual void OnFocusLost()
    {
        if (Input.IsActionPressed("UiAccept") ||
            (Input.IsMouseButtonPressed(MouseButtonCode.Left) && !IsMouseOver()))
        {
            Focused = false;
        }
    }

    protected override void OnThemeFileChanged(string themeFile)
    {
        try
        {
            Style = FileLoader.Load<SliderStyle>(themeFile);
        }
        catch (Exception ex)
        {
            Log.Error($"Failed to load SliderStyle from '{themeFile}': {ex.Message}");
        }
    }

    protected void PlaySound()
    {
        if (!Disabled)
        {
            MoveSound?.Play(AudioBus);
        }
    }

    protected abstract void CalculateTrackBounds();
    protected abstract void UpdateHoverStates();
    protected abstract void HandleInput();
    protected abstract void UpdateGrabberThemeVisuals();
    protected abstract float ConvertPositionToValue(float position);
    protected abstract void DrawForeground(DrawingContext context);
    protected abstract Vector2 CalculateGrabberPosition();

    protected float ApplyStep(float rawValue)
    {
        float clampedValue = Math.Clamp(rawValue, MinValue, MaxValue);

        if (Step <= 0 || MinValue >= MaxValue)
        {
            return clampedValue;
        }

        float steppedValue = MinValue + (float)Math.Round((clampedValue - MinValue) / Step) * Step;
        return Math.Clamp(steppedValue, MinValue, MaxValue);
    }

    public override void Draw(DrawingContext context)
    {
        if (!Visible) return;

        DrawBackground(context);
        DrawForeground(context);
        DrawGrabber(context);
    }

    private void DrawBackground(DrawingContext context)
    {
        Vector2 sliderVisualTopLeft = GlobalPosition - Origin;
        var bounds = new Rect(sliderVisualTopLeft.X, sliderVisualTopLeft.Y, Size.X, Size.Y);
        DrawStyledRectangle(context, bounds, Style.Background);
    }

    private void DrawGrabber(DrawingContext context)
    {
        Vector2 grabberPos = CalculateGrabberPosition();
        ButtonStyle currentGrabberStyle = Style.Grabber.Current;

        var bounds = new Rect(grabberPos.X, grabberPos.Y, GrabberSize.X, GrabberSize.Y);
        DrawStyledRectangle(context, bounds, currentGrabberStyle);
    }

    protected override void HandleClickFocus()
    {
        if (Disabled || !Focusable) return;

        if (trackHovered || grabberHovered)
        {
            Focused = true;
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\Ui\Slider\SliderStyle.cs">
namespace Cherris;

public class SliderStyle
{
    public BoxStyle Background { get; set; } = new()
    {
        FillColor = DefaultTheme.DisabledFill,        BorderColor = DefaultTheme.DisabledBorder
    };
    public BoxStyle Foreground { get; set; } = new()
    {
        FillColor = DefaultTheme.Accent,        BorderColor = DefaultTheme.AccentBorder
    };
    public ButtonStylePack Grabber { get; set; } = new();
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\Ui\Slider\VSlider.cs">
using Vortice.Mathematics;
namespace Cherris;

public class VSlider : Slider
{
    public VSliderDirection Direction { get; set; } = VSliderDirection.TopToBottom;

    public VSlider()
    {
        Size = new(16, 200);
        GrabberSize = new(24, 12);
    }
    protected override void CalculateTrackBounds()
    {
        Vector2 sliderVisualTopLeft = GlobalPosition - Origin;
        this.trackPosition = sliderVisualTopLeft;        trackMin = sliderVisualTopLeft.Y;        trackMax = sliderVisualTopLeft.Y + Size.Y;    }

    protected override void UpdateHoverStates()
    {
        Vector2 mousePos = GetLocalMousePosition();        Vector2 visualSliderTopLeft = this.trackPosition;
        trackHovered = mousePos.X >= visualSliderTopLeft.X &&
                       mousePos.X <= visualSliderTopLeft.X + Size.X &&
                       mousePos.Y >= visualSliderTopLeft.Y &&
                       mousePos.Y <= visualSliderTopLeft.Y + Size.Y;

        Vector2 grabberTopLeftPos = CalculateGrabberPosition();
        grabberHovered = mousePos.X >= grabberTopLeftPos.X &&
                         mousePos.X <= grabberTopLeftPos.X + GrabberSize.X &&
                         mousePos.Y >= grabberTopLeftPos.Y &&
                         mousePos.Y <= grabberTopLeftPos.Y + GrabberSize.Y;
    }

    protected override void HandleInput()
    {
        HandleMousePress();
        HandleMouseDrag();
        HandleMouseWheel();
    }

    private void HandleMousePress()
    {
        if (Input.IsMouseButtonPressed(MouseButtonCode.Left))
        {
            if (trackHovered)
            {
                float localMouseY = GetLocalMousePosition().Y;
                float clampedMouseY = Math.Clamp(localMouseY, this.trackPosition.Y, this.trackPosition.Y + Size.Y);
                Value = ConvertPositionToValue(clampedMouseY);
                grabberPressed = true;
                PlaySound();
            }
        }
        else if (Input.IsMouseButtonReleased(MouseButtonCode.Left))
        {
            grabberPressed = false;
        }
    }

    private void HandleMouseDrag()
    {
        if (!grabberPressed) return;

        if (Input.IsMouseButtonReleased(MouseButtonCode.Left))
        {
            grabberPressed = false;
            return;
        }
        float localMouseY = GetLocalMousePosition().Y;
        float clampedMouseY = Math.Clamp(localMouseY, this.trackPosition.Y, this.trackPosition.Y + Size.Y);
        Value = ConvertPositionToValue(clampedMouseY);
    }

    private void HandleMouseWheel()
    {
        if (!trackHovered && !grabberHovered) return;

        float wheelDelta = Input.GetMouseWheelMovement();
        if (wheelDelta == 0) return;

        Value = ApplyStep(Value + (wheelDelta * Step * (Direction == VSliderDirection.TopToBottom ? 1 : -1)));
        PlaySound();
    }

    protected override float ConvertPositionToValue(float positionOnTrackInWindowSpace)
    {
        float visualTrackTopEdge = this.trackPosition.Y;        float effectiveTrackHeight = Size.Y;

        if (effectiveTrackHeight <= 0) return MinValue;

        float normalized = (positionOnTrackInWindowSpace - visualTrackTopEdge) / effectiveTrackHeight;
        normalized = Math.Clamp(normalized, 0f, 1f);

        if (Direction == VSliderDirection.BottomToTop)
        {
            normalized = 1f - normalized;
        }

        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return ApplyStep(rawValue);
    }

    protected override void DrawForeground(DrawingContext context)
    {
        Vector2 sliderVisualTopLeft = GlobalPosition - Origin;
        float range = MaxValue - MinValue;
        float fillRatio = (range == 0) ? 0.0f : (this.Value - MinValue) / range;
        fillRatio = Math.Clamp(fillRatio, 0f, 1f);

        float foregroundHeight = Size.Y * fillRatio;
        Rect foregroundRect;

        if (Direction == VSliderDirection.BottomToTop)
        {
            foregroundRect = new Rect(
                sliderVisualTopLeft.X,
                sliderVisualTopLeft.Y + Size.Y - foregroundHeight,
                Size.X,
                foregroundHeight
            );
        }
        else        {
            foregroundRect = new Rect(
                sliderVisualTopLeft.X,
                sliderVisualTopLeft.Y,
                Size.X,
                foregroundHeight
            );
        }

        if (foregroundRect.Width > 0 && foregroundRect.Height > 0)
        {
            DrawStyledRectangle(context, foregroundRect, Style.Foreground);
        }
    }

    protected override Vector2 CalculateGrabberPosition()
    {
        Vector2 sliderVisualTopLeft = GlobalPosition - Origin;
        float range = MaxValue - MinValue;
        float normalizedValue = (range == 0) ? 0.0f : (this.Value - MinValue) / range;
        normalizedValue = Math.Clamp(normalizedValue, 0f, 1f);

        if (Direction == VSliderDirection.BottomToTop)
        {
            normalizedValue = 1f - normalizedValue;
        }

        float grabberCenterY_relativeToSliderTop = normalizedValue * Size.Y;
        float grabberTopY_relativeToSliderTop = grabberCenterY_relativeToSliderTop - GrabberSize.Y / 2f;
        grabberTopY_relativeToSliderTop = Math.Clamp(grabberTopY_relativeToSliderTop, 0, Size.Y - GrabberSize.Y);
        float finalGrabberTopY_global = sliderVisualTopLeft.Y + grabberTopY_relativeToSliderTop;

        float grabberLeftX_relativeToSliderLeft = (Size.X / 2f) - GrabberSize.X / 2f;
        float finalGrabberLeftX_global = sliderVisualTopLeft.X + grabberLeftX_relativeToSliderLeft;

        return new Vector2(finalGrabberLeftX_global, finalGrabberTopY_global);
    }

    protected override void UpdateGrabberThemeVisuals()
    {
        if (Disabled)
        {
            Style.Grabber.Current = Style.Grabber.Disabled;
            return;
        }

        if (grabberPressed)
        {
            Style.Grabber.Current = Style.Grabber.Pressed;
        }
        else if (Focused)
        {
            Style.Grabber.Current = grabberHovered ? Style.Grabber.Hover : Style.Grabber.Focused;
        }
        else if (grabberHovered)
        {
            Style.Grabber.Current = Style.Grabber.Hover;
        }
        else
        {
            Style.Grabber.Current = Style.Grabber.Normal;
        }
    }

    protected override void HandleKeyboardNavigation()
    {
        if (Input.IsActionPressed("UiUp"))
        {
            Value = ApplyStep(Value + Step * (Direction == VSliderDirection.TopToBottom ? -1 : 1));
            PlaySound();
        }
        else if (Input.IsActionPressed("UiDown"))
        {
            Value = ApplyStep(Value - Step * (Direction == VSliderDirection.TopToBottom ? -1 : 1));
            PlaySound();
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\DirectUI\Cherris\Source\Nodes\Ui\Slider\VSliderDirection.cs">
namespace Cherris;

public enum VSliderDirection
{
    TopToBottom,
    BottomToTop
}
</file>

