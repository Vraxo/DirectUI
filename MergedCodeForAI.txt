<file path="Alignment.cs">
// Alignment.cs
namespace DirectUI;

public enum HAlignment { Left, Center, Right }
public enum VAlignment { Top, Center, Bottom }

public struct Alignment(HAlignment horizontal, VAlignment vertical)
{
    public HAlignment Horizontal { get; set; } = horizontal;
    public VAlignment Vertical { get; set; } = vertical;
}
</file>

<file path="AppHost.cs">
// AppHost.cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Numerics;
using DirectUI.Diagnostics;
using DirectUI.Input;
using Vortice.Mathematics;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI;

/// <summary>
/// Manages the application's rendering lifecycle, graphics device, and input state aggregation.
/// This class acts as the "engine" that is hosted by a window.
/// </summary>
public class AppHost
{
    private readonly Action<UIContext> _drawCallback;
    private readonly Color4 _backgroundColor;
    private readonly FpsCounter _fpsCounter;
    private readonly UIResources _uiResources;
    private readonly InputManager _inputManager;
    private readonly Stopwatch _frameTimer = new();
    private long _lastFrameTicks;

    private GraphicsDevice? _graphicsDevice;
    private IntPtr _hwnd;

    public bool ShowFpsCounter { get; set; } = true;
    public InputManager Input => _inputManager;

    public AppHost(Action<UIContext> drawCallback, Color4 backgroundColor)
    {
        _drawCallback = drawCallback ?? throw new ArgumentNullException(nameof(drawCallback));
        _backgroundColor = backgroundColor;
        _fpsCounter = new FpsCounter();
        _uiResources = new UIResources();
        _inputManager = new InputManager();

        _frameTimer.Start();
        _lastFrameTicks = _frameTimer.ElapsedTicks;

        // Initialize the FpsCounter once during construction.
        // The DWriteFactory is available from shared resources, which are initialized
        // by the Application's static constructor before any AppHost is created.
        if (SharedGraphicsResources.DWriteFactory != null)
        {
            _fpsCounter.Initialize(SharedGraphicsResources.DWriteFactory);
        }
        else
        {
            Console.WriteLine("CRITICAL: DWriteFactory was not available for FpsCounter initialization.");
        }
    }

    public bool Initialize(IntPtr hwnd, SizeI clientSize)
    {
        _hwnd = hwnd;
        if (_graphicsDevice?.IsInitialized ?? false) return true;
        if (_hwnd == IntPtr.Zero) return false;

        _graphicsDevice ??= new GraphicsDevice();

        return _graphicsDevice.Initialize(_hwnd, clientSize);
    }

    public void Cleanup()
    {
        _fpsCounter.Cleanup();
        _uiResources.CleanupResources();
        _graphicsDevice?.Cleanup();
    }

    public void Resize(SizeI newSize)
    {
        if (_graphicsDevice?.IsInitialized ?? false)
        {
            _graphicsDevice.Resize(newSize);
        }
        else if (_hwnd != IntPtr.Zero)
        {
            Initialize(_hwnd, GetClientRectSizeForHost());
        }
    }

    public void Render()
    {
        // Prevent re-entrant rendering calls, which can happen if a new window
        // is created and painted synchronously inside another window's render loop.
        if (UI.IsRendering) return;

        if (!(_graphicsDevice?.IsInitialized ?? false))
        {
            if (!Initialize(_hwnd, GetClientRectSizeForHost()))
            {
                // On failure, still need to prepare the input manager for the next attempt.
                _inputManager.PrepareNextFrame();
                return;
            }
        }

        // Calculate delta time for the frame
        long currentTicks = _frameTimer.ElapsedTicks;
        float deltaTime = (float)(currentTicks - _lastFrameTicks) / Stopwatch.Frequency;
        _lastFrameTicks = currentTicks;

        // Clamp delta time to avoid huge jumps (e.g., when debugging or window is moved)
        deltaTime = Math.Min(deltaTime, 1.0f / 15.0f); // Clamp to a minimum of 15 FPS

        _fpsCounter.Update(); // Update FPS counter once per render call.

        _graphicsDevice!.BeginDraw();

        var rt = _graphicsDevice.RenderTarget!;
        var dwrite = _graphicsDevice.DWriteFactory!;

        try
        {
            rt.Clear(_backgroundColor);

            // Get the immutable input state for this frame from the InputManager
            var inputState = _inputManager.GetCurrentState();

            var uiContext = new UIContext(rt, dwrite, inputState, _uiResources, deltaTime);
            UI.BeginFrame(uiContext);

            _drawCallback(uiContext);

            if (ShowFpsCounter)
            {
                _fpsCounter.Draw(rt);
            }

            UI.EndFrame();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred during drawing: {ex}");
            _graphicsDevice.Cleanup();
        }
        finally
        {
            _graphicsDevice.EndDraw();
            // Prepare the input manager for the next frame.
            _inputManager.PrepareNextFrame();
        }
    }

    private SizeI GetClientRectSizeForHost()
    {
        if (_hwnd != IntPtr.Zero && NativeMethods.GetClientRect(_hwnd, out NativeMethods.RECT r))
        {
            int width = Math.Max(1, r.right - r.left);
            int height = Math.Max(1, r.bottom - r.top);
            return new SizeI(width, height);
        }
        // Fallback for when the handle is not yet valid during initialization.
        // This size isn't critical as resize will be called immediately after.
        return new SizeI(1, 1);
    }
}
</file>

<file path="Application.cs">
using System;
using System.Collections.Generic;

namespace DirectUI;

/// <summary>
/// Manages the application's global message loop and window collection.
/// </summary>
public static class Application
{
    private static readonly List<Win32Window> s_windows = new();
    private static bool s_isRunning = false;

    /// <summary>
    /// A static constructor is guaranteed to run once before the class is used.
    /// This is the perfect place to initialize application-wide resources.
    /// </summary>
    static Application()
    {
        SharedGraphicsResources.Initialize();
    }

    /// <summary>
    /// Registers a window with the application manager. Called by Win32Window's constructor.
    /// </summary>
    public static void RegisterWindow(Win32Window window)
    {
        if (!s_windows.Contains(window))
        {
            s_windows.Add(window);
        }
    }

    /// <summary>
    /// Unregisters a window. Called when a window is destroyed.
    /// </summary>
    public static void UnregisterWindow(Win32Window window)
    {
        s_windows.Remove(window);
        // If the last window is closed, exit the application.
        if (s_windows.Count == 0)
        {
            Exit();
        }
    }

    /// <summary>
    /// Starts and runs the main application message loop.
    /// </summary>
    public static void Run()
    {
        if (s_windows.Count == 0)
        {
            Console.WriteLine("Application.Run() called with no windows registered.");
            return;
        }

        s_isRunning = true;
        while (s_isRunning)
        {
            ProcessMessages();

            if (!s_isRunning) break;

            // Create a copy for safe iteration, as windows can be closed (and removed) during the loop.
            var windowsToUpdate = new List<Win32Window>(s_windows);
            foreach (var window in windowsToUpdate)
            {
                if (window.Handle != IntPtr.Zero)
                {
                    window.FrameUpdate();
                }
            }
        }

        // Clean up resources after the main loop has finished.
        SharedGraphicsResources.Cleanup();
    }

    /// <summary>
    /// Processes all pending window messages in the queue.
    /// </summary>
    private static void ProcessMessages()
    {
        while (NativeMethods.PeekMessage(out var msg, IntPtr.Zero, 0, 0, NativeMethods.PM_REMOVE))
        {
            if (msg.message == NativeMethods.WM_QUIT)
            {
                s_isRunning = false;
                break;
            }

            NativeMethods.TranslateMessage(ref msg);
            NativeMethods.DispatchMessage(ref msg);
        }
    }

    /// <summary>
    /// Signals the application to exit its message loop.
    /// </summary>
    public static void Exit()
    {
        if (s_isRunning)
        {
            s_isRunning = false;
            // Post a quit message to ensure the loop breaks out of GetMessage if it's blocking.
            NativeMethods.PostQuitMessage(0);
        }
    }
}
</file>

<file path="Direct2DAppWindow.cs">
// Direct2DAppWindow.cs
using System;
using System.Numerics;
using DirectUI.Input;
using Vortice.Mathematics;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI;

public abstract class Direct2DAppWindow : Win32Window
{
    protected AppHost? _appHost;

    protected Direct2DAppWindow(string title = "Vortice DirectUI Base Window", int width = 800, int height = 600)
        : base(title, width, height)
    {
    }

    /// <summary>
    /// Factory method for the derived class to create its specific AppHost.
    /// The AppHost contains the rendering logic and graphics resources.
    /// </summary>
    protected abstract AppHost CreateAppHost();

    protected override bool Initialize()
    {
        Console.WriteLine("Direct2DAppWindow initializing...");
        _appHost = CreateAppHost();
        return _appHost.Initialize(Handle, GetClientRectSize());
    }

    protected override void Cleanup()
    {
        Console.WriteLine("Direct2DAppWindow cleaning up its resources...");
        _appHost?.Cleanup();
        _appHost = null;
    }

    protected override void OnPaint()
    {
        _appHost?.Render();
    }

    public override void FrameUpdate()
    {
        Invalidate(); // Always invalidate to trigger a paint message for a continuous render loop.
    }

    protected override void OnSize(int width, int height)
    {
        _appHost?.Resize(new SizeI(width, height));
    }

    protected override void OnMouseMove(int x, int y)
    {
        _appHost?.Input.SetMousePosition(x, y);
        Invalidate();
    }

    protected override void OnMouseDown(MouseButton button, int x, int y)
    {
        _appHost?.Input.SetMousePosition(x, y); // Update position on click
        _appHost?.Input.SetMouseDown(button);
        Invalidate();
    }

    protected override void OnMouseUp(MouseButton button, int x, int y)
    {
        _appHost?.Input.SetMousePosition(x, y); // Update position on release
        _appHost?.Input.SetMouseUp(button);
        Invalidate();
    }

    protected override void OnMouseWheel(float delta)
    {
        _appHost?.Input.AddMouseWheelDelta(delta);
        Invalidate();
    }

    protected override void OnKeyDown(Keys key)
    {
        _appHost?.Input.AddKeyPressed(key);

        if (key == Keys.Escape)
        {
            Close();
        }
        Invalidate();
    }

    protected override void OnKeyUp(Keys key)
    {
        _appHost?.Input.AddKeyReleased(key);
        Invalidate();
    }

    protected override void OnChar(char c)
    {
        _appHost?.Input.AddCharacterInput(c);
        Invalidate();
    }

    protected override bool OnClose() { return true; }

    protected SizeI GetClientRectSize()
    {
        if (Handle != nint.Zero && NativeMethods.GetClientRect(Handle, out NativeMethods.RECT r))
        {
            int width = Math.Max(1, r.right - r.left);
            int height = Math.Max(1, r.bottom - r.top);
            return new SizeI(width, height);
        }
        int baseWidth = Math.Max(1, Width);
        int baseHeight = Math.Max(1, Height);
        if (Handle != nint.Zero)
        {
            Console.WriteLine($"GetClientRect failed. Falling back to stored size: {baseWidth}x{baseHeight}");
        }
        return new SizeI(baseWidth, baseHeight);
    }
}
</file>

<file path="DrawingContext.cs">
using Vortice.Direct2D1;
using Vortice.DirectWrite;

namespace DirectUI;

public readonly struct DrawingContext
{
    public readonly ID2D1HwndRenderTarget RenderTarget;
    public readonly IDWriteFactory DWriteFactory;

    public DrawingContext(ID2D1HwndRenderTarget renderTarget, IDWriteFactory dwriteFactory)
    {
        RenderTarget = renderTarget;
        DWriteFactory = dwriteFactory;
    }
}
</file>

<file path="GraphicsDevice.cs">
// GraphicsDevice.cs
using System;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.DXGI;
using SharpGen.Runtime;
using Vortice.Mathematics;
using Vortice.DCommon;
using D2D = Vortice.Direct2D1;
using DW = Vortice.DirectWrite;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI;

public class GraphicsDevice : IDisposable
{
    public ID2D1Factory1? D2DFactory => SharedGraphicsResources.D2DFactory;
    public IDWriteFactory? DWriteFactory => SharedGraphicsResources.DWriteFactory;
    public ID2D1HwndRenderTarget? RenderTarget { get; private set; }
    public bool IsInitialized { get; private set; } = false;

    private bool _isDisposed = false;

    public bool Initialize(IntPtr hwnd, SizeI size)
    {
        if (IsInitialized) return true;
        if (hwnd == IntPtr.Zero) return false;

        Console.WriteLine($"Attempting Graphics Initialization for HWND {hwnd} with size {size}...");
        try
        {
            // Clean up any previous (potentially invalid) instance resources
            CleanupRenderTarget();

            if (D2DFactory is null || DWriteFactory is null)
            {
                throw new InvalidOperationException("Shared graphics factories are not initialized. Application.Run() must be called first.");
            }

            if (size.Width <= 0 || size.Height <= 0)
            {
                Console.WriteLine($"Invalid client rect size ({size}). Aborting graphics initialization.");
                return false;
            }

            var dxgiPixelFormat = new PixelFormat(Format.B8G8R8A8_UNorm, Vortice.DCommon.AlphaMode.Premultiplied);
            var renderTargetProperties = new RenderTargetProperties(dxgiPixelFormat);
            var hwndRenderTargetProperties = new HwndRenderTargetProperties
            {
                Hwnd = hwnd,
                PixelSize = size,
                PresentOptions = PresentOptions.Immediately
            };

            RenderTarget = D2DFactory.CreateHwndRenderTarget(renderTargetProperties, hwndRenderTargetProperties);
            if (RenderTarget is null) throw new InvalidOperationException("Render target creation returned null unexpectedly.");

            RenderTarget.TextAntialiasMode = D2D.TextAntialiasMode.Cleartype;

            Console.WriteLine($"Vortice Graphics initialized successfully for HWND {hwnd}.");
            IsInitialized = true;
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Graphics Initialization failed: {ex.Message}");
            Cleanup(); // Ensures we are in a clean state after failure
            return false;
        }
    }

    public void Resize(SizeI newSize)
    {
        if (!IsInitialized || RenderTarget == null) return;

        try
        {
            Console.WriteLine($"Resizing render target to {newSize}...");
            RenderTarget.Resize(newSize);
            Console.WriteLine("Successfully resized render target.");
        }
        catch (SharpGenException ex)
        {
            Console.WriteLine($"Failed to resize Render Target (SharpGenException): {ex.Message} HRESULT: {ex.ResultCode}");
            if (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
            {
                Console.WriteLine("Render target needs recreation (Detected in Resize Exception).");
                MarkAsLost();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to resize Render Target (General Exception): {ex}");
            MarkAsLost();
        }
    }

    public void BeginDraw()
    {
        if (!IsInitialized || RenderTarget == null)
        {
            return;
        }
        RenderTarget.BeginDraw();
    }

    public void EndDraw()
    {
        if (!IsInitialized || RenderTarget == null) return;

        try
        {
            Result endDrawResult = RenderTarget.EndDraw();
            if (endDrawResult.Failure)
            {
                Console.WriteLine($"EndDraw failed: {endDrawResult.Description}");
                if (endDrawResult.Code == D2D.ResultCode.RecreateTarget.Code)
                {
                    Console.WriteLine("Render target needs recreation (Detected in EndDraw).");
                    MarkAsLost();
                }
            }
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Render target needs recreation (Caught SharpGenException in EndDraw): {ex.Message}");
            MarkAsLost();
        }
    }

    private void MarkAsLost()
    {
        if (!IsInitialized) return;
        Console.WriteLine("Marking graphics device as lost. Resources will be recreated on next opportunity.");
        Cleanup();
    }

    private void CleanupRenderTarget()
    {
        RenderTarget?.Dispose();
        RenderTarget = null;
    }

    public void Cleanup()
    {
        bool resourcesExisted = RenderTarget is not null;
        if (resourcesExisted) Console.WriteLine("Cleaning up GraphicsDevice instance resources...");

        CleanupRenderTarget();
        IsInitialized = false;

        if (resourcesExisted) Console.WriteLine("Finished cleaning GraphicsDevice instance resources.");
    }

    public void Dispose()
    {
        if (_isDisposed) return;
        Cleanup();
        _isDisposed = true;
        GC.SuppressFinalize(this);
    }

    ~GraphicsDevice()
    {
        Dispose();
    }
}
</file>

<file path="ModalWindow.cs">
using Vortice.Mathematics;

namespace DirectUI;

public class ModalWindow : Direct2DAppWindow
{
    private readonly Win32Window _owner;
    private readonly Action<UIContext> _drawCallback;

    public ModalWindow(Win32Window owner, string title, int width, int height, Action<UIContext> drawCallback)
        : base(title, width, height)
    {
        _owner = owner ?? throw new ArgumentNullException(nameof(owner));
        _drawCallback = drawCallback ?? throw new ArgumentNullException(nameof(drawCallback));
    }

    protected override AppHost CreateAppHost()
    {
        Color4 backgroundColor = new(37 / 255f, 37 / 255f, 38 / 255f, 1.0f);
        return new(_drawCallback, backgroundColor);
    }

    public bool CreateAsModal()
    {
        if (Handle != IntPtr.Zero)
        {
            return true;
        }

        uint style =
            NativeMethods.WS_POPUP |
            NativeMethods.WS_CAPTION |
            NativeMethods.WS_SYSMENU |
            NativeMethods.WS_VISIBLE |
            NativeMethods.WS_THICKFRAME;

        int? x = null;
        int? y = null;

        // FIX: Use the owner's handle to get its position for centering.
        if (_owner.Handle != IntPtr.Zero && _owner.GetWindowRect(out NativeMethods.RECT ownerRect))
        {
            int ownerWidth = ownerRect.right - ownerRect.left;
            int ownerHeight = ownerRect.bottom - ownerRect.top;
            int modalWidth = Width;
            int modalHeight = Height;

            x = ownerRect.left + (ownerWidth - modalWidth) / 2;
            y = ownerRect.top + (ownerHeight - modalHeight) / 2;
        }

        // FIX: Pass the owner's handle to the base Create method.
        if (!Create(_owner.Handle, style, x, y))
        {
            return false;
        }

        if (Handle == IntPtr.Zero)
        {
            return false;
        }

        // FIX: Disable the OWNER window, not this modal window.
        // This is the core fix for the modal behavior bug.
        NativeMethods.EnableWindow(_owner.Handle, false);

        return true;
    }

    protected override void OnDestroy()
    {
        // FIX: Re-enable the OWNER window when this modal is destroyed.
        if (_owner.Handle != IntPtr.Zero)
        {
            NativeMethods.EnableWindow(_owner.Handle, true);
        }

        base.OnDestroy();
    }
}
</file>

<file path="MouseButton.cs">
namespace DirectUI;

public enum MouseButton
{
    Left,
    Right,
    Middle,
    XButton1,
    XButton2
}
</file>

<file path="NativeMethods.cs">
// NativeMethods.cs
using System;
using System.Runtime.InteropServices;

// No changes needed here if it was correct from the previous step.
// Ensure these constants are defined:
// WM_NCCREATE, WM_CREATE, WM_NCDESTROY, WM_PAINT, WM_DESTROY, WM_SIZE,
// WM_CLOSE, WM_KEYDOWN, WM_LBUTTONDOWN, WM_LBUTTONUP, WM_MOUSEMOVE, WM_QUIT
// GWLP_USERDATA, VK_ESCAPE, etc.
// And the structs: WNDCLASSEX, MSG, POINT, RECT, CREATESTRUCT
// And the functions: RegisterClassEx, CreateWindowEx, GetMessage, etc.
// And the delegates: WndProc

namespace DirectUI;

internal static class NativeMethods
{
    // --- Constants ---
    public const uint CS_HREDRAW = 0x0002;
    public const uint CS_VREDRAW = 0x0001;
    public const uint CS_OWNDC = 0x0020;

    public const uint WS_OVERLAPPED = 0x00000000;
    public const uint WS_CAPTION = 0x00C00000;
    public const uint WS_SYSMENU = 0x00080000;
    public const uint WS_THICKFRAME = 0x00040000;
    public const uint WS_MINIMIZEBOX = 0x00020000;
    public const uint WS_MAXIMIZEBOX = 0x00010000;
    public const uint WS_OVERLAPPEDWINDOW = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
    public const uint WS_VISIBLE = 0x10000000;
    public const uint WS_POPUP = 0x80000000;

    public const int WM_NCCREATE = 0x0081;
    public const int WM_CREATE = 0x0001;
    public const int WM_NCDESTROY = 0x0082;
    public const int WM_PAINT = 0x000F;
    public const int WM_DESTROY = 0x0002;
    public const int WM_SIZE = 0x0005;
    public const int WM_CLOSE = 0x0010;
    public const int WM_KEYDOWN = 0x0100;
    public const int WM_KEYUP = 0x0101;
    public const int WM_SYSKEYUP = 0x0105;
    public const int WM_LBUTTONDOWN = 0x0201;
    public const int WM_LBUTTONUP = 0x0202; // Ensure this exists
    public const int WM_RBUTTONDOWN = 0x0204;
    public const int WM_RBUTTONUP = 0x0205;
    public const int WM_MBUTTONDOWN = 0x0207;
    public const int WM_MBUTTONUP = 0x0208;
    public const int WM_XBUTTONDOWN = 0x020B;
    public const int WM_XBUTTONUP = 0x020C;
    public const int WM_MOUSEMOVE = 0x0200; // Ensure this exists
    public const int WM_MOUSEWHEEL = 0x020A;
    public const int WM_QUIT = 0x0012;
    public const int WM_CHAR = 0x0102;


    public const int CW_USEDEFAULT = unchecked((int)0x80000000);
    public const int SW_SHOWNORMAL = 1;
    public const int GWLP_USERDATA = -21;

    public const uint PM_REMOVE = 0x0001;

    // --- Structures ---
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
    public struct WNDCLASSEX
    { /* ... as before ... */
        public int cbSize;
        public uint style;
        public WndProc lpfnWndProc; // Use delegate type directly
        public int cbClsExtra;
        public int cbWndExtra;
        public IntPtr hInstance;
        public IntPtr hIcon;
        public IntPtr hCursor;
        public IntPtr hbrBackground;
        public string lpszMenuName;
        public string lpszClassName;
        public IntPtr hIconSm;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct MSG
    { /* ... as before ... */
        public IntPtr hwnd;
        public uint message;
        public IntPtr wParam;
        public IntPtr lParam;
        public uint time;
        public POINT pt;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct POINT
    { /* ... as before ... */
        public int X;
        public int Y;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct RECT
    { /* ... as before ... */
        public int left;
        public int top;
        public int right;
        public int bottom;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct CREATESTRUCT
    { /* ... as before ... */
        public IntPtr lpCreateParams;
        public IntPtr hInstance;
        public IntPtr hMenu;
        public IntPtr hwndParent;
        public int cy; // Height
        public int cx; // Width
        public int y;  // Top
        public int x;  // Left
        public int style;
        [MarshalAs(UnmanagedType.LPWStr)] // Assuming Unicode
        public string lpszName;
        [MarshalAs(UnmanagedType.LPWStr)] // Assuming Unicode
        public string lpszClass;
        public int dwExStyle;
    }

    // --- Delegates ---
    public delegate IntPtr WndProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam);

    // --- Functions ---
    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern ushort RegisterClassEx([In] ref WNDCLASSEX lpwcx);
    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern IntPtr CreateWindowEx(uint dwExStyle, string lpClassName, string lpWindowName, uint dwStyle, int x, int y, int nWidth, int nHeight, IntPtr hWndParent, IntPtr hMenu, IntPtr hInstance, IntPtr lpParam);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool UpdateWindow(IntPtr hWnd);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool DestroyWindow(IntPtr hWnd);
    [DllImport("user32.dll")]
    public static extern IntPtr DefWindowProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam);
    [DllImport("user32.dll")]
    public static extern void PostQuitMessage(int nExitCode);
    [DllImport("user32.dll")]
    public static extern bool GetMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax);
    [DllImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool PeekMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax, uint wRemoveMsg);
    [DllImport("user32.dll")]
    public static extern bool TranslateMessage([In] ref MSG lpMsg);
    [DllImport("user32.dll")]
    public static extern IntPtr DispatchMessage([In] ref MSG lpmsg);
    [DllImport("user32.dll")]
    public static extern bool GetClientRect(IntPtr hWnd, out RECT lpRect);
    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern IntPtr GetModuleHandle(string lpModuleName);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool InvalidateRect(IntPtr hWnd, IntPtr lpRect, bool bErase);
    [DllImport("user32.dll")]
    public static extern IntPtr LoadCursor(IntPtr hInstance, int lpCursorName);
    [DllImport("user32.dll")]
    public static extern IntPtr LoadIcon(IntPtr hInstance, IntPtr lpIconName);
    [DllImport("user32.dll", EntryPoint = "SetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr SetWindowLongPtr64(IntPtr hWnd, int nIndex, IntPtr dwNewLong);
    [DllImport("user32.dll", EntryPoint = "SetWindowLongW", SetLastError = true)]
    private static extern IntPtr SetWindowLong32(IntPtr hWnd, int nIndex, IntPtr dwNewLong);
    [DllImport("user32.dll", EntryPoint = "GetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr GetWindowLongPtr64(IntPtr hWnd, int nIndex);
    [DllImport("user32.dll", EntryPoint = "GetWindowLongW", SetLastError = true)]
    private static extern IntPtr GetWindowLong32(IntPtr hWnd, int nIndex);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr SetCapture(IntPtr hWnd);
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool ReleaseCapture();
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool EnableWindow(IntPtr hWnd, bool bEnable);
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool GetWindowRect(IntPtr hwnd, out RECT lpRect);


    public static IntPtr SetWindowLongPtr(IntPtr hWnd, int nIndex, IntPtr dwNewLong)
    {
        if (IntPtr.Size == 8) return SetWindowLongPtr64(hWnd, nIndex, dwNewLong);
        else return SetWindowLong32(hWnd, nIndex, dwNewLong);
    }
    public static IntPtr GetWindowLongPtr(IntPtr hWnd, int nIndex)
    {
        if (IntPtr.Size == 8) return GetWindowLongPtr64(hWnd, nIndex);
        else return GetWindowLong32(hWnd, nIndex);
    }

    // --- Helpers ---
    public static short LoWord(IntPtr val) => unchecked((short)(long)val);
    public static short HiWord(IntPtr val) => unchecked((short)((long)val >> 16));
}
</file>

<file path="SharedGraphicsResources.cs">
// SharedGraphicsResources.cs
using System;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using SharpGen.Runtime;
using D2D = Vortice.Direct2D1;
using DW = Vortice.DirectWrite;

namespace DirectUI;

/// <summary>
/// Manages graphics resources that are shared across the entire application,
/// such as the main Direct2D and DirectWrite factories.
/// </summary>
internal static class SharedGraphicsResources
{
    public static ID2D1Factory1? D2DFactory { get; private set; }
    public static IDWriteFactory? DWriteFactory { get; private set; }

    private static bool s_isInitialized = false;

    /// <summary>
    /// Initializes the shared factories. Should be called once at application startup.
    /// </summary>
    public static void Initialize()
    {
        if (s_isInitialized) return;

        try
        {
            Result factoryResult = D2D1.D2D1CreateFactory(D2D.FactoryType.SingleThreaded, out ID2D1Factory1? d2dFactory);
            factoryResult.CheckError();
            D2DFactory = d2dFactory ?? throw new InvalidOperationException("Shared D2D Factory creation failed silently.");

            Result dwriteResult = DW.DWrite.DWriteCreateFactory(DW.FactoryType.Shared, out IDWriteFactory? dwriteFactory);
            dwriteResult.CheckError();
            DWriteFactory = dwriteFactory ?? throw new InvalidOperationException("Shared DWrite Factory creation failed silently.");

            Console.WriteLine("Shared Graphics Factories Initialized.");
            s_isInitialized = true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"FATAL: Could not initialize shared graphics resources: {ex.Message}");
            Cleanup();
            throw;
        }
    }

    /// <summary>
    /// Disposes of the shared factories. Should be called once when the application is closing.
    /// </summary>
    public static void Cleanup()
    {
        if (!s_isInitialized) return;
        Console.WriteLine("Cleaning up shared graphics factories...");
        DWriteFactory?.Dispose();
        DWriteFactory = null;
        D2DFactory?.Dispose();
        D2DFactory = null;
        s_isInitialized = false;
        Console.WriteLine("Shared graphics factories cleaned up.");
    }
}
</file>

<file path="Win32Window.cs">
// Win32Window.cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace DirectUI;

public abstract class Win32Window : IDisposable
{
    private readonly string _windowClassName;
    private readonly string _windowTitle;
    private readonly int _initialWidth;
    private readonly int _initialHeight;
    private IntPtr _hwnd = IntPtr.Zero;
    private IntPtr _hInstance = IntPtr.Zero;
    private NativeMethods.WndProc _wndProcDelegate;
    private bool _isDisposed = false;
    private static readonly HashSet<string> RegisteredClassNames = new HashSet<string>();
    private GCHandle _gcHandle;

    public IntPtr Handle => _hwnd;
    public int Width { get; protected set; }
    public int Height { get; protected set; }
    protected IntPtr OwnerHandle { get; private set; } = IntPtr.Zero;

    protected Win32Window(string title, int width, int height, string className = null)
    {
        _windowTitle = title ?? "Win32 Window";
        _initialWidth = width > 0 ? width : 800;
        _initialHeight = height > 0 ? height : 600;
        Width = _initialWidth;
        Height = _initialHeight;
        _windowClassName = className ?? ("Win32Window_" + Guid.NewGuid().ToString("N"));
        _wndProcDelegate = WindowProcedure;
    }

    public bool Create(IntPtr owner = default, uint? style = null, int? x = null, int? y = null)
    {
        OwnerHandle = owner;

        if (_hwnd != IntPtr.Zero)
        {
            return true;
        }

        if (!TryCreateWindow(owner, style, x, y))
        {
            Console.WriteLine("Window creation failed.");
            Dispose();
            return false;
        }

        if (!Initialize())
        {
            Console.WriteLine("Derived init failed.");
            Dispose();
            return false;
        }

        NativeMethods.ShowWindow(_hwnd, NativeMethods.SW_SHOWNORMAL);
        NativeMethods.UpdateWindow(_hwnd);

        return true;
    }

    private bool TryCreateWindow(IntPtr owner, uint? style, int? x, int? y)
    {
        _hInstance = NativeMethods.GetModuleHandle(null);

        if (_hInstance == IntPtr.Zero)
        {
            _hInstance = Process.GetCurrentProcess().Handle;
        }

        Application.RegisterWindow(this);

        lock (RegisteredClassNames)
        {
            if (!RegisteredClassNames.Contains(_windowClassName))
            {
                NativeMethods.WNDCLASSEX wndClass = new()
                {
                    cbSize = Marshal.SizeOf(typeof(NativeMethods.WNDCLASSEX)),
                    style = NativeMethods.CS_HREDRAW | NativeMethods.CS_VREDRAW,
                    lpfnWndProc = _wndProcDelegate,
                    hInstance = _hInstance,
                    lpszClassName = _windowClassName,
                    hIcon = NativeMethods.LoadIcon(IntPtr.Zero, (IntPtr)32512),
                    hCursor = NativeMethods.LoadCursor(IntPtr.Zero, 32512),
                };

                if (NativeMethods.RegisterClassEx(ref wndClass) == 0)
                {
                    Console.WriteLine($"RegisterClassEx failed: {Marshal.GetLastWin32Error()}");
                    return false;
                }

                RegisteredClassNames.Add(_windowClassName);
                Console.WriteLine($"Class '{_windowClassName}' registered.");
            }
        }

        _gcHandle = GCHandle.Alloc(this);

        uint windowStyle = style ?? (NativeMethods.WS_OVERLAPPEDWINDOW | NativeMethods.WS_VISIBLE);

        int finalX = x ?? NativeMethods.CW_USEDEFAULT;
        int finalY = y ?? NativeMethods.CW_USEDEFAULT;

        _hwnd = NativeMethods.CreateWindowEx(
            0,
            _windowClassName,
            _windowTitle,
            windowStyle,
            finalX,
            finalY,
            _initialWidth,
            _initialHeight,
            owner,
            IntPtr.Zero,
            _hInstance,
            GCHandle.ToIntPtr(_gcHandle));

        if (_hwnd == IntPtr.Zero)
        {
            Console.WriteLine($"CreateWindowEx failed: {Marshal.GetLastWin32Error()}");

            if (_gcHandle.IsAllocated)
            {
                _gcHandle.Free();
            }

            return false;
        }

        Console.WriteLine($"Window created: {_hwnd}"); return true;
    }

    private static IntPtr WindowProcedure(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        Win32Window? window = null;

        if (msg == NativeMethods.WM_NCCREATE)
        {
            var cs = Marshal.PtrToStructure<NativeMethods.CREATESTRUCT>(lParam);
            var handle = GCHandle.FromIntPtr(cs.lpCreateParams); window = handle.Target as Win32Window;

            NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, GCHandle.ToIntPtr(handle));
            Console.WriteLine($"WM_NCCREATE: Associated instance with HWND {hWnd}");
        }
        else
        {
            IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA);

            if (ptr != IntPtr.Zero)
            {
                var handle = GCHandle.FromIntPtr(ptr); window = handle.Target as Win32Window;
            }
        }

        if (window is null)
        {
            return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
        }

        try
        {
            return window.HandleMessage(hWnd, msg, wParam, lParam);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling msg {msg}: {ex}");
        }

        return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
    }

    protected virtual IntPtr HandleMessage(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        switch (msg)
        {
            case NativeMethods.WM_PAINT:
                OnPaint();
                return IntPtr.Zero;

            case NativeMethods.WM_SIZE:
                Width = NativeMethods.LoWord(lParam);
                Height = NativeMethods.HiWord(lParam);
                OnSize(Width, Height);
                return IntPtr.Zero;

            case NativeMethods.WM_MOUSEMOVE:
                OnMouseMove(NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
                return IntPtr.Zero;

            case NativeMethods.WM_LBUTTONDOWN:
                NativeMethods.SetCapture(hWnd);
                OnMouseDown(MouseButton.Left, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
                return IntPtr.Zero;

            case NativeMethods.WM_LBUTTONUP:
                NativeMethods.ReleaseCapture();
                OnMouseUp(MouseButton.Left, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
                return IntPtr.Zero;

            case NativeMethods.WM_RBUTTONDOWN:
                NativeMethods.SetCapture(hWnd);
                OnMouseDown(MouseButton.Right, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
                return IntPtr.Zero;

            case NativeMethods.WM_RBUTTONUP:
                NativeMethods.ReleaseCapture();
                OnMouseUp(MouseButton.Right, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
                return IntPtr.Zero;

            case NativeMethods.WM_MBUTTONDOWN:
                NativeMethods.SetCapture(hWnd);
                OnMouseDown(MouseButton.Middle, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
                return IntPtr.Zero;

            case NativeMethods.WM_MBUTTONUP:
                NativeMethods.ReleaseCapture();
                OnMouseUp(MouseButton.Middle, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
                return IntPtr.Zero;

            case NativeMethods.WM_XBUTTONDOWN:
                {
                    short xButton = NativeMethods.HiWord(wParam);
                    var button = (xButton == 1) ? MouseButton.XButton1 : MouseButton.XButton2;
                    NativeMethods.SetCapture(hWnd);
                    OnMouseDown(button, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
                    return IntPtr.Zero;
                }

            case NativeMethods.WM_XBUTTONUP:
                {
                    short xButton = NativeMethods.HiWord(wParam);
                    var button = (xButton == 1) ? MouseButton.XButton1 : MouseButton.XButton2;
                    NativeMethods.ReleaseCapture();
                    OnMouseUp(button, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
                    return IntPtr.Zero;
                }

            case NativeMethods.WM_MOUSEWHEEL:
                short wheelDelta = NativeMethods.HiWord(wParam);
                OnMouseWheel((float)wheelDelta / 120.0f); // Normalize delta
                return IntPtr.Zero;

            case NativeMethods.WM_KEYDOWN:
                OnKeyDown((Keys)wParam);
                return IntPtr.Zero;

            case NativeMethods.WM_KEYUP:
                OnKeyUp((Keys)wParam);
                return IntPtr.Zero;

            case NativeMethods.WM_CHAR:
                OnChar((char)wParam);
                return IntPtr.Zero;

            case NativeMethods.WM_CLOSE:
                if (OnClose())
                {
                    NativeMethods.DestroyWindow(hWnd);
                }

                return IntPtr.Zero;

            case NativeMethods.WM_DESTROY:
                Console.WriteLine($"WM_DESTROY for {hWnd}.");
                Application.UnregisterWindow(this);
                OnDestroy();

                if (OwnerHandle == IntPtr.Zero)
                {
                    Application.Exit();
                }

                return IntPtr.Zero;

            case NativeMethods.WM_NCDESTROY:
                Console.WriteLine($"WM_NCDESTROY: Releasing GCHandle for {hWnd}.");

                IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA);

                if (ptr != IntPtr.Zero)
                {
                    var handle = GCHandle.FromIntPtr(ptr);

                    if (handle.IsAllocated)
                    {
                        handle.Free();
                    }

                    NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, IntPtr.Zero);
                }

                if (_gcHandle.IsAllocated && GCHandle.ToIntPtr(_gcHandle) == ptr)
                {
                    _gcHandle = default;

                }

                _hwnd = IntPtr.Zero;

                return IntPtr.Zero;

            default:
                return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
        }
    }

    public void Close()
    {
        if (_hwnd == IntPtr.Zero)
        {
            return;
        }

        NativeMethods.DestroyWindow(_hwnd);
    }

    public void Invalidate()
    {
        if (_hwnd == IntPtr.Zero)
        {
            return;
        }

        NativeMethods.InvalidateRect(_hwnd, IntPtr.Zero, false);
    }

    public virtual void FrameUpdate()
    {

    }

    internal bool GetWindowRect(out NativeMethods.RECT rect)
    {
        if (Handle == IntPtr.Zero)
        {
            rect = default;
            return false;
        }

        return NativeMethods.GetWindowRect(Handle, out rect);
    }

    protected virtual bool Initialize()
    {
        return true;
    }

    protected abstract void OnPaint();

    protected virtual void OnSize(int width, int height)
    {

    }

    protected virtual void OnMouseDown(MouseButton button, int x, int y)
    {

    }

protected virtual void OnMouseUp(MouseButton button, int x, int y)
    {

    }

    protected virtual void OnMouseMove(int x, int y)
    {

    }

    protected virtual void OnKeyDown(Keys key)
    {

    }

    protected virtual void OnKeyUp(Keys key)
    {

    }

    protected virtual void OnMouseWheel(float delta)
    {

    }

    protected virtual void OnChar(char c)
    {

    }

    protected virtual bool OnClose()
    {
        return true;
    }

    protected virtual void OnDestroy()
    {

    }

    protected virtual void Cleanup()
    {

    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (_isDisposed)
        {
            return;
        }

        if (disposing)
        {
            Console.WriteLine("Disposing Win32Window (managed)...");
            Cleanup();
        }

        Console.WriteLine("Disposing Win32Window (unmanaged)...");

        if (_hwnd != IntPtr.Zero)
        {
            Console.WriteLine($"Destroying window {_hwnd} during Dispose...");
            NativeMethods.DestroyWindow(_hwnd);
            _hwnd = IntPtr.Zero;
        }
        else
        {
            if (_gcHandle.IsAllocated)
            {
                Console.WriteLine("Freeing dangling GCHandle...");
                _gcHandle.Free();
            }
        }

        _isDisposed = true;

        Console.WriteLine("Win32Window disposed.");
    }

    ~Win32Window()
    {
        Console.WriteLine("Win32Window Finalizer!");
        Dispose(false);
    }
}
</file>

<file path="Containers\ComboboxState.cs">
namespace DirectUI;

internal class ComboboxState
{
    public bool IsOpen;
}
</file>

<file path="Containers\GridContainerState.cs">
using System.Numerics;

namespace DirectUI;

internal class GridContainerState : ILayoutContainer
{
    internal int Id { get; }
    internal Vector2 StartPosition { get; } // Top-left corner of the grid area
    internal int NumColumns { get; }
    internal Vector2 Gap { get; } // Gap between cells (X and Y)
    internal Vector2 AvailableSize { get; } // Total area the grid can occupy

    // Calculated layout values
    internal float CellWidth { get; }
    internal List<float> RowHeights { get; } = new(); // Store height of each completed row
    internal float CurrentRowMaxHeight { get; set; } = 0f; // Track max height of elements in the current row being built
    internal int CurrentCellIndex { get; set; } = 0; // 0-based index of the next cell to place an element in
    internal Vector2 CurrentDrawPosition { get; set; } // Calculated top-left for the next element

    // Tracking overall bounds occupied by elements
    internal float AccumulatedWidth { get; set; } = 0f;
    internal float AccumulatedHeight { get; set; } = 0f;


    internal GridContainerState(int id, Vector2 startPosition, Vector2 availableSize, int numColumns, Vector2 gap)
    {
        Id = id;
        StartPosition = startPosition;
        AvailableSize = availableSize;
        NumColumns = Math.Max(1, numColumns); // Ensure at least one column
        Gap = gap;

        // Calculate fixed cell width based on available space and gaps
        float totalHorizontalGap = Math.Max(0, NumColumns - 1) * Gap.X;
        float widthForCells = AvailableSize.X - totalHorizontalGap;
        CellWidth = (NumColumns > 0) ? Math.Max(0, widthForCells / NumColumns) : 0;

        // Initial position is the start position
        CurrentDrawPosition = startPosition;
        RowHeights.Add(0); // Add initial height for the first row (will be updated)
    }

    internal void MoveToNextCell(Vector2 elementSize)
    {
        // Update max height for the current row
        CurrentRowMaxHeight = Math.Max(CurrentRowMaxHeight, elementSize.Y);

        // Update total occupied width (conservative estimate using cell width)
        int currentCol = CurrentCellIndex % NumColumns;
        float currentWidth = (currentCol + 1) * CellWidth + currentCol * Gap.X;
        AccumulatedWidth = Math.Max(AccumulatedWidth, currentWidth);


        CurrentCellIndex++;
        int nextCol = CurrentCellIndex % NumColumns;

        if (nextCol == 0) // Moved to the start of a new row
        {
            // Finalize the height of the completed row
            RowHeights[^1] = CurrentRowMaxHeight; // Update last row's height
            AccumulatedHeight += CurrentRowMaxHeight + (RowHeights.Count > 1 ? Gap.Y : 0); // Add height and gap (if not first row)

            // Reset for the new row
            CurrentRowMaxHeight = 0f;
            RowHeights.Add(0); // Add placeholder height for the new row

            // Calculate Y position for the new row
            float newY = StartPosition.Y;
            for (int i = 0; i < RowHeights.Count - 1; i++) // Sum heights and gaps of completed rows
            {
                newY += RowHeights[i] + Gap.Y;
            }

            // Set position for the first cell of the new row
            CurrentDrawPosition = new Vector2(StartPosition.X, newY);

        }
        else // Moving to the next column in the same row
        {
            // Calculate X position for the next cell
            float currentX = StartPosition.X + nextCol * (CellWidth + Gap.X);
            CurrentDrawPosition = new Vector2(currentX, CurrentDrawPosition.Y); // Y stays the same
        }
    }

    internal Vector2 GetTotalOccupiedSize()
    {
        // Calculate final height including the current row being built
        float finalHeight = AccumulatedHeight + CurrentRowMaxHeight;
        return new Vector2(AccumulatedWidth, finalHeight);
    }

    public Vector2 GetCurrentPosition() => CurrentDrawPosition;

    public void Advance(Vector2 elementSize) => MoveToNextCell(elementSize);
}
</file>

<file path="Containers\HBoxContainerState.cs">
using System.Numerics;

namespace DirectUI;

public class HBoxContainerState : ILayoutContainer
{
    internal int Id { get; }
    internal Vector2 StartPosition { get; set; }
    internal Vector2 CurrentPosition { get; set; }
    internal float Gap { get; set; }
    internal float MaxElementHeight { get; set; } = 0f;
    internal float AccumulatedWidth { get; set; } = 0f;
    internal int ElementCount { get; set; } = 0;

    internal HBoxContainerState(int id)
    {
        Id = id;
    }

    public Vector2 GetCurrentPosition() => CurrentPosition;

    public void Advance(Vector2 elementSize)
    {
        if (elementSize.Y > MaxElementHeight)
        {
            MaxElementHeight = elementSize.Y;
        }

        AccumulatedWidth += elementSize.X;
        if (ElementCount > 0)
        {
            AccumulatedWidth += Gap;
        }
        float advanceX = elementSize.X + Gap;
        CurrentPosition = new Vector2(CurrentPosition.X + advanceX, CurrentPosition.Y);
        ElementCount++;
    }
}
</file>

<file path="Containers\ResizableHPanelState.cs">
using System.Numerics;

namespace DirectUI;

internal class ResizableHPanelState : ILayoutContainer
{
    internal int Id { get; }
    internal HBoxContainerState InnerHBox { get; }
    internal bool ClipRectWasPushed { get; }

    internal ResizableHPanelState(int id, HBoxContainerState innerHBox, bool clipPushed)
    {
        Id = id;
        InnerHBox = innerHBox;
        ClipRectWasPushed = clipPushed;
    }

    public Vector2 GetCurrentPosition() => InnerHBox.GetCurrentPosition();

    public void Advance(Vector2 elementSize) => InnerHBox.Advance(elementSize);
}
</file>

<file path="Containers\ResizablePanelState.cs">
using System.Numerics;

namespace DirectUI;

internal class ResizablePanelState : ILayoutContainer
{
    internal int Id { get; }
    internal VBoxContainerState InnerVBox { get; }
    internal bool ClipRectWasPushed { get; }

    internal ResizablePanelState(int id, VBoxContainerState innerVBox, bool clipPushed)
    {
        Id = id;
        InnerVBox = innerVBox;
        ClipRectWasPushed = clipPushed;
    }

    public Vector2 GetCurrentPosition() => InnerVBox.GetCurrentPosition();

    public void Advance(Vector2 elementSize) => InnerVBox.Advance(elementSize);
}
</file>

<file path="Containers\ScrollContainerState.cs">
using System.Numerics;

namespace DirectUI;

public class ScrollContainerState : ILayoutContainer
{
    // State managed by the UI system
    internal Vector2 CurrentScrollOffset { get; set; }

    // Per-frame calculated values
    internal int Id { get; set; }
    internal Vector2 Position { get; set; }
    internal Vector2 VisibleSize { get; set; }
    internal Vector2 ContentSize { get; set; }
    internal bool IsHovered { get; set; }
    internal VBoxContainerState ContentVBox { get; set; } = null!;

    // Public parameterless constructor required for GetOrCreateElement
    public ScrollContainerState() { }

    public Vector2 GetCurrentPosition() => ContentVBox.GetCurrentPosition();

    public void Advance(Vector2 elementSize) => ContentVBox.Advance(elementSize);
}
</file>

<file path="Containers\TreeViewState.cs">
namespace DirectUI;

internal class TreeViewState
{
    internal int Id { get; }
    internal TreeStyle Style { get; }
    internal Stack<bool> IndentLineState { get; } = new();

    internal TreeViewState(int id, TreeStyle style)
    {
        Id = id;
        Style = style;
    }
}
</file>

<file path="Containers\VBoxContainerState.cs">
using System.Numerics;

namespace DirectUI;

public class VBoxContainerState : ILayoutContainer
{
    internal int Id { get; }
    internal Vector2 StartPosition { get; set; }
    internal Vector2 CurrentPosition { get; set; } // Top-left for the next element
    internal float Gap { get; set; }
    internal float MaxElementWidth { get; set; } = 0f; // Track width for container bounds
    internal float AccumulatedHeight { get; set; } = 0f; // Track height for container bounds
    internal int ElementCount { get; set; } = 0;

    internal VBoxContainerState(int id)
    {
        Id = id;
    }

    public Vector2 GetCurrentPosition() => CurrentPosition;

    public void Advance(Vector2 elementSize)
    {
        if (elementSize.X > MaxElementWidth)
        {
            MaxElementWidth = elementSize.X;
        }

        AccumulatedHeight += elementSize.Y;
        if (ElementCount > 0)
        {
            AccumulatedHeight += Gap;
        }
        float advanceY = elementSize.Y + Gap;
        CurrentPosition = new Vector2(CurrentPosition.X, CurrentPosition.Y + advanceY);
        ElementCount++;
    }
}
</file>

<file path="Core\ILayoutContainer.cs">
using System.Numerics;

namespace DirectUI;

public interface ILayoutContainer
{
    Vector2 GetCurrentPosition();
    void Advance(Vector2 elementSize);
}
</file>

<file path="Core\UI.Button.cs">
using System.Numerics;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

public static partial class UI
{
    public static bool Button(
        string id,
        string text,
        Vector2 size = default,
        ButtonStylePack? theme = null,
        bool disabled = false,
        bool autoWidth = false,
        Vector2? textMargin = null,
        Button.ActionMode clickMode = DirectUI.Button.ActionMode.Release,
        Button.ClickBehavior clickBehavior = DirectUI.Button.ClickBehavior.Left,
        Alignment? textAlignment = null,
        Vector2? textOffset = null,
        Vector2? origin = null,
        object? userData = null)
    {
        if (!IsContextValid()) return false;

        int intId = id.GetHashCode();
        var finalTheme = theme ?? State.GetOrCreateElement<ButtonStylePack>(HashCode.Combine(intId, "theme"));
        State.SetUserData(intId, userData);

        Vector2 finalSize = size == default ? new Vector2(84, 28) : size;
        Vector2 finalOrigin = origin ?? Vector2.Zero;

        // Auto-width calculation must happen before culling.
        if (autoWidth)
        {
            var styleForMeasuring = finalTheme.Normal; // Measure against the normal style
            Vector2 measuredSize = Resources.MeasureText(Context.DWriteFactory, text, styleForMeasuring);
            Vector2 margin = textMargin ?? new Vector2(10, 5);
            finalSize.X = measuredSize.X + margin.X * 2;
        }

        Vector2 drawPos = Context.Layout.GetCurrentPosition();
        Rect widgetBounds = new Rect(drawPos.X - finalOrigin.X, drawPos.Y - finalOrigin.Y, finalSize.X, finalSize.Y);

        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(finalSize);
            return false;
        }

        bool pushedClip = false;
        if (Context.Layout.IsInLayoutContainer() && Context.Layout.PeekContainer() is GridContainerState grid)
        {
            float clipStartY = grid.CurrentDrawPosition.Y;
            float gridBottomY = grid.StartPosition.Y + grid.AvailableSize.Y;
            float clipHeight = Math.Max(0f, gridBottomY - clipStartY);
            Rect cellClipRect = new Rect(grid.CurrentDrawPosition.X, clipStartY, Math.Max(0f, grid.CellWidth), clipHeight);
            if (Context.RenderTarget is not null && cellClipRect.Width > 0 && cellClipRect.Height > 0)
            {
                Context.RenderTarget.PushAxisAlignedClip(cellClipRect, D2D.AntialiasMode.Aliased);
                pushedClip = true;
            }
        }

        bool clicked = ButtonPrimitive(
            intId,
            widgetBounds,
            text,
            finalTheme,
            disabled,
            textAlignment ?? new Alignment(HAlignment.Center, VAlignment.Center),
            clickMode,
            clickBehavior,
            textOffset ?? Vector2.Zero
        );

        if (pushedClip && Context.RenderTarget is not null)
        {
            Context.RenderTarget.PopAxisAlignedClip();
        }

        Context.Layout.AdvanceLayout(finalSize);
        return clicked;
    }
}
</file>

<file path="Core\UI.ComboBox.cs">
using System.Numerics;

namespace DirectUI;

public static partial class UI
{
    public static bool Combobox(
        string id,
        ref int selectedIndex,
        string[] items,
        Vector2 size,
        Vector2 position = default,
        ButtonStylePack? theme = null,
        bool disabled = false)
    {
        if (!IsContextValid())
        {
            return false;
        }

        int intId = id.GetHashCode();
        Vector2 drawPos = Context.Layout.ApplyLayout(position);

        // Culling check
        if (!Context.Layout.IsRectVisible(new(drawPos.X, drawPos.Y, size.X, size.Y)))
        {
            Context.Layout.AdvanceLayout(size);
            return false;
        }

        var comboboxInstance = State.GetOrCreateElement<InternalComboboxLogic>(intId);
        int newIndex = comboboxInstance.UpdateAndDraw(intId, selectedIndex, items, drawPos, size, theme, disabled);

        bool valueChanged = newIndex != selectedIndex;
        if (valueChanged)
        {
            selectedIndex = newIndex;
        }

        Context.Layout.AdvanceLayout(size);
        return valueChanged;
    }
}
</file>

<file path="Core\UI.Containers.cs">
// Core/UI.Containers.cs
using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

public static partial class UI
{
    public static void BeginHBoxContainer(string id, Vector2 position, float gap = 5.0f)
    {
        Context.Layout.BeginHBox(id.GetHashCode(), position, gap);
    }

    public static void EndHBoxContainer()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not HBoxContainerState state)
        { Console.WriteLine("Error: EndHBoxContainer called without a matching BeginHBoxContainer."); return; }
        Context.Layout.PopContainer();
        if (Context.Layout.IsInLayoutContainer())
        { Context.Layout.AdvanceContainerLayout(new Vector2(state.AccumulatedWidth, state.MaxElementHeight)); }
    }

    public static void BeginVBoxContainer(string id, Vector2 position, float gap = 5.0f)
    {
        Context.Layout.BeginVBox(id.GetHashCode(), position, gap);
    }

    public static void EndVBoxContainer()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not VBoxContainerState state)
        { Console.WriteLine("Error: EndVBoxContainer called without a matching BeginVBoxContainer."); return; }
        Context.Layout.PopContainer();
        if (Context.Layout.IsInLayoutContainer())
        { Context.Layout.AdvanceContainerLayout(new Vector2(state.MaxElementWidth, state.AccumulatedHeight)); }
    }

    public static void BeginGridContainer(string id, Vector2 position, Vector2 availableSize, int numColumns, Vector2 gap)
    {
        Context.Layout.PushContainer(new GridContainerState(id.GetHashCode(), position, availableSize, numColumns, gap));
    }

    public static void EndGridContainer()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not GridContainerState state)
        { Console.WriteLine("Error: EndGridContainer called without a matching BeginGridContainer."); return; }
        Context.Layout.PopContainer();
        if (Context.Layout.IsInLayoutContainer())
        {
            Vector2 containerSize = state.GetTotalOccupiedSize();
            Context.Layout.AdvanceContainerLayout(containerSize);
        }
    }

    public static void BeginScrollableRegion(string id, Vector2 size)
    {
        if (!IsContextValid()) return;

        int intId = id.GetHashCode();
        Vector2 position = Context.Layout.GetCurrentPosition();
        Rect regionBounds = new Rect(position.X, position.Y, size.X, size.Y);

        var scrollState = State.GetOrCreateElement<ScrollContainerState>(intId);
        scrollState.Id = intId;
        scrollState.Position = position;
        scrollState.VisibleSize = size;
        scrollState.IsHovered = regionBounds.Contains(Context.InputState.MousePosition);

        // Handle scroll input
        if (scrollState.IsHovered && Context.InputState.ScrollDelta != 0)
        {
            var offset = scrollState.CurrentScrollOffset;
            offset.Y -= Context.InputState.ScrollDelta * 20; // Apply scroll wheel input
            scrollState.CurrentScrollOffset = offset;
        }

        // Clamp the offset *before* using it for layout. Use the content size from the *previous* frame for this.
        float maxScrollY = Math.Max(0, scrollState.ContentSize.Y - scrollState.VisibleSize.Y);
        var clampedOffset = scrollState.CurrentScrollOffset;
        clampedOffset.Y = Math.Clamp(clampedOffset.Y, 0, maxScrollY);
        scrollState.CurrentScrollOffset = clampedOffset;

        // Begin the inner container for content layout, offset by the now-clamped scroll position
        var contentVBoxId = HashCode.Combine(intId, "scroll_vbox");
        var contentVBox = Context.Layout.GetOrCreateVBoxState(contentVBoxId);
        contentVBox.StartPosition = position - scrollState.CurrentScrollOffset;
        contentVBox.CurrentPosition = position - scrollState.CurrentScrollOffset;
        contentVBox.Gap = 0; // The user can nest another VBox inside for gaps
        contentVBox.MaxElementWidth = 0f;
        contentVBox.AccumulatedHeight = 0f;
        contentVBox.ElementCount = 0;
        scrollState.ContentVBox = contentVBox;

        Context.Layout.PushClipRect(regionBounds);
        Context.RenderTarget.PushAxisAlignedClip(regionBounds, D2D.AntialiasMode.Aliased);

        Context.Layout.PushContainer(scrollState);
    }

    public static void EndScrollableRegion()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not ScrollContainerState scrollState)
        { Console.WriteLine("Error: EndScrollableRegion called without a matching Begin."); return; }

        // Finalize content size based on what was rendered inside the container.
        // This new size will be used for clamping in the *next* frame.
        scrollState.ContentSize = new Vector2(scrollState.ContentVBox.MaxElementWidth, scrollState.ContentVBox.AccumulatedHeight);

        // Pop the container and clip rect so the scrollbar can be drawn outside the content's clipped area.
        Context.Layout.PopContainer();
        Context.RenderTarget.PopAxisAlignedClip();
        Context.Layout.PopClipRect();

        // Draw scrollbar if needed. This will return a new, validated scroll offset.
        if (scrollState.ContentSize.Y > scrollState.VisibleSize.Y)
        {
            string scrollBarIdString = scrollState.Id + "_scrollbar";
            float scrollbarThickness = 12f;
            var scrollBarPos = new Vector2(scrollState.Position.X + scrollState.VisibleSize.X - scrollbarThickness, scrollState.Position.Y);

            // The VScrollBar handles all its own logic, including clamping the value against the new content size.
            float newScrollY = VScrollBar(
                id: scrollBarIdString,
                currentScrollOffset: scrollState.CurrentScrollOffset.Y,
                position: scrollBarPos,
                trackHeight: scrollState.VisibleSize.Y,
                contentHeight: scrollState.ContentSize.Y,
                visibleHeight: scrollState.VisibleSize.Y,
                thickness: scrollbarThickness);

            // Update the state with the value from the scrollbar for the next frame.
            scrollState.CurrentScrollOffset = new Vector2(scrollState.CurrentScrollOffset.X, newScrollY);
        }
        else
        {
            // If no scrollbar is needed, ensure the offset is zero.
            scrollState.CurrentScrollOffset = new Vector2(scrollState.CurrentScrollOffset.X, 0);
        }

        // After everything, advance the main layout cursor by the size of the scroll region itself.
        Context.Layout.AdvanceLayout(scrollState.VisibleSize);
    }

    public static void BeginResizableVPanel(
        string id,
        ref float currentWidth,
        HAlignment alignment = HAlignment.Left,
        float topOffset = 0f,
        float minWidth = 50f,
        float maxWidth = 500f,
        float resizeHandleWidth = 5f,
        BoxStyle? panelStyle = null,
        Vector2 padding = default,
        float gap = 5f,
        bool disabled = false)
    {
        if (!IsContextValid()) return;
        var intId = id.GetHashCode();

        Vector2 finalPadding = (padding == default) ? new Vector2(5, 5) : padding;

        var input = Context.InputState;
        var renderTarget = Context.RenderTarget;
        var windowWidth = renderTarget.Size.Width;
        var windowHeight = renderTarget.Size.Height;
        var availableHeight = windowHeight - topOffset;

        if (!disabled)
        {
            float handleWidth = Math.Min(resizeHandleWidth, currentWidth);
            float panelX = (alignment == HAlignment.Right) ? windowWidth - currentWidth : 0;
            float handleX = (alignment == HAlignment.Right) ? panelX : panelX + currentWidth - handleWidth;
            Rect handleRect = new Rect(handleX, topOffset, handleWidth, availableHeight);

            bool isHoveringHandle = handleRect.Contains(input.MousePosition.X, input.MousePosition.Y);
            if (isHoveringHandle) State.SetPotentialInputTarget(intId);
            if (input.WasLeftMousePressedThisFrame && isHoveringHandle && State.PotentialInputTargetId == intId && !State.DragInProgressFromPreviousFrame) State.SetPotentialCaptorForFrame(intId);
            if (State.ActivelyPressedElementId == intId && !input.IsLeftMouseDown) State.ClearActivePress(intId);
            if (State.ActivelyPressedElementId == intId && input.IsLeftMouseDown)
            {
                if (alignment == HAlignment.Left) currentWidth = Math.Clamp(input.MousePosition.X, minWidth, maxWidth);
                else currentWidth = Math.Clamp(windowWidth - input.MousePosition.X, minWidth, maxWidth);
            }
        }

        var finalPanelStyle = panelStyle ?? new BoxStyle { FillColor = new(0.15f, 0.15f, 0.2f, 1.0f), BorderColor = DefaultTheme.NormalBorder, BorderLength = 1 };
        currentWidth = Math.Max(0, currentWidth);
        float finalPanelX = (alignment == HAlignment.Right) ? windowWidth - currentWidth : 0;
        Rect panelRect = new Rect(finalPanelX, topOffset, currentWidth, availableHeight);
        if (panelRect.Width > 0 && panelRect.Height > 0)
        {
            Resources.DrawBoxStyleHelper(renderTarget, new Vector2(panelRect.X, panelRect.Y), new Vector2(panelRect.Width, panelRect.Height), finalPanelStyle);
        }

        Vector2 contentStartPosition = new Vector2(finalPanelX + finalPadding.X, topOffset + finalPadding.Y);
        Rect contentClipRect = new Rect(contentStartPosition.X, contentStartPosition.Y, Math.Max(0, currentWidth - (finalPadding.X * 2)), Math.Max(0, availableHeight - (finalPadding.Y * 2)));
        bool clipPushed = false;
        if (contentClipRect.Width > 0 && contentClipRect.Height > 0)
        {
            renderTarget.PushAxisAlignedClip(contentClipRect, D2D.AntialiasMode.Aliased);
            Context.Layout.PushClipRect(contentClipRect); // For culling
            clipPushed = true;
        }

        var vboxId = HashCode.Combine(intId, "_vbox");
        var vboxState = Context.Layout.GetOrCreateVBoxState(vboxId);
        vboxState.StartPosition = contentStartPosition;
        vboxState.CurrentPosition = contentStartPosition;
        vboxState.Gap = gap;
        vboxState.MaxElementWidth = 0f;
        vboxState.AccumulatedHeight = 0f;
        vboxState.ElementCount = 0;

        var panelState = new ResizablePanelState(intId, vboxState, clipPushed);
        Context.Layout.PushContainer(panelState);
    }

    public static void EndResizableVPanel()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not ResizablePanelState state)
        { Console.WriteLine("Error: EndResizableVPanel called without a matching BeginResizableVPanel."); return; }
        if (state.ClipRectWasPushed && Context.RenderTarget is not null)
        {
            Context.Layout.PopClipRect(); // For culling
            Context.RenderTarget.PopAxisAlignedClip();
        }
        Context.Layout.PopContainer();
    }

    public static void BeginResizableHPanel(
        string id,
        ref float currentHeight,
        float reservedLeftSpace,
        float reservedRightSpace,
        float topOffset = 0f,
        float minHeight = 50f,
        float maxHeight = 300f,
        float resizeHandleHeight = 5f,
        BoxStyle? panelStyle = null,
        Vector2 padding = default,
        float gap = 5f,
        bool disabled = false)
    {
        if (!IsContextValid()) return;
        var intId = id.GetHashCode();

        Vector2 finalPadding = (padding == default) ? new Vector2(5, 5) : padding;

        var input = Context.InputState;
        var renderTarget = Context.RenderTarget;
        var windowWidth = renderTarget.Size.Width;
        var windowHeight = renderTarget.Size.Height;
        var availableWidth = Math.Max(0, windowWidth - reservedLeftSpace - reservedRightSpace);
        var maxAllowedHeight = windowHeight - topOffset;
        var effectiveMaxHeight = Math.Min(maxHeight, maxAllowedHeight);
        float clampMax = Math.Max(minHeight, effectiveMaxHeight);

        if (!disabled)
        {
            currentHeight = Math.Clamp(currentHeight, minHeight, clampMax);
            float panelY = windowHeight - currentHeight;
            float handleHeight = Math.Min(resizeHandleHeight, currentHeight);
            Rect handleRect = new Rect(reservedLeftSpace, panelY, availableWidth, handleHeight);

            bool isHoveringHandle = handleRect.Contains(input.MousePosition.X, input.MousePosition.Y);
            if (isHoveringHandle) State.SetPotentialInputTarget(intId);
            if (input.WasLeftMousePressedThisFrame && isHoveringHandle && State.PotentialInputTargetId == intId && !State.DragInProgressFromPreviousFrame) State.SetPotentialCaptorForFrame(intId);
            if (State.ActivelyPressedElementId == intId && !input.IsLeftMouseDown) State.ClearActivePress(intId);
            if (State.ActivelyPressedElementId == intId && input.IsLeftMouseDown)
            {
                float clampedMouseY = Math.Max(input.MousePosition.Y, topOffset);
                currentHeight = Math.Clamp(windowHeight - clampedMouseY, minHeight, clampMax);
            }
        }

        var finalPanelStyle = panelStyle ?? new BoxStyle { FillColor = new(0.15f, 0.15f, 0.2f, 1.0f), BorderColor = DefaultTheme.NormalBorder, BorderLength = 1 };
        currentHeight = Math.Clamp(currentHeight, minHeight, clampMax);
        float finalPanelY = windowHeight - currentHeight;
        Rect panelRect = new Rect(reservedLeftSpace, finalPanelY, availableWidth, currentHeight);
        if (panelRect.Width > 0 && panelRect.Height > 0)
        {
            Resources.DrawBoxStyleHelper(renderTarget, new Vector2(panelRect.X, panelRect.Y), new Vector2(panelRect.Width, panelRect.Height), finalPanelStyle);
        }

        Vector2 contentStartPosition = new Vector2(reservedLeftSpace + finalPadding.X, finalPanelY + finalPadding.Y);
        Rect contentClipRect = new Rect(contentStartPosition.X, contentStartPosition.Y, Math.Max(0, availableWidth - (finalPadding.X * 2)), Math.Max(0, currentHeight - (finalPadding.Y * 2)));
        bool clipPushed = false;
        if (contentClipRect.Width > 0 && contentClipRect.Height > 0)
        {
            renderTarget.PushAxisAlignedClip(contentClipRect, D2D.AntialiasMode.Aliased);
            Context.Layout.PushClipRect(contentClipRect); // For culling
            clipPushed = true;
        }

        var hboxId = HashCode.Combine(intId, "_hbox");
        var hboxState = Context.Layout.GetOrCreateHBoxState(hboxId);
        hboxState.StartPosition = contentStartPosition;
        hboxState.CurrentPosition = contentStartPosition;
        hboxState.Gap = gap;
        hboxState.MaxElementHeight = 0f;
        hboxState.AccumulatedWidth = 0f;
        hboxState.ElementCount = 0;

        var panelState = new ResizableHPanelState(intId, hboxState, clipPushed);
        Context.Layout.PushContainer(panelState);
    }

    public static void EndResizableHPanel()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not ResizableHPanelState state)
        { Console.WriteLine("Error: EndResizableHPanel called without a matching BeginResizableHPanel."); return; }
        if (state.ClipRectWasPushed && Context.RenderTarget is not null)
        {
            Context.Layout.PopClipRect(); // For culling
            Context.RenderTarget.PopAxisAlignedClip();
        }
        Context.Layout.PopContainer();
    }
}
</file>

<file path="Core\UI.cs">
using System;
using System.Numerics;

namespace DirectUI;

public static partial class UI
{
    // --- Core Components ---
    public static UIContext Context { get; private set; } = null!;
    public static UIPersistentState State { get; private set; } = null!;
    public static UIResources Resources { get; private set; } = null!;
    public static bool IsRendering { get; private set; } = false;

    // --- Frame Management ---
    public static void BeginFrame(UIContext context)
    {
        IsRendering = true;

        Context = context;
        Resources = context.Resources; // Set the active resources for this frame
        State ??= new UIPersistentState();

        State.ResetFrameState(context.InputState);

        Context.Layout.ClearStack();
        Context.treeStateStack.Clear();
    }

    public static void EndFrame()
    {
        // If a click happened this frame but no UI element captured it, and no popup was open, clear focus.
        if (Context.InputState.WasLeftMousePressedThisFrame && State.InputCaptorId == 0 && !State.IsPopupOpen)
        {
            State.SetFocus(0);
        }

        HandlePopupLogic();

        if (Context.Layout.ContainerStackCount > 0)
        {
            Console.WriteLine($"Warning: Mismatch in Begin/End container calls. {Context.Layout.ContainerStackCount} containers left open at EndFrame.");
            Context.Layout.ClearStack();
        }
        if (Context.treeStateStack.Count > 0)
        {
            Console.WriteLine($"Warning: Mismatch in Begin/End Tree calls. {Context.treeStateStack.Count} trees left open at EndFrame.");
            Context.treeStateStack.Clear();
        }

        // It's important that IsRendering is set to false AFTER the context is cleared.
        Context = null!;
        Resources = null!;
        IsRendering = false;
    }

    /// <summary>
    /// Handles popup logic at the end of a frame, ensuring they are drawn last and closed correctly.
    /// </summary>
    private static void HandlePopupLogic()
    {
        if (!State.IsPopupOpen) return;

        // If a mouse press occurred outside the popup's bounds, close the popup.
        if (Context.InputState.WasLeftMousePressedThisFrame)
        {
            if (!State.PopupBounds.Contains(Context.InputState.MousePosition))
            {
                State.ClearActivePopup();
                return; // Don't draw the popup since we just closed it.
            }
        }

        // Execute the callback to draw the popup content.
        State.PopupDrawCallback?.Invoke(Context);
    }


    // --- Helper Methods ---
    private static bool IsContextValid()
    {
        if (Context?.RenderTarget is null || Context?.DWriteFactory is null || Resources is null)
        {
            Console.WriteLine($"Error: UI method called outside BeginFrame/EndFrame or context is invalid.");
            return false;
        }
        return true;
    }
}
</file>

<file path="Core\UI.Label.cs">
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static void Label(string id, string text, Vector2? size = null, ButtonStyle? style = null, Alignment? textAlignment = null)
    {
        if (!IsContextValid() || string.IsNullOrEmpty(text))
        {
            return;
        }

        ButtonStyle finalStyle = style ?? new();
        finalStyle.FontColor = GetStyleColor(StyleColor.Text, finalStyle.FontColor);

        Alignment finalAlignment = textAlignment
            ?? new(HAlignment.Left, VAlignment.Center);

        Vector2 measuredSize = Resources.MeasureText(Context.DWriteFactory, text, finalStyle);

        Vector2 finalSize;
        if (size.HasValue)
        {
            finalSize = new Vector2(
                size.Value.X > 0 ? size.Value.X : measuredSize.X,
                size.Value.Y > 0 ? size.Value.Y : measuredSize.Y
            );
        }
        else
        {
            finalSize = measuredSize;
        }

        Vector2 drawPos = Context.Layout.GetCurrentPosition();
        Rect widgetBounds = new(drawPos.X, drawPos.Y, finalSize.X, finalSize.Y);

        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(finalSize);
            return;
        }

        DrawLabelText(
            Context.RenderTarget,
            Context.DWriteFactory,
            Resources,
            widgetBounds,
            text,
            finalStyle,
            finalAlignment);

        Context.Layout.AdvanceLayout(finalSize);
    }

    private static void DrawLabelText(
        ID2D1RenderTarget renderTarget,
        IDWriteFactory dwriteFactory,
        UIResources resources,
        Rect bounds,
        string text,
        ButtonStyle style,
        Alignment textAlignment)
    {
        ID2D1SolidColorBrush? textBrush = resources.GetOrCreateBrush(renderTarget, style.FontColor);

        if (textBrush is null)
        {
            return;
        }

        UIResources.TextLayoutCacheKey layoutKey = new(text, style, new(bounds.Width, bounds.Height), textAlignment);

        if (!resources.textLayoutCache.TryGetValue(layoutKey, out var textLayout))
        {
            IDWriteTextFormat? textFormat = resources.GetOrCreateTextFormat(dwriteFactory, style);

            if (textFormat is null)
            {
                return;
            }

            textLayout = dwriteFactory.CreateTextLayout(text, textFormat, bounds.Width, bounds.Height);
            textLayout.TextAlignment = textAlignment.Horizontal switch
            {
                HAlignment.Left => TextAlignment.Leading,
                HAlignment.Center => TextAlignment.Center,
                HAlignment.Right => TextAlignment.Trailing,
                _ => TextAlignment.Leading
            };
            textLayout.ParagraphAlignment = textAlignment.Vertical switch
            {
                VAlignment.Top => ParagraphAlignment.Near,
                VAlignment.Center => ParagraphAlignment.Center,
                VAlignment.Bottom => ParagraphAlignment.Far,
                _ => ParagraphAlignment.Near
            };
            resources.textLayoutCache[layoutKey] = textLayout;
        }

        float yOffsetCorrection = textAlignment.Vertical == VAlignment.Center
            ? -1.5f
            : 0f;

        renderTarget.DrawTextLayout(
            new(bounds.X, bounds.Y + yOffsetCorrection),
            textLayout,
            textBrush,
            DrawTextOptions.None);
    }
}
</file>

<file path="Core\UI.LineEdit.cs">
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static bool LineEdit(
        string id,
        ref string text,
        Vector2 size,
        Vector2 position = default,
        ButtonStylePack? theme = null,
        string placeholderText = "",
        bool isPassword = false,
        char passwordChar = '*',
        int maxLength = 1024,
        bool disabled = false,
        Vector2? textMargin = null)
    {
        if (!IsContextValid()) return false;

        int intId = id.GetHashCode();
        var finalPosition = Context.Layout.ApplyLayout(position);
        var finalMargin = textMargin ?? new Vector2(4, 2);

        // Culling Check
        Rect widgetBounds = new Rect(finalPosition.X, finalPosition.Y, size.X, size.Y);
        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(size); // Still advance layout cursor
            return false;
        }

        // Get the stateless logic/drawing class instance
        var lineEditInstance = State.GetOrCreateElement<LineEdit>(intId);
        // Get the state object for this specific line edit
        var lineEditState = State.GetOrCreateElement<LineEditState>(HashCode.Combine(intId, "state"));

        bool textChanged = lineEditInstance.UpdateAndDraw(
            intId,
            ref text,
            lineEditState, // Pass the state object to the logic class
            finalPosition,
            size,
            theme,
            placeholderText,
            isPassword,
            passwordChar,
            maxLength,
            disabled,
            finalMargin);

        Context.Layout.AdvanceLayout(size);
        return textChanged;
    }
}
</file>

<file path="Core\UI.ScrollBar.cs">
// Core/UI.ScrollBar.cs
using System;
using System.Numerics;

namespace DirectUI;

public static partial class UI
{
    /// <summary>
    /// Draws a vertical scrollbar and handles its interaction.
    /// </summary>
    /// <param name="id">A unique identifier for the scrollbar.</param>
    /// <param name="currentScrollOffset">The current vertical scroll offset, which this control will modify.</param>
    /// <param name="position">The top-left position where the scrollbar will be drawn.</param>
    /// <param name="trackHeight">The total height of the scrollbar track.</param>
    /// <param name="contentHeight">The total height of the content being scrolled.</param>
    /// <param name="visibleHeight">The height of the visible portion of the content.</param>
    /// <param name="thickness">The width of the scrollbar.</param>
    /// <param name="theme">The style for the scrollbar's track.</param>
    /// <param name="thumbTheme">The style for the scrollbar's draggable thumb.</param>
    /// <returns>The new vertical scroll offset after user interaction.</returns>
    public static float VScrollBar(
        string id,
        float currentScrollOffset,
        Vector2 position,
        float trackHeight,
        float contentHeight,
        float visibleHeight,
        float thickness = 12f,
        SliderStyle? theme = null,
        ButtonStylePack? thumbTheme = null)
    {
        if (!IsContextValid()) return currentScrollOffset;

        int intId = id.GetHashCode();
        InternalScrollBarLogic scrollBarInstance = State.GetOrCreateElement<InternalScrollBarLogic>(intId);

        // Configure instance
        scrollBarInstance.Position = position;
        scrollBarInstance.TrackLength = trackHeight;
        scrollBarInstance.TrackThickness = thickness;
        scrollBarInstance.IsVertical = true;
        scrollBarInstance.ContentSize = contentHeight;
        scrollBarInstance.VisibleSize = visibleHeight;
        scrollBarInstance.Theme = theme ?? scrollBarInstance.Theme ?? new SliderStyle();
        scrollBarInstance.ThumbTheme = thumbTheme ?? scrollBarInstance.ThumbTheme ?? new ButtonStylePack();

        float newScrollOffset = scrollBarInstance.UpdateAndDraw(intId, currentScrollOffset);

        // A scrollbar, being an overlay, does not advance the main layout cursor.

        return newScrollOffset;
    }

    /// <summary>
    /// Draws a horizontal scrollbar and handles its interaction.
    /// </summary>
    /// <param name="id">A unique identifier for the scrollbar.</param>
    /// <param name="currentScrollOffset">The current horizontal scroll offset, which this control will modify.</param>
    /// <param name="position">The top-left position where the scrollbar will be drawn.</param>
    /// <param name="trackWidth">The total width of the scrollbar track.</param>
    /// <param name="contentWidth">The total width of the content being scrolled.</param>
    /// <param name="visibleWidth">The width of the visible portion of the content.</param>
    /// <param name="thickness">The height of the scrollbar.</param>
    /// <param name="theme">The style for the scrollbar's track.</param>
    /// <param name="thumbTheme">The style for the scrollbar's draggable thumb.</param>
    /// <returns>The new horizontal scroll offset after user interaction.</returns>
    public static float HScrollBar(
        string id,
        float currentScrollOffset,
        Vector2 position,
        float trackWidth,
        float contentWidth,
        float visibleWidth,
        float thickness = 12f,
        SliderStyle? theme = null,
        ButtonStylePack? thumbTheme = null)
    {
        if (!IsContextValid()) return currentScrollOffset;

        int intId = id.GetHashCode();
        InternalScrollBarLogic scrollBarInstance = State.GetOrCreateElement<InternalScrollBarLogic>(intId);

        // Configure instance
        scrollBarInstance.Position = position;
        scrollBarInstance.TrackLength = trackWidth;
        scrollBarInstance.TrackThickness = thickness;
        scrollBarInstance.IsVertical = false;
        scrollBarInstance.ContentSize = contentWidth;
        scrollBarInstance.VisibleSize = visibleWidth;
        scrollBarInstance.Theme = theme ?? scrollBarInstance.Theme ?? new SliderStyle();
        scrollBarInstance.ThumbTheme = thumbTheme ?? scrollBarInstance.ThumbTheme ?? new ButtonStylePack();

        float newScrollOffset = scrollBarInstance.UpdateAndDraw(intId, currentScrollOffset);

        return newScrollOffset;
    }
}
</file>

<file path="Core\UI.Slider.cs">
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static float HSlider(
        string id,
        float currentValue,
        float minValue,
        float maxValue,
        Vector2 size,
        Vector2 position = default,
        float step = 0.01f,
        SliderStyle? theme = null,
        ButtonStylePack? grabberTheme = null,
        Vector2? grabberSize = null,
        HSliderDirection direction = HSliderDirection.LeftToRight,
        bool disabled = false,
        object? userData = null,
        Vector2? origin = null)
    {
        if (!IsContextValid()) return currentValue;

        int intId = id.GetHashCode();
        Vector2 drawPos = Context.Layout.ApplyLayout(position);

        // Culling Check
        Rect widgetBounds = new Rect(drawPos.X, drawPos.Y, size.X, size.Y);
        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(size);
            return currentValue;
        }

        InternalHSliderLogic sliderInstance = State.GetOrCreateElement<InternalHSliderLogic>(intId);
        sliderInstance.Position = drawPos;

        // Configure instance
        sliderInstance.Size = size;
        sliderInstance.MinValue = minValue;
        sliderInstance.MaxValue = maxValue;
        sliderInstance.Step = step;
        sliderInstance.Theme = theme ?? sliderInstance.Theme ?? new SliderStyle();
        sliderInstance.GrabberTheme = grabberTheme ?? sliderInstance.GrabberTheme ?? new ButtonStylePack();
        sliderInstance.GrabberSize = grabberSize ?? new Vector2(16, 16);
        sliderInstance.Origin = origin ?? Vector2.Zero;
        sliderInstance.Disabled = disabled;
        sliderInstance.UserData = userData;
        sliderInstance.Direction = direction;


        float newValue = sliderInstance.UpdateAndDraw(intId, currentValue);
        Context.Layout.AdvanceLayout(sliderInstance.Size);
        return newValue;
    }

    public static float VSlider(
        string id,
        float currentValue,
        float minValue,
        float maxValue,
        Vector2 size,
        Vector2 position = default,
        float step = 0.01f,
        SliderStyle? theme = null,
        ButtonStylePack? grabberTheme = null,
        Vector2? grabberSize = null,
        VSliderDirection direction = VSliderDirection.TopToBottom,
        bool disabled = false,
        object? userData = null,
        Vector2? origin = null)
    {
        if (!IsContextValid()) return currentValue;

        int intId = id.GetHashCode();
        Vector2 drawPos = Context.Layout.ApplyLayout(position);

        // Culling Check
        Rect widgetBounds = new Rect(drawPos.X, drawPos.Y, size.X, size.Y);
        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(size);
            return currentValue;
        }

        InternalVSliderLogic sliderInstance = State.GetOrCreateElement<InternalVSliderLogic>(intId);
        sliderInstance.Position = drawPos;

        // Configure instance
        sliderInstance.Size = size;
        sliderInstance.MinValue = minValue;
        sliderInstance.MaxValue = maxValue;
        sliderInstance.Step = step;
        sliderInstance.Theme = theme ?? sliderInstance.Theme ?? new SliderStyle();
        sliderInstance.GrabberTheme = grabberTheme ?? sliderInstance.GrabberTheme ?? new ButtonStylePack();
        sliderInstance.GrabberSize = grabberSize ?? new Vector2(16, 16);
        sliderInstance.Origin = origin ?? Vector2.Zero;
        sliderInstance.Disabled = disabled;
        sliderInstance.UserData = userData;
        sliderInstance.Direction = direction;

        float newValue = sliderInstance.UpdateAndDraw(intId, currentValue);
        Context.Layout.AdvanceLayout(sliderInstance.Size);
        return newValue;
    }
}
</file>

<file path="Core\UI.StatelessWidgets.cs">
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    /// <summary>
    /// The core, stateless primitive for drawing and interacting with a button.
    /// This is the single source of truth for all button-like controls.
    /// </summary>
    internal static bool ButtonPrimitive(
        int id,
        Rect bounds,
        string text,
        ButtonStylePack theme,
        bool disabled,
        Alignment textAlignment,
        DirectUI.Button.ActionMode clickMode,
        DirectUI.Button.ClickBehavior clickBehavior,
        Vector2 textOffset)
    {
        var context = Context;
        var state = State;
        var resources = Resources;
        var renderTarget = context.RenderTarget;
        var dwriteFactory = context.DWriteFactory;
        var input = context.InputState;

        // --- State Calculation ---
        bool isFocused = !disabled && state.FocusedElementId == id;
        bool isHovering = !disabled && bounds.Width > 0 && bounds.Height > 0 && bounds.Contains(input.MousePosition.X, input.MousePosition.Y);
        if (isHovering)
        {
            state.SetPotentialInputTarget(id);
        }

        // --- Click Detection ---
        bool wasClickedThisFrame = false;
        bool isPressed = state.ActivelyPressedElementId == id;

        bool primaryActionPressedThisFrame = (clickBehavior is DirectUI.Button.ClickBehavior.Left or DirectUI.Button.ClickBehavior.Both) && input.WasLeftMousePressedThisFrame;
        bool secondaryActionPressedThisFrame = (clickBehavior is DirectUI.Button.ClickBehavior.Right or DirectUI.Button.ClickBehavior.Both) && input.WasRightMousePressedThisFrame;
        bool anyActionPressedThisFrame = primaryActionPressedThisFrame || secondaryActionPressedThisFrame;

        bool primaryActionHeld = (clickBehavior is DirectUI.Button.ClickBehavior.Left or DirectUI.Button.ClickBehavior.Both) && input.IsLeftMouseDown;
        bool secondaryActionHeld = (clickBehavior is DirectUI.Button.ClickBehavior.Right or DirectUI.Button.ClickBehavior.Both) && input.IsRightMouseDown;
        bool anyActionHeld = primaryActionHeld || secondaryActionHeld;


        if (!anyActionHeld && isPressed)
        {
            if (isHovering && clickMode == DirectUI.Button.ActionMode.Release)
            {
                wasClickedThisFrame = true;
            }
            state.ClearActivePress(id);
            isPressed = false;
        }

        if (anyActionPressedThisFrame)
        {
            if (isHovering && state.PotentialInputTargetId == id && !state.DragInProgressFromPreviousFrame)
            {
                state.SetButtonPotentialCaptorForFrame(id);
                state.SetFocus(id);
                isPressed = true;
            }
        }

        if (!wasClickedThisFrame && clickMode == DirectUI.Button.ActionMode.Press && state.InputCaptorId == id)
        {
            wasClickedThisFrame = true;
        }

        // --- Style Resolution ---
        ButtonStyle currentStyle = ResolveButtonStyle(theme, isHovering, isPressed, disabled, isFocused);

        // --- Drawing ---
        if (bounds.Width > 0 && bounds.Height > 0)
        {
            // Draw Background
            resources.DrawBoxStyleHelper(renderTarget, new Vector2(bounds.X, bounds.Y), new Vector2(bounds.Width, bounds.Height), currentStyle);

            // Draw Text
            DrawButtonText(renderTarget, dwriteFactory, resources, bounds, text, currentStyle, textAlignment, textOffset);
        }

        return wasClickedThisFrame;
    }

    /// <summary>
    /// Resolves the final ButtonStyle for the current frame by applying interaction state and style stack overrides.
    /// </summary>
    private static ButtonStyle ResolveButtonStyle(ButtonStylePack theme, bool isHovering, bool isPressed, bool isDisabled, bool isFocused)
    {
        // Determine base style from interaction state
        theme.UpdateCurrentStyle(isHovering, isPressed, isDisabled, isFocused);
        ButtonStyle baseStyle = theme.Current;

        // Create a temporary, modifiable copy for this frame to apply style stack overrides
        var finalStyle = new ButtonStyle
        {
            FillColor = baseStyle.FillColor,
            BorderColor = baseStyle.BorderColor,
            FontColor = baseStyle.FontColor,
            BorderLengthTop = baseStyle.BorderLengthTop,
            BorderLengthRight = baseStyle.BorderLengthRight,
            BorderLengthBottom = baseStyle.BorderLengthBottom,
            BorderLengthLeft = baseStyle.BorderLengthLeft,
            Roundness = baseStyle.Roundness,
            FontName = baseStyle.FontName,
            FontSize = baseStyle.FontSize,
            FontWeight = baseStyle.FontWeight,
            FontStyle = baseStyle.FontStyle,
            FontStretch = baseStyle.FontStretch
        };

        // Override with values from the style stack if they exist
        if (isDisabled)
        {
            finalStyle.FillColor = GetStyleColor(StyleColor.ButtonDisabled, finalStyle.FillColor);
            finalStyle.BorderColor = GetStyleColor(StyleColor.BorderDisabled, finalStyle.BorderColor);
            finalStyle.FontColor = GetStyleColor(StyleColor.TextDisabled, finalStyle.FontColor);
        }
        else if (isPressed)
        {
            finalStyle.FillColor = GetStyleColor(StyleColor.ButtonPressed, finalStyle.FillColor);
            finalStyle.BorderColor = GetStyleColor(StyleColor.BorderPressed, finalStyle.BorderColor);
        }
        else if (isHovering)
        {
            finalStyle.FillColor = GetStyleColor(StyleColor.ButtonHovered, finalStyle.FillColor);
            finalStyle.BorderColor = GetStyleColor(StyleColor.BorderHovered, finalStyle.BorderColor);
        }
        else if (isFocused)
        {
            finalStyle.BorderColor = GetStyleColor(StyleColor.BorderFocused, finalStyle.BorderColor);
        }
        else // Normal
        {
            finalStyle.FillColor = GetStyleColor(StyleColor.Button, finalStyle.FillColor);
            finalStyle.BorderColor = GetStyleColor(StyleColor.Border, finalStyle.BorderColor);
        }

        if (!isDisabled)
        {
            finalStyle.FontColor = GetStyleColor(StyleColor.Text, finalStyle.FontColor);
        }

        finalStyle.Roundness = GetStyleVar(StyleVar.FrameRounding, finalStyle.Roundness);
        finalStyle.BorderLength = GetStyleVar(StyleVar.FrameBorderSize, finalStyle.BorderLength);

        return finalStyle;
    }

    /// <summary>
    /// Draws the text for a button, using the central text layout cache.
    /// </summary>
    private static void DrawButtonText(
        ID2D1RenderTarget renderTarget,
        IDWriteFactory dwriteFactory,
        UIResources resources,
        Rect bounds,
        string text,
        ButtonStyle style,
        Alignment textAlignment,
        Vector2 textOffset)
    {
        if (string.IsNullOrEmpty(text)) return;

        var textBrush = resources.GetOrCreateBrush(renderTarget, style.FontColor);
        if (textBrush is null) return;

        var layoutKey = new UIResources.TextLayoutCacheKey(text, style, new(bounds.Width, bounds.Height), textAlignment);
        if (!resources.textLayoutCache.TryGetValue(layoutKey, out var textLayout))
        {
            var textFormat = resources.GetOrCreateTextFormat(dwriteFactory, style);
            if (textFormat is null) return;

            textLayout = dwriteFactory.CreateTextLayout(text, textFormat, bounds.Width, bounds.Height);
            textLayout.TextAlignment = textAlignment.Horizontal switch
            {
                HAlignment.Left => Vortice.DirectWrite.TextAlignment.Leading,
                HAlignment.Center => Vortice.DirectWrite.TextAlignment.Center,
                HAlignment.Right => Vortice.DirectWrite.TextAlignment.Trailing,
                _ => Vortice.DirectWrite.TextAlignment.Leading
            };
            textLayout.ParagraphAlignment = textAlignment.Vertical switch
            {
                VAlignment.Top => ParagraphAlignment.Near,
                VAlignment.Center => ParagraphAlignment.Center,
                VAlignment.Bottom => ParagraphAlignment.Far,
                _ => ParagraphAlignment.Near
            };
            resources.textLayoutCache[layoutKey] = textLayout;
        }

        // A small vertical adjustment to compensate for font metrics making text appear slightly too low when using ParagraphAlignment.Center.
        float yOffsetCorrection = (textAlignment.Vertical == VAlignment.Center) ? -1.5f : 0f;

        renderTarget.DrawTextLayout(new Vector2(bounds.X + textOffset.X, bounds.Y + textOffset.Y + yOffsetCorrection), textLayout, textBrush, DrawTextOptions.None);
    }
}
</file>

<file path="Core\UI.Style.cs">
using System;
using System.Collections.Generic;
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public enum StyleVar
{
    FrameRounding,
    FrameBorderSize,
    // Future additions could include:
    // ItemSpacing,
    // FramePadding,
    // ButtonTextAlign,
}

public enum StyleColor
{
    Text,
    TextDisabled,
    Button,
    ButtonHovered,
    ButtonPressed,
    ButtonDisabled,
    Border,
    BorderHovered,
    BorderPressed,
    BorderDisabled,
    BorderFocused,
}

public static partial class UI
{
    // --- Style Stack API ---

    public static void PushStyleVar(StyleVar styleVar, float value)
    {
        Context.styleVarStack.Push((styleVar, value));
    }

    public static void PushStyleVar(StyleVar styleVar, Vector2 value)
    {
        Context.styleVarStack.Push((styleVar, value));
    }

    public static void PopStyleVar(int count = 1)
    {
        for (int i = 0; i < count; i++)
        {
            if (Context.styleVarStack.Count > 0)
            {
                Context.styleVarStack.Pop();
            }
        }
    }

    public static void PushStyleColor(StyleColor styleColor, Color4 color)
    {
        Context.styleColorStack.Push((styleColor, color));
    }

    public static void PopStyleColor(int count = 1)
    {
        for (int i = 0; i < count; i++)
        {
            if (Context.styleColorStack.Count > 0)
            {
                Context.styleColorStack.Pop();
            }
        }
    }

    // --- Style Accessors (for internal widget use) ---

    internal static T GetStyleVar<T>(StyleVar styleVar, T defaultValue)
    {
        foreach (var (key, value) in Context.styleVarStack)
        {
            if (key == styleVar && value is T typedValue)
            {
                return typedValue;
            }
        }
        return defaultValue;
    }

    internal static Color4 GetStyleColor(StyleColor styleColor, Color4 defaultValue)
    {
        foreach (var (key, value) in Context.styleColorStack)
        {
            if (key == styleColor)
            {
                return value;
            }
        }
        return defaultValue;
    }
}
</file>

<file path="Core\UI.TabBar.cs">
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    private static bool TabButtonPrimitive(int id, string text, Vector2 size, bool isActive, TabStylePack theme, bool disabled)
    {
        if (!IsContextValid()) return false;

        var intId = id;
        var position = Context.Layout.GetCurrentPosition();
        Rect bounds = new(position.X, position.Y, size.X, size.Y);

        InputState input = Context.InputState;
        bool isHovering = !disabled && bounds.Contains(input.MousePosition.X, input.MousePosition.Y);
        bool wasClicked = false;

        if (isHovering) State.SetPotentialInputTarget(intId);

        if (input.WasLeftMousePressedThisFrame && isHovering && State.PotentialInputTargetId == intId)
        {
            wasClicked = true;
        }

        theme.UpdateCurrentStyle(isHovering, isActive, disabled, false);
        var currentStyle = theme.Current;

        var rt = Context.RenderTarget;
        Resources.DrawBoxStyleHelper(rt, new Vector2(bounds.X, bounds.Y), new Vector2(bounds.Width, bounds.Height), currentStyle);

        var textBrush = Resources.GetOrCreateBrush(rt, currentStyle.FontColor);
        if (textBrush is not null && !string.IsNullOrEmpty(text))
        {
            var dwriteFactory = Context.DWriteFactory;
            var textAlignment = new Alignment(HAlignment.Center, VAlignment.Center);

            var layoutKey = new UIResources.TextLayoutCacheKey(text, currentStyle, size, textAlignment);
            if (!Resources.textLayoutCache.TryGetValue(layoutKey, out var textLayout))
            {
                var textFormat = Resources.GetOrCreateTextFormat(dwriteFactory, currentStyle);
                if (textFormat is not null)
                {
                    textLayout = dwriteFactory.CreateTextLayout(text, textFormat, size.X, size.Y);
                    textLayout.TextAlignment = Vortice.DirectWrite.TextAlignment.Center;
                    textLayout.ParagraphAlignment = ParagraphAlignment.Center;
                    Resources.textLayoutCache[layoutKey] = textLayout;
                }
            }

            if (textLayout is not null)
            {
                rt.DrawTextLayout(new Vector2(bounds.X, bounds.Y), textLayout, textBrush, DrawTextOptions.None);
            }
        }

        Context.Layout.AdvanceLayout(size);
        return wasClicked;
    }

    public static void TabBar(string id, string[] tabLabels, ref int activeIndex, TabStylePack? theme = null)
    {
        if (!IsContextValid() || tabLabels is null || tabLabels.Length == 0) return;

        int intId = id.GetHashCode();
        var themeId = HashCode.Combine(intId, "theme_default");
        var tabTheme = theme ?? State.GetOrCreateElement<TabStylePack>(themeId);
        var state = State.GetOrCreateElement<TabBarState>(intId);

        const float textMarginX = 15f;
        const float tabHeight = 30f;
        float uniformTabWidth;

        if (state.CachedUniformWidth < 0) // Not calculated yet, or invalidated.
        {
            float maxWidth = 0;
            var styleForMeasuring = tabTheme.Normal;
            foreach (var label in tabLabels)
            {
                Vector2 measuredSize = Resources.MeasureText(Context.DWriteFactory, label, styleForMeasuring);
                if (measuredSize.X > maxWidth)
                {
                    maxWidth = measuredSize.X;
                }
            }
            uniformTabWidth = maxWidth + textMarginX * 2;
            state.CachedUniformWidth = uniformTabWidth;
        }
        else
        {
            uniformTabWidth = state.CachedUniformWidth;
        }

        var tabSize = new Vector2(uniformTabWidth, tabHeight);

        var hboxIdString = id + "_hbox";
        BeginHBoxContainer(hboxIdString, Context.Layout.GetCurrentPosition(), 0);
        for (int i = 0; i < tabLabels.Length; i++)
        {
            var buttonId = HashCode.Combine(intId, i);
            bool wasClicked = TabButtonPrimitive(
                buttonId,
                tabLabels[i],
                tabSize,
                i == activeIndex,
                tabTheme,
                false
            );
            if (wasClicked)
            {
                activeIndex = i;
            }
        }
        EndHBoxContainer();
    }
}
</file>

<file path="Core\UI.Tree.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static void Tree<T>(string id, TreeNode<T> root, out TreeNode<T>? clickedNode, TreeStyle? style = null)
    {
        if (!IsContextValid() || root is null) { clickedNode = null; return; }

        clickedNode = null;
        int intId = id.GetHashCode();
        var styleId = HashCode.Combine(intId, "style");
        var treeStyle = style ?? State.GetOrCreateElement<TreeStyle>(styleId);

        var treeState = new TreeViewState(intId, treeStyle);
        Context.treeStateStack.Push(treeState);
        ProcessTreeNodeRecursive(intId, 0, root, ref clickedNode);
        Context.treeStateStack.Pop();
    }

    private static void ProcessTreeNodeRecursive<T>(int parentIdHash, int index, TreeNode<T> node, ref TreeNode<T>? clickedNode)
    {
        if (Context.treeStateStack.Count == 0) return;
        var treeState = Context.treeStateStack.Peek();
        var style = treeState.Style;
        var renderTarget = Context.RenderTarget;

        var startLayoutPos = Context.Layout.GetCurrentPosition();
        var brush = Resources.GetOrCreateBrush(renderTarget, style.LineColor);
        if (brush is not null)
        {
            int i = 0;
            foreach (var shouldDrawLine in treeState.IndentLineState)
            {
                if (shouldDrawLine)
                {
                    float x = startLayoutPos.X + (i * style.Indent) + (style.Indent * 0.5f);
                    renderTarget.DrawLine(new Vector2(x, startLayoutPos.Y), new Vector2(x, startLayoutPos.Y + style.RowHeight), brush, 1.0f);
                }
                i++;
            }
            if (treeState.IndentLineState.Count > 0)
            {
                float hLineXStart = startLayoutPos.X + ((treeState.IndentLineState.Count - 1) * style.Indent) + (style.Indent * 0.5f);
                float hLineY = startLayoutPos.Y + style.RowHeight * 0.5f;
                renderTarget.DrawLine(new Vector2(hLineXStart, hLineY), new Vector2(hLineXStart + style.Indent * 0.5f, hLineY), brush, 1.0f);
            }
        }

        float indentSize = treeState.IndentLineState.Count * style.Indent;
        var nodeRowStartPos = startLayoutPos + new Vector2(indentSize, 0);
        float currentX = nodeRowStartPos.X;
        float gap = 5;

        int nodeHash = node.GetHashCode();
        int toggleId = HashCode.Combine(parentIdHash, index, nodeHash, 0);
        int labelId = HashCode.Combine(parentIdHash, index, nodeHash, 1);

        float toggleWidth = style.RowHeight - 4;
        if (node.Children.Count > 0)
        {
            var bounds = new Rect(currentX, nodeRowStartPos.Y, toggleWidth, style.RowHeight);
            if (ButtonPrimitive(toggleId, bounds, node.IsExpanded ? "-" : "+", style.ToggleStyle, false, new Alignment(HAlignment.Center, VAlignment.Center), DirectUI.Button.ActionMode.Release, DirectUI.Button.ClickBehavior.Left, Vector2.Zero))
            {
                node.IsExpanded = !node.IsExpanded;
            }
        }
        currentX += toggleWidth;

        currentX += gap;
        var labelStyle = style.NodeLabelStyle;
        var labelTextAlignment = new Alignment(HAlignment.Left, VAlignment.Center);
        float labelMargin = 4;
        var labelSize = Resources.MeasureText(Context.DWriteFactory, node.Text, labelStyle.Normal);
        float labelWidth = labelSize.X + labelMargin * 2;
        var labelOffset = new Vector2(labelMargin, 0);
        var labelBounds = new Rect(currentX, nodeRowStartPos.Y, labelWidth, style.RowHeight);
        if (ButtonPrimitive(labelId, labelBounds, node.Text, labelStyle, false, labelTextAlignment, DirectUI.Button.ActionMode.Press, DirectUI.Button.ClickBehavior.Left, labelOffset))
        {
            clickedNode = node;
        }
        currentX += labelWidth;

        Context.Layout.AdvanceLayout(new Vector2((currentX - nodeRowStartPos.X), style.RowHeight));

        if (node.IsExpanded && node.Children.Count > 0)
        {
            for (int childIdx = 0; childIdx < node.Children.Count; childIdx++)
            {
                bool isLastChild = childIdx == node.Children.Count - 1;
                treeState.IndentLineState.Push(!isLastChild);
                ProcessTreeNodeRecursive(toggleId, childIdx, node.Children[childIdx], ref clickedNode);
                treeState.IndentLineState.Pop();
            }
        }
    }
}
</file>

<file path="Core\UIContext.cs">
using System.Collections.Generic;
using Vortice.Direct2D1;
using Vortice.DirectWrite;

namespace DirectUI;

public class UIContext
{
    // Per-frame resources
    public ID2D1HwndRenderTarget RenderTarget { get; }
    public IDWriteFactory DWriteFactory { get; }
    public InputState InputState { get; }
    public UIResources Resources { get; }
    public float DeltaTime { get; }

    // Layout and state management
    public UILayoutManager Layout { get; }
    internal readonly Stack<TreeViewState> treeStateStack = new();
    internal readonly Stack<(StyleVar, object)> styleVarStack = new();
    internal readonly Stack<(StyleColor, Vortice.Mathematics.Color4)> styleColorStack = new();

    public UIContext(ID2D1HwndRenderTarget renderTarget, IDWriteFactory dwriteFactory, InputState inputState, UIResources resources, float deltaTime)
    {
        RenderTarget = renderTarget;
        DWriteFactory = dwriteFactory;
        InputState = inputState;
        Resources = resources;
        DeltaTime = deltaTime;
        Layout = new UILayoutManager();
    }
}
</file>

<file path="Core\UILayoutManager.cs">
using System.Numerics;
using Vortice.Mathematics;
using System;

namespace DirectUI;

public class UILayoutManager
{
    private readonly Stack<ILayoutContainer> _containerStack = new();
    private readonly Dictionary<int, object> _containerStateCache = new();
    private readonly Stack<Rect> _clipRectStack = new();

    public int ContainerStackCount => _containerStack.Count;
    public bool IsInLayoutContainer() => _containerStack.Count > 0;

    public void PushContainer(ILayoutContainer containerState) => _containerStack.Push(containerState);
    public ILayoutContainer PopContainer() => _containerStack.Pop();
    public ILayoutContainer PeekContainer() => _containerStack.Peek();
    public void ClearStack()
    {
        _containerStack.Clear();
        _clipRectStack.Clear();
    }

    public void PushClipRect(Rect rect) => _clipRectStack.Push(rect);
    public void PopClipRect()
    {
        if (_clipRectStack.Count > 0)
        {
            _clipRectStack.Pop();
        }
    }

    public Rect GetCurrentClipRect()
    {
        if (_clipRectStack.Count > 0)
        {
            return _clipRectStack.Peek();
        }
        // Return a very large rectangle representing no clipping
        return new Rect(float.MinValue / 2, float.MinValue / 2, float.MaxValue, float.MaxValue);
    }

    public bool IsRectVisible(Rect rect)
    {
        if (_clipRectStack.Count == 0) return true;

        var currentClip = GetCurrentClipRect();

        // Basic intersection test
        return rect.X < currentClip.X + currentClip.Width &&
               rect.X + rect.Width > currentClip.X &&
               rect.Y < currentClip.Y + currentClip.Height &&
               rect.Y + rect.Height > currentClip.Y;
    }

    public HBoxContainerState GetOrCreateHBoxState(int id)
    {
        if (!_containerStateCache.TryGetValue(id, out var state) || state is not HBoxContainerState hboxState)
        {
            hboxState = new HBoxContainerState(id);
            _containerStateCache[id] = hboxState;
        }
        return hboxState;
    }

    public VBoxContainerState GetOrCreateVBoxState(int id)
    {
        if (!_containerStateCache.TryGetValue(id, out var state) || state is not VBoxContainerState vboxState)
        {
            vboxState = new VBoxContainerState(id);
            _containerStateCache[id] = vboxState;
        }
        return vboxState;
    }

    public void BeginHBox(int id, Vector2 startPosition, float gap)
    {
        var hboxState = GetOrCreateHBoxState(id);

        // Reset per-frame properties
        hboxState.StartPosition = startPosition;
        hboxState.CurrentPosition = startPosition;
        hboxState.Gap = gap;
        hboxState.MaxElementHeight = 0f;
        hboxState.AccumulatedWidth = 0f;
        hboxState.ElementCount = 0;

        PushContainer(hboxState);
    }

    public void BeginVBox(int id, Vector2 startPosition, float gap)
    {
        VBoxContainerState vboxState = GetOrCreateVBoxState(id);

        // Reset per-frame properties
        vboxState.StartPosition = startPosition;
        vboxState.CurrentPosition = startPosition;
        vboxState.Gap = gap;
        vboxState.MaxElementWidth = 0f;
        vboxState.AccumulatedHeight = 0f;
        vboxState.ElementCount = 0;

        PushContainer(vboxState);
    }

    public Vector2 ApplyLayout(Vector2 defaultPosition)
    {
        return IsInLayoutContainer() ? GetCurrentPosition() : defaultPosition;
    }

    public void AdvanceLayout(Vector2 elementSize)
    {
        if (IsInLayoutContainer())
        {
            AdvanceContainerLayout(new Vector2(Math.Max(0, elementSize.X), Math.Max(0, elementSize.Y)));
        }
    }

    public Vector2 GetCurrentPosition()
    {
        if (_containerStack.Count == 0)
        {
            return Vector2.Zero;
        }
        // Polymorphic call to the container at the top of the stack.
        return _containerStack.Peek().GetCurrentPosition();
    }

    public void AdvanceContainerLayout(Vector2 elementSize)
    {
        if (_containerStack.Count == 0) return;

        // Polymorphic call to the container at the top of the stack.
        _containerStack.Peek().Advance(elementSize);
    }
}
</file>

<file path="Core\UIPersistentState.cs">
using System;
using System.Collections.Generic;
using Vortice.Mathematics;

namespace DirectUI;

/// <summary>
/// Manages state that persists across frames, such as UI element instances
/// and input capture state (e.g., which element is currently being pressed).
/// </summary>
public class UIPersistentState
{
    // --- Persistent Element State ---
    private readonly Dictionary<int, object> uiElements = new();
    private readonly Dictionary<int, object?> _userData = new();

    // --- Popup/Overlay State ---
    private int _activePopupId;
    private Action<UIContext>? _popupDrawCallback;
    private Rect _popupBounds;

    // Staging area for results from the previous frame to be read in the current one.
    private int _nextFramePopupResult;
    private bool _nextFramePopupResultAvailable;
    private int _nextFramePopupResultOwnerId;

    public int PopupResult { get; private set; }
    public bool PopupResultAvailable { get; private set; }
    public int PopupResultOwnerId { get; private set; }


    public T GetOrCreateElement<T>(int id) where T : new()
    {
        if (uiElements.TryGetValue(id, out object? element) && element is T existingElement)
        {
            return existingElement;
        }

        T newElement = new();
        uiElements[id] = newElement;
        return newElement;
    }

    public void SetUserData(int id, object? data)
    {
        if (data != null)
        {
            _userData[id] = data;
        }
        else
        {
            _userData.Remove(id);
        }
    }

    public object? GetUserData(int id)
    {
        return _userData.TryGetValue(id, out var data) ? data : null;
    }


    // --- Input State (persists across frames until interaction ends) ---
    public int ActivelyPressedElementId { get; private set; } = 0;
    public bool DragInProgressFromPreviousFrame { get; private set; } = false;
    public int FocusedElementId { get; private set; } = 0;

    // --- Input State (reset each frame) ---
    public int PotentialInputTargetId { get; private set; } = 0;
    public int InputCaptorId { get; private set; } = 0;
    private bool captureAttemptedThisFrame = false;
    public bool NonSliderElementClaimedPress { get; private set; } = false;


    /// <summary>
    /// Resets the per-frame state variables. Called once at the beginning of each frame.
    /// </summary>
    public void ResetFrameState(InputState input)
    {
        DragInProgressFromPreviousFrame = input.IsLeftMouseDown && ActivelyPressedElementId != 0;
        PotentialInputTargetId = 0;
        InputCaptorId = 0;
        captureAttemptedThisFrame = false;
        NonSliderElementClaimedPress = false;

        // At the start of the frame, transfer the popup result from the previous frame
        // to the current frame's readable state.
        PopupResult = _nextFramePopupResult;
        PopupResultAvailable = _nextFramePopupResultAvailable;
        PopupResultOwnerId = _nextFramePopupResultOwnerId;

        // Clear the "next frame" state, making it ready for this frame's popups to write to.
        _nextFramePopupResult = 0;
        _nextFramePopupResultAvailable = false;
        _nextFramePopupResultOwnerId = 0;
    }

    // --- Popup Management ---
    public bool IsPopupOpen => _activePopupId != 0;
    public int ActivePopupId => _activePopupId;
    public Rect PopupBounds => _popupBounds;
    public Action<UIContext>? PopupDrawCallback => _popupDrawCallback;

    public void SetActivePopup(int ownerId, Action<UIContext> drawCallback, Rect bounds)
    {
        _activePopupId = ownerId;
        _popupDrawCallback = drawCallback;
        _popupBounds = bounds;
    }

    public void SetPopupResult(int ownerId, int result)
    {
        // This sets the data that will become available at the start of the *next* frame.
        _nextFramePopupResultOwnerId = ownerId;
        _nextFramePopupResult = result;
        _nextFramePopupResultAvailable = true;
    }

    public void ClearActivePopup()
    {
        _activePopupId = 0;
        _popupDrawCallback = null;
        _popupBounds = default;
    }


    // --- Input Capture & Targeting ---
    public bool IsElementActive()
    {
        return ActivelyPressedElementId != 0;
    }

    public void SetPotentialInputTarget(int id)
    {
        // Don't allow elements to become potential targets if a popup is open and the cursor is outside it.
        if (IsPopupOpen && !_popupBounds.Contains(UI.Context.InputState.MousePosition))
        {
            return;
        }
        PotentialInputTargetId = id;
    }

    public void SetPotentialCaptorForFrame(int id)
    {
        captureAttemptedThisFrame = true;
        InputCaptorId = id;
        ActivelyPressedElementId = id;
    }

    public void SetButtonPotentialCaptorForFrame(int id)
    {
        captureAttemptedThisFrame = true;
        InputCaptorId = id;
        ActivelyPressedElementId = id;
        NonSliderElementClaimedPress = true;
    }

    public void ClearActivePress(int id)
    {
        if (ActivelyPressedElementId == id)
        {
            ActivelyPressedElementId = 0;
        }
    }

    // --- Focus Management ---
    public void SetFocus(int id)
    {
        FocusedElementId = id;
    }
}
</file>

<file path="Core\UIResources.cs">
using SharpGen.Runtime;
using System;
using System.Collections.Generic;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace DirectUI;

/// <summary>
/// Manages the creation, caching, and cleanup of shareable graphics resources
/// like brushes and text formats to avoid recreating them every frame.
/// This is now an instance class, with one instance per AppHost/window.
/// </summary>
public class UIResources
{
    // --- Font Caching Key ---
    internal readonly struct FontKey : IEquatable<FontKey>
    {
        public readonly string FontName;
        public readonly float FontSize;
        public readonly FontWeight FontWeight;
        public readonly FontStyle FontStyle;
        public readonly FontStretch FontStretch;

        public FontKey(ButtonStyle style)
        {
            FontName = style.FontName;
            FontSize = style.FontSize;
            FontWeight = style.FontWeight;
            FontStyle = style.FontStyle;
            FontStretch = style.FontStretch;
        }

        public bool Equals(FontKey other) => FontName == other.FontName && FontSize.Equals(other.FontSize) && FontWeight == other.FontWeight && FontStyle == other.FontStyle && FontStretch == other.FontStretch;
        public override bool Equals(object? obj) => obj is FontKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(FontName, FontSize, FontWeight, FontStyle, FontStretch);
    }

    // --- Text Layout Caching Key ---
    internal readonly struct TextLayoutCacheKey : IEquatable<TextLayoutCacheKey>
    {
        public readonly string Text;
        public readonly FontKey FontKey;
        public readonly Vector2 MaxSize;
        public readonly HAlignment HAlign;
        public readonly VAlignment VAlign;

        public TextLayoutCacheKey(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment)
        {
            Text = text;
            FontKey = new FontKey(style);
            MaxSize = maxSize;
            HAlign = alignment.Horizontal;
            VAlign = alignment.Vertical;
        }

        public bool Equals(TextLayoutCacheKey other) => Text == other.Text && MaxSize.Equals(other.MaxSize) && HAlign == other.HAlign && VAlign == other.VAlign && FontKey.Equals(other.FontKey);
        public override bool Equals(object? obj) => obj is TextLayoutCacheKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(Text, FontKey, MaxSize, HAlign, VAlign);
    }

    // --- Caches ---
    private readonly Dictionary<Color4, ID2D1SolidColorBrush> brushCache = new();
    private readonly Dictionary<FontKey, IDWriteTextFormat> textFormatCache = new();
    private readonly Dictionary<(string, FontKey), Vector2> textSizeCache = new();
    internal readonly Dictionary<TextLayoutCacheKey, IDWriteTextLayout> textLayoutCache = new();

    // --- Brush and Font Cache ---
    public ID2D1SolidColorBrush GetOrCreateBrush(ID2D1RenderTarget renderTarget, Color4 color)
    {
        if (renderTarget is null) { Console.WriteLine("Error: GetOrCreateBrush called with no active render target."); return null!; }
        if (brushCache.TryGetValue(color, out ID2D1SolidColorBrush? brush) && brush is not null) { return brush; }
        else if (brush is null && brushCache.ContainsKey(color)) { brushCache.Remove(color); }
        try
        {
            brush = renderTarget.CreateSolidColorBrush(color);
            if (brush is not null) { brushCache[color] = brush; return brush; }
            else { Console.WriteLine($"Warning: CreateSolidColorBrush returned null for color {color}"); return null!; }
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == ResultCode.RecreateTarget.Code) { Console.WriteLine($"Brush creation failed due to RecreateTarget error (Color: {color}). External cleanup needed."); return null!; }
        catch (Exception ex) { Console.WriteLine($"Error creating brush for color {color}: {ex.Message}"); return null!; }
    }

    public IDWriteTextFormat? GetOrCreateTextFormat(IDWriteFactory dwriteFactory, ButtonStyle style)
    {
        if (dwriteFactory is null) return null;

        var key = new FontKey(style);
        if (textFormatCache.TryGetValue(key, out var format))
        {
            return format;
        }

        try
        {
            var newFormat = dwriteFactory.CreateTextFormat(style.FontName, null, style.FontWeight, style.FontStyle, style.FontStretch, style.FontSize, "en-us");
            if (newFormat is not null) { textFormatCache[key] = newFormat; }
            return newFormat;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error creating text format for font '{style.FontName}': {ex.Message}");
            return null;
        }
    }

    public Vector2 MeasureText(IDWriteFactory dwriteFactory, string text, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(text) || style is null) return Vector2.Zero;

        var fontKey = new FontKey(style);
        var cacheKey = (text, fontKey);
        if (textSizeCache.TryGetValue(cacheKey, out var cachedSize)) return cachedSize;

        IDWriteTextFormat? textFormat = GetOrCreateTextFormat(dwriteFactory, style);
        if (textFormat is null) { Console.WriteLine("Warning: Failed to create/get TextFormat for measurement."); return Vector2.Zero; }

        using var textLayout = dwriteFactory.CreateTextLayout(text, textFormat, float.MaxValue, float.MaxValue);
        TextMetrics textMetrics = textLayout.Metrics;
        var measuredSize = new Vector2(textMetrics.WidthIncludingTrailingWhitespace, textMetrics.Height);
        textSizeCache[cacheKey] = measuredSize;
        return measuredSize;
    }

    public void DrawBoxStyleHelper(ID2D1RenderTarget renderTarget, Vector2 pos, Vector2 size, BoxStyle style)
    {
        if (renderTarget is null || style is null || size.X <= 0 || size.Y <= 0) return;

        ID2D1SolidColorBrush fillBrush = GetOrCreateBrush(renderTarget, style.FillColor);
        ID2D1SolidColorBrush borderBrush = GetOrCreateBrush(renderTarget, style.BorderColor);

        float borderTop = Math.Max(0f, style.BorderLengthTop);
        float borderRight = Math.Max(0f, style.BorderLengthRight);
        float borderBottom = Math.Max(0f, style.BorderLengthBottom);
        float borderLeft = Math.Max(0f, style.BorderLengthLeft);

        bool hasVisibleFill = style.FillColor.A > 0 && fillBrush is not null;
        bool hasVisibleBorder = style.BorderColor.A > 0 && borderBrush is not null && (borderTop > 0 || borderRight > 0 || borderBottom > 0 || borderLeft > 0);

        if (!hasVisibleFill && !hasVisibleBorder) return;

        if (style.Roundness > 0.0f)
        {
            Rect outerBounds = new Rect(pos.X, pos.Y, size.X, size.Y);
            float maxRadius = Math.Min(outerBounds.Width * 0.5f, outerBounds.Height * 0.5f);
            float radius = Math.Max(0f, maxRadius * Math.Clamp(style.Roundness, 0.0f, 1.0f));

            if (float.IsFinite(radius) && radius >= 0)
            {
                if (hasVisibleBorder)
                {
                    System.Drawing.RectangleF outerRectF = new(outerBounds.X, outerBounds.Y, outerBounds.Width, outerBounds.Height);
                    renderTarget.FillRoundedRectangle(new RoundedRectangle(outerRectF, radius, radius), borderBrush);
                }
                if (hasVisibleFill)
                {
                    float fillX = pos.X + borderLeft;
                    float fillY = pos.Y + borderTop;
                    float fillWidth = Math.Max(0f, size.X - borderLeft - borderRight);
                    float fillHeight = Math.Max(0f, size.Y - borderTop - borderBottom);
                    if (fillWidth > 0 && fillHeight > 0)
                    {
                        float avgBorderX = (borderLeft + borderRight) * 0.5f;
                        float avgBorderY = (borderTop + borderBottom) * 0.5f;
                        float innerRadiusX = Math.Max(0f, radius - avgBorderX);
                        float innerRadiusY = Math.Max(0f, radius - avgBorderY);
                        System.Drawing.RectangleF fillRectF = new(fillX, fillY, fillWidth, fillHeight);
                        renderTarget.FillRoundedRectangle(new RoundedRectangle(fillRectF, innerRadiusX, innerRadiusY), fillBrush);
                    }
                    else if (!hasVisibleBorder && fillBrush is not null)
                    {
                        System.Drawing.RectangleF outerRectF = new(outerBounds.X, outerBounds.Y, outerBounds.Width, outerBounds.Height);
                        renderTarget.FillRoundedRectangle(new RoundedRectangle(outerRectF, radius, radius), fillBrush);
                    }
                }
                return;
            }
        }
        if (hasVisibleBorder && borderBrush is not null)
        {
            renderTarget.FillRectangle(new Rect(pos.X, pos.Y, size.X, size.Y), borderBrush);
        }
        if (hasVisibleFill)
        {
            float fillX = pos.X + borderLeft;
            float fillY = pos.Y + borderTop;
            float fillWidth = Math.Max(0f, size.X - borderLeft - borderRight);
            float fillHeight = Math.Max(0f, size.Y - borderTop - borderBottom);
            if (fillWidth > 0 && fillHeight > 0)
            {
                renderTarget.FillRectangle(new Rect(fillX, fillY, fillWidth, fillHeight), fillBrush);
            }
            else if (!hasVisibleBorder && fillBrush is not null)
            {
                renderTarget.FillRectangle(new Rect(pos.X, pos.Y, size.X, size.Y), fillBrush);
            }
        }
    }

    public void CleanupResources()
    {
        Console.WriteLine("UI Resource Cleanup: Disposing cached resources...");
        int brushCount = brushCache.Count;
        foreach (var pair in brushCache) { pair.Value?.Dispose(); }
        brushCache.Clear();

        int formatCount = textFormatCache.Count;
        foreach (var pair in textFormatCache) { pair.Value?.Dispose(); }
        textFormatCache.Clear();

        int layoutCount = textLayoutCache.Count;
        foreach (var pair in textLayoutCache) { pair.Value?.Dispose(); }
        textLayoutCache.Clear();

        int sizeCacheCount = textSizeCache.Count;
        textSizeCache.Clear();

        Console.WriteLine($"UI Resource Cleanup finished. Disposed {brushCount} brushes, {formatCount} text formats, and {layoutCount} text layouts. Cleared {sizeCacheCount} size cache entries.");
    }
}
</file>

<file path="Diagnostics\FpsCounter.cs">
using System;
using System.Diagnostics;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;
using DW = Vortice.DirectWrite;

namespace DirectUI.Diagnostics;

public class FpsCounter
{
    // Configuration
    private readonly Color4 _textColor = DefaultTheme.Text;
    private readonly string _fontName = "Consolas";
    private readonly float _fontSize = 14.0f;
    private const int UpdatesPerSecond = 2; // Update twice a second

    // State
    private readonly Stopwatch _timer = new();
    private long _lastUpdateTimeTicks = 0;
    private int _frameCountSinceUpdate = 0;
    private float _currentFps = 0.0f;
    private long _updateIntervalInStopwatchTicks;

    // Direct2D Resources (Device-Independent only)
    private IDWriteTextFormat? _textFormat;

    public void Initialize(IDWriteFactory dwriteFactory)
    {
        ArgumentNullException.ThrowIfNull(dwriteFactory);

        Cleanup(); // Ensure any old resources are released

        try
        {
            _textFormat = dwriteFactory.CreateTextFormat(_fontName, null, FontWeight.Normal, FontStyle.Normal, FontStretch.Normal, _fontSize, "en-us");
            _textFormat.TextAlignment = DW.TextAlignment.Leading;
            _textFormat.ParagraphAlignment = ParagraphAlignment.Near;

            Console.WriteLine("Created FPS text format resource.");

            // Calculate the update interval based on the Stopwatch's actual frequency.
            if (Stopwatch.IsHighResolution)
            {
                _updateIntervalInStopwatchTicks = Stopwatch.Frequency / UpdatesPerSecond;
            }
            else
            {
                // Fallback for low-resolution timer
                _updateIntervalInStopwatchTicks = TimeSpan.TicksPerSecond / UpdatesPerSecond;
            }

            _frameCountSinceUpdate = 0;
            _currentFps = 0;
            _lastUpdateTimeTicks = 0;
            _timer.Restart();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Warning: Failed to create FPS counter text format: {ex.Message}");
            Cleanup(); // Clean up partial resources on failure
        }
    }

    public void Cleanup()
    {
        _timer.Stop();
        _textFormat?.Dispose();
        _textFormat = null;
    }

    /// <summary>
    /// Updates the frame count and recalculates the FPS value if the update interval has passed.
    /// This should be called once per rendered frame.
    /// </summary>
    public void Update()
    {
        if (!_timer.IsRunning) _timer.Start();

        _frameCountSinceUpdate++;
        long elapsedTicks = _timer.ElapsedTicks;
        long timeSinceLastUpdate = elapsedTicks - _lastUpdateTimeTicks;

        if (timeSinceLastUpdate >= _updateIntervalInStopwatchTicks)
        {
            long frequency = Stopwatch.IsHighResolution ? Stopwatch.Frequency : TimeSpan.TicksPerSecond;
            float secondsElapsed = (float)timeSinceLastUpdate / frequency;

            _currentFps = (secondsElapsed > 0.001f) ? (_frameCountSinceUpdate / secondsElapsed) : 0.0f;
            _frameCountSinceUpdate = 0;
            _lastUpdateTimeTicks = elapsedTicks;
        }
    }

    public void Draw(ID2D1RenderTarget renderTarget)
    {
        if (_textFormat is null || UI.Resources is null)
        {
            return;
        }

        var textBrush = UI.Resources.GetOrCreateBrush(renderTarget, _textColor);
        if (textBrush is null)
        {
            return;
        }

        string fpsText = $"FPS: {_currentFps:F1}";
        var layoutRect = new Rect(5f, 5f, 150f, 30f);
        renderTarget.DrawText(fpsText, _textFormat, layoutRect, textBrush);
    }
}
</file>

<file path="Input\InputManager.cs">
// Input/InputManager.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;

namespace DirectUI.Input;

/// <summary>
/// Aggregates raw input events over a frame and provides a snapshot of the input state.
/// </summary>
public class InputManager
{
    // Persistent state (held across frames)
    private Vector2 _currentMousePos = new(-1, -1);
    private bool _isLeftMouseButtonDown;
    private bool _isRightMouseButtonDown;
    private readonly HashSet<Keys> _heldKeys = new();

    // Per-frame state (reset every frame)
    private bool _wasLeftMouseClickedThisFrame;
    private bool _wasRightMouseClickedThisFrame;
    private float _scrollDeltaThisFrame;
    private readonly Queue<char> _typedCharsThisFrame = new();
    private readonly List<Keys> _pressedKeysThisFrame = new();
    private readonly List<Keys> _releasedKeysThisFrame = new();
    private readonly List<MouseButton> _pressedMouseButtonsThisFrame = new();

    /// <summary>
    /// Creates a snapshot of the current input state for the UI to process.
    /// </summary>
    public InputState GetCurrentState()
    {
        return new InputState(
            _currentMousePos,
            _wasLeftMouseClickedThisFrame,
            _isLeftMouseButtonDown,
            _wasRightMouseClickedThisFrame,
            _isRightMouseButtonDown,
            _scrollDeltaThisFrame,
            _typedCharsThisFrame.ToList(), // Create a copy for the readonly list
            _pressedKeysThisFrame,
            _releasedKeysThisFrame,
            _heldKeys,
            _pressedMouseButtonsThisFrame.ToList() // Create a copy for the readonly list
        );
    }

    /// <summary>
    /// Resets the per-frame input state. Should be called after a frame has been rendered.
    /// </summary>
    public void PrepareNextFrame()
    {
        _wasLeftMouseClickedThisFrame = false;
        _wasRightMouseClickedThisFrame = false;
        _scrollDeltaThisFrame = 0f;
        _typedCharsThisFrame.Clear();
        _pressedKeysThisFrame.Clear();
        _releasedKeysThisFrame.Clear();
        _pressedMouseButtonsThisFrame.Clear();
    }

    // --- Raw Event Handlers ---

    public void SetMousePosition(int x, int y)
    {
        _currentMousePos = new Vector2(x, y);
    }

    public void AddMouseWheelDelta(float delta)
    {
        _scrollDeltaThisFrame += delta;
    }

    public void SetMouseDown(MouseButton button)
    {
        _pressedMouseButtonsThisFrame.Add(button);

        if (button == MouseButton.Left)
        {
            _isLeftMouseButtonDown = true;
            _wasLeftMouseClickedThisFrame = true;
        }
        else if (button == MouseButton.Right)
        {
            _isRightMouseButtonDown = true;
            _wasRightMouseClickedThisFrame = true;
        }
    }

    public void SetMouseUp(MouseButton button)
    {
        if (button == MouseButton.Left)
        {
            _isLeftMouseButtonDown = false;
        }
        else if (button == MouseButton.Right)
        {
            _isRightMouseButtonDown = false;
        }
    }

    public void AddCharacterInput(char c)
    {
        // Filter out control characters except for tab and newline which might be useful in text boxes.
        if (!char.IsControl(c) || c == '\t' || c == '\n')
        {
            _typedCharsThisFrame.Enqueue(c);
        }
    }

    public void AddKeyPressed(Keys key)
    {
        if (!_heldKeys.Contains(key))
        {
            _pressedKeysThisFrame.Add(key);
            _heldKeys.Add(key);
        }
    }

    public void AddKeyReleased(Keys key)
    {
        if (_heldKeys.Contains(key))
        {
            _releasedKeysThisFrame.Add(key);
            _heldKeys.Remove(key);
        }
    }
}
</file>

<file path="Input\InputState.cs">
// InputState.cs
using System.Collections.Generic;
using System.Numerics;

namespace DirectUI;

// Holds input state needed for UI processing in a single frame
public readonly struct InputState
{
    public readonly Vector2 MousePosition;
    public readonly bool WasLeftMousePressedThisFrame; // True if the left button went down this frame
    public readonly bool IsLeftMouseDown; // True if the left button is currently held down
    public readonly bool WasRightMousePressedThisFrame; // True if the right button went down this frame
    public readonly bool IsRightMouseDown; // True if the right button is currently held down
    public readonly float ScrollDelta; // Mouse wheel scroll amount this frame
    public readonly IReadOnlyList<char> TypedCharacters; // Characters typed this frame
    public readonly IReadOnlyList<Keys> PressedKeys; // Keys pressed down this frame
    public readonly IReadOnlyList<Keys> ReleasedKeys; // Keys released this frame
    public readonly IReadOnlyCollection<Keys> HeldKeys; // Keys currently held down
    public readonly IReadOnlyList<MouseButton> PressedMouseButtons; // Mouse buttons pressed down this frame

    public InputState(
        Vector2 mousePosition,
        bool wasLeftMousePressedThisFrame,
        bool isLeftMouseDown,
        bool wasRightMousePressedThisFrame,
        bool isRightMouseDown,
        float scrollDelta,
        IReadOnlyList<char> typedCharacters,
        IReadOnlyList<Keys> pressedKeys,
        IReadOnlyList<Keys> releasedKeys,
        IReadOnlyCollection<Keys> heldKeys,
        IReadOnlyList<MouseButton> pressedMouseButtons)
    {
        MousePosition = mousePosition;
        WasLeftMousePressedThisFrame = wasLeftMousePressedThisFrame;
        IsLeftMouseDown = isLeftMouseDown;
        WasRightMousePressedThisFrame = wasRightMousePressedThisFrame;
        IsRightMouseDown = isRightMouseDown;
        ScrollDelta = scrollDelta;
        TypedCharacters = typedCharacters;
        PressedKeys = pressedKeys;
        ReleasedKeys = releasedKeys;
        HeldKeys = heldKeys;
        PressedMouseButtons = pressedMouseButtons;
    }
}
</file>

<file path="Input\Keys.cs">
namespace DirectUI;

/// <summary>
/// Defines keyboard keys for use in application-level input handling.
/// The values correspond to Win32 Virtual-Key Codes.
/// </summary>
public enum Keys
{
    /// <summary>
    /// The key is not recognized.
    /// </summary>
    Unknown = 0,

    // Action Keys
    /// <summary>The BACKSPACE key.</summary>
    Backspace = 0x08,
    /// <summary>The TAB key.</summary>
    Tab = 0x09,
    /// <summary>The ENTER key.</summary>
    Enter = 0x0D,
    /// <summary>The SHIFT key.</summary>
    Shift = 0x10,
    /// <summary>The CTRL key.</summary>
    Control = 0x11,
    /// <summary>The ALT key.</summary>
    Alt = 0x12,
    /// <summary>The PAUSE key.</summary>
    Pause = 0x13,
    /// <summary>The CAPS LOCK key.</summary>
    CapsLock = 0x14,
    /// <summary>The ESC key.</summary>
    Escape = 0x1B,
    /// <summary>The SPACEBAR key.</summary>
    Space = 0x20,
    /// <summary>The PAGE UP key.</summary>
    PageUp = 0x21,
    /// <summary>The PAGE DOWN key.</summary>
    PageDown = 0x22,
    /// <summary>The END key.</summary>
    End = 0x23,
    /// <summary>The HOME key.</summary>
    Home = 0x24,
    /// <summary>The LEFT ARROW key.</summary>
    LeftArrow = 0x25,
    /// <summary>The UP ARROW key.</summary>
    UpArrow = 0x26,
    /// <summary>The RIGHT ARROW key.</summary>
    RightArrow = 0x27,
    /// <summary>The DOWN ARROW key.</summary>
    DownArrow = 0x28,
    /// <summary>The INSERT key.</summary>
    Insert = 0x2D,
    /// <summary>The DELETE key.</summary>
    Delete = 0x2E,

    // Digit Keys
    /// <summary>The 0 key.</summary>
    D0 = 0x30,
    /// <summary>The 1 key.</summary>
    D1 = 0x31,
    /// <summary>The 2 key.</summary>
    D2 = 0x32,
    /// <summary>The 3 key.</summary>
    D3 = 0x33,
    /// <summary>The 4 key.</summary>
    D4 = 0x34,
    /// <summary>The 5 key.</summary>
    D5 = 0x35,
    /// <summary>The 6 key.</summary>
    D6 = 0x36,
    /// <summary>The 7 key.</summary>
    D7 = 0x37,
    /// <summary>The 8 key.</summary>
    D8 = 0x38,
    /// <summary>The 9 key.</summary>
    D9 = 0x39,

    // Letter Keys
    /// <summary>The A key.</summary>
    A = 0x41,
    /// <summary>The B key.</summary>
    B = 0x42,
    /// <summary>The C key.</summary>
    C = 0x43,
    /// <summary>The D key.</summary>
    D = 0x44,
    /// <summary>The E key.</summary>
    E = 0x45,
    /// <summary>The F key.</summary>
    F = 0x46,
    /// <summary>The G key.</summary>
    G = 0x47,
    /// <summary>The H key.</summary>
    H = 0x48,
    /// <summary>The I key.</summary>
    I = 0x49,
    /// <summary>The J key.</summary>
    J = 0x4A,
    /// <summary>The K key.</summary>
    K = 0x4B,
    /// <summary>The L key.</summary>
    L = 0x4C,
    /// <summary>The M key.</summary>
    M = 0x4D,
    /// <summary>The N key.</summary>
    N = 0x4E,
    /// <summary>The O key.</summary>
    O = 0x4F,
    /// <summary>The P key.</summary>
    P = 0x50,
    /// <summary>The Q key.</summary>
    Q = 0x51,
    /// <summary>The R key.</summary>
    R = 0x52,
    /// <summary>The S key.</summary>
    S = 0x53,
    /// <summary>The T key.</summary>
    T = 0x54,
    /// <summary>The U key.</summary>
    U = 0x55,
    /// <summary>The V key.</summary>
    V = 0x56,
    /// <summary>The W key.</summary>
    W = 0x57,
    /// <summary>The X key.</summary>
    X = 0x58,
    /// <summary>The Y key.</summary>
    Y = 0x59,
    /// <summary>The Z key.</summary>
    Z = 0x5A,

    // Function Keys
    /// <summary>The F1 key.</summary>
    F1 = 0x70,
    /// <summary>The F2 key.</summary>
    F2 = 0x71,
    /// <summary>The F3 key.</summary>
    F3 = 0x72,
    /// <summary>The F4 key.</summary>
    F4 = 0x73,
    /// <summary>The F5 key.</summary>
    F5 = 0x74,
    /// <summary>The F6 key.</summary>
    F6 = 0x75,
    /// <summary>The F7 key.</summary>
    F7 = 0x76,
    /// <summary>The F8 key.</summary>
    F8 = 0x77,
    /// <summary>The F9 key.</summary>
    F9 = 0x78,
    /// <summary>The F10 key.</summary>
    F10 = 0x79,
    /// <summary>The F11 key.</summary>
    F11 = 0x7A,
    /// <summary>The F12 key.</summary>
    F12 = 0x7B,
}
</file>

<file path="Styles\BoxStyle.cs">
using Vortice.Mathematics;

namespace DirectUI;

public class BoxStyle
{
    public float Roundness { get; set; } = 0.2f;
    public Color4 FillColor { get; set; } = DefaultTheme.NormalFill;
    public Color4 BorderColor { get; set; } = DefaultTheme.NormalBorder;

    public float BorderLengthTop { get; set; } = 1.0f;
    public float BorderLengthRight { get; set; } = 1.0f;
    public float BorderLengthBottom { get; set; } = 1.0f;
    public float BorderLengthLeft { get; set; } = 1.0f;

    public float BorderLength
    {
        get => BorderLengthTop; // Return a representative value
        set
        {
            BorderLengthTop = value;
            BorderLengthRight = value;
            BorderLengthBottom = value;
            BorderLengthLeft = value;
        }
    }

    public BoxStyle() { }

    protected BoxStyle(BoxStyle other)
    {
        this.Roundness = other.Roundness;
        this.FillColor = other.FillColor;
        this.BorderColor = other.BorderColor;
        this.BorderLengthTop = other.BorderLengthTop;
        this.BorderLengthRight = other.BorderLengthRight;
        this.BorderLengthBottom = other.BorderLengthBottom;
        this.BorderLengthLeft = other.BorderLengthLeft;
    }
}
</file>

<file path="Styles\ButtonStyle.cs">
// ButtonStyle.cs
using Vortice.Mathematics;
using Vortice.DirectWrite; // For Font related enums eventually

namespace DirectUI;

public class ButtonStyle : BoxStyle
{
    // DirectWrite Font properties will be managed elsewhere (e.g., IDWriteTextFormat)
    // public float FontSpacing { get; set; } = 0; // Handled by TextFormat
    // public float FontSize { get; set; } = 16; // Handled by TextFormat
    // public Font? Font { get; set; } = null; // Represented by TextFormat
    public Color4 FontColor { get; set; } = DefaultTheme.Text;

    // Properties needed for creating IDWriteTextFormat
    public string FontName { get; set; } = "Segoe UI";
    public float FontSize { get; set; } = 16.0f;
    public FontWeight FontWeight { get; set; } = FontWeight.Normal;
    public FontStyle FontStyle { get; set; } = FontStyle.Normal;
    public FontStretch FontStretch { get; set; } = FontStretch.Normal;

    public ButtonStyle() { }

    public ButtonStyle(ButtonStyle other) : base(other)
    {
        this.FontColor = other.FontColor;
        this.FontName = other.FontName;
        this.FontSize = other.FontSize;
        this.FontWeight = other.FontWeight;
        this.FontStyle = other.FontStyle;
        this.FontStretch = other.FontStretch;
    }
}
</file>

<file path="Styles\ButtonStylePack.cs">
using System.Collections.Generic;
using System;
using Vortice.Mathematics;
using Vortice.DirectWrite;

namespace DirectUI;

public sealed class ButtonStylePack
{
    public ButtonStyle Current { get; internal set; }
    public ButtonStyle Normal { get; set; } = new();
    public ButtonStyle Hover { get; set; } = new();
    public ButtonStyle Pressed { get; set; } = new();
    public ButtonStyle Disabled { get; set; } = new();
    public ButtonStyle Focused { get; set; } = new();

    public ButtonStylePack()
    {
        Hover.FillColor = DefaultTheme.HoverFill;
        Hover.BorderColor = DefaultTheme.HoverBorder;

        Pressed.FillColor = DefaultTheme.Accent;
        Pressed.BorderColor = DefaultTheme.AccentBorder;

        Disabled.FillColor = DefaultTheme.DisabledFill;
        Disabled.BorderColor = DefaultTheme.DisabledBorder;
        Disabled.FontColor = DefaultTheme.DisabledText;

        Focused.FillColor = DefaultTheme.NormalFill;
        Focused.BorderColor = DefaultTheme.FocusBorder;
        Focused.BorderLength = 1;

        Current = Normal;
    }

    public void UpdateCurrentStyle(bool isHovering, bool isPressed, bool isDisabled, bool isFocused)
    {
        if (isDisabled)
        {
            Current = Disabled;
        }
        else if (isPressed)
        {
            Current = Pressed;
        }
        else if (isHovering)
        {
            Current = Hover;
        }
        else if (isFocused)
        {
            Current = Focused;
        }
        else
        {
            Current = Normal;
        }
    }

    private IEnumerable<ButtonStyle> AllStyles => [Normal, Hover, Pressed, Disabled, Focused];

    public string FontName
    {
        set => SetAll(s => s.FontName = value);
    }

    public float FontSize
    {
        set => SetAll(s => s.FontSize = value);
    }

    public FontWeight FontWeight
    {
        set => SetAll(s => s.FontWeight = value);
    }

    public FontStyle FontStyle
    {
        set => SetAll(s => s.FontStyle = value);
    }

    public FontStretch FontStretch
    {
        set => SetAll(s => s.FontStretch = value);
    }

    public Color4 FontColor
    {
        set => SetAll(s => s.FontColor = value);
    }

    public float Roundness
    {
        set => SetAll(s => s.Roundness = value);
    }

    // Updated setter
    public float BorderLength
    {
        set => SetAll(s => s.BorderLength = value);
    }

    // Obsolete - kept for backward compatibility or remove if breaking change is ok
    [Obsolete("Use BorderLength instead.")]
    public float BorderThickness
    {
        set => SetAll(s => s.BorderLength = value);
    }

    public Color4 FillColor
    {
        set => SetAll(s => s.FillColor = value);
    }

    public Color4 BorderColor
    {
        set => SetAll(s => s.BorderColor = value);
    }

    private void SetAll(Action<ButtonStyle> setter)
    {
        foreach (ButtonStyle style in AllStyles)
        {
            setter(style);
        }
        // Update Current directly after modifying the source styles
        // No need to call setter(Current) separately if UpdateCurrentStyle is called later.
        // If UpdateCurrentStyle might not be called, uncommenting setter(Current) ensures immediate consistency.
        // setter(Current);
    }
}
</file>

<file path="Styles\DefaultTheme.cs">
// DefaultTheme.cs
using Vortice.Mathematics;

namespace DirectUI;

// Defines default colors for the UI theme
public static class DefaultTheme
{
    // --- Theme Color Definitions ---

    private static class Ue5ThemeColors
    {
        // Palette based on Unreal Engine 5 Editor
        public static readonly Color4 Fill = new Color4(42 / 255f, 42 / 255f, 42 / 255f, 1.0f);        // #2A2A2A
        public static readonly Color4 FillLighter = new Color4(58 / 255f, 58 / 255f, 58 / 255f, 1.0f);  // #3A3A3A
        public static readonly Color4 Border = new Color4(21 / 255f, 21 / 255f, 21 / 255f, 1.0f);      // #151515 (Matches window background)

        // --- CHANGE HERE ---
        // Changed from blue to a light gray for a more authentic UE5 feel.
        public static readonly Color4 Hover = new Color4(160 / 255f, 160 / 255f, 160 / 255f, 1.0f);   // #A0A0A0
        // --- END CHANGE ---

        public static readonly Color4 Accent = new Color4(255 / 255f, 171 / 255f, 0 / 255f, 1.0f);     // Orange #FFAB00
        public static readonly Color4 AccentBorder = new Color4(255 / 255f, 187 / 255f, 51 / 255f, 1.0f); // Lighter Orange

        public static readonly Color4 DisabledFill = new Color4(32 / 255f, 32 / 255f, 32 / 255f, 0.8f);
        public static readonly Color4 DisabledBorder = new Color4(48 / 255f, 48 / 255f, 48 / 255f, 0.8f);
        public static readonly Color4 DisabledText = new Color4(128 / 255f, 128 / 255f, 128 / 255f, 1.0f);

        public static readonly Color4 Text = new Color4(240 / 255f, 240 / 255f, 240 / 255f, 1.0f);     // #F0F0F0
    }

    private static class OriginalColors
    {
        public static readonly Color4 NormalFill = new Color4(0.25f, 0.25f, 0.3f, 1.0f);
        public static readonly Color4 NormalBorder = new Color4(0.4f, 0.4f, 0.45f, 1.0f);
        public static readonly Color4 HoverFill = new Color4(0.35f, 0.35f, 0.4f, 1.0f);
        public static readonly Color4 HoverBorder = new Color4(0.5f, 0.5f, 0.55f, 1.0f);
        public static readonly Color4 Accent = new Color4(0.2f, 0.4f, 0.8f, 1.0f);
        public static readonly Color4 AccentBorder = new Color4(0.3f, 0.5f, 0.9f, 1.0f);
        public static readonly Color4 DisabledFill = new Color4(0.2f, 0.2f, 0.2f, 0.8f);
        public static readonly Color4 DisabledBorder = new Color4(0.3f, 0.3f, 0.3f, 0.8f);
        public static readonly Color4 DisabledText = new Color4(0.5f, 0.5f, 0.5f, 1.0f);
        public static readonly Color4 Text = Colors.WhiteSmoke;
    }


    // --- Current Active Theme ---
    // Change the assignments here to swap themes.

    // Basic Palette
    public static readonly Color4 White = Colors.White;
    public static readonly Color4 Black = Colors.Black;
    public static readonly Color4 Transparent = Colors.Transparent;

    // --- ACTIVE THEME: UE5 ---
    public static readonly Color4 NormalFill = Ue5ThemeColors.Fill;
    public static readonly Color4 NormalBorder = Ue5ThemeColors.Border;
    public static readonly Color4 HoverFill = Ue5ThemeColors.FillLighter;    // Subtle gray change for hover fill
    public static readonly Color4 HoverBorder = Ue5ThemeColors.Hover;        // Light gray border on hover
    public static readonly Color4 Accent = Ue5ThemeColors.Accent;            // Orange accent for pressed
    public static readonly Color4 AccentBorder = Ue5ThemeColors.AccentBorder;
    public static readonly Color4 DisabledFill = Ue5ThemeColors.DisabledFill;
    public static readonly Color4 DisabledBorder = Ue5ThemeColors.DisabledBorder;
    public static readonly Color4 DisabledText = Ue5ThemeColors.DisabledText;
    public static readonly Color4 FocusBorder = Ue5ThemeColors.Hover;        // Use gray for focus
    public static readonly Color4 Text = Ue5ThemeColors.Text;

    /*
    // --- BACKUP THEME: Original ---
    // To restore the original theme, comment out the "UE5" block above
    // and uncomment this block below.
    public static readonly Color4 NormalFill = OriginalColors.NormalFill;
    public static readonly Color4 NormalBorder = OriginalColors.NormalBorder;
    public static readonly Color4 HoverFill = OriginalColors.HoverFill;
    public static readonly Color4 HoverBorder = OriginalColors.HoverBorder;
    public static readonly Color4 Accent = OriginalColors.Accent;
    public static readonly Color4 AccentBorder = OriginalColors.AccentBorder;
    public static readonly Color4 DisabledFill = OriginalColors.DisabledFill;
    public static readonly Color4 DisabledBorder = OriginalColors.DisabledBorder;
    public static readonly Color4 DisabledText = OriginalColors.DisabledText;
    public static readonly Color4 FocusBorder = Colors.LightSkyBlue;
    public static readonly Color4 Text = OriginalColors.Text;
    */
}
</file>

<file path="Styles\SliderStyle.cs">
// MODIFIED: Styles/SliderStyle.cs
// Summary: Updated default BoxStyle initializations to use BorderLength instead of BorderThickness.
using Vortice.Mathematics;

namespace DirectUI;

public class SliderStyle
{
    public BoxStyle Background { get; set; } = new()
    {
        FillColor = DefaultTheme.DisabledFill,
        BorderColor = DefaultTheme.NormalBorder,
        Roundness = 0.5f,
        BorderLength = 1.0f // Use new property
    };

    public BoxStyle Foreground { get; set; } = new()
    {
        FillColor = DefaultTheme.Accent,
        BorderColor = Colors.Transparent,
        Roundness = 0.5f,
        BorderLength = 0.0f // Use new property
    };
}
</file>

<file path="Styles\TabStyle.cs">
namespace DirectUI;

public class TabStyle : ButtonStyle
{
    // For now, this is a marker class. It can hold tab-specific style properties later.
}
</file>

<file path="Styles\TabStylePack.cs">
using Vortice.Mathematics;

namespace DirectUI;

public sealed class TabStylePack
{
    public TabStyle Current { get; private set; }
    public TabStyle Normal { get; set; } = new();
    public TabStyle Hover { get; set; } = new();
    public TabStyle Active { get; set; } = new();
    public TabStyle ActiveHover { get; set; } = new();
    public TabStyle Disabled { get; set; } = new();

    public TabStylePack()
    {
        var panelBg = new Color4(37 / 255f, 37 / 255f, 38 / 255f, 1.0f);
        var hoverBorder = DefaultTheme.HoverBorder;
        var accentBorder = DefaultTheme.AccentBorder;

        string fontName = "Segoe UI";
        float fontSize = 14f;

        // Inactive tab
        Normal.FillColor = DefaultTheme.NormalFill;
        Normal.BorderColor = DefaultTheme.NormalBorder;
        Normal.BorderLength = 1f;
        Normal.Roundness = 0f;
        Normal.FontName = fontName; Normal.FontSize = fontSize;

        // Inactive tab, hovered
        Hover.FillColor = DefaultTheme.HoverFill;
        Hover.BorderColor = hoverBorder;
        Hover.BorderLength = 1f;
        Hover.Roundness = 0f;
        Hover.FontName = fontName; Hover.FontSize = fontSize;

        // Active tab
        Active.FillColor = panelBg;
        Active.BorderColor = hoverBorder;
        Active.BorderLengthTop = 1f; Active.BorderLengthLeft = 1f; Active.BorderLengthRight = 1f; Active.BorderLengthBottom = 0f;
        Active.Roundness = 0f;
        Active.FontName = fontName; Active.FontSize = fontSize;

        // Active tab, hovered
        ActiveHover.FillColor = panelBg;
        ActiveHover.BorderColor = accentBorder;
        ActiveHover.BorderLengthTop = 1f; ActiveHover.BorderLengthLeft = 1f; ActiveHover.BorderLengthRight = 1f; ActiveHover.BorderLengthBottom = 0f;
        ActiveHover.Roundness = 0f;
        ActiveHover.FontName = fontName; ActiveHover.FontSize = fontSize;

        Disabled.FillColor = DefaultTheme.DisabledFill;
        Disabled.BorderColor = DefaultTheme.DisabledBorder;
        Disabled.FontColor = DefaultTheme.DisabledText;
        Disabled.FontName = fontName; Disabled.FontSize = fontSize;

        Current = Normal;
    }

    public void UpdateCurrentStyle(bool isHovering, bool isActive, bool isDisabled, bool isFocused)
    {
        if (isDisabled)
        {
            Current = Disabled;
        }
        else if (isActive) Current = isHovering ? ActiveHover : Active;
        else if (isHovering) Current = Hover;
        else
        {
            Current = Normal;
        }
    }
}
</file>

<file path="Styles\TreeStyle.cs">
using DirectUI;
using Vortice.Mathematics;

namespace DirectUI;

public class TreeStyle
{
    public float Indent { get; set; } = 19f;
    public float RowHeight { get; set; } = 22f;
    public Color4 LineColor { get; set; } = DefaultTheme.HoverBorder;
    public ButtonStylePack ToggleStyle { get; set; }
    public ButtonStylePack NodeLabelStyle { get; set; }

    public TreeStyle()
    {
        ToggleStyle = new ButtonStylePack
        {
            Roundness = 0.2f,
            BorderLength = 1f,
            FontName = "Consolas",
            FontSize = 14
        };
        ToggleStyle.Normal.FillColor = DefaultTheme.NormalFill;
        ToggleStyle.Normal.BorderColor = DefaultTheme.NormalBorder;
        ToggleStyle.Hover.FillColor = DefaultTheme.HoverFill;
        ToggleStyle.Hover.BorderColor = DefaultTheme.HoverBorder;
        ToggleStyle.Pressed.FillColor = DefaultTheme.Accent;
        ToggleStyle.Pressed.BorderColor = DefaultTheme.AccentBorder;

        NodeLabelStyle = new ButtonStylePack
        {
            Roundness = 0f,
            BorderLength = 0f,
            FontName = "Segoe UI",
            FontSize = 14
        };
        NodeLabelStyle.Normal.FillColor = Colors.Transparent;
        NodeLabelStyle.Normal.FontColor = DefaultTheme.Text;
        NodeLabelStyle.Hover.FillColor = new Color4(0.25f, 0.25f, 0.25f, 0.5f); // Semi-transparent gray
        NodeLabelStyle.Hover.FontColor = DefaultTheme.Text;
        NodeLabelStyle.Pressed.FillColor = DefaultTheme.Accent;
        NodeLabelStyle.Pressed.FontColor = Colors.White;
        NodeLabelStyle.Pressed.BorderColor = DefaultTheme.AccentBorder;
    }
}
</file>

<file path="Widgets\Button.cs">
namespace DirectUI;

public static class Button
{
    public enum ActionMode { Release, Press }
    public enum ClickBehavior { Left, Right, Both }
}
</file>

<file path="Widgets\InternalComboboxLogic.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

/// <summary>
/// Provides the internal logic for the combobox widget, including managing popup state.
/// </summary>
internal class InternalComboboxLogic
{
    public int UpdateAndDraw(
        int id,
        int selectedIndex,
        string[] items,
        Vector2 position,
        Vector2 size,
        ButtonStylePack? theme,
        bool disabled)
    {
        var context = UI.Context;
        var state = UI.State;
        var resources = UI.Resources;

        int newSelectedIndex = selectedIndex;

        // If a selection was made in the popup during the last frame's EndFrame,
        // the result will be available now for us to consume.
        if (state.PopupResultAvailable && state.PopupResultOwnerId == id)
        {
            newSelectedIndex = state.PopupResult;
        }

        var comboboxState = state.GetOrCreateElement<ComboboxState>(id);
        var themeId = HashCode.Combine(id, "theme");
        var finalTheme = theme ?? state.GetOrCreateElement<ButtonStylePack>(themeId);

        // Sync local open state with global popup state
        if (comboboxState.IsOpen && state.ActivePopupId != id)
        {
            comboboxState.IsOpen = false;
        }

        // The text on the button should reflect the potentially new index
        string currentItemText = (newSelectedIndex >= 0 && newSelectedIndex < items.Length)
            ? items[newSelectedIndex]
            : string.Empty;

        // Draw the main button
        var bounds = new Rect(position.X, position.Y, size.X, size.Y);
        bool clicked = UI.ButtonPrimitive(
            id,
            bounds,
            currentItemText,
            finalTheme,
            disabled,
            new Alignment(HAlignment.Left, VAlignment.Center),
            Button.ActionMode.Release,
            Button.ClickBehavior.Left,
            new Vector2(5, 0)
        );

        if (clicked && !disabled)
        {
            if (comboboxState.IsOpen)
            {
                // If it was already open for us, clicking again closes it.
                state.ClearActivePopup();
                comboboxState.IsOpen = false;
            }
            else
            {
                // Request to open the popup.
                // First, ensure any other popups are closed.
                state.ClearActivePopup();

                // Calculate popup properties
                float popupY = position.Y + size.Y + 2;
                float itemHeight = size.Y; // Items are same height as the button
                float popupHeight = items.Length * itemHeight;
                var popupBounds = new Rect(position.X, popupY, size.X, popupHeight);

                // Define the draw callback for the popup, which runs at EndFrame
                Action<UIContext> drawCallback = (ctx) =>
                {
                    // Draw popup background
                    var popupStyle = new BoxStyle { FillColor = DefaultTheme.NormalFill, BorderColor = DefaultTheme.FocusBorder, BorderLength = 1f, Roundness = 0f };
                    resources.DrawBoxStyleHelper(ctx.RenderTarget, popupBounds.TopLeft, new Vector2(popupBounds.Width, popupBounds.Height), popupStyle);

                    // Draw items
                    for (int i = 0; i < items.Length; i++)
                    {
                        var itemBounds = new Rect(popupBounds.X, popupBounds.Y + i * itemHeight, popupBounds.Width, itemHeight);
                        var itemTheme = new ButtonStylePack { Roundness = 0f, BorderLength = 0f };
                        itemTheme.Normal.FillColor = Colors.Transparent;
                        itemTheme.Hover.FillColor = DefaultTheme.HoverFill;
                        itemTheme.Pressed.FillColor = DefaultTheme.Accent;

                        int itemId = HashCode.Combine(id, "item", i);

                        if (UI.ButtonPrimitive(itemId, itemBounds, items[i], itemTheme, false, new Alignment(HAlignment.Left, VAlignment.Center), Button.ActionMode.Release, Button.ClickBehavior.Left, new Vector2(5, 0)))
                        {
                            // A selection was made. Post the result to be picked up next frame.
                            state.SetPopupResult(id, i);

                            // Close the popup.
                            state.ClearActivePopup();
                        }
                    }
                };

                state.SetActivePopup(id, drawCallback, popupBounds);
                comboboxState.IsOpen = true;
            }
        }

        return newSelectedIndex;
    }
}
</file>

<file path="Widgets\InternalHSliderLogic.cs">
using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

internal class InternalHSliderLogic : InternalSliderLogic
{
    public HSliderDirection Direction { get; set; } = HSliderDirection.LeftToRight;

    protected override void CalculateTrackBounds()
    {
        trackMinBound = trackPosition.X;
        trackMaxBound = trackPosition.X + Size.X;
    }

    protected override float HandleInput(InputState input, float currentValue)
    {
        float newValue = currentValue;
        Vector2 mousePos = input.MousePosition;
        var state = UI.State;

        Vector2 currentGrabberPos = CalculateGrabberPosition(currentValue);
        Rect currentGrabberBounds = new Rect(currentGrabberPos.X, currentGrabberPos.Y, GrabberSize.X, GrabberSize.Y);
        isGrabberHovered = currentGrabberBounds.Contains(mousePos.X, mousePos.Y);

        Rect trackBoundsRect = new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y);
        isTrackHovered = trackBoundsRect.Contains(mousePos.X, mousePos.Y);

        bool isSliderHovered = isGrabberHovered || isTrackHovered;

        if (isSliderHovered)
        {
            state.SetPotentialInputTarget(GlobalIntId);
        }

        if (state.ActivelyPressedElementId == GlobalIntId && !input.IsLeftMouseDown)
        {
            state.ClearActivePress(GlobalIntId);
        }

        if (input.WasLeftMousePressedThisFrame)
        {
            if (isSliderHovered && state.PotentialInputTargetId == GlobalIntId && !state.DragInProgressFromPreviousFrame)
            {
                state.SetButtonPotentialCaptorForFrame(GlobalIntId);
                state.SetFocus(GlobalIntId);

                if (isTrackHovered && !isGrabberHovered)
                {
                    pendingTrackClickValueJump = true;
                    trackClickPosition = Math.Clamp(mousePos.X, trackMinBound, trackMaxBound);
                }
            }
        }

        if (state.ActivelyPressedElementId == GlobalIntId && input.IsLeftMouseDown)
        {
            if (!pendingTrackClickValueJump)
            {
                float clampedX = Math.Clamp(mousePos.X, trackMinBound, trackMaxBound);
                newValue = ConvertPositionToValue(clampedX);
                newValue = ApplyStep(newValue);
                newValue = Math.Clamp(newValue, MinValue, MaxValue);
            }
        }

        return newValue;
    }

    protected override float ConvertPositionToValue(float position)
    {
        if (trackMaxBound <= trackMinBound) return MinValue;
        float normalized = (position - trackMinBound) / (trackMaxBound - trackMinBound);
        normalized = Math.Clamp(normalized, 0.0f, 1.0f);
        if (Direction == HSliderDirection.RightToLeft) { normalized = 1.0f - normalized; }
        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return rawValue;
    }
    protected override Vector2 CalculateGrabberPosition(float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0;
        if (Direction == HSliderDirection.RightToLeft) { normalizedValue = 1.0f - normalizedValue; }
        float trackWidth = Size.X;
        float centerX = trackMinBound + normalizedValue * trackWidth;
        float xPos = centerX - (GrabberSize.X / 2.0f);
        float yPos = trackPosition.Y + (Size.Y / 2.0f) - (GrabberSize.Y / 2.0f);
        float minX = trackPosition.X;
        float maxX = trackPosition.X + Size.X - GrabberSize.X;
        if (maxX < minX) maxX = minX;
        xPos = Math.Clamp(xPos, minX, maxX);
        return new Vector2(xPos, yPos);
    }
    protected override void DrawForeground(ID2D1RenderTarget renderTarget, float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        if (valueRange <= 0 || renderTarget is null) return;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0.0f;
        float foregroundWidth = Size.X * normalizedValue;
        if (foregroundWidth <= 0.001f) return;
        Rect clipRect;
        if (Direction == HSliderDirection.RightToLeft) { clipRect = new Rect(trackPosition.X + Size.X - foregroundWidth, trackPosition.Y, foregroundWidth, Size.Y); }
        else { clipRect = new Rect(trackPosition.X, trackPosition.Y, foregroundWidth, Size.Y); }
        renderTarget.PushAxisAlignedClip(clipRect, D2D.AntialiasMode.Aliased);
        UI.Resources.DrawBoxStyleHelper(renderTarget, trackPosition, Size, Theme.Foreground);
        renderTarget.PopAxisAlignedClip();
    }
}
</file>

<file path="Widgets\InternalScrollBarLogic.cs">
// Widgets/InternalScrollBarLogic.cs
using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.Mathematics;

namespace DirectUI;

/// <summary>
/// Internal class that encapsulates the state, logic, and drawing for a proportional scrollbar.
/// </summary>
internal class InternalScrollBarLogic
{
    // --- Configuration (set per-frame) ---
    public Vector2 Position { get; set; }
    public float TrackLength { get; set; }
    public float TrackThickness { get; set; }
    public bool IsVertical { get; set; }
    public float ContentSize { get; set; }
    public float VisibleSize { get; set; }
    public SliderStyle Theme { get; set; } = new();
    public ButtonStylePack ThumbTheme { get; set; } = new();

    // --- Internal State ---
    private int _id;
    private bool _isThumbHovered;
    private bool _isThumbPressed;
    private bool _isFocused;
    private float _dragStartMousePos;
    private float _dragStartScrollOffset;

    /// <summary>
    /// The main update and draw entry point called by the public UI method.
    /// </summary>
    public float UpdateAndDraw(int id, float currentScrollOffset)
    {
        if (VisibleSize >= ContentSize) return 0; // No scrolling needed, offset must be 0.

        _id = id;
        var context = UI.Context;
        var state = UI.State;
        var input = context.InputState;

        _isFocused = state.FocusedElementId == _id;
        float newScrollOffset = HandleInput(input, currentScrollOffset);

        _isThumbPressed = state.ActivelyPressedElementId == _id;
        ThumbTheme.UpdateCurrentStyle(_isThumbHovered, _isThumbPressed, false, _isFocused);

        if (context.RenderTarget != null)
        {
            Draw(context.RenderTarget, newScrollOffset);
        }

        return newScrollOffset;
    }

    private Rect GetTrackBounds()
    {
        return IsVertical
            ? new Rect(Position.X, Position.Y, TrackThickness, TrackLength)
            : new Rect(Position.X, Position.Y, TrackLength, TrackThickness);
    }

    private Rect GetThumbBounds(float currentScrollOffset, out float thumbLength)
    {
        thumbLength = 0;
        if (VisibleSize >= ContentSize) return new Rect();

        float viewRatio = VisibleSize / ContentSize;
        thumbLength = TrackLength * viewRatio;
        float minThumbLength = 20f; // Ensure thumb is always grabbable
        thumbLength = Math.Max(minThumbLength, thumbLength);

        float maxScrollOffset = ContentSize - VisibleSize;
        float scrollableTrackLength = TrackLength - thumbLength;

        if (scrollableTrackLength <= 0) return GetTrackBounds();

        float scrollRatio = (maxScrollOffset > 0) ? currentScrollOffset / maxScrollOffset : 0;
        float thumbOffsetInTrack = scrollableTrackLength * scrollRatio;

        return IsVertical
            ? new Rect(Position.X, Position.Y + thumbOffsetInTrack, TrackThickness, thumbLength)
            : new Rect(Position.X + thumbOffsetInTrack, Position.Y, thumbLength, TrackThickness);
    }

    private float HandleInput(InputState input, float currentScrollOffset)
    {
        var state = UI.State;
        var trackBounds = GetTrackBounds();
        var thumbBounds = GetThumbBounds(currentScrollOffset, out float thumbLength);

        _isThumbHovered = thumbBounds.Contains(input.MousePosition);
        bool isTrackHovered = trackBounds.Contains(input.MousePosition);

        if (_isThumbHovered || isTrackHovered)
        {
            state.SetPotentialInputTarget(_id);
        }

        _isThumbPressed = state.ActivelyPressedElementId == _id;

        if (_isThumbPressed && !input.IsLeftMouseDown)
        {
            state.ClearActivePress(_id);
            _isThumbPressed = false;
        }

        if (input.WasLeftMousePressedThisFrame && state.PotentialInputTargetId == _id)
        {
            state.SetButtonPotentialCaptorForFrame(_id);
            state.SetFocus(_id);
            _isThumbPressed = true;

            if (_isThumbHovered)
            {
                _dragStartMousePos = IsVertical ? input.MousePosition.Y : input.MousePosition.X;
                _dragStartScrollOffset = currentScrollOffset;
            }
            else // Clicked on track
            {
                float mousePosOnTrack = IsVertical ? input.MousePosition.Y : input.MousePosition.X;
                float thumbStart = IsVertical ? thumbBounds.Y : thumbBounds.X;
                float thumbEnd = thumbStart + thumbLength;

                float pageAmount = VisibleSize;
                if (mousePosOnTrack < thumbStart)
                {
                    return Math.Max(0, currentScrollOffset - pageAmount);
                }
                else if (mousePosOnTrack > thumbEnd)
                {
                    float maxScroll = ContentSize - VisibleSize;
                    return Math.Min(maxScroll, currentScrollOffset + pageAmount);
                }
            }
        }

        if (_isThumbPressed && input.IsLeftMouseDown)
        {
            float maxScrollOffset = ContentSize - VisibleSize;
            float scrollableTrackLength = TrackLength - thumbLength;
            if (scrollableTrackLength <= 0) return currentScrollOffset;

            float currentMousePos = IsVertical ? input.MousePosition.Y : input.MousePosition.X;
            float mouseDelta = currentMousePos - _dragStartMousePos;

            float scrollDelta = mouseDelta * (maxScrollOffset / scrollableTrackLength);

            float newScrollOffset = _dragStartScrollOffset + scrollDelta;
            return Math.Clamp(newScrollOffset, 0, maxScrollOffset);
        }

        return currentScrollOffset;
    }

    private void Draw(ID2D1RenderTarget rt, float currentScrollOffset)
    {
        // Draw Track
        UI.Resources.DrawBoxStyleHelper(rt, Position,
            IsVertical ? new Vector2(TrackThickness, TrackLength) : new Vector2(TrackLength, TrackThickness),
            Theme.Background);

        // Draw Thumb
        var thumbBounds = GetThumbBounds(currentScrollOffset, out _);
        if (thumbBounds.Width > 0 && thumbBounds.Height > 0)
        {
            var thumbStyle = new BoxStyle
            {
                FillColor = ThumbTheme.Current.FillColor,
                BorderColor = ThumbTheme.Current.BorderColor,
                BorderLength = ThumbTheme.Current.BorderLength,
                Roundness = ThumbTheme.Current.Roundness
            };
            // BUG FIX: Convert Vortice.Mathematics.Rect.Size (a Size) to a System.Numerics.Vector2
            UI.Resources.DrawBoxStyleHelper(rt, thumbBounds.TopLeft, new Vector2(thumbBounds.Width, thumbBounds.Height), thumbStyle);
        }
    }
}
</file>

<file path="Widgets\InternalSliderLogic.cs">
using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.Mathematics;

namespace DirectUI;

internal abstract class InternalSliderLogic
{
    // --- Configuration ---
    public Vector2 Position { get; set; }
    public Vector2 Size { get; set; }
    public Vector2 Origin { get; set; }
    public float MinValue { get; set; }
    public float MaxValue { get; set; }
    public float Step { get; set; }
    public SliderStyle Theme { get; set; } = new();
    public ButtonStylePack GrabberTheme { get; set; } = new();
    public Vector2 GrabberSize { get; set; } = new(16, 16);
    public bool Disabled { get; set; }
    public object? UserData { get; set; }

    // --- Internal State ---
    protected bool isGrabberPressed = false;
    protected bool isGrabberHovered = false;
    protected bool isTrackHovered = false;
    protected bool isFocused = false;
    protected Vector2 trackPosition;
    protected float trackMinBound;
    protected float trackMaxBound;
    protected bool pendingTrackClickValueJump = false;
    protected float trackClickPosition = 0f;
    protected int GlobalIntId { get; private set; } = 0;


    // --- Calculated Properties ---
    public Rect GlobalBounds => new(Position.X - Origin.X, Position.Y - Origin.Y, Size.X, Size.Y);

    // --- Abstract Methods ---
    protected abstract void CalculateTrackBounds();
    protected abstract float HandleInput(InputState input, float currentValue);
    protected abstract float ConvertPositionToValue(float position);
    protected abstract Vector2 CalculateGrabberPosition(float currentValue);
    protected abstract void DrawForeground(ID2D1RenderTarget renderTarget, float currentValue);


    // --- Common Logic ---
    internal float UpdateAndDraw(int id, float currentValue)
    {
        var context = UI.Context;
        var state = UI.State;

        GlobalIntId = id;
        isFocused = state.FocusedElementId == GlobalIntId;
        trackPosition = Position - Origin;
        CalculateTrackBounds();

        pendingTrackClickValueJump = false;
        float newValue = currentValue;

        if (Disabled)
        {
            isGrabberHovered = false;
            isGrabberPressed = false;
            isTrackHovered = false;
            if (state.ActivelyPressedElementId == GlobalIntId) state.ClearActivePress(GlobalIntId);
        }
        else
        {
            newValue = HandleInput(context.InputState, currentValue);
        }

        if (pendingTrackClickValueJump && state.InputCaptorId == GlobalIntId && !state.NonSliderElementClaimedPress)
        {
            newValue = ConvertPositionToValue(trackClickPosition);
            newValue = ApplyStep(newValue);
            newValue = Math.Clamp(newValue, MinValue, MaxValue);
        }
        pendingTrackClickValueJump = false;

        UpdateGrabberThemeStyle();

        if (context.RenderTarget is null)
        {
            Console.WriteLine("Error: RenderTarget is null during Slider UpdateAndDraw.");
            return newValue;
        }

        try
        {
            DrawBackground(context.RenderTarget);
            DrawForeground(context.RenderTarget, newValue);
            DrawGrabber(context.RenderTarget, newValue);
        }
        catch (SharpGen.Runtime.SharpGenException ex) when (ex.ResultCode.Code == Vortice.Direct2D1.ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Slider Draw failed (RecreateTarget): {ex.Message}. External cleanup needed.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error drawing slider: {ex.Message}");
        }

        return newValue;
    }

    // --- Helper Methods ---
    protected float ApplyStep(float value)
    {
        float clampedValue = Math.Clamp(value, MinValue, MaxValue);
        if (Step <= 0 || MaxValue <= MinValue)
        {
            return clampedValue;
        }

        float range = MaxValue - MinValue;
        if (range < Step && Step > 0)
        {
            return (value - MinValue < range / 2.0f) ? MinValue : MaxValue;
        }

        float stepsFromMin = (float)Math.Round((clampedValue - MinValue) / Step);
        float steppedValue = MinValue + stepsFromMin * Step;

        return Math.Clamp(steppedValue, MinValue, MaxValue);
    }


    protected void UpdateGrabberThemeStyle()
    {
        isGrabberPressed = UI.State.ActivelyPressedElementId == GlobalIntId;
        isFocused = UI.State.FocusedElementId == GlobalIntId;
        GrabberTheme.UpdateCurrentStyle(isGrabberHovered, isGrabberPressed, Disabled, isFocused);
    }


    // --- Drawing Methods ---
    protected void DrawBackground(ID2D1RenderTarget renderTarget)
    {
        UI.Resources.DrawBoxStyleHelper(renderTarget, trackPosition, Size, Theme.Background);
    }

    protected void DrawGrabber(ID2D1RenderTarget renderTarget, float currentValue)
    {
        Vector2 grabberPos = CalculateGrabberPosition(currentValue);
        UI.Resources.DrawBoxStyleHelper(renderTarget, grabberPos, GrabberSize, GrabberTheme.Current);
    }
}
</file>

<file path="Widgets\InternalVSlider.cs">
using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

internal class InternalVSliderLogic : InternalSliderLogic
{
    public VSliderDirection Direction { get; set; } = VSliderDirection.TopToBottom;

    protected override void CalculateTrackBounds()
    {
        trackMinBound = trackPosition.Y;
        trackMaxBound = trackPosition.Y + Size.Y;
    }

    protected override float HandleInput(InputState input, float currentValue)
    {
        float newValue = currentValue;
        Vector2 mousePos = input.MousePosition;
        var state = UI.State;

        Vector2 currentGrabberPos = CalculateGrabberPosition(currentValue);
        Rect currentGrabberBounds = new Rect(currentGrabberPos.X, currentGrabberPos.Y, GrabberSize.X, GrabberSize.Y);
        isGrabberHovered = currentGrabberBounds.Contains(mousePos.X, mousePos.Y);

        Rect trackBoundsRect = new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y);
        isTrackHovered = trackBoundsRect.Contains(mousePos.X, mousePos.Y);

        bool isSliderHovered = isGrabberHovered || isTrackHovered;

        if (isSliderHovered)
        {
            state.SetPotentialInputTarget(GlobalIntId);
        }

        if (state.ActivelyPressedElementId == GlobalIntId && !input.IsLeftMouseDown)
        {
            state.ClearActivePress(GlobalIntId);
        }

        if (input.WasLeftMousePressedThisFrame)
        {
            if (isSliderHovered && state.PotentialInputTargetId == GlobalIntId && !state.DragInProgressFromPreviousFrame)
            {
                state.SetButtonPotentialCaptorForFrame(GlobalIntId);
                state.SetFocus(GlobalIntId);

                if (isTrackHovered && !isGrabberHovered)
                {
                    pendingTrackClickValueJump = true;
                    trackClickPosition = Math.Clamp(mousePos.Y, trackMinBound, trackMaxBound);
                }
            }
        }

        if (state.ActivelyPressedElementId == GlobalIntId && input.IsLeftMouseDown)
        {
            if (!pendingTrackClickValueJump)
            {
                float clampedY = Math.Clamp(mousePos.Y, trackMinBound, trackMaxBound);
                newValue = ConvertPositionToValue(clampedY);
                newValue = ApplyStep(newValue);
                newValue = Math.Clamp(newValue, MinValue, MaxValue);
            }
        }

        return newValue;
    }

    protected override float ConvertPositionToValue(float position)
    {
        if (trackMaxBound <= trackMinBound) return MinValue;
        float normalized = (position - trackMinBound) / (trackMaxBound - trackMinBound);
        normalized = Math.Clamp(normalized, 0.0f, 1.0f);
        if (Direction == VSliderDirection.BottomToTop) { normalized = 1.0f - normalized; }
        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return rawValue;
    }
    protected override Vector2 CalculateGrabberPosition(float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0;
        if (Direction == VSliderDirection.BottomToTop) { normalizedValue = 1.0f - normalizedValue; }
        float trackHeight = Size.Y;
        float centerY = trackMinBound + normalizedValue * trackHeight;
        float yPos = centerY - (GrabberSize.Y / 2.0f);
        float xPos = trackPosition.X + (Size.X / 2.0f) - (GrabberSize.X / 2.0f);
        float minY = trackPosition.Y;
        float maxY = trackPosition.Y + Size.Y - GrabberSize.Y;
        if (maxY < minY) maxY = minY;
        yPos = Math.Clamp(yPos, minY, maxY);
        return new Vector2(xPos, yPos);
    }
    protected override void DrawForeground(ID2D1RenderTarget renderTarget, float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        if (valueRange <= 0 || renderTarget is null) return;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0.0f;
        float foregroundHeight = Size.Y * normalizedValue;
        if (foregroundHeight <= 0.001f) return;
        Rect clipRect;
        if (Direction == VSliderDirection.BottomToTop) { clipRect = new Rect(trackPosition.X, trackPosition.Y + Size.Y - foregroundHeight, Size.X, foregroundHeight); }
        else { clipRect = new Rect(trackPosition.X, trackPosition.Y, Size.X, foregroundHeight); }
        renderTarget.PushAxisAlignedClip(clipRect, D2D.AntialiasMode.Aliased);
        UI.Resources.DrawBoxStyleHelper(renderTarget, trackPosition, Size, Theme.Foreground);
        renderTarget.PopAxisAlignedClip();
    }
}
</file>

<file path="Widgets\LineEdit.cs">
// Widgets/LineEdit.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;
using SharpGen.Runtime;

namespace DirectUI;

// Logic and drawing for an immediate-mode LineEdit control. This class is STATELESS.
// All persistent state is managed in a separate LineEditState object.
internal class LineEdit
{
    // === CACHED RENDERING RESOURCES (transient, not persistent state) ===
    private IDWriteTextLayout? _cachedTextLayout;
    private string _cachedText = " "; // Use a non-null, non-empty default
    private ButtonStyle? _cachedStyle;
    private float _cachedMaxWidth = -1;

    // === MAIN UPDATE & DRAW METHOD ===
    public bool UpdateAndDraw(
        int intId,
        ref string text,
        LineEditState state, // The state is now passed in
        Vector2 position,
        Vector2 size,
        ButtonStylePack? theme,
        string placeholderText,
        bool isPassword,
        char passwordChar,
        int maxLength,
        bool disabled,
        Vector2 textMargin)
    {
        var context = UI.Context;
        var uiState = UI.State;
        var resources = UI.Resources;

        var themeId = HashCode.Combine(intId, "theme");
        var finalTheme = theme ?? uiState.GetOrCreateElement<ButtonStylePack>(themeId);
        var input = context.InputState;

        // If no specific theme was provided, configure the default one for a LineEdit look.
        if (theme is null)
        {
            // This setup runs once per widget instance and is then cached.
            finalTheme.Roundness = 0f;
            finalTheme.BorderLength = 1f;

            // Normal state (inset look)
            finalTheme.Normal.FillColor = DefaultTheme.NormalBorder; // Very dark, same as window border
            finalTheme.Normal.BorderColor = Colors.Black;

            // Hover state (subtle brightening)
            finalTheme.Hover.FillColor = new Color4(35 / 255f, 35 / 255f, 35 / 255f, 1.0f);
            finalTheme.Hover.BorderColor = Colors.Black;

            // Focused state (bright border)
            finalTheme.Focused.FillColor = finalTheme.Normal.FillColor;
            finalTheme.Focused.BorderColor = DefaultTheme.FocusBorder;

            // Disabled state
            finalTheme.Disabled.FillColor = finalTheme.Normal.FillColor;
            finalTheme.Disabled.BorderColor = new Color4(48 / 255f, 48 / 255f, 48 / 255f, 1.0f);
        }

        Rect bounds = new(position.X, position.Y, size.X, size.Y);
        bool textChanged = false;

        // --- Focus Management & Caret Placement on Click ---
        bool isHovering = bounds.Contains(input.MousePosition.X, input.MousePosition.Y);
        if (input.WasLeftMousePressedThisFrame && isHovering && !disabled)
        {
            uiState.SetFocus(intId);
            uiState.SetPotentialCaptorForFrame(intId); // Claim the press

            // --- BEGIN: Caret positioning logic on click ---
            // We need to temporarily calculate drawing info here for hit-testing.
            // This is the only place we need to do this, as keyboard input moves the caret programmatically.
            finalTheme.UpdateCurrentStyle(isHovering, false, disabled, true); // We are now focused
            var styleForHitTest = finalTheme.Current;
            var textForHitTest = isPassword ? new string(passwordChar, text.Length) : text;
            var contentRectForHitTest = new Rect(
                bounds.X + textMargin.X,
                bounds.Y + textMargin.Y,
                Math.Max(0, bounds.Width - textMargin.X * 2),
                Math.Max(0, bounds.Height - textMargin.Y * 2)
            );

            var textLayout = GetTextLayout(textForHitTest, size, styleForHitTest, float.MaxValue);
            if (textLayout != null)
            {
                float relativeClickX = input.MousePosition.X - contentRectForHitTest.Left + state.ScrollPixelOffset;
                float relativeClickY = input.MousePosition.Y - contentRectForHitTest.Top;

                textLayout.HitTestPoint(relativeClickX, relativeClickY, out RawBool isTrailingHit, out RawBool isInside, out var hitTestMetrics);

                int newCaretPos = (int)hitTestMetrics.TextPosition;
                if (isTrailingHit)
                {
                    newCaretPos++;
                }

                state.CaretPosition = Math.Clamp(newCaretPos, 0, text.Length);

                // Reset blink and update scroll to show caret.
                state.IsBlinkOn = true;
                state.BlinkTimer = 0;
                UpdateView(text, state, size, textMargin);
            }
            // --- END: Caret positioning logic on click ---
        }

        // --- Input Processing ---
        if (uiState.FocusedElementId == intId && !disabled)
        {
            textChanged = ProcessInput(ref text, state, size, maxLength, textMargin, input);
        }

        // --- Drawing ---
        finalTheme.UpdateCurrentStyle(isHovering, false, disabled, uiState.FocusedElementId == intId);
        resources.DrawBoxStyleHelper(context.RenderTarget, position, size, finalTheme.Current);

        // Define content area and clip to it
        Rect contentRect = new Rect(
            bounds.X + textMargin.X,
            bounds.Y + textMargin.Y,
            Math.Max(0, bounds.Width - textMargin.X * 2),
            Math.Max(0, bounds.Height - textMargin.Y * 2)
        );
        context.RenderTarget.PushAxisAlignedClip(contentRect, D2D.AntialiasMode.PerPrimitive);

        string textToDraw;
        ButtonStyle styleToDraw;
        var drawPos = contentRect.TopLeft;

        if (string.IsNullOrEmpty(text) && !(uiState.FocusedElementId == intId))
        {
            textToDraw = placeholderText;
            styleToDraw = new ButtonStyle(finalTheme.Disabled)
            {
                FontColor = new Color4(100 / 255f, 100 / 255f, 100 / 255f, 1.0f) // Custom placeholder color
            };
        }
        else
        {
            textToDraw = isPassword ? new string(passwordChar, text.Length) : text;
            styleToDraw = finalTheme.Current;
        }

        DrawVisibleText(textToDraw, state, size, styleToDraw, drawPos);

        if (uiState.FocusedElementId == intId && state.IsBlinkOn)
        {
            // For caret color, we should use the normal text color, not placeholder color
            DrawCaret(textToDraw, state, size, finalTheme.Current, contentRect);
        }

        context.RenderTarget.PopAxisAlignedClip();

        return textChanged;
    }

    private bool ProcessInput(ref string text, LineEditState state, Vector2 size, int maxLength, Vector2 textMargin, InputState input)
    {
        bool textChanged = false;

        state.BlinkTimer += UI.Context.DeltaTime;
        if (state.BlinkTimer > 0.5f)
        {
            state.BlinkTimer = 0;
            state.IsBlinkOn = !state.IsBlinkOn;
        }

        bool isCtrlHeld = input.HeldKeys.Contains(Keys.Control);

        if (input.TypedCharacters.Any())
        {
            PushUndoState(text, state);
            foreach (char c in input.TypedCharacters)
            {
                if (text.Length < maxLength)
                {
                    text = text.Insert(state.CaretPosition, c.ToString());
                    state.CaretPosition++;
                    textChanged = true;
                }
            }
        }

        foreach (var key in input.PressedKeys)
        {
            bool hasChanged = true;
            PushUndoState(text, state); // Push on first key press
            switch (key)
            {
                case Keys.Backspace:
                    if (state.CaretPosition > 0)
                    {
                        int removeCount = 1;
                        if (isCtrlHeld) removeCount = state.CaretPosition - FindPreviousWordStart(text, state.CaretPosition);
                        text = text.Remove(state.CaretPosition - removeCount, removeCount);
                        state.CaretPosition -= removeCount;
                    }
                    break;
                case Keys.Delete:
                    if (state.CaretPosition < text.Length)
                    {
                        int removeCount = 1;
                        if (isCtrlHeld) removeCount = FindNextWordEnd(text, state.CaretPosition) - state.CaretPosition;
                        text = text.Remove(state.CaretPosition, removeCount);
                    }
                    break;
                case Keys.LeftArrow:
                    state.CaretPosition = isCtrlHeld ? FindPreviousWordStart(text, state.CaretPosition) : state.CaretPosition - 1;
                    break;
                case Keys.RightArrow:
                    state.CaretPosition = isCtrlHeld ? FindNextWordEnd(text, state.CaretPosition) : state.CaretPosition + 1;
                    break;
                case Keys.Home: state.CaretPosition = 0; break;
                case Keys.End: state.CaretPosition = text.Length; break;
                case Keys.Z when isCtrlHeld: Undo(ref text, state); break;
                case Keys.Y when isCtrlHeld: Redo(ref text, state); break;
                default: hasChanged = false; break;
            }
            if (hasChanged) textChanged = true;
        }

        state.CaretPosition = Math.Clamp(state.CaretPosition, 0, text.Length);

        if (textChanged || input.PressedKeys.Any(k => k is Keys.LeftArrow or Keys.RightArrow or Keys.Home or Keys.End))
        {
            UpdateView(text, state, size, textMargin);
            state.IsBlinkOn = true;
            state.BlinkTimer = 0;
        }

        return textChanged;
    }

    private int FindPreviousWordStart(string text, int currentPos)
    {
        if (currentPos == 0) return 0;
        int pos = currentPos - 1;
        while (pos > 0 && char.IsWhiteSpace(text[pos])) pos--;
        while (pos > 0 && !char.IsWhiteSpace(text[pos - 1])) pos--;
        return pos;
    }

    private int FindNextWordEnd(string text, int currentPos)
    {
        if (currentPos >= text.Length) return text.Length;
        int pos = currentPos;
        while (pos < text.Length && !char.IsWhiteSpace(text[pos])) pos++;
        while (pos < text.Length && char.IsWhiteSpace(text[pos])) pos++;
        return pos;
    }

    private void DrawVisibleText(string fullText, LineEditState state, Vector2 size, ButtonStyle style, Vector2 contentTopLeft)
    {
        if (string.IsNullOrEmpty(fullText)) return;

        var context = UI.Context;
        var rt = context.RenderTarget;
        var textBrush = UI.Resources.GetOrCreateBrush(rt, style.FontColor);
        var textLayout = GetTextLayout(fullText, size, style, float.MaxValue);

        if (textBrush == null || textLayout == null) return;

        var originalTransform = rt.Transform;

        // A small vertical adjustment to compensate for font metrics making text appear slightly too low when using ParagraphAlignment.Center.
        const float yOffsetCorrection = -1.5f;
        var translation = Matrix3x2.CreateTranslation(contentTopLeft.X - state.ScrollPixelOffset, contentTopLeft.Y + yOffsetCorrection);
        rt.Transform = translation * originalTransform;

        rt.DrawTextLayout(Vector2.Zero, textLayout, textBrush, DrawTextOptions.None);

        rt.Transform = originalTransform;
    }

    private void DrawCaret(string text, LineEditState state, Vector2 size, ButtonStyle style, Rect contentRect)
    {
        var textLayout = GetTextLayout(text, size, style, float.MaxValue);
        if (textLayout == null) return;

        textLayout.HitTestTextPosition((uint)state.CaretPosition, false, out _, out _, out var hitTestMetrics);
        float caretX = contentRect.Left + hitTestMetrics.Left - state.ScrollPixelOffset;
        Rect caretRect = new Rect(caretX, contentRect.Top, 1, contentRect.Height);

        var context = UI.Context;
        var caretBrush = UI.Resources.GetOrCreateBrush(context.RenderTarget, style.FontColor);
        if (caretBrush != null)
        {
            context.RenderTarget.FillRectangle(caretRect, caretBrush);
        }
    }

    private IDWriteTextLayout? GetTextLayout(string text, Vector2 size, ButtonStyle style, float maxWidth)
    {
        var dwrite = UI.Context.DWriteFactory;

        // Check if cached layout is still valid
        if (_cachedTextLayout != null && _cachedText == text && _cachedStyle == style && _cachedMaxWidth == maxWidth)
        {
            return _cachedTextLayout;
        }

        // If not, create a new one
        var textFormat = UI.Resources.GetOrCreateTextFormat(dwrite, style);
        if (textFormat == null) return null;

        textFormat.WordWrapping = WordWrapping.NoWrap;
        textFormat.TextAlignment = Vortice.DirectWrite.TextAlignment.Leading;
        textFormat.ParagraphAlignment = ParagraphAlignment.Center;

        _cachedTextLayout?.Dispose();
        _cachedTextLayout = dwrite.CreateTextLayout(text, textFormat, maxWidth, size.Y);

        // Update cache state
        _cachedText = text;
        _cachedStyle = style;
        _cachedMaxWidth = maxWidth;

        return _cachedTextLayout;
    }

    private void UpdateView(string text, LineEditState state, Vector2 size, Vector2 textMargin)
    {
        float availableWidth = size.X - textMargin.X * 2;
        var style = new ButtonStyle(); // A default style is fine for measuring

        var textLayout = GetTextLayout(text, size, style, float.MaxValue);
        if (textLayout == null) return;

        textLayout.HitTestTextPosition((uint)state.CaretPosition, false, out _, out _, out var hitTestMetrics);
        float caretAbsoluteX = hitTestMetrics.Left;

        if (caretAbsoluteX - state.ScrollPixelOffset > availableWidth)
        {
            state.ScrollPixelOffset = caretAbsoluteX - availableWidth;
        }
        else if (caretAbsoluteX - state.ScrollPixelOffset < 0)
        {
            state.ScrollPixelOffset = caretAbsoluteX;
        }

        float maxScroll = Math.Max(0, textLayout.Metrics.WidthIncludingTrailingWhitespace - availableWidth);
        state.ScrollPixelOffset = Math.Clamp(state.ScrollPixelOffset, 0, maxScroll);
    }

    private void PushUndoState(string text, LineEditState state)
    {
        var lastState = state.UndoStack.Count > 0 ? state.UndoStack.Peek() : default;
        if (state.UndoStack.Count > 0 && lastState.Text == text && lastState.CaretPosition == state.CaretPosition) return;

        if (state.UndoStack.Count >= LineEditState.HistoryLimit) state.UndoStack.Pop();
        state.UndoStack.Push(new LineEditUndoRecord(text, state.CaretPosition, state.ScrollPixelOffset));
        state.RedoStack.Clear();
    }

    private void Undo(ref string text, LineEditState state)
    {
        if (state.UndoStack.Count == 0) return;
        state.RedoStack.Push(new LineEditUndoRecord(text, state.CaretPosition, state.ScrollPixelOffset));
        var lastState = state.UndoStack.Pop();
        text = lastState.Text;
        state.CaretPosition = lastState.CaretPosition;
        state.ScrollPixelOffset = lastState.ScrollPixelOffset;
    }

    private void Redo(ref string text, LineEditState state)
    {
        if (state.RedoStack.Count == 0) return;
        state.UndoStack.Push(new LineEditUndoRecord(text, state.CaretPosition, state.ScrollPixelOffset));
        var nextState = state.RedoStack.Pop();
        text = nextState.Text;
        state.CaretPosition = nextState.CaretPosition;
        state.ScrollPixelOffset = nextState.ScrollPixelOffset;
    }
}
</file>

<file path="Widgets\LineEditState.cs">
using System.Collections.Generic;

namespace DirectUI;

internal record struct LineEditUndoRecord(string Text, int CaretPosition, float ScrollPixelOffset);

internal class LineEditState
{
    internal int CaretPosition;
    internal float ScrollPixelOffset;

    internal float BlinkTimer;
    internal bool IsBlinkOn = true;

    internal readonly Stack<LineEditUndoRecord> UndoStack = new();
    internal readonly Stack<LineEditUndoRecord> RedoStack = new();
    internal const int HistoryLimit = 50;
}
</file>

<file path="Widgets\SliderDirection.cs">
namespace DirectUI;

public enum HSliderDirection { LeftToRight, RightToLeft }
public enum VSliderDirection { TopToBottom, BottomToTop }
</file>

<file path="Widgets\TabBarState.cs">
namespace DirectUI;

internal class TabBarState
{
    internal float CachedUniformWidth = -1f;
}
</file>

<file path="Widgets\TreeNode.cs">
using System.Collections.Generic;

namespace DirectUI;

/// <summary>
/// Represents a node in a generic tree structure.
/// </summary>
/// <typeparam name="T">The type of the user data associated with the node.</typeparam>
public class TreeNode<T>
{
    public string Text { get; set; }
    public T UserData { get; set; }
    public bool IsExpanded { get; set; }
    public List<TreeNode<T>> Children { get; } = new();

    public TreeNode(string text, T userData, bool expanded = false)
    {
        Text = text;
        UserData = userData;
        IsExpanded = expanded;
    }

    /// <summary>
    /// Adds a new child node to this node.
    /// </summary>
    /// <param name="text">The display text of the child node.</param>
    /// <param name="userData">The user data associated with the child node.</param>
    /// <param name="expanded">Whether the child node is expanded by default.</param>
    /// <returns>The newly created child node.</returns>
    public TreeNode<T> AddChild(string text, T userData, bool expanded = false)
    {
        var child = new TreeNode<T>(text, userData, expanded);
        Children.Add(child);
        return child;
    }
}
</file>

<file path="InputBinding.cs">
namespace Cocoshell.Input;

public enum BindingType
{
    Keyboard,
    MouseButton
}

public class InputBinding
{
    // Property names match the YAML file keys (PascalCase)
    public BindingType Type { get; set; }
    public string KeyOrButton { get; set; } = string.Empty;
}
</file>

<file path="InputManager.cs">
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Cocoshell.Input;

public static class InputMapManager
{
    public static Dictionary<string, List<InputBinding>> Load(string filePath)
    {
        if (!File.Exists(filePath))
        {
            Console.WriteLine($"Warning: Input map file not found at '{filePath}'. Returning empty map.");
            return [];
        }

        try
        {
            var deserializer = new DeserializerBuilder()
                .WithNamingConvention(PascalCaseNamingConvention.Instance)
                .Build();

            string text = File.ReadAllText(filePath);
            var loadedMap = deserializer.Deserialize<Dictionary<string, List<InputBinding>>>(text);
            
            return loadedMap ?? [];
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error parsing input map file '{filePath}': {ex.Message}. Returning empty map.");
            return [];
        }
    }

    public static void Save(string filePath, Dictionary<string, List<InputBinding>> map)
    {
        try
        {
            var serializer = new SerializerBuilder()
                .WithNamingConvention(PascalCaseNamingConvention.Instance)
                .DisableAliases()
                .Build();
            
            string yaml = serializer.Serialize(map);
            
            File.WriteAllText(filePath, yaml);
            Console.WriteLine($"Successfully saved input map to '{filePath}'.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving input map file '{filePath}': {ex.Message}");
        }
    }
}
</file>

<file path="InputMapEditor.cs">
using System.Numerics;
using Cocoshell.Input;
using Vortice.Mathematics;

namespace DirectUI;

public class InputMapEditor
{
    private Dictionary<string, List<InputBinding>> _inputMap;
    private readonly string _inputMapPath;
    private bool _inputMapDirty = false;
    private int _newActionCounter = 1;
    private (string ActionName, int BindingIndex)? _listeningForBinding;
    private bool _ignoreInputForOneFrame;
    private readonly List<string> _actionNamesCache = new();
    private static readonly string[] s_bindingTypeNames = Enum.GetNames(typeof(BindingType));

    public InputMapEditor(string inputMapPath)
    {
        _inputMapPath = inputMapPath;
        _inputMap = LoadMap();
        UpdateActionNamesCache();
    }

    public bool IsDirty()
    {
        return _inputMapDirty;
    }

    public void RevertChanges()
    {
        _inputMap = LoadMap();
        UpdateActionNamesCache();
        _inputMapDirty = false;
    }

    public void SaveChanges()
    {
        InputMapManager.Save(_inputMapPath, _inputMap);
        _inputMapDirty = false;
    }

    public void Draw(UIContext context, Rect contentArea)
    {
        // --- Input Listening Logic ---
        HandleInputListening(context);

        var paddedContentRect = new Rect(
            contentArea.X + 10, contentArea.Y + 10,
            Math.Max(0, contentArea.Width - 20),
            Math.Max(0, contentArea.Height - 20)
        );

        string? actionToRemove = null;
        var scrollableSize = new Vector2(paddedContentRect.Width, paddedContentRect.Height - 40);

        // Outer VBox to hold the scroll region and the buttons below it
        UI.BeginVBoxContainer("input_map_vbox", paddedContentRect.TopLeft, 10);
        {
            // --- Scrollable list of actions and bindings ---
            UI.BeginScrollableRegion("input_map_scroll", scrollableSize);
            UI.BeginVBoxContainer("input_map_scroll_content", UI.Context.Layout.GetCurrentPosition(), 8);
            {
                for (int i = 0; i < _actionNamesCache.Count; i++)
                {
                    string actionName = _actionNamesCache[i];
                    if (!_inputMap.TryGetValue(actionName, out var bindings)) continue;

                    string? removedAction = DrawInputMapAction(actionName, bindings);
                    if (removedAction != null)
                    {
                        actionToRemove = removedAction;
                    }
                }
            }
            UI.EndVBoxContainer();
            UI.EndScrollableRegion();

            if (actionToRemove != null)
            {
                _inputMap.Remove(actionToRemove);
                UpdateActionNamesCache();
                _inputMapDirty = true;
            }

            // --- Action Buttons (Add, Apply, Revert) ---
            DrawActionButtons();
        }
        UI.EndVBoxContainer();
    }

    private void HandleInputListening(UIContext context)
    {
        if (_ignoreInputForOneFrame)
        {
            _ignoreInputForOneFrame = false;
            return;
        }

        if (!_listeningForBinding.HasValue) return;

        var (actionName, bindingIndex) = _listeningForBinding.Value;
        var input = context.InputState;

        // Ensure the binding still exists before trying to modify it
        if (!_inputMap.TryGetValue(actionName, out var bindings) || bindingIndex >= bindings.Count)
        {
            _listeningForBinding = null;
            return;
        }

        InputBinding targetBinding = bindings[bindingIndex];
        bool inputWasBound = false;

        // Check for Keyboard Input
        if (input.PressedKeys.Count > 0)
        {
            targetBinding.Type = BindingType.Keyboard;
            targetBinding.KeyOrButton = input.PressedKeys[0].ToString();
            inputWasBound = true;
        }
        // Check for Mouse Input
        else if (input.PressedMouseButtons.Count > 0)
        {
            targetBinding.Type = BindingType.MouseButton;
            targetBinding.KeyOrButton = input.PressedMouseButtons[0].ToString();
            inputWasBound = true;
        }
        // Check if user clicked somewhere else to cancel
        else if (input.WasLeftMousePressedThisFrame || input.WasRightMousePressedThisFrame)
        {
            // This click didn't start a new binding listen, so it must be a cancel click.
            _listeningForBinding = null;
        }

        if (inputWasBound)
        {
            _inputMapDirty = true;
            _listeningForBinding = null; // Stop listening
        }
    }


    private string? DrawInputMapAction(string actionName, List<InputBinding> bindings)
    {
        string? actionToRemove = null;
        int bindingToRemove = -1;

        // --- Action Header (Name + Remove Button) ---
        UI.BeginHBoxContainer($"action_hbox_{actionName}", UI.Context.Layout.GetCurrentPosition(), 5);
        {
            UI.PushStyleColor(StyleColor.Button, Colors.Transparent);
            UI.PushStyleColor(StyleColor.TextDisabled, DefaultTheme.Text);
            UI.Button($"action_label_{actionName}", actionName, disabled: true, autoWidth: true);
            UI.PopStyleColor(2);

            UI.PushStyleVar(StyleVar.FrameRounding, 0.5f);
            UI.PushStyleColor(StyleColor.Button, new Color4(0.5f, 0.2f, 0.2f, 1f));
            if (UI.Button($"action_remove_{actionName}", "x", size: new Vector2(20, 20))) actionToRemove = actionName;
            UI.PopStyleColor();
            UI.PopStyleVar();
        }
        UI.EndHBoxContainer();

        // --- Indented VBox for bindings ---
        UI.BeginHBoxContainer($"bindings_outer_hbox_{actionName}", UI.Context.Layout.GetCurrentPosition(), 0);
        {
            UI.Button($"indent_spacer_{actionName}", "", size: new Vector2(20, 0), disabled: true); // Indent
            UI.BeginVBoxContainer($"bindings_vbox_{actionName}", UI.Context.Layout.GetCurrentPosition(), 5);
            {
                for (int j = 0; j < bindings.Count; j++)
                {
                    var binding = bindings[j];
                    UI.BeginHBoxContainer($"binding_hbox_{actionName}_{j}", UI.Context.Layout.GetCurrentPosition(), 5);
                    {
                        // Binding Type Combobox
                        int selectedIndex = (int)binding.Type;
                        if (UI.Combobox($"binding_type_{actionName}_{j}", ref selectedIndex, s_bindingTypeNames, new Vector2(100, 24)))
                        {
                            binding.Type = (BindingType)selectedIndex;
                            _inputMapDirty = true;
                        }

                        // Button to display binding and enter listening mode
                        string buttonText = binding.KeyOrButton;
                        bool isThisOneListening = _listeningForBinding.HasValue &&
                                                  _listeningForBinding.Value.ActionName == actionName &&
                                                  _listeningForBinding.Value.BindingIndex == j;

                        if (isThisOneListening)
                        {
                            buttonText = "Press a key...";
                        }

                        if (UI.Button($"binding_key_{actionName}_{j}", buttonText, new Vector2(150, 24)))
                        {
                            if (!isThisOneListening)
                            {
                                // Start listening for this binding
                                _listeningForBinding = (actionName, j);
                                _ignoreInputForOneFrame = true;
                            }
                            else
                            {
                                // If already listening, clicking again cancels
                                _listeningForBinding = null;
                            }
                        }

                        // Remove Binding Button
                        UI.PushStyleVar(StyleVar.FrameRounding, 0.5f);
                        UI.PushStyleColor(StyleColor.Button, new(0.5f, 0.2f, 0.2f, 1f));
                        
                        if (UI.Button($"binding_remove_{actionName}_{j}", "x", size: new(24, 24)))
                        {
                            bindingToRemove = j;
                        }

                        UI.PopStyleColor();
                        UI.PopStyleVar();
                    }
                    UI.EndHBoxContainer();
                }

                if (bindingToRemove != -1)
                {
                    bindings.RemoveAt(bindingToRemove);
                    _inputMapDirty = true;
                }

                // "Add Binding" button for this action
                if (UI.Button($"add_binding_{actionName}", "Add Binding", size: new(100, 24)))
                {
                    bindings.Add(new() 
                    { 
                        Type = BindingType.Keyboard,
                        KeyOrButton = "None"
                    });

                    _inputMapDirty = true;
                }
            }
            UI.EndVBoxContainer();
        }
        UI.EndHBoxContainer();

        return actionToRemove;
    }

    private void DrawActionButtons()
    {
        UI.BeginHBoxContainer("input_map_actions", UI.Context.Layout.GetCurrentPosition(), 10);
        {
            UI.PushStyleVar(StyleVar.FrameRounding, 0.2f);
            UI.PushStyleColor(StyleColor.Button, DefaultTheme.NormalFill);
            UI.PushStyleColor(StyleColor.ButtonDisabled, DefaultTheme.DisabledFill);
            UI.PushStyleColor(StyleColor.TextDisabled, DefaultTheme.DisabledText);

            if (UI.Button("add_new_action", "Add New Action", autoWidth: true, textMargin: new Vector2(10, 5)))
            {
                string newActionName;

                do
                {
                    newActionName = $"NewAction_{_newActionCounter++}";
                }
                while (_inputMap.ContainsKey(newActionName));

                _inputMap[newActionName] = [];
                UpdateActionNamesCache();
                _inputMapDirty = true;
            }

            if (UI.Button("apply_changes", "Apply Changes", disabled: !_inputMapDirty, autoWidth: true, textMargin: new(10, 5)))
            {
                SaveChanges();
            }

            if (UI.Button("revert_changes", "Revert", autoWidth: true, textMargin: new(10, 5)))
            {
                RevertChanges();
            }

            UI.PopStyleColor(3);
            UI.PopStyleVar();
        }
        UI.EndHBoxContainer();
    }

    private Dictionary<string, List<InputBinding>> LoadMap()
    {
        try
        {
            return InputMapManager.Load(_inputMapPath);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load input map: {ex.Message}");
            return [];
        }
    }

    private void UpdateActionNamesCache()
    {
        _actionNamesCache.Clear();

        if (_inputMap is null)
        {
            return;
        }

        _actionNamesCache.AddRange(_inputMap.Keys);
    }
}
</file>

<file path="MyDirectUIApp.cs">
// MyDirectUIApp.cs
using System;
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

/// <summary>
/// The main application window class. This class is responsible for creating and
/// managing the window, hosting the rendering engine (AppHost), and orchestrating
/// the different views and modal dialogs.
/// </summary>
public class MyDirectUIApp : Direct2DAppWindow
{
    // View models for different parts of the UI
    private readonly MainView _mainView;
    private readonly InputMapEditor _inputMapEditor;

    // State for managing the modal "Project Settings" window
    private ModalWindow? _projectWindow;
    private bool _isProjectWindowOpen = false;
    private int _projectWindowActiveTab = 0;
    private static readonly string[] ProjectWindowTabLabels = { "General", "Input Map" };

    public MyDirectUIApp(string title, int width, int height) : base(title, width, height)
    {
        _mainView = new MainView();

        // This path would typically come from a config file or service locator
        string inputMapPath = @"D:\Parsa Stuff\Visual Studio\Cosmocrush\Cherris\Res\Cherris\InputMap.yaml";
        _inputMapEditor = new InputMapEditor(inputMapPath);
    }

    protected override AppHost CreateAppHost()
    {
        var backgroundColor = new Color4(21 / 255f, 21 / 255f, 21 / 255f, 1.0f); // #151515
        return new AppHost(DrawUI, backgroundColor);
    }

    protected override void OnKeyDown(Keys key)
    {
        if (key == Keys.F3)
        {
            if (_appHost != null)
            {
                _appHost.ShowFpsCounter = !_appHost.ShowFpsCounter;
            }
        }
        base.OnKeyDown(key); // Important: ensures input is registered and default keys (ESC) work
    }

    /// <summary>
    /// The primary drawing callback for the main application window. It delegates
    /// drawing to the main view after handling any window state management.
    /// </summary>
    private void DrawUI(UIContext context)
    {
        ManageModalWindowState();
        _mainView.Draw(context, OpenProjectWindow);
    }

    /// <summary>
    /// The drawing callback passed to the modal window.
    /// </summary>
    private void DrawProjectWindowUI(UIContext context)
    {
        var rt = context.RenderTarget;
        float windowWidth = rt.Size.Width;
        float windowHeight = rt.Size.Height;
        float tabBarHeight = 30f;
        var contentArea = new Rect(0, tabBarHeight, windowWidth, windowHeight - tabBarHeight);

        // --- Draw Tab Bar ---
        UI.TabBar("project_tabs", ProjectWindowTabLabels, ref _projectWindowActiveTab);

        // --- Draw Content Panel Background ---
        var panelStyle = new BoxStyle
        {
            FillColor = new(37 / 255f, 37 / 255f, 38 / 255f, 1.0f),
            BorderColor = DefaultTheme.HoverBorder,
            BorderLengthTop = 1f,
            Roundness = 0f
        };
        // BUG FIX: Convert Vortice.Mathematics.Size to System.Numerics.Vector2
        UI.Resources.DrawBoxStyleHelper(rt, contentArea.TopLeft, new Vector2(contentArea.Width, contentArea.Height), panelStyle);

        // --- Draw Active Tab Content ---
        if (_projectWindowActiveTab == 0)
        {
            DrawGeneralSettingsTab(context, contentArea);
        }
        else if (_projectWindowActiveTab == 1)
        {
            _inputMapEditor.Draw(context, contentArea);
        }
    }

    private void DrawGeneralSettingsTab(UIContext context, Rect contentArea)
    {
        var contentPos = contentArea.TopLeft + new Vector2(10, 10);
        UI.BeginVBoxContainer("tab_general_vbox", contentPos, 10);
        if (UI.Button("modal_button_1", "A button in a modal")) { /* ... */ }
        if (UI.Button("modal_button_close", "Close Me"))
        {
            _isProjectWindowOpen = false; // Signal the window to close
        }
        UI.EndVBoxContainer();
    }

    private void OpenProjectWindow()
    {
        if (_isProjectWindowOpen) return;

        _projectWindow = new ModalWindow(this, "Project Settings", 600, 400, DrawProjectWindowUI);
        if (_projectWindow.CreateAsModal())
        {
            _isProjectWindowOpen = true;
        }
        else
        {
            Console.WriteLine("Failed to create modal window.");
            _projectWindow.Dispose();
            _projectWindow = null;
        }
    }

    private void ManageModalWindowState()
    {
        if (_projectWindow == null) return;

        // If the OS window handle is gone (e.g., user clicked the 'X' button),
        // we must clean up our reference to it.
        if (_projectWindow.Handle == IntPtr.Zero)
        {
            _projectWindow.Dispose();
            _projectWindow = null;
            _isProjectWindowOpen = false;

            // Revert any unsaved changes in the editor since the window was closed abruptly.
            if (_inputMapEditor.IsDirty())
            {
                _inputMapEditor.RevertChanges();
            }
        }
        // If our application logic has requested the window to close (e.g., via a button click),
        // then we tell the window to close itself.
        else if (!_isProjectWindowOpen)
        {
            _projectWindow.Close();
        }
    }
}
</file>

<file path="Program.cs">
using DirectUI;
using System;

namespace Cocoshell;

public class Program
{
    [STAThread] // Important for COM (Direct2D) and Win32 APIs
    static void Main(string[] args)
    {
        Console.WriteLine("Starting Refactored Direct2D Application...");

        // Use 'using' to ensure Dispose is called automatically
        using (var appWindow = new MyDirectUIApp("My Refactored D2D App", 1024, 768))
        {
            try
            {
                // Create the main window, which registers itself with the Application manager.
                // The static constructor in Application will ensure resources are ready.
                if (appWindow.Create())
                {
                    // Run the central message loop that processes all windows.
                    // This will also handle cleanup when the loop exits.
                    Application.Run();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Unhandled exception in Run: {ex}");
                // Log exception, show message box, etc.
            }
        } // appWindow.Dispose() is called here, which triggers its window closure

        Console.WriteLine("Application finished.");
        // Console.ReadKey(); // Optional: Keep console open after exit
    }
}
</file>

<file path="SceneNode.cs">
namespace DirectUI;

public class SceneNode
{
    public string Name { get; set; } = "Unnamed";
    public string UserData { get; set; } = "";
    public bool IsExpanded { get; set; } = false;
    public List<SceneNode>? Children { get; set; }
}
</file>

<file path="SceneParser.cs">
using YamlDotNet.Serialization;

namespace DirectUI;

public static class SceneParser
{
    public static TreeNode<string> Parse(string filePath)
    {
        var deserializer = new DeserializerBuilder().Build();
        var yamlData = deserializer.Deserialize<Dictionary<object, object>>(File.ReadAllText(filePath));

        return ConvertToTreeNode(ConvertDictionary(yamlData));
    }

    private static Dictionary<string, object> ConvertDictionary(Dictionary<object, object> dict)
    {
        Dictionary<string, object> newDict = [];

        foreach (KeyValuePair<object, object> kvp in dict)
        {
            if (kvp.Key is not string key)
            {
                continue;
            }

            newDict[key] = kvp.Value;
        }

        return newDict;
    }

    private static TreeNode<string> ConvertToTreeNode(Dictionary<string, object> nodeData)
    {
        if (!nodeData.TryGetValue("Node", out var nodeDescriptorObj) && !nodeData.TryGetValue("node", out nodeDescriptorObj))
        {
            throw new InvalidDataException("YAML node data is missing the 'Node' or 'node' key.");
        }

        string nodeDescriptor = nodeDescriptorObj.ToString();
        string[] parts = nodeDescriptor.Split(["::"], StringSplitOptions.None);
        string nodeName = parts.Length > 1 ? parts[1] : parts[0];
        string nodeType = parts[0];

        string userData = $"Type: {nodeType}";

        TreeNode<string> treeNode = new(nodeName, userData, false);

        if (!nodeData.TryGetValue("children", out var childrenObj) || childrenObj is not List<object> childrenList)
        {
            return treeNode;
        }

        if (childrenList.Count > 0)
        {
            treeNode.IsExpanded = true;
        }

        foreach (object childObj in childrenList)
        {
            if (childObj is not Dictionary<object, object> childDict)
            {
                continue;
            }

            Dictionary<string, object> stringKeyDict = ConvertDictionary(childDict);
            TreeNode<string> childTreeNode = ConvertToTreeNode(stringKeyDict);
            treeNode.Children.Add(childTreeNode);
        }

        return treeNode;
    }
}
</file>

<file path="Views\BottomPanelView.cs">
namespace DirectUI;

public class BottomPanelView
{
    public static void Draw()
    {
        UI.PushStyleVar(StyleVar.FrameRounding, 0f);
        
        if (UI.Button("bottom_button", "Bottom Panel Button"))
        {

        }

        UI.PopStyleVar();
    }
}
</file>

<file path="Views\InspectorView.cs">
using System.Numerics;
using Vortice.DirectWrite;

namespace DirectUI;

public class InspectorView
{
    private const float PanelPadding = 10f;

    private ButtonStyle titleStyle = new()
    {
        FontWeight = FontWeight.SemiBold,
        FontSize = 16f
    };

    public void Draw(TreeNode<string>? selectedNode, float panelWidth)
    {
        float availableWidth = panelWidth - (PanelPadding * 2);

        UI.Label(
            "inspector_title",
            "Inspector",
            size: new(availableWidth, 0),
            style: titleStyle,
            textAlignment: new(HAlignment.Center, VAlignment.Center)
        );

        if (selectedNode is null)
        {
            UI.Button("no_selection_label", "No node selected.", disabled: true, autoWidth: true);
            return;
        }

        // A VBox to layout property rows vertically.
        UI.BeginVBoxContainer("inspector_properties_vbox", UI.Context.Layout.GetCurrentPosition(), 5f);
        {
            // --- Property Row for "Name" ---
            // Use a 2-column grid for the label and the value editor.
            float gridGap = 5f;
            // GridContainer creates uniform columns. We calculate the width for each cell.
            float cellWidth = (availableWidth - gridGap) / 2f;

            UI.BeginGridContainer(
                id: $"grid_name_{selectedNode.GetHashCode()}",
                position: UI.Context.Layout.GetCurrentPosition(),
                availableSize: new Vector2(availableWidth, 24), // Height for one row.
                numColumns: 2,
                gap: new Vector2(gridGap, 0)
            );
            {
                // Column 1: Label
                UI.Label(
                    "name_label",
                    "Name",
                    size: new(cellWidth, 24), // Explicitly size the label to fit the cell.
                    textAlignment: new(HAlignment.Left, VAlignment.Center)
                );

                // Column 2: LineEdit
                string nodeName = selectedNode.Text;
                // The LineEdit must also be sized to fit its cell.
                if (UI.LineEdit($"node_name_edit_{selectedNode.GetHashCode()}", ref nodeName, new(cellWidth, 24)))
                {
                    selectedNode.Text = nodeName;
                }
            }
            UI.EndGridContainer();

            // Future properties can be added here as more grid containers...
        }
        UI.EndVBoxContainer();
    }
}
</file>

<file path="Views\MainView.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public class MainView
{
    // --- Constants ---
    private const float MenuBarHeight = 30f;
    private const float PanelPadding = 10f;
    private const float PanelGap = 10f;

    // --- State for layout ---
    private float _leftPanelWidth = 250f;
    private float _rightPanelWidth = 300f;
    private float _bottomPanelHeight = 150f;

    // --- Child Views ---
    private readonly MenuBarView _menuBarView;
    private readonly SceneTreeView _sceneTreeView;
    private readonly InspectorView _inspectorView;
    private readonly BottomPanelView _bottomPanelView;

    public MainView()
    {
        _menuBarView = new MenuBarView();
        _sceneTreeView = new SceneTreeView();
        _inspectorView = new InspectorView();
        _bottomPanelView = new BottomPanelView();
    }

    public void Draw(UIContext context, Action openProjectWindowAction)
    {
        _menuBarView.Draw(context, openProjectWindowAction);
        DrawMainLayoutPanels();
    }

    private void DrawMainLayoutPanels()
    {
        DrawLeftPanel();
        DrawRightPanel();
        DrawBottomPanel();
    }

    private void DrawLeftPanel()
    {
        var panelStyle = new BoxStyle { BorderLength = 1, Roundness = 0f };
        var padding = new Vector2(PanelPadding, PanelPadding);

        UI.BeginResizableVPanel("left_panel", ref _leftPanelWidth, HAlignment.Left, MenuBarHeight,
            minWidth: 150, maxWidth: 400, padding: padding, gap: PanelGap, panelStyle: panelStyle);

        _sceneTreeView.Draw();

        UI.EndResizableVPanel();
    }

    private void DrawRightPanel()
    {
        var panelStyle = new BoxStyle { BorderLength = 1, Roundness = 0f };
        var padding = new Vector2(PanelPadding, PanelPadding);

        UI.BeginResizableVPanel("right_panel", ref _rightPanelWidth, HAlignment.Right, MenuBarHeight,
            minWidth: 150, maxWidth: 400, padding: padding, gap: PanelGap, panelStyle: panelStyle);

        _inspectorView.Draw(_sceneTreeView.SelectedNode, _rightPanelWidth);

        UI.EndResizableVPanel();
    }

    private void DrawBottomPanel()
    {
        var panelStyle = new BoxStyle { BorderLength = 1, Roundness = 0f };
        var padding = new Vector2(PanelPadding, PanelPadding);

        UI.BeginResizableHPanel("bottom_panel", ref _bottomPanelHeight, _leftPanelWidth, _rightPanelWidth, MenuBarHeight,
            minHeight: 50, maxHeight: 300, padding: padding, gap: PanelGap, panelStyle: panelStyle);

        BottomPanelView.Draw();

        UI.EndResizableHPanel();
    }
}
</file>

<file path="Views\MenuBarView.cs">
using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.Mathematics;

namespace DirectUI;

public class MenuBarView
{
    private const float MenuBarHeight = 30f;

    public void Draw(UIContext context, Action openProjectWindowAction)
    {
        var rt = context.RenderTarget;

        ID2D1SolidColorBrush menuBarBackgroundBrush = UI.Resources.GetOrCreateBrush(rt, new Color4(37 / 255f, 37 / 255f, 38 / 255f, 1f));
        ID2D1SolidColorBrush menuBarBorderBrush = UI.Resources.GetOrCreateBrush(rt, DefaultTheme.NormalBorder);
        rt.FillRectangle(new Rect(0, 0, rt.Size.Width, MenuBarHeight), menuBarBackgroundBrush);
        rt.DrawLine(new Vector2(0, MenuBarHeight - 1), new Vector2(rt.Size.Width, MenuBarHeight - 1), menuBarBorderBrush, 1f);

        // Define a shared style for all menu buttons
        UI.PushStyleVar(StyleVar.FrameRounding, 0.0f);
        UI.PushStyleVar(StyleVar.FrameBorderSize, 0.0f);
        UI.PushStyleColor(StyleColor.Button, Colors.Transparent);
        UI.PushStyleColor(StyleColor.ButtonHovered, new Color4(63 / 255f, 63 / 255f, 70 / 255f, 1f));
        UI.PushStyleColor(StyleColor.ButtonPressed, DefaultTheme.Accent);
        UI.PushStyleColor(StyleColor.Text, new Color4(204 / 255f, 204 / 255f, 204 / 255f, 1f));

        UI.BeginHBoxContainer("menu_bar", new Vector2(5, 0), 0);
        {
            if (MenuBarButton("file_button", "File"))
            {

            }

            if (MenuBarButton("project_button", "Project"))
            {
                openProjectWindowAction?.Invoke();
            }

            if (MenuBarButton("edit_button", "Edit"))
            {

            }

            if (MenuBarButton("view_button", "View"))
            {

            }

            if (MenuBarButton("help_button", "Help")) 
            {

            }
        }
        UI.EndHBoxContainer();

        UI.PopStyleColor(4);
        UI.PopStyleVar(2);
    }

    private static bool MenuBarButton(string id, string text)
    {
        return UI.Button(
            id,
            text,
            size: new(0, MenuBarHeight),
            autoWidth: true,
            textMargin: new(10, 0),
            textAlignment: new(HAlignment.Center, VAlignment.Center));
    }
}
</file>

<file path="Views\SceneTreeView.cs">
using System;
using System.IO;

namespace DirectUI;

public class SceneTreeView
{
    private readonly TreeNode<string> _fileRoot;
    private readonly TreeStyle _treeStyle = new();

    public TreeNode<string>? SelectedNode { get; private set; }

    public SceneTreeView()
    {
        try
        {
            // A hardcoded path for demonstration purposes.
            string scenePath = @"D:\Parsa Stuff\Visual Studio\Cosmocrush\Cosmocrush\Res\Scenes\Player.yaml";
            _fileRoot = File.Exists(scenePath)
                ? SceneParser.Parse(scenePath)
                : CreateDefaultTree("Scene file not found", scenePath);
        }
        catch (Exception ex)
        {
            _fileRoot = CreateDefaultTree($"Error parsing scene: {ex.Message}", "");
        }
        SelectedNode = null;
    }

    public void Draw()
    {
        UI.BeginVBoxContainer("tree_vbox", UI.Context.Layout.GetCurrentPosition(), 0);
        UI.Tree("file_tree", _fileRoot, out var clickedNode, _treeStyle);
        if (clickedNode is not null)
        {
            SelectedNode = clickedNode;
        }
        UI.EndVBoxContainer();
    }

    private static TreeNode<string> CreateDefaultTree(string reason, string path)
    {
        var root = new TreeNode<string>("Error", "Could not load scene", true);
        root.AddChild(reason, "");

        if (!string.IsNullOrEmpty(path))
        {
            root.AddChild($"Path: {path}", "");
        }

        return root;
    }
}
</file>

