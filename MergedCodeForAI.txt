<file path="Alignment.cs">
// Alignment.cs
namespace DirectUI;

public enum HAlignment { Left, Center, Right }
public enum VAlignment { Top, Center, Bottom }

public struct Alignment(HAlignment horizontal, VAlignment vertical)
{
    public HAlignment Horizontal { get; set; } = horizontal;
    public VAlignment Vertical { get; set; } = vertical;
}
</file>

<file path="Direct2DAppWindow.cs">
// MODIFIED: Direct2DAppWindow.cs
// Summary: Changed PresentOptions from None to Immediately in HwndRenderTargetProperties to attempt disabling VSync throttling.
using System;
using System.Numerics;
using System.Diagnostics;

using Vortice;
using Vortice.Mathematics;

using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.DXGI;
using SharpGen.Runtime;

using D2D = Vortice.Direct2D1;
using DW = Vortice.DirectWrite;

using D2DFactoryType = Vortice.Direct2D1.FactoryType;
using SizeI = Vortice.Mathematics.SizeI;
using Rect = Vortice.Mathematics.Rect;

using DirectUI;
using DirectUI.Diagnostics;
using Vortice.DCommon;

namespace DirectUI;

public abstract class Direct2DAppWindow : Win32Window
{
    protected ID2D1Factory1? d2dFactory;
    protected IDWriteFactory? dwriteFactory;
    protected ID2D1HwndRenderTarget? renderTarget;

    protected Color4 backgroundColor = new(0.1f, 0.1f, 0.15f, 1.0f);
    protected bool graphicsInitialized = false;

    protected Vector2 currentMousePos = new(-1, -1);
    protected bool isLeftMouseButtonDown = false;
    protected bool wasLeftMouseClickedThisFrame = false;

    // --- FPS Counter ---
    private readonly FpsCounter _fpsCounter;

    public Direct2DAppWindow(string title = "Vortice DirectUI Base Window", int width = 800, int height = 600)
        : base(title, width, height)
    {
        _fpsCounter = new FpsCounter();
    }

    protected override bool Initialize()
    {
        Console.WriteLine("Direct2DAppWindow initializing Vortice Graphics...");
        return InitializeGraphics();
    }

    protected override void Cleanup()
    {
        Console.WriteLine("Direct2DAppWindow cleaning up its resources...");
        CleanupGraphics();
    }

    protected override void OnPaint()
    {
        // Update FPS counter and invalidate if the text changed
        if (_fpsCounter.Update())
        {
            Invalidate();
        }

        if (!graphicsInitialized || renderTarget is null || dwriteFactory is null)
        {
            if (!graphicsInitialized && Handle != nint.Zero)
            {
                InitializeGraphics();
                if (!graphicsInitialized || renderTarget is null || dwriteFactory is null)
                {
                    wasLeftMouseClickedThisFrame = false;
                    return;
                }
            }
            else
            {
                wasLeftMouseClickedThisFrame = false;
                return;
            }
        }

        try
        {
            renderTarget.BeginDraw();
            renderTarget.Clear(backgroundColor);

            var inputState = new InputState(
                currentMousePos,
                wasLeftMouseClickedThisFrame,
                isLeftMouseButtonDown
            );

            var drawingContext = new DrawingContext(renderTarget, dwriteFactory);

            // --- Draw Main UI Content ---
            DrawUIContent(drawingContext, inputState);

            // --- Draw FPS Counter ---
            _fpsCounter.Draw(renderTarget);


            Result endDrawResult = renderTarget.EndDraw();

            if (endDrawResult.Failure)
            {
                Console.WriteLine($"EndDraw failed: {endDrawResult.Description}");
                if (endDrawResult.Code == D2D.ResultCode.RecreateTarget.Code)
                {
                    Console.WriteLine("Render target needs recreation (Detected in EndDraw).");
                    graphicsInitialized = false;
                    CleanupGraphics();
                }
            }
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Render target needs recreation (Caught SharpGenException in OnPaint): {ex.Message}");
            graphicsInitialized = false;
            CleanupGraphics();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Rendering Error: {ex}");
            graphicsInitialized = false;
            CleanupGraphics();
        }
        finally
        {
            wasLeftMouseClickedThisFrame = false;
        }
    }

    protected virtual void DrawUIContent(DrawingContext context, InputState input)
    {
        // Base implementation does nothing.
    }

    protected override void OnSize(int width, int height)
    {
        if (graphicsInitialized && renderTarget is not null)
        {
            Console.WriteLine($"Window resized to {width}x{height}. Resizing render target...");
            try
            {
                var newPixelSize = new SizeI(width, height);

                // Resize the render target first.
                renderTarget.Resize(newPixelSize);

                // Then notify components that rely on it.
                _fpsCounter.HandleResize(renderTarget);

                Console.WriteLine($"Successfully resized render target.");
            }
            catch (SharpGenException ex)
            {
                Console.WriteLine($"Failed to resize Render Target (SharpGenException): {ex.Message} HRESULT: {ex.ResultCode}");
                if (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
                {
                    Console.WriteLine("Render target needs recreation (Detected in Resize Exception).");
                    graphicsInitialized = false;
                    CleanupGraphics();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to resize Render Target (General Exception): {ex}");
                graphicsInitialized = false;
                CleanupGraphics();
            }
        }
        else if (!graphicsInitialized && Handle != nint.Zero)
        {
            InitializeGraphics();
        }
    }

    protected override void OnMouseMove(int x, int y) { currentMousePos = new Vector2(x, y); Invalidate(); }

    protected override void OnMouseDown(MouseButton button, int x, int y)
    {
        currentMousePos = new Vector2(x, y);
        if (button == MouseButton.Left)
        {
            isLeftMouseButtonDown = true;
            wasLeftMouseClickedThisFrame = true;
        }
        Invalidate();
    }

    protected override void OnMouseUp(MouseButton button, int x, int y)
    {
        currentMousePos = new Vector2(x, y);
        if (button == MouseButton.Left)
        {
            isLeftMouseButtonDown = false;
        }
        Invalidate();
    }

    protected override void OnKeyDown(int keyCode)
    {
        if (keyCode == NativeMethods.VK_ESCAPE)
        {
            Close();
        }
        Invalidate();
    }

    protected override bool OnClose() { return true; }

    protected virtual bool InitializeGraphics()
    {
        if (graphicsInitialized) return true;
        if (Handle == nint.Zero) return false;

        Console.WriteLine($"Attempting Graphics Initialization for HWND {Handle}...");

        try
        {
            CleanupGraphics();

            Result factoryResult = D2D1.D2D1CreateFactory(D2DFactoryType.SingleThreaded, out d2dFactory);
            factoryResult.CheckError();
            if (d2dFactory is null) throw new InvalidOperationException("D2D Factory creation failed silently.");

            Result dwriteResult = DWrite.DWriteCreateFactory(DW.FactoryType.Shared, out dwriteFactory);
            dwriteResult.CheckError();
            if (dwriteFactory is null) throw new InvalidOperationException("DWrite Factory creation failed silently.");

            var clientRectSize = GetClientRectSize();
            if (clientRectSize.Width <= 0 || clientRectSize.Height <= 0)
            {
                Console.WriteLine($"Invalid client rect size ({clientRectSize.Width}x{clientRectSize.Height}). Aborting graphics initialization.");
                CleanupGraphics();
                return false;
            }

            var dxgiPixelFormat = new PixelFormat(Format.B8G8R8A8_UNorm, Vortice.DCommon.AlphaMode.Premultiplied);
            var renderTargetProperties = new RenderTargetProperties(dxgiPixelFormat);
            var hwndRenderTargetProperties = new HwndRenderTargetProperties
            {
                Hwnd = Handle,
                PixelSize = new SizeI(clientRectSize.Width, clientRectSize.Height),
                // --- CHANGE HERE ---
                PresentOptions = PresentOptions.Immediately // Attempt to disable VSync throttling
                // --- END CHANGE ---
            };

            renderTarget = d2dFactory.CreateHwndRenderTarget(renderTargetProperties, hwndRenderTargetProperties);
            if (renderTarget is null) throw new InvalidOperationException("Render target creation returned null unexpectedly.");

            renderTarget.TextAntialiasMode = D2D.TextAntialiasMode.Cleartype;

            // --- Initialize FPS Counter ---
            _fpsCounter.Initialize(renderTarget, dwriteFactory);


            Console.WriteLine($"Vortice Graphics initialized successfully for HWND {Handle}.");
            graphicsInitialized = true;
            return true;
        }
        catch (SharpGenException ex)
        {
            Console.WriteLine($"Graphics Initialization failed (SharpGenException): {ex.Message} HRESULT: {ex.ResultCode}");
            CleanupGraphics(); graphicsInitialized = false; return false;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Graphics Initialization failed (General Exception): {ex}");
            CleanupGraphics(); graphicsInitialized = false; return false;
        }
    }

    protected virtual void CleanupGraphics()
    {
        bool resourcesExisted = d2dFactory is not null || renderTarget is not null || dwriteFactory is not null;
        if (resourcesExisted) Console.WriteLine("Cleaning up Vortice Graphics resources...");

        _fpsCounter.Cleanup();

        UI.CleanupResources();

        renderTarget?.Dispose(); renderTarget = null;
        dwriteFactory?.Dispose(); dwriteFactory = null;
        d2dFactory?.Dispose(); d2dFactory = null;
        graphicsInitialized = false;

        if (resourcesExisted) Console.WriteLine("Finished cleaning graphics resources.");
    }

    protected SizeI GetClientRectSize()
    {
        if (Handle != nint.Zero && NativeMethods.GetClientRect(Handle, out NativeMethods.RECT r))
        {
            int width = Math.Max(1, r.right - r.left);
            int height = Math.Max(1, r.bottom - r.top);
            return new SizeI(width, height);
        }
        int baseWidth = Math.Max(1, Width);
        int baseHeight = Math.Max(1, Height);
        if (Handle != nint.Zero)
        {
            Console.WriteLine($"GetClientRect failed. Falling back to stored size: {baseWidth}x{baseHeight}");
        }
        return new SizeI(baseWidth, baseHeight);
    }
}
</file>

<file path="DrawingContext.cs">
// DrawingContext.cs
using Vortice.Direct2D1;
using Vortice.DirectWrite;

namespace DirectUI;

// Holds rendering resources needed for UI drawing
public readonly struct DrawingContext
{
    public readonly ID2D1HwndRenderTarget RenderTarget;
    public readonly IDWriteFactory DWriteFactory;
    // Could potentially add D2DFactory later if needed

    public DrawingContext(ID2D1HwndRenderTarget renderTarget, IDWriteFactory dwriteFactory)
    {
        RenderTarget = renderTarget;
        DWriteFactory = dwriteFactory;
    }
}
</file>

<file path="InputState.cs">
// InputState.cs
using System.Numerics;

namespace DirectUI;

// Holds input state needed for UI processing in a single frame
public readonly struct InputState
{
    public readonly Vector2 MousePosition;
    public readonly bool WasLeftMousePressedThisFrame; // True if the left button went down this frame
    public readonly bool IsLeftMouseDown; // True if the left button is currently held down
    // Add fields for Right mouse button if ClickBehavior.Right/Both is used

    public InputState(Vector2 mousePosition, bool wasLeftMousePressedThisFrame, bool isLeftMouseDown)
    {
        MousePosition = mousePosition;
        WasLeftMousePressedThisFrame = wasLeftMousePressedThisFrame;
        IsLeftMouseDown = isLeftMouseDown;
    }
}
</file>

<file path="NativeMethods.cs">
using System;
using System.Runtime.InteropServices;

// No changes needed here if it was correct from the previous step.
// Ensure these constants are defined:
// WM_NCCREATE, WM_CREATE, WM_NCDESTROY, WM_PAINT, WM_DESTROY, WM_SIZE,
// WM_CLOSE, WM_KEYDOWN, WM_LBUTTONDOWN, WM_LBUTTONUP, WM_MOUSEMOVE, WM_QUIT
// GWLP_USERDATA, VK_ESCAPE, etc.
// And the structs: WNDCLASSEX, MSG, POINT, RECT, CREATESTRUCT
// And the functions: RegisterClassEx, CreateWindowEx, GetMessage, etc.
// And the delegates: WndProc

namespace DirectUI;

internal static class NativeMethods
{
    // --- Constants ---
    public const uint CS_HREDRAW = 0x0002;
    public const uint CS_VREDRAW = 0x0001;
    public const uint CS_OWNDC = 0x0020;

    public const uint WS_OVERLAPPEDWINDOW = 0xCF0000;
    public const uint WS_VISIBLE = 0x10000000;

    public const int WM_NCCREATE = 0x0081;
    public const int WM_CREATE = 0x0001;
    public const int WM_NCDESTROY = 0x0082;
    public const int WM_PAINT = 0x000F;
    public const int WM_DESTROY = 0x0002;
    public const int WM_SIZE = 0x0005;
    public const int WM_CLOSE = 0x0010;
    public const int WM_KEYDOWN = 0x0100;
    public const int WM_LBUTTONDOWN = 0x0201;
    public const int WM_LBUTTONUP = 0x0202; // Ensure this exists
    public const int WM_MOUSEMOVE = 0x0200; // Ensure this exists
    public const int WM_QUIT = 0x0012;

    public const int CW_USEDEFAULT = unchecked((int)0x80000000);
    public const int SW_SHOWNORMAL = 1;
    public const int VK_ESCAPE = 0x1B;
    public const int GWLP_USERDATA = -21;

    // --- Structures ---
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
    public struct WNDCLASSEX
    { /* ... as before ... */
        public int cbSize;
        public uint style;
        public WndProc lpfnWndProc; // Use delegate type directly
        public int cbClsExtra;
        public int cbWndExtra;
        public IntPtr hInstance;
        public IntPtr hIcon;
        public IntPtr hCursor;
        public IntPtr hbrBackground;
        public string lpszMenuName;
        public string lpszClassName;
        public IntPtr hIconSm;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct MSG
    { /* ... as before ... */
        public IntPtr hwnd;
        public uint message;
        public IntPtr wParam;
        public IntPtr lParam;
        public uint time;
        public POINT pt;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct POINT
    { /* ... as before ... */
        public int X;
        public int Y;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct RECT
    { /* ... as before ... */
        public int left;
        public int top;
        public int right;
        public int bottom;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct CREATESTRUCT
    { /* ... as before ... */
        public IntPtr lpCreateParams;
        public IntPtr hInstance;
        public IntPtr hMenu;
        public IntPtr hwndParent;
        public int cy; // Height
        public int cx; // Width
        public int y;  // Top
        public int x;  // Left
        public int style;
        [MarshalAs(UnmanagedType.LPWStr)] // Assuming Unicode
        public string lpszName;
        [MarshalAs(UnmanagedType.LPWStr)] // Assuming Unicode
        public string lpszClass;
        public int dwExStyle;
    }

    // --- Delegates ---
    public delegate IntPtr WndProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam);

    // --- Functions ---
    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern ushort RegisterClassEx([In] ref WNDCLASSEX lpwcx);
    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern IntPtr CreateWindowEx(uint dwExStyle, string lpClassName, string lpWindowName, uint dwStyle, int x, int y, int nWidth, int nHeight, IntPtr hWndParent, IntPtr hMenu, IntPtr hInstance, IntPtr lpParam);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool UpdateWindow(IntPtr hWnd);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool DestroyWindow(IntPtr hWnd);
    [DllImport("user32.dll")]
    public static extern IntPtr DefWindowProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam);
    [DllImport("user32.dll")]
    public static extern void PostQuitMessage(int nExitCode);
    [DllImport("user32.dll")]
    public static extern bool GetMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax);
    [DllImport("user32.dll")]
    public static extern bool TranslateMessage([In] ref MSG lpMsg);
    [DllImport("user32.dll")]
    public static extern IntPtr DispatchMessage([In] ref MSG lpmsg);
    [DllImport("user32.dll")]
    public static extern bool GetClientRect(IntPtr hWnd, out RECT lpRect);
    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern IntPtr GetModuleHandle(string lpModuleName);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool InvalidateRect(IntPtr hWnd, IntPtr lpRect, bool bErase);
    [DllImport("user32.dll")]
    public static extern IntPtr LoadCursor(IntPtr hInstance, int lpCursorName);
    [DllImport("user32.dll")]
    public static extern IntPtr LoadIcon(IntPtr hInstance, IntPtr lpIconName);
    [DllImport("user32.dll", EntryPoint = "SetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr SetWindowLongPtr64(IntPtr hWnd, int nIndex, IntPtr dwNewLong);
    [DllImport("user32.dll", EntryPoint = "SetWindowLongW", SetLastError = true)]
    private static extern IntPtr SetWindowLong32(IntPtr hWnd, int nIndex, IntPtr dwNewLong);
    [DllImport("user32.dll", EntryPoint = "GetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr GetWindowLongPtr64(IntPtr hWnd, int nIndex);
    [DllImport("user32.dll", EntryPoint = "GetWindowLongW", SetLastError = true)]
    private static extern IntPtr GetWindowLong32(IntPtr hWnd, int nIndex);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr SetCapture(IntPtr hWnd);
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool ReleaseCapture();


    public static IntPtr SetWindowLongPtr(IntPtr hWnd, int nIndex, IntPtr dwNewLong)
    {
        if (IntPtr.Size == 8) return SetWindowLongPtr64(hWnd, nIndex, dwNewLong);
        else return SetWindowLong32(hWnd, nIndex, dwNewLong);
    }
    public static IntPtr GetWindowLongPtr(IntPtr hWnd, int nIndex)
    {
        if (IntPtr.Size == 8) return GetWindowLongPtr64(hWnd, nIndex);
        else return GetWindowLong32(hWnd, nIndex);
    }

    // --- Helpers ---
    public static short LoWord(IntPtr val) => unchecked((short)(long)val);
    public static short HiWord(IntPtr val) => unchecked((short)((long)val >> 16));
}
</file>

<file path="Win32Window.cs">
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Collections.Generic;

namespace DirectUI;

public abstract class Win32Window : IDisposable
{
    // --- Ensure this class is identical to the previous version ---
    // Including:
    // Fields: _windowClassName, _windowTitle, _initialWidth, _initialHeight, _hwnd, _hInstance, _wndProcDelegate, _isDisposed, RegisteredClassNames, _gcHandle
    // Properties: Handle, Width, Height
    // Constructor: Win32Window(...)
    // Methods: Run(), TryCreateWindow(), WindowProcedure(static), HandleMessage(virtual), Close(), Invalidate()
    // Virtual Methods: Initialize(), OnPaint(), OnSize(), OnMouseDown(), OnMouseUp(), OnMouseMove(), OnKeyDown(), OnClose(), OnDestroy(), Cleanup()
    // IDisposable: Dispose(), Dispose(bool), Finalizer ~Win32Window()

    // --- Class Members (example subset) ---
    private readonly string _windowClassName;
    private readonly string _windowTitle;
    private readonly int _initialWidth;
    private readonly int _initialHeight;
    private IntPtr _hwnd = IntPtr.Zero;
    private IntPtr _hInstance = IntPtr.Zero;
    private NativeMethods.WndProc _wndProcDelegate;
    private bool _isDisposed = false;
    private static readonly HashSet<string> RegisteredClassNames = new HashSet<string>();
    private GCHandle _gcHandle;

    public IntPtr Handle => _hwnd;
    public int Width { get; protected set; } // Changed to protected set
    public int Height { get; protected set; } // Changed to protected set

    // --- Constructor ---
    protected Win32Window(string title, int width, int height, string className = null)
    {
        _windowTitle = title ?? "Win32 Window";
        _initialWidth = width > 0 ? width : 800;
        _initialHeight = height > 0 ? height : 600;
        Width = _initialWidth;
        Height = _initialHeight;
        _windowClassName = className ?? ("Win32Window_" + Guid.NewGuid().ToString("N"));
        _wndProcDelegate = WindowProcedure; // Pin delegate
    }

    // --- Methods (Ensure Run, TryCreateWindow, WindowProcedure, HandleMessage are as before) ---
    public void Run()
    { /* ... as before ... */
        if (_hwnd != IntPtr.Zero) throw new InvalidOperationException("Window already created.");
        if (!TryCreateWindow()) { Console.WriteLine("Window creation failed."); Dispose(); return; }
        if (!Initialize()) { Console.WriteLine("Derived init failed."); Dispose(); return; }
        NativeMethods.ShowWindow(_hwnd, NativeMethods.SW_SHOWNORMAL);
        NativeMethods.UpdateWindow(_hwnd);
        NativeMethods.MSG msg;
        while (NativeMethods.GetMessage(out msg, IntPtr.Zero, 0, 0))
        { NativeMethods.TranslateMessage(ref msg); NativeMethods.DispatchMessage(ref msg); }
        Console.WriteLine("Exiting message loop.");
    }

    private bool TryCreateWindow()
    { /* ... as before ... */
        _hInstance = NativeMethods.GetModuleHandle(null);
        if (_hInstance == IntPtr.Zero) _hInstance = Process.GetCurrentProcess().Handle;
        lock (RegisteredClassNames)
        {
            if (!RegisteredClassNames.Contains(_windowClassName))
            {
                var wndClass = new NativeMethods.WNDCLASSEX
                { /* ... fill struct ... */
                    cbSize = Marshal.SizeOf(typeof(NativeMethods.WNDCLASSEX)),
                    style = NativeMethods.CS_HREDRAW | NativeMethods.CS_VREDRAW,
                    lpfnWndProc = _wndProcDelegate,
                    hInstance = _hInstance,
                    lpszClassName = _windowClassName,
                    hIcon = NativeMethods.LoadIcon(IntPtr.Zero, (IntPtr)32512),
                    hCursor = NativeMethods.LoadCursor(IntPtr.Zero, 32512),
                };
                if (NativeMethods.RegisterClassEx(ref wndClass) == 0) { Console.WriteLine($"RegisterClassEx failed: {Marshal.GetLastWin32Error()}"); return false; }
                RegisteredClassNames.Add(_windowClassName); Console.WriteLine($"Class '{_windowClassName}' registered.");
            }
        }
        _gcHandle = GCHandle.Alloc(this);
        _hwnd = NativeMethods.CreateWindowEx(0, _windowClassName, _windowTitle, NativeMethods.WS_OVERLAPPEDWINDOW | NativeMethods.WS_VISIBLE,
            NativeMethods.CW_USEDEFAULT, NativeMethods.CW_USEDEFAULT, _initialWidth, _initialHeight, IntPtr.Zero, IntPtr.Zero, _hInstance, GCHandle.ToIntPtr(_gcHandle));
        if (_hwnd == IntPtr.Zero) { Console.WriteLine($"CreateWindowEx failed: {Marshal.GetLastWin32Error()}"); if (_gcHandle.IsAllocated) _gcHandle.Free(); return false; }
        Console.WriteLine($"Window created: {_hwnd}"); return true;
    }

    private static IntPtr WindowProcedure(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    { /* ... as before ... */
        Win32Window window = null;
        if (msg == NativeMethods.WM_NCCREATE)
        {
            var cs = Marshal.PtrToStructure<NativeMethods.CREATESTRUCT>(lParam);
            var handle = GCHandle.FromIntPtr(cs.lpCreateParams); window = handle.Target as Win32Window;
            NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, GCHandle.ToIntPtr(handle));
            Console.WriteLine($"WM_NCCREATE: Associated instance with HWND {hWnd}");
        }
        else
        {
            IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA);
            if (ptr != IntPtr.Zero) { var handle = GCHandle.FromIntPtr(ptr); window = handle.Target as Win32Window; }
        }
        if (window != null) { try { return window.HandleMessage(hWnd, msg, wParam, lParam); } catch (Exception ex) { Console.WriteLine($"Error handling msg {msg}: {ex}"); } }
        return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
    }

    protected virtual IntPtr HandleMessage(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    { /* ... as before ... */
        switch (msg)
        {
            case NativeMethods.WM_PAINT: OnPaint(); return IntPtr.Zero;
            case NativeMethods.WM_SIZE: Width = NativeMethods.LoWord(lParam); Height = NativeMethods.HiWord(lParam); OnSize(Width, Height); return IntPtr.Zero;
            case NativeMethods.WM_MOUSEMOVE: OnMouseMove(NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam)); return IntPtr.Zero;
            case NativeMethods.WM_LBUTTONDOWN:
                NativeMethods.SetCapture(hWnd);
                OnMouseDown(MouseButton.Left, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
                return IntPtr.Zero;
            case NativeMethods.WM_LBUTTONUP:
                NativeMethods.ReleaseCapture();
                OnMouseUp(MouseButton.Left, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
                return IntPtr.Zero;
            case NativeMethods.WM_KEYDOWN: OnKeyDown((int)wParam); return IntPtr.Zero;
            case NativeMethods.WM_CLOSE: if (OnClose()) { NativeMethods.DestroyWindow(hWnd); } return IntPtr.Zero;
            case NativeMethods.WM_DESTROY: Console.WriteLine($"WM_DESTROY for {hWnd}."); OnDestroy(); NativeMethods.PostQuitMessage(0); return IntPtr.Zero;
            case NativeMethods.WM_NCDESTROY: Console.WriteLine($"WM_NCDESTROY: Releasing GCHandle for {hWnd}."); IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA); if (ptr != IntPtr.Zero) { var handle = GCHandle.FromIntPtr(ptr); if (handle.IsAllocated) handle.Free(); NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, IntPtr.Zero); } if (_gcHandle.IsAllocated && GCHandle.ToIntPtr(_gcHandle) == ptr) { _gcHandle = default; } _hwnd = IntPtr.Zero; return IntPtr.Zero;
            default: return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
        }
    }

    public void Close() { if (_hwnd != IntPtr.Zero) NativeMethods.DestroyWindow(_hwnd); }
    public void Invalidate() { if (_hwnd != IntPtr.Zero) NativeMethods.InvalidateRect(_hwnd, IntPtr.Zero, false); }

    // --- Virtual Methods (Ensure all needed methods are declared) ---
    protected virtual bool Initialize() { return true; }
    protected virtual void OnPaint() { }
    protected virtual void OnSize(int width, int height) { }
    protected virtual void OnMouseDown(MouseButton button, int x, int y) { }
    protected virtual void OnMouseUp(MouseButton button, int x, int y) { }     // Ensure exists
    protected virtual void OnMouseMove(int x, int y) { }     // Ensure exists
    protected virtual void OnKeyDown(int keyCode) { }
    protected virtual bool OnClose() { return true; }
    protected virtual void OnDestroy() { }
    protected virtual void Cleanup() { }

    // --- IDisposable (Ensure implementation is as before) ---
    public void Dispose()
    {
        Dispose(true); 
        GC.SuppressFinalize(this); 
    }
    
    protected virtual void Dispose(bool disposing)
    {
        if (_isDisposed)
        {
            return;
        }

        if (disposing) 
        { 
            Console.WriteLine("Disposing Win32Window (managed)..."); 
            Cleanup(); 
        }

        Console.WriteLine("Disposing Win32Window (unmanaged)...");

        if (_hwnd != IntPtr.Zero) 
        { 
            Console.WriteLine($"Destroying window {_hwnd} during Dispose..."); 
            NativeMethods.DestroyWindow(_hwnd); 
            _hwnd = IntPtr.Zero; 
        }
        else 
        { 
            if (_gcHandle.IsAllocated) 
            { 
                Console.WriteLine("Freeing dangling GCHandle...");
                _gcHandle.Free(); 
            } 
        }

        _isDisposed = true; 

        Console.WriteLine("Win32Window disposed.");
    }

    ~Win32Window() 
    { 
        Console.WriteLine("Win32Window Finalizer!"); 
        Dispose(false); 
    }
}

public enum MouseButton 
{ 
    Left, 
    Right, 
    Middle, 
    XButton1, 
    XButton2 
}
</file>

<file path="Containers\GridContainerState.cs">
// NEW: GridContainerState.cs
// Summary: State object for managing grid layout.
using System.Collections.Generic;
using System.Numerics;

namespace DirectUI;

internal class GridContainerState
{
    internal string Id { get; }
    internal Vector2 StartPosition { get; } // Top-left corner of the grid area
    internal int NumColumns { get; }
    internal Vector2 Gap { get; } // Gap between cells (X and Y)
    internal Vector2 AvailableSize { get; } // Total area the grid can occupy

    // Calculated layout values
    internal float CellWidth { get; }
    internal List<float> RowHeights { get; } = new(); // Store height of each completed row
    internal float CurrentRowMaxHeight { get; set; } = 0f; // Track max height of elements in the current row being built
    internal int CurrentCellIndex { get; set; } = 0; // 0-based index of the next cell to place an element in
    internal Vector2 CurrentDrawPosition { get; set; } // Calculated top-left for the next element

    // Tracking overall bounds occupied by elements
    internal float AccumulatedWidth { get; set; } = 0f;
    internal float AccumulatedHeight { get; set; } = 0f;


    internal GridContainerState(string id, Vector2 startPosition, Vector2 availableSize, int numColumns, Vector2 gap)
    {
        Id = id;
        StartPosition = startPosition;
        AvailableSize = availableSize;
        NumColumns = Math.Max(1, numColumns); // Ensure at least one column
        Gap = gap;

        // Calculate fixed cell width based on available space and gaps
        float totalHorizontalGap = Math.Max(0, NumColumns - 1) * Gap.X;
        float widthForCells = AvailableSize.X - totalHorizontalGap;
        CellWidth = (NumColumns > 0) ? Math.Max(0, widthForCells / NumColumns) : 0;

        // Initial position is the start position
        CurrentDrawPosition = startPosition;
        RowHeights.Add(0); // Add initial height for the first row (will be updated)
    }

    internal void MoveToNextCell(Vector2 elementSize)
    {
        // Update max height for the current row
        CurrentRowMaxHeight = Math.Max(CurrentRowMaxHeight, elementSize.Y);

        // Update total occupied width (conservative estimate using cell width)
        int currentCol = CurrentCellIndex % NumColumns;
        float currentWidth = (currentCol + 1) * CellWidth + currentCol * Gap.X;
        AccumulatedWidth = Math.Max(AccumulatedWidth, currentWidth);


        CurrentCellIndex++;
        int nextCol = CurrentCellIndex % NumColumns;

        if (nextCol == 0) // Moved to the start of a new row
        {
            // Finalize the height of the completed row
            RowHeights[^1] = CurrentRowMaxHeight; // Update last row's height
            AccumulatedHeight += CurrentRowMaxHeight + (RowHeights.Count > 1 ? Gap.Y : 0); // Add height and gap (if not first row)

            // Reset for the new row
            CurrentRowMaxHeight = 0f;
            RowHeights.Add(0); // Add placeholder height for the new row

            // Calculate Y position for the new row
            float newY = StartPosition.Y;
            for (int i = 0; i < RowHeights.Count - 1; i++) // Sum heights and gaps of completed rows
            {
                newY += RowHeights[i] + Gap.Y;
            }

            // Set position for the first cell of the new row
            CurrentDrawPosition = new Vector2(StartPosition.X, newY);

        }
        else // Moving to the next column in the same row
        {
            // Calculate X position for the next cell
            float currentX = StartPosition.X + nextCol * (CellWidth + Gap.X);
            CurrentDrawPosition = new Vector2(currentX, CurrentDrawPosition.Y); // Y stays the same
        }
    }

    internal Vector2 GetTotalOccupiedSize()
    {
        // Calculate final height including the current row being built
        float finalHeight = AccumulatedHeight + CurrentRowMaxHeight;
        return new Vector2(AccumulatedWidth, finalHeight);
    }
}
</file>

<file path="Containers\HBoxContainerState.cs">
using System.Numerics;

namespace DirectUI;

internal class HBoxContainerState
{
    internal string Id { get; }
    internal Vector2 StartPosition { get; }
    internal Vector2 CurrentPosition { get; set; }
    internal float Gap { get; }
    internal float MaxElementHeight { get; set; } = 0f;
    internal float AccumulatedWidth { get; set; } = 0f;
    internal int ElementCount { get; set; } = 0;

    internal HBoxContainerState(string id, Vector2 startPosition, float gap)
    {
        Id = id;
        StartPosition = startPosition;
        CurrentPosition = startPosition;
        Gap = gap;
    }
}
</file>

<file path="Containers\ResizableHPanelState.cs">
namespace DirectUI;

internal class ResizableHPanelState
{
    internal string Id { get; }
    internal HBoxContainerState InnerHBox { get; }
    internal bool ClipRectWasPushed { get; }

    internal ResizableHPanelState(string id, HBoxContainerState innerHBox, bool clipPushed)
    {
        Id = id;
        InnerHBox = innerHBox;
        ClipRectWasPushed = clipPushed;
    }
}
</file>

<file path="Containers\ResizablePanelState.cs">
namespace DirectUI;

internal class ResizablePanelState
{
    internal string Id { get; }
    internal VBoxContainerState InnerVBox { get; }
    internal bool ClipRectWasPushed { get; }

    internal ResizablePanelState(string id, VBoxContainerState innerVBox, bool clipPushed)
    {
        Id = id;
        InnerVBox = innerVBox;
        ClipRectWasPushed = clipPushed;
    }
}
</file>

<file path="Containers\VBoxContainerState.cs">
using System.Numerics;

namespace DirectUI;

internal class VBoxContainerState
{
    internal string Id { get; }
    internal Vector2 StartPosition { get; }
    internal Vector2 CurrentPosition { get; set; } // Top-left for the next element
    internal float Gap { get; }
    internal float MaxElementWidth { get; set; } = 0f; // Track width for container bounds
    internal float AccumulatedHeight { get; set; } = 0f; // Track height for container bounds
    internal int ElementCount { get; set; } = 0;

    internal VBoxContainerState(string id, Vector2 startPosition, float gap)
    {
        Id = id;
        StartPosition = startPosition;
        CurrentPosition = startPosition;
        Gap = gap;
    }
}
</file>

<file path="Core\UI.Containers.cs">
using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.Mathematics;
using static System.Net.Mime.MediaTypeNames;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

public static partial class UI
{
    // --- Containers ---
    public static void BeginHBoxContainer(string id, Vector2 position, float gap = 5.0f)
    {
        var containerState = new HBoxContainerState(id, position, gap);
        containerStack.Push(containerState);
    }
    public static void EndHBoxContainer()
    {
        if (containerStack.Count == 0 || containerStack.Peek() is not HBoxContainerState state)
        { Console.WriteLine("Error: EndHBoxContainer called without a matching BeginHBoxContainer."); return; }
        containerStack.Pop();
        if (IsInLayoutContainer())
        { AdvanceLayoutCursor(new Vector2(state.AccumulatedWidth, state.MaxElementHeight)); }
    }
    public static void BeginVBoxContainer(string id, Vector2 position, float gap = 5.0f)
    {
        var containerState = new VBoxContainerState(id, position, gap);
        containerStack.Push(containerState);
    }
    public static void EndVBoxContainer()
    {
        if (containerStack.Count == 0 || containerStack.Peek() is not VBoxContainerState state)
        { Console.WriteLine("Error: EndVBoxContainer called without a matching BeginVBoxContainer."); return; }
        containerStack.Pop();
        if (IsInLayoutContainer())
        { AdvanceLayoutCursor(new Vector2(state.MaxElementWidth, state.AccumulatedHeight)); }
    }
    public static void BeginGridContainer(string id, Vector2 position, Vector2 availableSize, int numColumns, Vector2 gap)
    {
        var containerState = new GridContainerState(id, position, availableSize, numColumns, gap);
        containerStack.Push(containerState);
    }
    public static void EndGridContainer()
    {
        if (containerStack.Count == 0 || containerStack.Peek() is not GridContainerState state)
        { Console.WriteLine("Error: EndGridContainer called without a matching BeginGridContainer."); return; }
        containerStack.Pop();
        if (IsInLayoutContainer())
        {
            if (state.RowHeights.Count > 0 && state.CurrentCellIndex > 0)
            {
                int lastPopulatedRowIndex = (state.CurrentCellIndex - 1) / state.NumColumns;
                if (lastPopulatedRowIndex < state.RowHeights.Count)
                { state.RowHeights[lastPopulatedRowIndex] = state.CurrentRowMaxHeight; }
                else { Console.WriteLine($"Warning: Grid '{state.Id}' - Row index mismatch during EndGridContainer."); }
                state.AccumulatedHeight = 0f; bool firstRowAdded = false;
                for (int i = 0; i < state.RowHeights.Count; i++) { if (state.RowHeights[i] > 0) { if (firstRowAdded) { state.AccumulatedHeight += state.Gap.Y; } state.AccumulatedHeight += state.RowHeights[i]; firstRowAdded = true; } }
            }
            Vector2 containerSize = state.GetTotalOccupiedSize();
            AdvanceLayoutCursor(containerSize);
        }
    }

    public static void BeginResizableVPanel(string id, ref float currentWidth, ResizablePanelDefinition definition, HAlignment alignment = HAlignment.Left, float topOffset = 0f)
    {
        if (!IsContextValid() || definition == null) return;
        var intId = id.GetHashCode();

        var input = CurrentInputState;
        var renderTarget = CurrentRenderTarget!;
        var windowWidth = renderTarget.Size.Width;
        var windowHeight = renderTarget.Size.Height;
        var availableHeight = windowHeight - topOffset;

        // --- Input and Resizing Logic ---
        if (!definition.Disabled)
        {
            float handleWidth = definition.ResizeHandleWidth;
            float panelX = (alignment == HAlignment.Right) ? windowWidth - currentWidth : 0;
            handleWidth = Math.Min(handleWidth, currentWidth);
            float handleX = (alignment == HAlignment.Right) ? panelX : panelX + currentWidth - handleWidth;
            Rect handleRect = new Rect(handleX, topOffset, handleWidth, availableHeight);

            bool isHoveringHandle = handleRect.Contains(input.MousePosition.X, input.MousePosition.Y);
            if (isHoveringHandle) SetPotentialInputTarget(intId);
            if (input.WasLeftMousePressedThisFrame && isHoveringHandle && PotentialInputTargetId == intId && !dragInProgressFromPreviousFrame) SetPotentialCaptorForFrame(intId);
            if (ActivelyPressedElementId == intId && !input.IsLeftMouseDown) ClearActivePress(intId);
            if (ActivelyPressedElementId == intId && input.IsLeftMouseDown)
            {
                if (alignment == HAlignment.Left) currentWidth = Math.Clamp(input.MousePosition.X, definition.MinWidth, definition.MaxWidth);
                else currentWidth = Math.Clamp(windowWidth - input.MousePosition.X, definition.MinWidth, definition.MaxWidth);
            }
        }

        // --- Drawing ---
        var panelStyle = definition.PanelStyle ?? new BoxStyle { FillColor = new(0.15f, 0.15f, 0.2f, 1.0f), BorderColor = DefaultTheme.NormalBorder, BorderLength = 1 };
        currentWidth = Math.Max(0, currentWidth);
        float finalPanelX = (alignment == HAlignment.Right) ? windowWidth - currentWidth : 0;
        Rect panelRect = new Rect(finalPanelX, topOffset, currentWidth, availableHeight);
        if (panelRect.Width > 0 && panelRect.Height > 0)
        {
            DrawBoxStyleHelper(renderTarget, new Vector2(panelRect.X, panelRect.Y), new Vector2(panelRect.Width, panelRect.Height), panelStyle);
        }

        // --- Container & Clipping Logic ---
        Vector2 contentStartPosition = new Vector2(finalPanelX + definition.Padding.X, topOffset + definition.Padding.Y);
        Rect contentClipRect = new Rect(contentStartPosition.X, contentStartPosition.Y, Math.Max(0, currentWidth - (definition.Padding.X * 2)), Math.Max(0, availableHeight - (definition.Padding.Y * 2)));
        bool clipPushed = false;
        if (contentClipRect.Width > 0 && contentClipRect.Height > 0)
        {
            renderTarget.PushAxisAlignedClip(contentClipRect, D2D.AntialiasMode.Aliased);
            clipPushed = true;
        }
        var vboxState = new VBoxContainerState(id + "_vbox", contentStartPosition, definition.Gap);
        var panelState = new ResizablePanelState(id, vboxState, clipPushed);
        containerStack.Push(panelState);
    }

    public static void EndResizableVPanel()
    {
        if (containerStack.Count == 0 || containerStack.Peek() is not ResizablePanelState state)
        {
            Console.WriteLine("Error: EndResizableVPanel called without a matching BeginResizableVPanel.");
            return;
        }

        if (state.ClipRectWasPushed && CurrentRenderTarget is not null)
        {
            CurrentRenderTarget.PopAxisAlignedClip();
        }

        containerStack.Pop();
    }

    public static void BeginResizableHPanel(string id, ref float currentHeight, ResizableHPanelDefinition definition, float reservedLeftSpace, float reservedRightSpace, float topOffset = 0f)
    {
        if (!IsContextValid() || definition == null) return;
        var intId = id.GetHashCode();

        var input = CurrentInputState;
        var renderTarget = CurrentRenderTarget!;
        var windowWidth = renderTarget.Size.Width;
        var windowHeight = renderTarget.Size.Height;
        var availableWidth = Math.Max(0, windowWidth - reservedLeftSpace - reservedRightSpace);
        var maxAllowedHeight = windowHeight - topOffset;
        var effectiveMaxHeight = Math.Min(definition.MaxHeight, maxAllowedHeight);


        // --- Input and Resizing Logic ---
        if (!definition.Disabled)
        {
            currentHeight = Math.Clamp(currentHeight, definition.MinHeight, effectiveMaxHeight);

            float panelY = windowHeight - currentHeight;
            float handleHeight = definition.ResizeHandleWidth;
            handleHeight = Math.Min(handleHeight, currentHeight);
            Rect handleRect = new Rect(reservedLeftSpace, panelY, availableWidth, handleHeight);

            bool isHoveringHandle = handleRect.Contains(input.MousePosition.X, input.MousePosition.Y);
            if (isHoveringHandle) SetPotentialInputTarget(intId);
            if (input.WasLeftMousePressedThisFrame && isHoveringHandle && PotentialInputTargetId == intId && !dragInProgressFromPreviousFrame) SetPotentialCaptorForFrame(intId);
            if (ActivelyPressedElementId == intId && !input.IsLeftMouseDown) ClearActivePress(intId);
            if (ActivelyPressedElementId == intId && input.IsLeftMouseDown)
            {
                float clampedMouseY = Math.Max(input.MousePosition.Y, topOffset);
                currentHeight = Math.Clamp(windowHeight - clampedMouseY, definition.MinHeight, effectiveMaxHeight);
            }
        }

        // --- Drawing ---
        var panelStyle = definition.PanelStyle ?? new BoxStyle { FillColor = new(0.15f, 0.15f, 0.2f, 1.0f), BorderColor = DefaultTheme.NormalBorder, BorderLength = 1 };
        currentHeight = Math.Clamp(currentHeight, definition.MinHeight, effectiveMaxHeight);
        float finalPanelY = windowHeight - currentHeight;
        Rect panelRect = new Rect(reservedLeftSpace, finalPanelY, availableWidth, currentHeight);
        if (panelRect.Width > 0 && panelRect.Height > 0)
        {
            DrawBoxStyleHelper(renderTarget, new Vector2(panelRect.X, panelRect.Y), new Vector2(panelRect.Width, panelRect.Height), panelStyle);
        }

        // --- Container & Clipping Logic ---
        Vector2 contentStartPosition = new Vector2(reservedLeftSpace + definition.Padding.X, finalPanelY + definition.Padding.Y);
        Rect contentClipRect = new Rect(contentStartPosition.X, contentStartPosition.Y, Math.Max(0, availableWidth - (definition.Padding.X * 2)), Math.Max(0, currentHeight - (definition.Padding.Y * 2)));
        bool clipPushed = false;
        if (contentClipRect.Width > 0 && contentClipRect.Height > 0)
        {
            renderTarget.PushAxisAlignedClip(contentClipRect, D2D.AntialiasMode.Aliased);
            clipPushed = true;
        }
        var hboxState = new HBoxContainerState(id + "_hbox", contentStartPosition, definition.Gap);
        var panelState = new ResizableHPanelState(id, hboxState, clipPushed);
        containerStack.Push(panelState);
    }

    public static void EndResizableHPanel()
    {
        if (containerStack.Count == 0 || containerStack.Peek() is not ResizableHPanelState state)
        {
            Console.WriteLine("Error: EndResizableHPanel called without a matching BeginResizableHPanel.");
            return;
        }

        if (state.ClipRectWasPushed && CurrentRenderTarget is not null)
        {
            CurrentRenderTarget.PopAxisAlignedClip();
        }

        containerStack.Pop();
    }
}
</file>

<file path="Core\UI.cs">
using SharpGen.Runtime;
using System;
using System.Collections.Generic;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

internal class TreeViewState
{
    internal string Id { get; }
    internal TreeStyle Style { get; }
    internal Stack<bool> IndentLineState { get; } = new();

    internal TreeViewState(string id, TreeStyle style)
    {
        Id = id;
        Style = style;
    }
}


public enum HSliderDirection { LeftToRight, RightToLeft }
public enum VSliderDirection { TopToBottom, BottomToTop }

public static partial class UI
{
    // --- Font Caching Key ---
    private readonly struct FontKey : IEquatable<FontKey>
    {
        public readonly string FontName;
        public readonly float FontSize;
        public readonly FontWeight FontWeight;
        public readonly FontStyle FontStyle;
        public readonly FontStretch FontStretch;

        public FontKey(ButtonStyle style)
        {
            FontName = style.FontName;
            FontSize = style.FontSize;
            FontWeight = style.FontWeight;
            FontStyle = style.FontStyle;
            FontStretch = style.FontStretch;
        }

        public bool Equals(FontKey other)
        {
            return FontName == other.FontName &&
                   FontSize.Equals(other.FontSize) &&
                   FontWeight == other.FontWeight &&
                   FontStyle == other.FontStyle &&
                   FontStretch == other.FontStretch;
        }

        public override bool Equals(object? obj) => obj is FontKey other && Equals(other);

        public override int GetHashCode() => HashCode.Combine(FontName, FontSize, FontWeight, FontStyle, FontStretch);
    }


    // --- State fields ---
    private static ID2D1HwndRenderTarget? currentRenderTarget;
    private static IDWriteFactory? currentDWriteFactory;
    private static InputState currentInputState;
    private static readonly Dictionary<string, object> uiElements = new();
    private static readonly Dictionary<Color4, ID2D1SolidColorBrush> brushCache = new();
    private static readonly Dictionary<FontKey, IDWriteTextFormat> textFormatCache = new();
    private static readonly Stack<object> containerStack = new();
    private static readonly Stack<TreeViewState> treeStateStack = new();

    // Input State
    private static bool captureAttemptedThisFrame = false;
    private static int inputCaptorId = 0;
    private static int potentialInputTargetId = 0;
    private static int activelyPressedElementId = 0;
    internal static bool dragInProgressFromPreviousFrame = false;
    internal static bool nonSliderElementClaimedPress = false;

    // --- Public/Internal Properties ---
    public static ID2D1HwndRenderTarget? CurrentRenderTarget => currentRenderTarget;
    public static IDWriteFactory? CurrentDWriteFactory => currentDWriteFactory;
    public static InputState CurrentInputState => currentInputState;
    public static int ActivelyPressedElementId => activelyPressedElementId;
    public static int InputCaptorId => inputCaptorId;
    internal static int PotentialInputTargetId => potentialInputTargetId;

    // --- Frame Management ---
    public static void BeginFrame(DrawingContext context, InputState input)
    {
        currentRenderTarget = context.RenderTarget;
        currentDWriteFactory = context.DWriteFactory;
        currentInputState = input;
        containerStack.Clear();
        treeStateStack.Clear();

        dragInProgressFromPreviousFrame = input.IsLeftMouseDown && activelyPressedElementId != 0;

        captureAttemptedThisFrame = false;
        inputCaptorId = 0;
        potentialInputTargetId = 0;
        nonSliderElementClaimedPress = false;

        // The active element is now cleared by the element itself upon release,
        // or by a new element capturing input. This prevents the state from being
        // cleared before the release event can be processed.
    }

    public static void EndFrame()
    {
        if (containerStack.Count > 0)
        {
            Console.WriteLine($"Warning: Mismatch in Begin/End container calls. {containerStack.Count} containers left open at EndFrame.");
            containerStack.Clear();
        }
        if (treeStateStack.Count > 0)
        {
            Console.WriteLine($"Warning: Mismatch in Begin/End Tree calls. {treeStateStack.Count} trees left open at EndFrame.");
            treeStateStack.Clear();
        }
        currentRenderTarget = null;
        currentDWriteFactory = null;
    }

    internal static void BeginTree(string id, TreeStyle style)
    {
        treeStateStack.Push(new TreeViewState(id, style));
    }

    internal static void EndTree()
    {
        if (treeStateStack.Count == 0)
        {
            Console.WriteLine("Error: EndTree called without a matching BeginTree.");
            return;
        }
        treeStateStack.Pop();
    }


    // --- Input Capture & Targeting ---

    public static bool IsElementActive()
    {
        return activelyPressedElementId is not 0;
    }

    internal static void SetPotentialInputTarget(int id)
    {
        potentialInputTargetId = id;
    }

    internal static void SetPotentialCaptorForFrame(int id)
    {
        captureAttemptedThisFrame = true;
        inputCaptorId = id;
        activelyPressedElementId = id;
    }

    internal static void SetButtonPotentialCaptorForFrame(int id)
    {
        captureAttemptedThisFrame = true;
        inputCaptorId = id;
        activelyPressedElementId = id;
        nonSliderElementClaimedPress = true;
    }

    internal static void ClearActivePress(int id)
    {
        if (activelyPressedElementId == id)
        {
            activelyPressedElementId = 0;
        }
    }

    // --- Helper Methods ---
    private static bool IsContextValid()
    {
        if (CurrentRenderTarget is null || CurrentDWriteFactory is null) { Console.WriteLine($"Error: UI method called outside BeginFrame/EndFrame or context is invalid."); return false; }
        return true;
    }
    private static DrawingContext GetCurrentDrawingContext()
    {
        if (!IsContextValid()) { throw new InvalidOperationException("Attempted to get DrawingContext when UI context is invalid."); }
        return new DrawingContext(CurrentRenderTarget!, CurrentDWriteFactory!);
    }
    private static T GetOrCreateElement<T>(string id) where T : new()
    {
        if (uiElements.TryGetValue(id, out object? element) && element is T existingElement) { return existingElement; }
        else { T newElement = new(); uiElements[id] = newElement; return newElement; }
    }
    private static void ApplyButtonDefinition(Button instance, ButtonDefinition definition)
    {
        instance.Size = definition.Size; instance.Text = definition.Text; instance.Themes = definition.Theme ?? instance.Themes ?? new ButtonStylePack();
        instance.Origin = definition.Origin ?? Vector2.Zero; instance.TextAlignment = definition.TextAlignment ?? new Alignment(HAlignment.Center, VAlignment.Center);
        instance.TextOffset = definition.TextOffset ?? Vector2.Zero; instance.AutoWidth = definition.AutoWidth; instance.TextMargin = definition.TextMargin ?? new Vector2(10, 5);
        instance.Behavior = definition.Behavior; instance.LeftClickActionMode = definition.LeftClickActionMode; instance.Disabled = definition.Disabled; instance.UserData = definition.UserData;
    }
    private static void ApplySliderDefinition(InternalSliderLogic instance, SliderDefinition definition)
    {
        instance.Size = definition.Size; instance.MinValue = definition.MinValue; instance.MaxValue = definition.MaxValue; instance.Step = definition.Step;
        instance.Theme = definition.Theme ?? instance.Theme ?? new SliderStyle(); instance.GrabberTheme = definition.GrabberTheme ?? instance.GrabberTheme ?? new ButtonStylePack();
        instance.GrabberSize = definition.GrabberSize ?? instance.GrabberSize; instance.Origin = definition.Origin ?? Vector2.Zero; instance.Disabled = definition.Disabled; instance.UserData = definition.UserData;
    }

    // --- Brush and Font Cache ---
    public static ID2D1SolidColorBrush GetOrCreateBrush(Color4 color)
    {
        if (CurrentRenderTarget is null) { Console.WriteLine("Error: GetOrCreateBrush called with no active render target."); return null!; }
        if (brushCache.TryGetValue(color, out ID2D1SolidColorBrush? brush) && brush is not null) { return brush; }
        else if (brush is null && brushCache.ContainsKey(color)) { brushCache.Remove(color); }
        try
        {
            brush = CurrentRenderTarget.CreateSolidColorBrush(color);
            if (brush is not null) { brushCache[color] = brush; return brush; }
            else { Console.WriteLine($"Warning: CreateSolidColorBrush returned null for color {color}"); return null!; }
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == ResultCode.RecreateTarget.Code) { Console.WriteLine($"Brush creation failed due to RecreateTarget error (Color: {color}). External cleanup needed."); return null!; }
        catch (Exception ex) { Console.WriteLine($"Error creating brush for color {color}: {ex.Message}"); return null!; }
    }

    public static IDWriteTextFormat? GetOrCreateTextFormat(ButtonStyle style)
    {
        if (CurrentDWriteFactory is null) return null;

        var key = new FontKey(style);
        if (textFormatCache.TryGetValue(key, out var format))
        {
            return format;
        }

        try
        {
            var newFormat = CurrentDWriteFactory.CreateTextFormat(
                style.FontName,
                null,
                style.FontWeight,
                style.FontStyle,
                style.FontStretch,
                style.FontSize,
                "en-us"
            );
            if (newFormat is not null)
            {
                textFormatCache[key] = newFormat;
            }
            return newFormat;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error creating text format for font '{style.FontName}': {ex.Message}");
            return null;
        }
    }

    public static Vector2 MeasureText(IDWriteFactory dwriteFactory, string text, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(text) || style is null)
        {
            return Vector2.Zero;
        }

        IDWriteTextFormat? textFormat = GetOrCreateTextFormat(style);
        if (textFormat is null)
        {
            Console.WriteLine("Warning: Failed to create/get TextFormat for measurement.");
            return Vector2.Zero;
        }

        using var textLayout = dwriteFactory.CreateTextLayout(
            text,
            textFormat,
            float.MaxValue, // Max width
            float.MaxValue  // Max height
        );

        TextMetrics textMetrics = textLayout.Metrics;
        return new Vector2(textMetrics.WidthIncludingTrailingWhitespace, textMetrics.Height);
    }


    // --- Resource Cleanup ---
    public static void CleanupResources()
    {
        Console.WriteLine("UI Resource Cleanup: Disposing cached brushes and text formats...");
        int brushCount = brushCache.Count;
        foreach (var pair in brushCache) { pair.Value?.Dispose(); }
        brushCache.Clear();

        int formatCount = textFormatCache.Count;
        foreach (var pair in textFormatCache) { pair.Value?.Dispose(); }
        textFormatCache.Clear();

        Console.WriteLine($"UI Resource Cleanup finished. Disposed {brushCount} brushes and {formatCount} text formats.");
        containerStack.Clear();
        treeStateStack.Clear();
    }
}
</file>

<file path="Core\UI.Drawing.cs">
using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    // --- SHARED DRAWING HELPERS ---
    internal static void DrawBoxStyleHelper(ID2D1RenderTarget renderTarget, Vector2 pos, Vector2 size, BoxStyle style)
    {
        if (renderTarget is null || style is null || size.X <= 0 || size.Y <= 0) return;

        ID2D1SolidColorBrush fillBrush = GetOrCreateBrush(style.FillColor);
        ID2D1SolidColorBrush borderBrush = GetOrCreateBrush(style.BorderColor);

        float borderTop = Math.Max(0f, style.BorderLengthTop);
        float borderRight = Math.Max(0f, style.BorderLengthRight);
        float borderBottom = Math.Max(0f, style.BorderLengthBottom);
        float borderLeft = Math.Max(0f, style.BorderLengthLeft);

        bool hasVisibleFill = style.FillColor.A > 0 && fillBrush is not null;
        bool hasVisibleBorder = style.BorderColor.A > 0 && borderBrush is not null && (borderTop > 0 || borderRight > 0 || borderBottom > 0 || borderLeft > 0);

        if (!hasVisibleFill && !hasVisibleBorder) return;

        // --- Rounded Rectangle Rendering (Layered Approach) ---
        if (style.Roundness > 0.0f)
        {
            Rect outerBounds = new Rect(pos.X, pos.Y, size.X, size.Y);
            float maxRadius = Math.Min(outerBounds.Width * 0.5f, outerBounds.Height * 0.5f);
            float radius = Math.Max(0f, maxRadius * Math.Clamp(style.Roundness, 0.0f, 1.0f));

            if (float.IsFinite(radius) && radius >= 0)
            {
                // 1. Draw Border Area (Outer Rounded Rectangle)
                if (hasVisibleBorder)
                {
                    System.Drawing.RectangleF outerRectF = new(outerBounds.X, outerBounds.Y, outerBounds.Width, outerBounds.Height);
                    RoundedRectangle outerRoundedRect = new(outerRectF, radius, radius);
                    renderTarget.FillRoundedRectangle(outerRoundedRect, borderBrush);
                }

                // 2. Draw Fill Area (Inner Rounded Rectangle on top)
                if (hasVisibleFill)
                {
                    float fillX = pos.X + borderLeft;
                    float fillY = pos.Y + borderTop;
                    float fillWidth = Math.Max(0f, size.X - borderLeft - borderRight);
                    float fillHeight = Math.Max(0f, size.Y - borderTop - borderBottom);

                    if (fillWidth > 0 && fillHeight > 0)
                    {
                        // Adjust inner radius - clamp at zero. Use average border thickness for approximation.
                        float avgBorderX = (borderLeft + borderRight) * 0.5f;
                        float avgBorderY = (borderTop + borderBottom) * 0.5f;
                        float innerRadiusX = Math.Max(0f, radius - avgBorderX);
                        float innerRadiusY = Math.Max(0f, radius - avgBorderY);

                        System.Drawing.RectangleF fillRectF = new(fillX, fillY, fillWidth, fillHeight);
                        RoundedRectangle fillRoundedRect = new(fillRectF, innerRadiusX, innerRadiusY);
                        renderTarget.FillRoundedRectangle(fillRoundedRect, fillBrush);
                    }
                    // If fill consumes the whole area (e.g., no border), draw it directly using outer bounds/radius
                    else if (!hasVisibleBorder && fillBrush is not null)
                    {
                        System.Drawing.RectangleF outerRectF = new(outerBounds.X, outerBounds.Y, outerBounds.Width, outerBounds.Height);
                        RoundedRectangle outerRoundedRect = new(outerRectF, radius, radius);
                        renderTarget.FillRoundedRectangle(outerRoundedRect, fillBrush);
                    }
                }
                return; // Handled rounded case
            }
            // Fall through to sharp rendering if radius calculation failed
        }

        // --- Non-Rounded Rectangle Rendering (Layered Approach) ---

        // 1. Draw Border Area (Outer Rectangles)
        if (hasVisibleBorder && borderBrush is not null)
        {
            // Fill the entire background with border color first
            renderTarget.FillRectangle(new Rect(pos.X, pos.Y, size.X, size.Y), borderBrush);
        }

        // 2. Draw Fill Area (Inner Rectangle on top)
        if (hasVisibleFill)
        {
            float fillX = pos.X + borderLeft;
            float fillY = pos.Y + borderTop;
            float fillWidth = Math.Max(0f, size.X - borderLeft - borderRight);
            float fillHeight = Math.Max(0f, size.Y - borderTop - borderBottom);

            if (fillWidth > 0 && fillHeight > 0)
            {
                renderTarget.FillRectangle(new Rect(fillX, fillY, fillWidth, fillHeight), fillBrush);
            }
            // If fill consumes the whole area (e.g., no border), draw it directly
            else if (!hasVisibleBorder && fillBrush is not null)
            {
                renderTarget.FillRectangle(new Rect(pos.X, pos.Y, size.X, size.Y), fillBrush);
            }
        }
    }
}
</file>

<file path="Core\UI.Layout.cs">
using System;
using System.Numerics;

namespace DirectUI;

public static partial class UI
{
    // --- Layout Helpers ---
    internal static Vector2 ApplyLayout(Vector2 defaultPosition) { return IsInLayoutContainer() ? GetCurrentLayoutPositionInternal() : defaultPosition; }
    internal static void AdvanceLayout(Vector2 elementSize) { if (IsInLayoutContainer()) { AdvanceLayoutCursor(new Vector2(Math.Max(0, elementSize.X), Math.Max(0, elementSize.Y))); } }
    internal static bool IsInLayoutContainer() => containerStack.Count > 0;
    internal static Vector2 GetCurrentLayoutPositionInternal()
    {
        if (containerStack.Count == 0) return Vector2.Zero;
        object currentContainerState = containerStack.Peek();
        return currentContainerState switch
        {
            HBoxContainerState hbox => hbox.CurrentPosition,
            VBoxContainerState vbox => vbox.CurrentPosition,
            GridContainerState grid => grid.CurrentDrawPosition,
            ResizablePanelState panel => panel.InnerVBox.CurrentPosition,
            ResizableHPanelState hpanel => hpanel.InnerHBox.CurrentPosition,
            _ => Vector2.Zero,
        };
    }
    public static Vector2 GetCurrentLayoutPosition() { return IsInLayoutContainer() ? GetCurrentLayoutPositionInternal() : Vector2.Zero; }
    internal static void AdvanceLayoutCursor(Vector2 elementSize)
    {
        if (containerStack.Count == 0) return;
        object currentContainerState = containerStack.Peek();
        switch (currentContainerState)
        {
            case HBoxContainerState hbox:
                {
                    if (elementSize.Y > hbox.MaxElementHeight) hbox.MaxElementHeight = elementSize.Y;

                    // Add the width of the element just drawn to the total
                    hbox.AccumulatedWidth += elementSize.X;
                    // Add the gap to the total width if this wasn't the first element
                    if (hbox.ElementCount > 0)
                    {
                        hbox.AccumulatedWidth += hbox.Gap;
                    }

                    // Advance the cursor for the next element's position
                    float advanceX = elementSize.X + hbox.Gap;
                    hbox.CurrentPosition = new Vector2(hbox.CurrentPosition.X + advanceX, hbox.CurrentPosition.Y);

                    hbox.ElementCount++;
                    break;
                }
            case VBoxContainerState vbox:
                {
                    if (elementSize.X > vbox.MaxElementWidth) vbox.MaxElementWidth = elementSize.X;

                    // Add the height of the element just drawn to the total
                    vbox.AccumulatedHeight += elementSize.Y;
                    // Add the gap to the total height if this wasn't the first element
                    if (vbox.ElementCount > 0)
                    {
                        vbox.AccumulatedHeight += vbox.Gap;
                    }

                    // Advance the cursor for the next element's position
                    float advanceY = elementSize.Y + vbox.Gap;
                    vbox.CurrentPosition = new Vector2(vbox.CurrentPosition.X, vbox.CurrentPosition.Y + advanceY);

                    vbox.ElementCount++;
                    break;
                }
            case GridContainerState grid:
                {
                    grid.MoveToNextCell(elementSize);
                    break;
                }
            case ResizablePanelState panel:
                {
                    // This is just a wrapper, so we pass the call down to its inner VBox.
                    // We need to get a mutable reference to the inner VBox to do this.
                    var innerVBox = panel.InnerVBox;
                    if (elementSize.X > innerVBox.MaxElementWidth) innerVBox.MaxElementWidth = elementSize.X;

                    innerVBox.AccumulatedHeight += elementSize.Y;
                    if (innerVBox.ElementCount > 0)
                    {
                        innerVBox.AccumulatedHeight += innerVBox.Gap;
                    }
                    float advanceY = elementSize.Y + innerVBox.Gap;
                    innerVBox.CurrentPosition = new Vector2(innerVBox.CurrentPosition.X, innerVBox.CurrentPosition.Y + advanceY);
                    innerVBox.ElementCount++;
                    break;
                }
            case ResizableHPanelState hpanel:
                {
                    // This is just a wrapper, so we pass the call down to its inner HBox.
                    var innerHBox = hpanel.InnerHBox;
                    if (elementSize.Y > innerHBox.MaxElementHeight) innerHBox.MaxElementHeight = elementSize.Y;

                    innerHBox.AccumulatedWidth += elementSize.X;
                    if (innerHBox.ElementCount > 0)
                    {
                        innerHBox.AccumulatedWidth += innerHBox.Gap;
                    }
                    float advanceX = elementSize.X + innerHBox.Gap;
                    innerHBox.CurrentPosition = new Vector2(innerHBox.CurrentPosition.X + advanceX, innerHBox.CurrentPosition.Y);
                    innerHBox.ElementCount++;
                    break;
                }
            default:
                {
                    Console.WriteLine("Error: AdvanceLayoutCursor called with unexpected container type.");
                    break;
                }
        }
    }
}
</file>

<file path="Core\UI.StatelessWidgets.cs">
using DirectUI;
using System.Buffers.Text;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.DirectWrite;

using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    /// <summary>
    /// An internal, high-performance, stateless button drawing function.
    /// It does not use the GetOrCreateElement cache and avoids allocations.
    /// This is ideal for performance-critical loops like tree views.
    /// </summary>
    internal static bool StatelessButton(
        int id,
        Rect bounds,
        string text,
        ButtonStylePack stylePack,
        Alignment textAlignment,
        DirectUI.Button.ActionMode clickActionMode,
        bool autoWidth = false,
        Vector2? textMargin = null,
        Vector2 textOffset = default)
    {
        var input = CurrentInputState;
        var renderTarget = CurrentRenderTarget!;
        var dwriteFactory = CurrentDWriteFactory!;

        Vector2 finalSize = new(bounds.Width, bounds.Height);
        if (autoWidth)
        {
            var measuredSize = MeasureText(dwriteFactory, text, stylePack.Normal);
            var margin = textMargin ?? new Vector2(10, 5);
            finalSize.X = measuredSize.X + margin.X * 2;
        }
        Rect finalBounds = new Rect(bounds.X, bounds.Y, finalSize.X, finalSize.Y);

        // --- Input and State ---
        bool isHovering = finalBounds.Contains(input.MousePosition.X, input.MousePosition.Y);
        bool isPressed = ActivelyPressedElementId == id;
        bool wasClickedThisFrame = false;

        if (isHovering)
        {
            SetPotentialInputTarget(id);
        }

        if (!input.IsLeftMouseDown && isPressed)
        {
            if (isHovering && clickActionMode == DirectUI.Button.ActionMode.Release)
            {
                wasClickedThisFrame = true;
            }
            ClearActivePress(id);
            isPressed = false; // Update visual state immediately
        }

        if (input.WasLeftMousePressedThisFrame && isHovering && PotentialInputTargetId == id && !dragInProgressFromPreviousFrame)
        {
            SetButtonPotentialCaptorForFrame(id);
            isPressed = true; // Update visual state immediately
        }

        if (!wasClickedThisFrame && clickActionMode == DirectUI.Button.ActionMode.Press && InputCaptorId == id)
        {
            wasClickedThisFrame = true;
        }

        // --- Drawing ---
        stylePack.UpdateCurrentStyle(isHovering, isPressed, false);
        var currentStyle = stylePack.Current;

        DrawBoxStyleHelper(renderTarget, new Vector2(finalBounds.X, finalBounds.Y), new Vector2(finalBounds.Width, finalBounds.Height), currentStyle);

        // Draw Text
        ID2D1SolidColorBrush textBrush = GetOrCreateBrush(currentStyle.FontColor);
        IDWriteTextFormat? textFormat = GetOrCreateTextFormat(currentStyle);
        if (textBrush is not null && textFormat is not null && !string.IsNullOrEmpty(text))
        {
            // Lightweight layout object is created and disposed here.
            using var textLayout = dwriteFactory.CreateTextLayout(text, textFormat, finalBounds.Width, finalBounds.Height);

            textLayout.TextAlignment = textAlignment.Horizontal switch
            {
                HAlignment.Left => TextAlignment.Leading,
                HAlignment.Center => TextAlignment.Center,
                HAlignment.Right => TextAlignment.Trailing,
                _ => TextAlignment.Leading
            };
            textLayout.ParagraphAlignment = textAlignment.Vertical switch
            {
                VAlignment.Top => ParagraphAlignment.Near,
                VAlignment.Center => ParagraphAlignment.Center,
                VAlignment.Bottom => ParagraphAlignment.Far,
                _ => ParagraphAlignment.Near
            };

            var drawOrigin = new Vector2(finalBounds.X + textOffset.X, finalBounds.Y + textOffset.Y);
            renderTarget.DrawTextLayout(drawOrigin, textLayout, textBrush);
        }

        return wasClickedThisFrame;
    }
}
</file>

<file path="Core\UI.Widgets.cs">
using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

public static partial class UI
{
    // --- Widgets ---
    public static bool Button(string id, ButtonDefinition definition)
    {
        if (!IsContextValid() || definition is null) return false;
        Button buttonInstance = GetOrCreateElement<Button>(id);
        Vector2 elementPosition = ApplyLayout(definition.Position);
        buttonInstance.Position = elementPosition;
        ApplyButtonDefinition(buttonInstance, definition);

        bool pushedClip = false;
        Rect cellClipRect = Rect.Empty;
        if (IsInLayoutContainer())
        {
            if (containerStack.Peek() is GridContainerState grid)
            {
                float clipStartY = grid.CurrentDrawPosition.Y; float gridBottomY = grid.StartPosition.Y + grid.AvailableSize.Y;
                float clipHeight = Math.Max(0f, gridBottomY - clipStartY);
                cellClipRect = new Rect(grid.CurrentDrawPosition.X, clipStartY, Math.Max(0f, grid.CellWidth), clipHeight);
                if (CurrentRenderTarget is not null && cellClipRect.Width > 0 && cellClipRect.Height > 0)
                { CurrentRenderTarget.PushAxisAlignedClip(cellClipRect, D2D.AntialiasMode.Aliased); pushedClip = true; }
            }
        }

        bool clicked = buttonInstance.Update(id);
        if (pushedClip && CurrentRenderTarget is not null)
        { CurrentRenderTarget.PopAxisAlignedClip(); }

        AdvanceLayout(buttonInstance.Size);
        return clicked;
    }

    public static float HSlider(string id, float currentValue, SliderDefinition definition)
    {
        if (!IsContextValid() || definition is null) return currentValue;
        InternalHSliderLogic sliderInstance = GetOrCreateElement<InternalHSliderLogic>(id);
        Vector2 elementPosition = ApplyLayout(definition.Position);
        sliderInstance.Position = elementPosition;
        ApplySliderDefinition(sliderInstance, definition);
        sliderInstance.Direction = definition.HorizontalDirection;

        bool pushedClip = false;
        Rect cellClipRect = Rect.Empty;
        if (IsInLayoutContainer())
        {
            if (containerStack.Peek() is GridContainerState grid)
            {
                float clipStartY = grid.CurrentDrawPosition.Y; float gridBottomY = grid.StartPosition.Y + grid.AvailableSize.Y;
                float clipHeight = Math.Max(0f, gridBottomY - clipStartY);
                cellClipRect = new Rect(grid.CurrentDrawPosition.X, clipStartY, Math.Max(0f, grid.CellWidth), clipHeight);
                if (CurrentRenderTarget is not null && cellClipRect.Width > 0 && cellClipRect.Height > 0)
                { CurrentRenderTarget.PushAxisAlignedClip(cellClipRect, D2D.AntialiasMode.Aliased); pushedClip = true; }
            }
        }

        float newValue = sliderInstance.UpdateAndDraw(id, CurrentInputState, GetCurrentDrawingContext(), currentValue);
        if (pushedClip && CurrentRenderTarget is not null)
        { CurrentRenderTarget.PopAxisAlignedClip(); }

        AdvanceLayout(sliderInstance.Size);
        return newValue;
    }

    public static float VSlider(string id, float currentValue, SliderDefinition definition)
    {
        if (!IsContextValid() || definition is null) return currentValue;
        InternalVSliderLogic sliderInstance = GetOrCreateElement<InternalVSliderLogic>(id);
        Vector2 elementPosition = ApplyLayout(definition.Position);
        sliderInstance.Position = elementPosition;
        ApplySliderDefinition(sliderInstance, definition);
        sliderInstance.Direction = definition.VerticalDirection;

        bool pushedClip = false;
        Rect cellClipRect = Rect.Empty;
        if (IsInLayoutContainer())
        {
            if (containerStack.Peek() is GridContainerState grid)
            {
                float clipStartY = grid.CurrentDrawPosition.Y; float gridBottomY = grid.StartPosition.Y + grid.AvailableSize.Y;
                float clipHeight = Math.Max(0f, gridBottomY - clipStartY);
                cellClipRect = new Rect(grid.CurrentDrawPosition.X, clipStartY, Math.Max(0f, grid.CellWidth), clipHeight);
                if (CurrentRenderTarget is not null && cellClipRect.Width > 0 && cellClipRect.Height > 0)
                { CurrentRenderTarget.PushAxisAlignedClip(cellClipRect, D2D.AntialiasMode.Aliased); pushedClip = true; }
            }
        }

        float newValue = sliderInstance.UpdateAndDraw(id, CurrentInputState, GetCurrentDrawingContext(), currentValue);
        if (pushedClip && CurrentRenderTarget is not null)
        { CurrentRenderTarget.PopAxisAlignedClip(); }

        AdvanceLayout(sliderInstance.Size);

        return newValue;
    }

    public static void Tree<T>(string id, TreeNode<T> root, out TreeNode<T>? clickedNode, TreeStyle? style = null)
    {
        if (!IsContextValid() || root is null) { clickedNode = null; return; }

        clickedNode = null;
        var treeStyle = style ?? GetOrCreateElement<TreeStyle>(id + "_style");

        BeginTree(id, treeStyle);
        ProcessTreeNodeRecursive(id.GetHashCode(), 0, root, ref clickedNode);
        EndTree();
    }

    private static void ProcessTreeNodeRecursive<T>(int parentIdHash, int index, TreeNode<T> node, ref TreeNode<T>? clickedNode)
    {
        if (treeStateStack.Count == 0) return;
        var treeState = treeStateStack.Peek();
        var style = treeState.Style;
        var renderTarget = CurrentRenderTarget!;

        // --- Get current position and draw hierarchy lines ---
        var startLayoutPos = GetCurrentLayoutPositionInternal();
        var brush = GetOrCreateBrush(style.LineColor);
        if (brush is not null)
        {
            // Draw vertical lines for prior indent levels
            int i = 0;
            foreach (var shouldDrawLine in treeState.IndentLineState)
            {
                if (shouldDrawLine)
                {
                    float x = startLayoutPos.X + (i * style.Indent) + (style.Indent * 0.5f);
                    renderTarget.DrawLine(new Vector2(x, startLayoutPos.Y), new Vector2(x, startLayoutPos.Y + style.RowHeight), brush, 1.0f);
                }
                i++;
            }

            // Draw horizontal line for the current node itself
            if (treeState.IndentLineState.Count > 0)
            {
                float hLineXStart = startLayoutPos.X + ((treeState.IndentLineState.Count - 1) * style.Indent) + (style.Indent * 0.5f);
                float hLineY = startLayoutPos.Y + style.RowHeight * 0.5f;
                renderTarget.DrawLine(new Vector2(hLineXStart, hLineY), new Vector2(hLineXStart + style.Indent * 0.5f, hLineY), brush, 1.0f);
            }
        }

        // --- Manually lay out the node row ---
        float indentSize = treeState.IndentLineState.Count * style.Indent;
        var nodeRowStartPos = startLayoutPos + new Vector2(indentSize, 0);
        float currentX = nodeRowStartPos.X;
        float gap = 5;

        // --- ID Generation (Allocation-free) ---
        int nodeHash = node.GetHashCode();
        int toggleId = HashCode.Combine(parentIdHash, index, nodeHash, 0);
        int labelId = HashCode.Combine(parentIdHash, index, nodeHash, 1);


        // --- Toggle Button ---
        float toggleWidth = style.RowHeight - 4;
        if (node.Children.Count > 0)
        {
            var bounds = new Rect(currentX, nodeRowStartPos.Y, toggleWidth, style.RowHeight);
            if (StatelessButton(toggleId, bounds, node.IsExpanded ? "-" : "+", style.ToggleStyle, new Alignment(HAlignment.Center, VAlignment.Center), DirectUI.Button.ActionMode.Release))
            {
                node.IsExpanded = !node.IsExpanded;
            }
        }
        currentX += toggleWidth;

        // --- Label Button ---
        currentX += gap; // Add gap before the label
        var labelStyle = style.NodeLabelStyle;
        var labelTextAlignment = new Alignment(HAlignment.Left, VAlignment.Center);
        float labelMargin = 4;
        var labelSize = MeasureText(CurrentDWriteFactory!, node.Text, labelStyle.Normal);
        float labelWidth = labelSize.X + labelMargin * 2;
        var labelOffset = new Vector2(labelMargin, 0);

        var labelBounds = new Rect(currentX, nodeRowStartPos.Y, labelWidth, style.RowHeight);
        if (StatelessButton(labelId, labelBounds, node.Text, labelStyle, labelTextAlignment, DirectUI.Button.ActionMode.Press, textOffset: labelOffset))
        {
            clickedNode = node;
        }
        currentX += labelWidth;

        // --- Advance parent layout ---
        float totalWidth = (currentX - nodeRowStartPos.X);
        AdvanceLayout(new Vector2(totalWidth, style.RowHeight));

        // --- Recurse if expanded ---
        if (node.IsExpanded && node.Children.Count > 0)
        {
            for (int childIdx = 0; childIdx < node.Children.Count; childIdx++)
            {
                bool isLastChild = childIdx == node.Children.Count - 1;
                treeState.IndentLineState.Push(!isLastChild); // Don't draw vertical line past the last child
                ProcessTreeNodeRecursive(toggleId, childIdx, node.Children[childIdx], ref clickedNode); // Pass parent's unique int ID
                treeState.IndentLineState.Pop();
            }
        }
    }
}
</file>

<file path="Diagnostics\FpsCounter.cs">
using System;
using System.Diagnostics;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;
using DW = Vortice.DirectWrite;

namespace DirectUI.Diagnostics;

public class FpsCounter
{
    // Configuration
    private readonly Color4 _textColor = DefaultTheme.Text;
    private readonly string _fontName = "Consolas";
    private readonly float _fontSize = 14.0f;
    private const long FpsUpdateIntervalTicks = TimeSpan.TicksPerSecond / 2; // Update twice a second

    // State
    private readonly Stopwatch _timer = new();
    private long _lastUpdateTimeTicks = 0;
    private int _frameCountSinceUpdate = 0;
    private float _currentFps = 0.0f;

    // Direct2D Resources
    private ID2D1SolidColorBrush? _textBrush;
    private IDWriteTextFormat? _textFormat;

    public void Initialize(ID2D1RenderTarget renderTarget, IDWriteFactory dwriteFactory)
    {
        ArgumentNullException.ThrowIfNull(renderTarget);
        ArgumentNullException.ThrowIfNull(dwriteFactory);

        Cleanup(); // Ensure any old resources are released

        try
        {
            _textFormat = dwriteFactory.CreateTextFormat(_fontName, null, FontWeight.Normal, FontStyle.Normal, FontStretch.Normal, _fontSize, "en-us");
            _textFormat.TextAlignment = DW.TextAlignment.Leading;
            _textFormat.ParagraphAlignment = ParagraphAlignment.Near;

            _textBrush = renderTarget.CreateSolidColorBrush(_textColor);

            Console.WriteLine("Created FPS drawing resources.");

            _frameCountSinceUpdate = 0;
            _currentFps = 0;
            _lastUpdateTimeTicks = 0;
            _timer.Restart();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Warning: Failed to create FPS counter drawing resources: {ex.Message}");
            Cleanup(); // Clean up partial resources on failure
        }
    }

    public void Cleanup()
    {
        _timer.Stop();
        _textBrush?.Dispose();
        _textBrush = null;
        _textFormat?.Dispose();
        _textFormat = null;
    }

    public void HandleResize(ID2D1RenderTarget renderTarget)
    {
        // The text format is device-independent, but the brush is not.
        _textBrush?.Dispose();
        _textBrush = null;
        try
        {
            if (renderTarget is not null)
            {
                _textBrush = renderTarget.CreateSolidColorBrush(_textColor);
                Console.WriteLine("Recreated FPS brush after resize.");
            }
        }
        catch (Exception brushEx)
        {
            Console.WriteLine($"Warning: Failed to recreate FPS brush after resize: {brushEx.Message}");
        }
    }

    public bool Update()
    {
        if (!_timer.IsRunning)
        {
            _timer.Start();
            _lastUpdateTimeTicks = _timer.ElapsedTicks;
            _frameCountSinceUpdate = 0;
        }

        _frameCountSinceUpdate++;
        long elapsedTicks = _timer.ElapsedTicks;
        long timeSinceLastUpdate = elapsedTicks - _lastUpdateTimeTicks;

        if (timeSinceLastUpdate >= FpsUpdateIntervalTicks)
        {
            float secondsElapsed = (float)timeSinceLastUpdate / TimeSpan.TicksPerSecond;
            _currentFps = (secondsElapsed > 0.001f) ? (_frameCountSinceUpdate / secondsElapsed) : 0.0f;
            _frameCountSinceUpdate = 0;
            _lastUpdateTimeTicks = elapsedTicks;
            return true; // Indicates the text has changed, so a redraw is needed.
        }

        return false;
    }

    public void Draw(ID2D1RenderTarget renderTarget)
    {
        if (_textBrush is null || _textFormat is null)
        {
            return;
        }

        string fpsText = $"FPS: {_currentFps:F1}";
        var layoutRect = new Rect(5f, 5f, 150f, 30f);
        renderTarget.DrawText(fpsText, _textFormat, layoutRect, _textBrush);
    }
}
</file>

<file path="Styles\BoxStyle.cs">
// MODIFIED: Styles/BoxStyle.cs
// Summary: Replaced BorderThickness with BorderLengthTop, BorderLengthRight, BorderLengthBottom, BorderLengthLeft. Added convenience setter BorderLength.
using Vortice.Mathematics;

namespace DirectUI;

public class BoxStyle
{
    public float Roundness { get; set; } = 0.2f;
    public Color4 FillColor { get; set; } = DefaultTheme.NormalFill;
    public Color4 BorderColor { get; set; } = DefaultTheme.NormalBorder;

    public float BorderLengthTop { get; set; } = 1.0f;
    public float BorderLengthRight { get; set; } = 1.0f;
    public float BorderLengthBottom { get; set; } = 1.0f;
    public float BorderLengthLeft { get; set; } = 1.0f;

    public float BorderLength
    {
        set
        {
            BorderLengthTop = value;
            BorderLengthRight = value;
            BorderLengthBottom = value;
            BorderLengthLeft = value;
        }
    }
}
</file>

<file path="Styles\ButtonStyle.cs">
// ButtonStyle.cs
using Vortice.Mathematics;
using Vortice.DirectWrite; // For Font related enums eventually

namespace DirectUI;

public class ButtonStyle : BoxStyle
{
    // DirectWrite Font properties will be managed elsewhere (e.g., IDWriteTextFormat)
    // public float FontSpacing { get; set; } = 0; // Handled by TextFormat
    // public float FontSize { get; set; } = 16; // Handled by TextFormat
    // public Font? Font { get; set; } = null; // Represented by TextFormat
    public Color4 FontColor { get; set; } = DefaultTheme.Text;

    // Properties needed for creating IDWriteTextFormat
    public string FontName { get; set; } = "Segoe UI";
    public float FontSize { get; set; } = 16.0f;
    public FontWeight FontWeight { get; set; } = FontWeight.Normal;
    public FontStyle FontStyle { get; set; } = FontStyle.Normal;
    public FontStretch FontStretch { get; set; } = FontStretch.Normal;
}
</file>

<file path="Styles\ButtonStylePack.cs">
// MODIFIED: Styles/ButtonStylePack.cs
// Summary: Updated BorderThickness convenience setter to use the new BorderLength setter in BoxStyle. Added Obsolete attribute to BorderThickness.
using System.Collections.Generic;
using System;
using Vortice.Mathematics;
using Vortice.DirectWrite;

namespace DirectUI;

public sealed class ButtonStylePack
{
    public ButtonStyle Current { get; private set; }
    public ButtonStyle Normal { get; set; } = new();
    public ButtonStyle Hover { get; set; } = new();
    public ButtonStyle Pressed { get; set; } = new();
    public ButtonStyle Disabled { get; set; } = new();
    // public ButtonStyle Focused { get; set; } = new(); // Focus state not implemented yet

    public ButtonStylePack()
    {
        Hover.FillColor = DefaultTheme.HoverFill;
        Hover.BorderColor = DefaultTheme.HoverBorder;

        Pressed.FillColor = DefaultTheme.Accent;
        Pressed.BorderColor = DefaultTheme.AccentBorder;

        Disabled.FillColor = DefaultTheme.DisabledFill;
        Disabled.BorderColor = DefaultTheme.DisabledBorder;
        Disabled.FontColor = DefaultTheme.DisabledText;

        Current = Normal;
    }

    public void UpdateCurrentStyle(bool isHovering, bool isPressed, bool isDisabled /*, bool isFocused */)
    {
        if (isDisabled)
        {
            Current = Disabled;
        }
        else if (isPressed)
        {
            Current = Pressed;
        }
        else if (isHovering)
        {
            Current = Hover;
        }
        //else if (isFocused) // Future focus state
        //{
        //    Current = Focused;
        //}
        else
        {
            Current = Normal;
        }
    }

    private IEnumerable<ButtonStyle> AllStyles => [Normal, Hover, Pressed, Disabled /*, Focused*/];

    public string FontName
    {
        set => SetAll(s => s.FontName = value);
    }

    public float FontSize
    {
        set => SetAll(s => s.FontSize = value);
    }

    public FontWeight FontWeight
    {
        set => SetAll(s => s.FontWeight = value);
    }

    public FontStyle FontStyle
    {
        set => SetAll(s => s.FontStyle = value);
    }

    public FontStretch FontStretch
    {
        set => SetAll(s => s.FontStretch = value);
    }

    public Color4 FontColor
    {
        set => SetAll(s => s.FontColor = value);
    }

    public float Roundness
    {
        set => SetAll(s => s.Roundness = value);
    }

    // Updated setter
    public float BorderLength
    {
        set => SetAll(s => s.BorderLength = value);
    }

    // Obsolete - kept for backward compatibility or remove if breaking change is ok
    [Obsolete("Use BorderLength instead.")]
    public float BorderThickness
    {
        set => SetAll(s => s.BorderLength = value);
    }

    public Color4 FillColor
    {
        set => SetAll(s => s.FillColor = value);
    }

    public Color4 BorderColor
    {
        set => SetAll(s => s.BorderColor = value);
    }

    private void SetAll(Action<ButtonStyle> setter)
    {
        foreach (ButtonStyle style in AllStyles)
        {
            setter(style);
        }
        // Update Current directly after modifying the source styles
        // No need to call setter(Current) separately if UpdateCurrentStyle is called later.
        // If UpdateCurrentStyle might not be called, uncommenting setter(Current) ensures immediate consistency.
        // setter(Current);
    }
}
</file>

<file path="Styles\DefaultTheme.cs">
// DefaultTheme.cs
using Vortice.Mathematics;

namespace DirectUI;

// Defines default colors for the UI theme
public static class DefaultTheme
{
    // --- Theme Color Definitions ---

    private static class Ue5ThemeColors
    {
        // Palette based on Unreal Engine 5 Editor
        public static readonly Color4 Fill = new Color4(42 / 255f, 42 / 255f, 42 / 255f, 1.0f);        // #2A2A2A
        public static readonly Color4 FillLighter = new Color4(58 / 255f, 58 / 255f, 58 / 255f, 1.0f);  // #3A3A3A
        public static readonly Color4 Border = new Color4(21 / 255f, 21 / 255f, 21 / 255f, 1.0f);      // #151515 (Matches window background)

        // --- CHANGE HERE ---
        // Changed from blue to a light gray for a more authentic UE5 feel.
        public static readonly Color4 Hover = new Color4(160 / 255f, 160 / 255f, 160 / 255f, 1.0f);   // #A0A0A0
        // --- END CHANGE ---

        public static readonly Color4 Accent = new Color4(255 / 255f, 171 / 255f, 0 / 255f, 1.0f);     // Orange #FFAB00
        public static readonly Color4 AccentBorder = new Color4(255 / 255f, 187 / 255f, 51 / 255f, 1.0f); // Lighter Orange

        public static readonly Color4 DisabledFill = new Color4(32 / 255f, 32 / 255f, 32 / 255f, 0.8f);
        public static readonly Color4 DisabledBorder = new Color4(48 / 255f, 48 / 255f, 48 / 255f, 0.8f);
        public static readonly Color4 DisabledText = new Color4(128 / 255f, 128 / 255f, 128 / 255f, 1.0f);

        public static readonly Color4 Text = new Color4(240 / 255f, 240 / 255f, 240 / 255f, 1.0f);     // #F0F0F0
    }

    private static class OriginalColors
    {
        public static readonly Color4 NormalFill = new Color4(0.25f, 0.25f, 0.3f, 1.0f);
        public static readonly Color4 NormalBorder = new Color4(0.4f, 0.4f, 0.45f, 1.0f);
        public static readonly Color4 HoverFill = new Color4(0.35f, 0.35f, 0.4f, 1.0f);
        public static readonly Color4 HoverBorder = new Color4(0.5f, 0.5f, 0.55f, 1.0f);
        public static readonly Color4 Accent = new Color4(0.2f, 0.4f, 0.8f, 1.0f);
        public static readonly Color4 AccentBorder = new Color4(0.3f, 0.5f, 0.9f, 1.0f);
        public static readonly Color4 DisabledFill = new Color4(0.2f, 0.2f, 0.2f, 0.8f);
        public static readonly Color4 DisabledBorder = new Color4(0.3f, 0.3f, 0.3f, 0.8f);
        public static readonly Color4 DisabledText = new Color4(0.5f, 0.5f, 0.5f, 1.0f);
        public static readonly Color4 Text = Colors.WhiteSmoke;
    }


    // --- Current Active Theme ---
    // Change the assignments here to swap themes.

    // Basic Palette
    public static readonly Color4 White = Colors.White;
    public static readonly Color4 Black = Colors.Black;
    public static readonly Color4 Transparent = Colors.Transparent;

    // --- ACTIVE THEME: UE5 ---
    public static readonly Color4 NormalFill = Ue5ThemeColors.Fill;
    public static readonly Color4 NormalBorder = Ue5ThemeColors.Border;
    public static readonly Color4 HoverFill = Ue5ThemeColors.FillLighter;    // Subtle gray change for hover fill
    public static readonly Color4 HoverBorder = Ue5ThemeColors.Hover;        // Light gray border on hover
    public static readonly Color4 Accent = Ue5ThemeColors.Accent;            // Orange accent for pressed
    public static readonly Color4 AccentBorder = Ue5ThemeColors.AccentBorder;
    public static readonly Color4 DisabledFill = Ue5ThemeColors.DisabledFill;
    public static readonly Color4 DisabledBorder = Ue5ThemeColors.DisabledBorder;
    public static readonly Color4 DisabledText = Ue5ThemeColors.DisabledText;
    public static readonly Color4 FocusBorder = Ue5ThemeColors.Hover;        // Use gray for focus
    public static readonly Color4 Text = Ue5ThemeColors.Text;

    /*
    // --- BACKUP THEME: Original ---
    // To restore the original theme, comment out the "UE5" block above
    // and uncomment this block below.
    public static readonly Color4 NormalFill = OriginalColors.NormalFill;
    public static readonly Color4 NormalBorder = OriginalColors.NormalBorder;
    public static readonly Color4 HoverFill = OriginalColors.HoverFill;
    public static readonly Color4 HoverBorder = OriginalColors.HoverBorder;
    public static readonly Color4 Accent = OriginalColors.Accent;
    public static readonly Color4 AccentBorder = OriginalColors.AccentBorder;
    public static readonly Color4 DisabledFill = OriginalColors.DisabledFill;
    public static readonly Color4 DisabledBorder = OriginalColors.DisabledBorder;
    public static readonly Color4 DisabledText = OriginalColors.DisabledText;
    public static readonly Color4 FocusBorder = Colors.LightSkyBlue;
    public static readonly Color4 Text = OriginalColors.Text;
    */
}
</file>

<file path="Styles\SliderStyle.cs">
// MODIFIED: Styles/SliderStyle.cs
// Summary: Updated default BoxStyle initializations to use BorderLength instead of BorderThickness.
using Vortice.Mathematics;

namespace DirectUI;

public class SliderStyle
{
    public BoxStyle Background { get; set; } = new()
    {
        FillColor = DefaultTheme.DisabledFill,
        BorderColor = DefaultTheme.NormalBorder,
        Roundness = 0.5f,
        BorderLength = 1.0f // Use new property
    };

    public BoxStyle Foreground { get; set; } = new()
    {
        FillColor = DefaultTheme.Accent,
        BorderColor = Colors.Transparent,
        Roundness = 0.5f,
        BorderLength = 0.0f // Use new property
    };
}
</file>

<file path="Styles\TreeStyle.cs">
using DirectUI;
using Vortice.Mathematics;

namespace DirectUI;

public class TreeStyle
{
    public float Indent { get; set; } = 19f;
    public float RowHeight { get; set; } = 22f;
    public Color4 LineColor { get; set; } = DefaultTheme.HoverBorder;
    public ButtonStylePack ToggleStyle { get; set; }
    public ButtonStylePack NodeLabelStyle { get; set; }

    public TreeStyle()
    {
        ToggleStyle = new ButtonStylePack
        {
            Roundness = 0.2f,
            BorderLength = 1f,
            FontName = "Consolas",
            FontSize = 14
        };
        ToggleStyle.Normal.FillColor = DefaultTheme.NormalFill;
        ToggleStyle.Normal.BorderColor = DefaultTheme.NormalBorder;
        ToggleStyle.Hover.FillColor = DefaultTheme.HoverFill;
        ToggleStyle.Hover.BorderColor = DefaultTheme.HoverBorder;
        ToggleStyle.Pressed.FillColor = DefaultTheme.Accent;
        ToggleStyle.Pressed.BorderColor = DefaultTheme.AccentBorder;

        NodeLabelStyle = new ButtonStylePack
        {
            Roundness = 0f,
            BorderLength = 0f,
            FontName = "Segoe UI",
            FontSize = 14
        };
        NodeLabelStyle.Normal.FillColor = Colors.Transparent;
        NodeLabelStyle.Normal.FontColor = DefaultTheme.Text;
        NodeLabelStyle.Hover.FillColor = new Color4(0.25f, 0.25f, 0.25f, 0.5f); // Semi-transparent gray
        NodeLabelStyle.Hover.FontColor = DefaultTheme.Text;
        NodeLabelStyle.Pressed.FillColor = DefaultTheme.Accent;
        NodeLabelStyle.Pressed.FontColor = Colors.White;
        NodeLabelStyle.Pressed.BorderColor = DefaultTheme.AccentBorder;
    }
}
</file>

<file path="Widgets\Button.cs">
namespace DirectUI;

using System;
using System.Numerics;
using Vortice.DirectWrite;
using Vortice.Mathematics;
using Vortice.Direct2D1;
using SharpGen.Runtime;

public class Button
{
    public enum ActionMode { Release, Press }
    public enum ClickBehavior { Left, Right, Both }

    // --- Properties ---
    public Vector2 Position { get; set; } = Vector2.Zero;
    public Vector2 Size { get; set; } = new(84, 28);
    public Vector2 Origin { get; set; } = Vector2.Zero;
    public string Text { get; set; } = "";
    public Vector2 TextOffset { get; set; } = Vector2.Zero;
    public Alignment TextAlignment { get; set; } = new(HAlignment.Center, VAlignment.Center);
    public ButtonStylePack Themes { get; set; } = new();
    public ActionMode LeftClickActionMode { get; set; } = ActionMode.Release;
    public bool AutoWidth { get; set; } = false;
    public Vector2 TextMargin { get; set; } = new(10, 5);
    public ClickBehavior Behavior { get; set; } = Button.ClickBehavior.Left;
    public bool Disabled { get; set; } = false;
    public object? UserData { get; set; } = null;

    public bool IsHovering { get; internal set; } = false;

    public Rect GlobalBounds
    {
        get
        {
            float x = Position.X - Origin.X;
            float y = Position.Y - Origin.Y;
            float width = Math.Max(0, Size.X);
            float height = Math.Max(0, Size.Y);
            Rect calculatedBounds = new(x, y, width, height);

            return calculatedBounds;
        }
    }

    private bool isPressed = false;


    internal bool Update(string id)
    {
        ID2D1HwndRenderTarget? renderTarget = UI.CurrentRenderTarget;
        IDWriteFactory? dwriteFactory = UI.CurrentDWriteFactory;
        InputState input = UI.CurrentInputState;
        var intId = id.GetHashCode();

        if (renderTarget is null || dwriteFactory is null)
        {
            return false;
        }

        // --- Sizing (MUST be done before hit-testing) ---
        // This is now independent of hover/press state and ensures correct bounds.
        PerformAutoWidth(dwriteFactory);

        // --- Input Logic & State Update ---
        bool wasClickedThisFrame = false;
        isPressed = false; // Reset visual pressed state for the frame

        if (Disabled)
        {
            IsHovering = false;
            if (UI.ActivelyPressedElementId == intId)
            {
                UI.ClearActivePress(intId);
            }
        }
        else // Element is Enabled
        {
            Rect bounds = GlobalBounds; // NOW uses correct size from AutoWidth

            IsHovering = bounds.Width > 0 && bounds.Height > 0 && bounds.Contains(input.MousePosition.X, input.MousePosition.Y);

            if (IsHovering)
            {
                UI.SetPotentialInputTarget(intId);
            }

            // Determine relevant actions based on behavior
            bool primaryActionHeld = (Behavior is ClickBehavior.Left or ClickBehavior.Both) && input.IsLeftMouseDown;
            bool primaryActionPressedThisFrame = (Behavior is ClickBehavior.Left or ClickBehavior.Both) && input.WasLeftMousePressedThisFrame;
            // Add Right button logic here if Behavior.Right/Both is implemented fully

            // Handle Release Action
            if (!primaryActionHeld && UI.ActivelyPressedElementId == intId)
            {
                if (IsHovering && LeftClickActionMode is ActionMode.Release)
                {
                    wasClickedThisFrame = true;
                }
                UI.ClearActivePress(intId); // Clear press regardless of hover on release
            }

            // Handle Press Attempt (potential capture)
            if (primaryActionPressedThisFrame)
            {
                // Can only capture press if hovered, it's the potential target, and no drag was already in progress from a previous frame
                if (IsHovering && UI.PotentialInputTargetId == intId && !UI.dragInProgressFromPreviousFrame)
                {
                    // Attempt to capture input - this overwrites previous captors for the frame
                    UI.SetButtonPotentialCaptorForFrame(intId);
                }
            }

            // Determine visual pressed state for this frame (is it the element currently held down?)
            isPressed = (UI.ActivelyPressedElementId == intId);

        } // End Enabled block

        // --- Final Style Update & Drawing ---
        UpdateStyle(); // Update style based on the now-calculated states

        try
        {
            Rect currentBounds = GlobalBounds; // Bounds are now final for this frame

            if (currentBounds.Width > 0 && currentBounds.Height > 0)
            {
                DrawBackground(renderTarget);
                DrawText(renderTarget, dwriteFactory);
            }
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == ResultCode.RecreateTarget.Code)
        {
            // Retained log message for recoverable graphics issue.
            Console.WriteLine($"Render target needs recreation during Button draw: {ex.Message}");
            UI.CleanupResources(); // Clear brushes which are now invalid
            return false; // Cannot continue drawing
        }
        catch (Exception ex)
        {
            // Retained log message for unexpected error.
            Console.WriteLine($"Error drawing button {id}: {ex}");
            return false; // Indicate error
        }


        // --- Final Click Determination (for Press mode) ---
        // Click happens now if mode is Press AND this button was the final input captor for the frame.
        if (!wasClickedThisFrame && LeftClickActionMode is ActionMode.Press && UI.InputCaptorId == intId)
        {
            wasClickedThisFrame = true;
        }

        return wasClickedThisFrame;
    }

    internal void UpdateStyle()
    {
        Themes?.UpdateCurrentStyle(IsHovering, isPressed, Disabled);
    }

    internal void PerformAutoWidth(IDWriteFactory dwriteFactory)
    {
        if (!AutoWidth || dwriteFactory is null || Themes is null)
        {
            return;
        }

        // Always measure using the Normal theme to ensure consistent size across states.
        Vector2 textSize = UI.MeasureText(dwriteFactory, Text, Themes.Normal);
        float desiredWidth = textSize.X + TextMargin.X * 2; // Add horizontal margins

        // Use a small epsilon to avoid floating point jitter
        if (desiredWidth > 0 && Math.Abs(Size.X - desiredWidth) > 0.1f)
        {
            Size = new Vector2(desiredWidth, Size.Y);
        }
        else if (desiredWidth <= 0 && Size.X != 0)
        {
            // Optional: Handle case where text becomes empty - maybe reset to a MinWidth?
            // For now, do nothing, keeping potentially previous non-zero width.
        }
    }

    private void DrawBackground(ID2D1RenderTarget renderTarget)
    {
        Rect bounds = GlobalBounds;
        ButtonStyle? style = Themes?.Current;

        // Early exit if nothing to draw
        if (style is null || bounds.Width <= 0 || bounds.Height <= 0)
        {
            return;
        }

        UI.DrawBoxStyleHelper(renderTarget, new Vector2(bounds.X, bounds.Y), new Vector2(bounds.Width, bounds.Height), style);
    }

    private void DrawText(ID2D1RenderTarget renderTarget, IDWriteFactory dwriteFactory)
    {
        if (string.IsNullOrEmpty(Text)) return;
        ButtonStyle? style = Themes?.Current;
        if (style is null) return;

        ID2D1SolidColorBrush textBrush = UI.GetOrCreateBrush(style.FontColor);
        if (textBrush is null) return;

        IDWriteTextFormat? textFormat = UI.GetOrCreateTextFormat(style);
        if (textFormat is null) return;

        IDWriteTextLayout? textLayout = null;
        try
        {
            Rect bounds = GlobalBounds;
            if (bounds.Width <= 0 || bounds.Height <= 0) return;

            // Create a layout with the button's bounds as constraints.
            textLayout = dwriteFactory.CreateTextLayout(
                Text,
                textFormat,
                bounds.Width,
                bounds.Height
            );

            // Apply Alignment to the layout object itself.
            textLayout.TextAlignment = TextAlignment.Horizontal switch
            {
                HAlignment.Left => Vortice.DirectWrite.TextAlignment.Leading,
                HAlignment.Center => Vortice.DirectWrite.TextAlignment.Center,
                HAlignment.Right => Vortice.DirectWrite.TextAlignment.Trailing,
                _ => Vortice.DirectWrite.TextAlignment.Leading
            };
            textLayout.ParagraphAlignment = TextAlignment.Vertical switch
            {
                VAlignment.Top => ParagraphAlignment.Near,
                VAlignment.Center => ParagraphAlignment.Center,
                VAlignment.Bottom => ParagraphAlignment.Far,
                _ => ParagraphAlignment.Near
            };

            // The origin point for drawing the layout.
            var textOrigin = new Vector2(bounds.X + TextOffset.X, bounds.Y + TextOffset.Y);

            renderTarget.DrawTextLayout(
                textOrigin,
                textLayout,
                textBrush,
                DrawTextOptions.None // Clipping is handled by the layout's dimensions.
            );
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Button Text Draw failed (RecreateTarget): {ex.Message}.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error drawing button text: {ex.Message}");
        }
        finally
        {
            textLayout?.Dispose();
        }
    }
}
</file>

<file path="Widgets\ButtonDefinition.cs">
// ButtonDefinition.cs
using System.Numerics;
using Vortice.Mathematics; // For Color4 if needed directly, though ButtonStylePack handles colors

namespace DirectUI;

public class ButtonDefinition
{
    public Vector2 Position { get; set; } = Vector2.Zero;
    public Vector2 Size { get; set; } = new(84, 28); // Default size
    public string Text { get; set; } = "";
    public ButtonStylePack? Theme { get; set; } = null; // Optional theme override
    public Vector2? Origin { get; set; } = null; // Use null to indicate default (Vector2.Zero)
    public Alignment? TextAlignment { get; set; } = null; // Use null for default (Center, Center)
    public Vector2? TextOffset { get; set; } = null; // Use null for default (Vector2.Zero)
    public bool AutoWidth { get; set; } = false;
    public Vector2? TextMargin { get; set; } = null; // Use null for default (10, 5)
    public Button.ClickBehavior Behavior { get; set; } = Button.ClickBehavior.Left;
    public Button.ActionMode LeftClickActionMode { get; set; } = Button.ActionMode.Release;
    public bool Disabled { get; set; } = false;
    public object? UserData { get; set; } = null;
}
</file>

<file path="Widgets\InternalHSliderLogic.cs">
using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

internal class InternalHSliderLogic : InternalSliderLogic
{
    public HSliderDirection Direction { get; set; } = HSliderDirection.LeftToRight;

    protected override void CalculateTrackBounds()
    {
        trackMinBound = trackPosition.X;
        trackMaxBound = trackPosition.X + Size.X;
    }

    protected override float HandleInput(InputState input, float currentValue)
    {
        float newValue = currentValue;
        Vector2 mousePos = input.MousePosition;

        // 1. Calculate Hover States & Set Potential Target
        Vector2 currentGrabberPos = CalculateGrabberPosition(currentValue);
        Rect currentGrabberBounds = new Rect(currentGrabberPos.X, currentGrabberPos.Y, GrabberSize.X, GrabberSize.Y);
        isGrabberHovered = currentGrabberBounds.Contains(mousePos.X, mousePos.Y);

        Rect trackBoundsRect = new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y);
        isTrackHovered = trackBoundsRect.Contains(mousePos.X, mousePos.Y);

        bool isSliderHovered = isGrabberHovered || isTrackHovered;

        if (isSliderHovered)
        {
            UI.SetPotentialInputTarget(GlobalIntId);
        }

        // 2. Handle Mouse Release
        if (UI.ActivelyPressedElementId == GlobalIntId && !input.IsLeftMouseDown)
        {
            UI.ClearActivePress(GlobalIntId);
        }

        // 3. Handle Mouse Press Attempt
        if (input.WasLeftMousePressedThisFrame)
        {
            if (isSliderHovered && UI.PotentialInputTargetId == GlobalIntId && !UI.dragInProgressFromPreviousFrame)
            {
                UI.SetButtonPotentialCaptorForFrame(GlobalIntId);

                if (isTrackHovered && !isGrabberHovered)
                {
                    pendingTrackClickValueJump = true;
                    trackClickPosition = Math.Clamp(mousePos.X, trackMinBound, trackMaxBound);
                }
            }
        }

        // 4. Handle Mouse Held/Drag
        if (UI.ActivelyPressedElementId == GlobalIntId && input.IsLeftMouseDown)
        {
            if (!pendingTrackClickValueJump) // Only drag if not initiated by a deferred track click this frame
            {
                float clampedX = Math.Clamp(mousePos.X, trackMinBound, trackMaxBound);
                newValue = ConvertPositionToValue(clampedX);
                newValue = ApplyStep(newValue);
                newValue = Math.Clamp(newValue, MinValue, MaxValue);
            }
        }

        return newValue;
    }

    // --- Other methods unchanged ---
    protected override float ConvertPositionToValue(float position)
    {
        if (trackMaxBound <= trackMinBound) return MinValue;
        float normalized = (position - trackMinBound) / (trackMaxBound - trackMinBound);
        normalized = Math.Clamp(normalized, 0.0f, 1.0f);
        if (Direction == HSliderDirection.RightToLeft) { normalized = 1.0f - normalized; }
        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return rawValue;
    }
    protected override Vector2 CalculateGrabberPosition(float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0;
        if (Direction == HSliderDirection.RightToLeft) { normalizedValue = 1.0f - normalizedValue; }
        float trackWidth = Size.X;
        float centerX = trackMinBound + normalizedValue * trackWidth;
        float xPos = centerX - (GrabberSize.X / 2.0f);
        float yPos = trackPosition.Y + (Size.Y / 2.0f) - (GrabberSize.Y / 2.0f);
        float minX = trackPosition.X;
        float maxX = trackPosition.X + Size.X - GrabberSize.X;
        if (maxX < minX) maxX = minX;
        xPos = Math.Clamp(xPos, minX, maxX);
        return new Vector2(xPos, yPos);
    }
    protected override void DrawForeground(ID2D1RenderTarget renderTarget, float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        if (valueRange <= 0 || renderTarget is null) return;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0.0f;
        float foregroundWidth = Size.X * normalizedValue;
        if (foregroundWidth <= 0.001f) return;
        Rect clipRect;
        if (Direction == HSliderDirection.RightToLeft) { clipRect = new Rect(trackPosition.X + Size.X - foregroundWidth, trackPosition.Y, foregroundWidth, Size.Y); }
        else { clipRect = new Rect(trackPosition.X, trackPosition.Y, foregroundWidth, Size.Y); }
        renderTarget.PushAxisAlignedClip(clipRect, D2D.AntialiasMode.Aliased);
        UI.DrawBoxStyleHelper(renderTarget, trackPosition, Size, Theme.Foreground);
        renderTarget.PopAxisAlignedClip();
    }
}
</file>

<file path="Widgets\InternalSliderLogic.cs">
using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.Mathematics;

namespace DirectUI;

internal abstract class InternalSliderLogic
{
    // --- Configuration ---
    public Vector2 Position { get; set; }
    public Vector2 Size { get; set; }
    public Vector2 Origin { get; set; }
    public float MinValue { get; set; }
    public float MaxValue { get; set; }
    public float Step { get; set; }
    public SliderStyle Theme { get; set; } = new();
    public ButtonStylePack GrabberTheme { get; set; } = new();
    public Vector2 GrabberSize { get; set; } = new(16, 16);
    public bool Disabled { get; set; }
    public object? UserData { get; set; }

    // --- Internal State ---
    protected bool isGrabberPressed = false;
    protected bool isGrabberHovered = false;
    protected bool isTrackHovered = false;
    protected Vector2 trackPosition;
    protected float trackMinBound;
    protected float trackMaxBound;
    protected bool pendingTrackClickValueJump = false;
    protected float trackClickPosition = 0f;
    protected string GlobalId { get; private set; } = string.Empty;
    protected int GlobalIntId { get; private set; } = 0;


    // --- Calculated Properties ---
    public Rect GlobalBounds => new(Position.X - Origin.X, Position.Y - Origin.Y, Size.X, Size.Y);

    // --- Abstract Methods ---
    protected abstract void CalculateTrackBounds();
    protected abstract float HandleInput(InputState input, float currentValue);
    protected abstract float ConvertPositionToValue(float position);
    protected abstract Vector2 CalculateGrabberPosition(float currentValue);
    protected abstract void DrawForeground(ID2D1RenderTarget renderTarget, float currentValue);


    // --- Common Logic ---
    internal float UpdateAndDraw(string id, InputState input, DrawingContext context, float currentValue)
    {
        GlobalId = id;
        GlobalIntId = id.GetHashCode();
        trackPosition = Position - Origin;
        CalculateTrackBounds();

        pendingTrackClickValueJump = false;
        float newValue = currentValue;

        if (Disabled)
        {
            isGrabberHovered = false;
            isGrabberPressed = false;
            isTrackHovered = false;
            if (UI.ActivelyPressedElementId == GlobalIntId) UI.ClearActivePress(GlobalIntId);
        }
        else
        {
            // HandleInput sets potential target, calls SetPotentialCaptorForFrame,
            // sets pendingTrackClickValueJump, and returns value updated by DRAG.
            newValue = HandleInput(input, currentValue);
        }

        // Deferred Track Click Value Jump Check
        if (pendingTrackClickValueJump && UI.InputCaptorId == GlobalIntId && !UI.nonSliderElementClaimedPress)
        {
            newValue = ConvertPositionToValue(trackClickPosition);
            newValue = ApplyStep(newValue);
            newValue = Math.Clamp(newValue, MinValue, MaxValue);
        }
        pendingTrackClickValueJump = false;


        // Update visual style based on final state
        UpdateGrabberThemeStyle();

        if (context.RenderTarget is null)
        {
            Console.WriteLine("Error: RenderTarget is null during Slider UpdateAndDraw.");
            return newValue;
        }

        // --- Drawing ---
        try
        {
            DrawBackground(context.RenderTarget);
            DrawForeground(context.RenderTarget, newValue);
            DrawGrabber(context.RenderTarget, newValue);
        }
        catch (SharpGen.Runtime.SharpGenException ex) when (ex.ResultCode.Code == Vortice.Direct2D1.ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Slider Draw failed (RecreateTarget): {ex.Message}. External cleanup needed.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error drawing slider: {ex.Message}");
        }

        return newValue;
    }

    // --- Helper Methods ---
    protected float ApplyStep(float value)
    {
        float clampedValue = Math.Clamp(value, MinValue, MaxValue);
        if (Step <= 0 || MaxValue <= MinValue)
        {
            return clampedValue;
        }

        float range = MaxValue - MinValue;
        if (range < Step && Step > 0)
        {
            return (value - MinValue < range / 2.0f) ? MinValue : MaxValue;
        }

        float stepsFromMin = (float)Math.Round((clampedValue - MinValue) / Step);
        float steppedValue = MinValue + stepsFromMin * Step;

        return Math.Clamp(steppedValue, MinValue, MaxValue);
    }


    protected void UpdateGrabberThemeStyle()
    {
        isGrabberPressed = UI.ActivelyPressedElementId == GlobalIntId;
        GrabberTheme.UpdateCurrentStyle(isGrabberHovered, isGrabberPressed, Disabled);
    }


    // --- Drawing Methods ---
    protected void DrawBackground(ID2D1RenderTarget renderTarget)
    {
        UI.DrawBoxStyleHelper(renderTarget, trackPosition, Size, Theme.Background);
    }

    protected void DrawGrabber(ID2D1RenderTarget renderTarget, float currentValue)
    {
        Vector2 grabberPos = CalculateGrabberPosition(currentValue);
        UI.DrawBoxStyleHelper(renderTarget, grabberPos, GrabberSize, GrabberTheme.Current);
    }
}
</file>

<file path="Widgets\InternalVSlider.cs">
using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

internal class InternalVSliderLogic : InternalSliderLogic
{
    public VSliderDirection Direction { get; set; } = VSliderDirection.TopToBottom;

    protected override void CalculateTrackBounds()
    {
        trackMinBound = trackPosition.Y;
        trackMaxBound = trackPosition.Y + Size.Y;
    }

    protected override float HandleInput(InputState input, float currentValue)
    {
        float newValue = currentValue;
        Vector2 mousePos = input.MousePosition;

        // 1. Calculate Hover States & Set Potential Target
        Vector2 currentGrabberPos = CalculateGrabberPosition(currentValue);
        Rect currentGrabberBounds = new Rect(currentGrabberPos.X, currentGrabberPos.Y, GrabberSize.X, GrabberSize.Y);
        isGrabberHovered = currentGrabberBounds.Contains(mousePos.X, mousePos.Y);

        Rect trackBoundsRect = new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y);
        isTrackHovered = trackBoundsRect.Contains(mousePos.X, mousePos.Y);

        bool isSliderHovered = isGrabberHovered || isTrackHovered;

        if (isSliderHovered)
        {
            UI.SetPotentialInputTarget(GlobalIntId);
        }

        // 2. Handle Mouse Release
        if (UI.ActivelyPressedElementId == GlobalIntId && !input.IsLeftMouseDown)
        {
            UI.ClearActivePress(GlobalIntId);
        }

        // 3. Handle Mouse Press Attempt
        if (input.WasLeftMousePressedThisFrame)
        {
            if (isSliderHovered && UI.PotentialInputTargetId == GlobalIntId && !UI.dragInProgressFromPreviousFrame)
            {
                UI.SetButtonPotentialCaptorForFrame(GlobalIntId);

                if (isTrackHovered && !isGrabberHovered)
                {
                    pendingTrackClickValueJump = true;
                    trackClickPosition = Math.Clamp(mousePos.Y, trackMinBound, trackMaxBound);
                }
            }
        }

        // 4. Handle Mouse Held/Drag
        if (UI.ActivelyPressedElementId == GlobalIntId && input.IsLeftMouseDown)
        {
            if (!pendingTrackClickValueJump) // Only drag if not initiated by a deferred track click this frame
            {
                float clampedY = Math.Clamp(mousePos.Y, trackMinBound, trackMaxBound);
                newValue = ConvertPositionToValue(clampedY);
                newValue = ApplyStep(newValue);
                newValue = Math.Clamp(newValue, MinValue, MaxValue);
            }
        }

        return newValue;
    }

    // --- Other methods unchanged ---
    protected override float ConvertPositionToValue(float position)
    {
        if (trackMaxBound <= trackMinBound) return MinValue;
        float normalized = (position - trackMinBound) / (trackMaxBound - trackMinBound);
        normalized = Math.Clamp(normalized, 0.0f, 1.0f);
        if (Direction == VSliderDirection.BottomToTop) { normalized = 1.0f - normalized; }
        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return rawValue;
    }
    protected override Vector2 CalculateGrabberPosition(float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0;
        if (Direction == VSliderDirection.BottomToTop) { normalizedValue = 1.0f - normalizedValue; }
        float trackHeight = Size.Y;
        float centerY = trackMinBound + normalizedValue * trackHeight;
        float yPos = centerY - (GrabberSize.Y / 2.0f);
        float xPos = trackPosition.X + (Size.X / 2.0f) - (GrabberSize.X / 2.0f);
        float minY = trackPosition.Y;
        float maxY = trackPosition.Y + Size.Y - GrabberSize.Y;
        if (maxY < minY) maxY = minY;
        yPos = Math.Clamp(yPos, minY, maxY);
        return new Vector2(xPos, yPos);
    }
    protected override void DrawForeground(ID2D1RenderTarget renderTarget, float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        if (valueRange <= 0 || renderTarget is null) return;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0.0f;
        float foregroundHeight = Size.Y * normalizedValue;
        if (foregroundHeight <= 0.001f) return;
        Rect clipRect;
        if (Direction == VSliderDirection.BottomToTop) { clipRect = new Rect(trackPosition.X, trackPosition.Y + Size.Y - foregroundHeight, Size.X, foregroundHeight); }
        else { clipRect = new Rect(trackPosition.X, trackPosition.Y, Size.X, foregroundHeight); }
        renderTarget.PushAxisAlignedClip(clipRect, D2D.AntialiasMode.Aliased);
        UI.DrawBoxStyleHelper(renderTarget, trackPosition, Size, Theme.Foreground);
        renderTarget.PopAxisAlignedClip();
    }
}
</file>

<file path="Widgets\ResizableHPanelDefinition.cs">
using System.Numerics;

namespace DirectUI;

public class ResizableHPanelDefinition
{
    public float MinHeight { get; set; } = 50f;
    public float MaxHeight { get; set; } = 300f;
    public float ResizeHandleWidth { get; set; } = 5f; // This is actually handle *height* here
    public BoxStyle? PanelStyle { get; set; } = null;
    public Vector2 Padding { get; set; } = new Vector2(5, 5);
    public float Gap { get; set; } = 5f;
    public bool Disabled { get; set; } = false;
}
</file>

<file path="Widgets\ResizablePanelDefinition.cs">
using System.Numerics;

namespace DirectUI;

public class ResizablePanelDefinition
{
    public float MinWidth { get; set; } = 50f;
    public float MaxWidth { get; set; } = 500f;
    public float ResizeHandleWidth { get; set; } = 5f;
    public BoxStyle? PanelStyle { get; set; } = null;
    public Vector2 Padding { get; set; } = new Vector2(5, 5);
    public float Gap { get; set; } = 5f;
    public bool Disabled { get; set; } = false;
}
</file>

<file path="Widgets\SliderDefinition.cs">
// NEW: SliderDefinition.cs
// Summary: Configuration object for creating immediate-mode sliders (HSlider/VSlider).
using System.Numerics;

namespace DirectUI;

// Enums for direction (can reuse or redefine if needed, assume reuse for now)
// public enum HSliderDirection { LeftToRight, RightToLeft } // Already exists if Cherris files were added
// public enum VSliderDirection { TopToBottom, BottomToTop } // Already exists if Cherris files were added


public class SliderDefinition
{
    public Vector2 Position { get; set; } = Vector2.Zero; // Used if not in a container
    public Vector2 Size { get; set; } = new(200, 16); // Default size (adjust as needed)
    public float MinValue { get; set; } = 0.0f;
    public float MaxValue { get; set; } = 1.0f;
    public float Step { get; set; } = 0.01f;

    public SliderStyle? Theme { get; set; } = null; // Optional override for track style
    public ButtonStylePack? GrabberTheme { get; set; } = null; // Optional override for grabber style
    public Vector2? GrabberSize { get; set; } = null; // Optional override for grabber size (e.g., new(16, 16))

    // Direction specific to slider type, ignored by the other type
    public HSliderDirection HorizontalDirection { get; set; } = HSliderDirection.LeftToRight;
    public VSliderDirection VerticalDirection { get; set; } = VSliderDirection.TopToBottom;

    public bool Disabled { get; set; } = false;
    public object? UserData { get; set; } = null;
    public Vector2? Origin { get; set; } = null; // Use null for default (Vector2.Zero)
}
</file>

<file path="Widgets\TreeNode.cs">
using System.Collections.Generic;

namespace DirectUI;

/// <summary>
/// Represents a node in a generic tree structure.
/// </summary>
/// <typeparam name="T">The type of the user data associated with the node.</typeparam>
public class TreeNode<T>
{
    public string Text { get; set; }
    public T UserData { get; set; }
    public bool IsExpanded { get; set; }
    public List<TreeNode<T>> Children { get; } = new();

    public TreeNode(string text, T userData, bool expanded = false)
    {
        Text = text;
        UserData = userData;
        IsExpanded = expanded;
    }

    /// <summary>
    /// Adds a new child node to this node.
    /// </summary>
    /// <param name="text">The display text of the child node.</param>
    /// <param name="userData">The user data associated with the child node.</param>
    /// <param name="expanded">Whether the child node is expanded by default.</param>
    /// <returns>The newly created child node.</returns>
    public TreeNode<T> AddChild(string text, T userData, bool expanded = false)
    {
        var child = new TreeNode<T>(text, userData, expanded);
        Children.Add(child);
        return child;
    }
}
</file>

<file path="MyDirectUIApp.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI
{
    public class MyDirectUIApp : Direct2DAppWindow
    {
        private float sliderValue = 0.5f;
        private float leftPanelWidth = 250f;
        private float rightPanelWidth = 250f;
        private float bottomPanelHeight = 150f;

        private readonly TreeNode<string> _fileRoot;
        private readonly TreeStyle _treeStyle = new();


        // Constructor to match the call in Program.cs
        public MyDirectUIApp(string title, int width, int height)
            : base(title, width, height)
        {
            // Set a dark background color that matches the new theme
            backgroundColor = new Color4(21 / 255f, 21 / 255f, 21 / 255f, 1.0f); // #151515

            // --- Initialize Tree Data ---
            _fileRoot = new TreeNode<string>("Root", "C:/", true);
            var docs = _fileRoot.AddChild("Documents", "C:/Docs", true);
            docs.AddChild("Work", "C:/Docs/Work");
            var proj = docs.AddChild("Projects", "C:/Docs/Projects", true);
            proj.AddChild("DirectUI", "C:/Docs/Projects/DirectUI");
            proj.AddChild("Old Stuff", "C:/Docs/Projects/Old");
            docs.AddChild("Personal", "C:/Docs/Personal");

            var downloads = _fileRoot.AddChild("Downloads", "C:/Downloads");
            downloads.AddChild("Installer.exe", "C:/Downloads/Installer.exe");
            downloads.AddChild("archive.zip", "C:/Downloads/archive.zip");
        }

        protected override void DrawUIContent(DrawingContext context, InputState input)
        {
            // Must call BeginFrame before any UI calls
            UI.BeginFrame(context, input);

            float menuBarHeight = 30f;

            // --- Menu Bar ---
            var rt = context.RenderTarget;
            var menuBarBackgroundBrush = UI.GetOrCreateBrush(new Color4(37 / 255f, 37 / 255f, 38 / 255f, 1f));
            var menuBarBorderBrush = UI.GetOrCreateBrush(DefaultTheme.NormalBorder);

            if (menuBarBackgroundBrush != null)
            {
                rt.FillRectangle(new Rect(0, 0, rt.Size.Width, menuBarHeight), menuBarBackgroundBrush);
            }
            if (menuBarBorderBrush != null)
            {
                rt.DrawLine(new Vector2(0, menuBarHeight - 1), new Vector2(rt.Size.Width, menuBarHeight - 1), menuBarBorderBrush, 1f);
            }

            var menuButtonTheme = new ButtonStylePack
            {
                Roundness = 0f,
                BorderLength = 0,
                FontName = "Segoe UI",
                FontSize = 14
            };
            menuButtonTheme.Normal.FillColor = Colors.Transparent;
            menuButtonTheme.Normal.FontColor = new Color4(204 / 255f, 204 / 255f, 204 / 255f, 1f);
            menuButtonTheme.Hover.FillColor = new Color4(63 / 255f, 63 / 255f, 70 / 255f, 1f);
            menuButtonTheme.Pressed.FillColor = DefaultTheme.Accent;

            var menuButtonDef = new ButtonDefinition
            {
                Theme = menuButtonTheme,
                AutoWidth = true,
                TextMargin = new Vector2(10, 0),
                Size = new Vector2(0, menuBarHeight),
                TextAlignment = new Alignment(HAlignment.Center, VAlignment.Center)
            };

            UI.BeginHBoxContainer("menu_bar", new Vector2(5, 0), 0);
            menuButtonDef.Text = "File";
            if (UI.Button("file_button", menuButtonDef)) { Console.WriteLine("File clicked"); }
            menuButtonDef.Text = "Edit";
            if (UI.Button("edit_button", menuButtonDef)) { Console.WriteLine("Edit clicked"); }
            menuButtonDef.Text = "View";
            if (UI.Button("view_button", menuButtonDef)) { Console.WriteLine("View clicked"); }
            menuButtonDef.Text = "Help";
            if (UI.Button("help_button", menuButtonDef)) { Console.WriteLine("Help clicked"); }
            UI.EndHBoxContainer();


            // --- Define some styles ---
            var buttonTheme = new ButtonStylePack
            {
                Roundness = 0.2f,
                BorderLength = 1, // Thinner border
                FontName = "Segoe UI",
                FontSize = 16,
            };

            // This style now inherits its colors from the DefaultTheme
            var panelStyle = new BoxStyle
            {
                BorderLength = 1,
                Roundness = 0f
            };

            var vPanelDef = new ResizablePanelDefinition
            {
                MinWidth = 150,
                MaxWidth = 400,
                Padding = new Vector2(10, 10),
                Gap = 10,
                PanelStyle = panelStyle
            };

            var hPanelDef = new ResizableHPanelDefinition
            {
                MinHeight = 50,
                MaxHeight = 300,
                Padding = new Vector2(10, 10),
                Gap = 10,
                PanelStyle = panelStyle
            };


            // --- Left Panel ---
            UI.BeginResizableVPanel("left_panel", ref leftPanelWidth, vPanelDef, HAlignment.Left, menuBarHeight);

            // Wrap tree in a VBox with 0 gap to ensure lines connect correctly
            UI.BeginVBoxContainer("tree_vbox", UI.GetCurrentLayoutPosition(), 0);
            UI.Tree("file_tree", _fileRoot, out var clickedNode, _treeStyle);
            if (clickedNode is not null)
            {
                Console.WriteLine($"Tree Node Clicked: '{clickedNode.Text}', Path: {clickedNode.UserData}");
            }
            UI.EndVBoxContainer();

            UI.EndResizableVPanel();

            // --- Right Panel ---
            UI.BeginResizableVPanel("right_panel", ref rightPanelWidth, vPanelDef, HAlignment.Right, menuBarHeight);
            if (UI.Button("right_button_1", new ButtonDefinition { Text = "Right Panel", Theme = buttonTheme }))
            {
                Console.WriteLine("Right panel button 1 clicked!");
            }
            if (UI.Button("right_button_2", new ButtonDefinition { Text = "Another Button", Theme = buttonTheme }))
            {
                Console.WriteLine("Right panel button 2 clicked!");
            }
            sliderValue = UI.HSlider("my_slider", sliderValue, new SliderDefinition { Size = new Vector2(200, 20) });

            UI.EndResizableVPanel();

            // --- Bottom Panel ---
            UI.BeginResizableHPanel("bottom_panel", ref bottomPanelHeight, hPanelDef, leftPanelWidth, rightPanelWidth, menuBarHeight);
            if (UI.Button("bottom_button", new ButtonDefinition { Text = "Bottom Panel Button", Theme = buttonTheme }))
            {
                Console.WriteLine("Bottom button clicked!");
            }
            UI.EndResizableHPanel();

            // --- End of UI ---
            // Must call EndFrame after all UI calls
            UI.EndFrame();
        }
    }
}
</file>

<file path="Program.cs">
using DirectUI;

namespace Cocoshell;

public class Program
{
    [STAThread] // Important for COM (Direct2D) and Win32 APIs
    static void Main(string[] args)
    {
        Console.WriteLine("Starting Refactored Direct2D Application...");

        // Use 'using' to ensure Dispose is called automatically
        using (var appWindow = new MyDirectUIApp("My Refactored D2D App", 1024, 768))
        {
            try
            {
                appWindow.Run(); // Creates window, enters message loop
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Unhandled exception in Run: {ex}");
                // Log exception, show message box, etc.
            }
        } // appWindow.Dispose() is called here

        Console.WriteLine("Application finished.");
        // Console.ReadKey(); // Optional: Keep console open after exit
    }
}
</file>

