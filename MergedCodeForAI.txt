<file path="Alignment.cs">
// Alignment.cs
namespace DirectUI;

public enum HAlignment { Left, Center, Right }
public enum VAlignment { Top, Center, Bottom }

public struct Alignment(HAlignment horizontal, VAlignment vertical)
{
    public HAlignment Horizontal { get; set; } = horizontal;
    public VAlignment Vertical { get; set; } = vertical;
}
</file>

<file path="Direct2DAppWindow.cs">
// MODIFIED: Direct2DAppWindow.cs
// Summary: Changed PresentOptions from None to Immediately in HwndRenderTargetProperties to attempt disabling VSync throttling.
using System;
using System.Numerics;
using System.Diagnostics;

using Vortice;
using Vortice.Mathematics;

using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.DXGI;
using SharpGen.Runtime;

using D2D = Vortice.Direct2D1;
using DW = Vortice.DirectWrite;

using D2DFactoryType = Vortice.Direct2D1.FactoryType;
using SizeI = Vortice.Mathematics.SizeI;
using Rect = Vortice.Mathematics.Rect;

using DirectUI;
using Vortice.DCommon;

namespace DirectUI;

public abstract class Direct2DAppWindow : Win32Window
{
    protected ID2D1Factory1? d2dFactory;
    protected IDWriteFactory? dwriteFactory;
    protected ID2D1HwndRenderTarget? renderTarget;

    protected Color4 backgroundColor = new(0.1f, 0.1f, 0.15f, 1.0f);
    protected bool graphicsInitialized = false;

    protected Vector2 currentMousePos = new(-1, -1);
    protected bool isLeftMouseButtonDown = false;
    protected bool wasLeftMouseClickedThisFrame = false;

    // --- FPS Counter Fields ---
    private Stopwatch fpsTimer = new();
    private long lastFpsUpdateTimeTicks = 0;
    private int frameCountSinceUpdate = 0;
    private float currentFps = 0.0f;
    private const long FpsUpdateIntervalTicks = TimeSpan.TicksPerSecond / 2;
    private ID2D1SolidColorBrush? fpsTextBrush;
    private IDWriteTextFormat? fpsTextFormat;
    private readonly Color4 fpsTextColor = DefaultTheme.Text;
    private readonly string fpsFontName = "Consolas";
    private readonly float fpsFontSize = 14.0f;
    // --- End FPS Counter Fields ---

    public Direct2DAppWindow(string title = "Vortice DirectUI Base Window", int width = 800, int height = 600)
        : base(title, width, height)
    { }

    protected override bool Initialize()
    {
        Console.WriteLine("Direct2DAppWindow initializing Vortice Graphics...");
        return InitializeGraphics();
    }

    protected override void Cleanup()
    {
        Console.WriteLine("Direct2DAppWindow cleaning up its resources...");
        CleanupGraphics();
    }

    protected override void OnPaint()
    {
        // --- FPS Timer Update ---
        if (!fpsTimer.IsRunning)
        {
            fpsTimer.Start();
            lastFpsUpdateTimeTicks = fpsTimer.ElapsedTicks;
            frameCountSinceUpdate = 0;
        }

        frameCountSinceUpdate++;
        long elapsedTicks = fpsTimer.ElapsedTicks;
        long timeSinceLastUpdate = elapsedTicks - lastFpsUpdateTimeTicks;

        if (timeSinceLastUpdate >= FpsUpdateIntervalTicks)
        {
            float secondsElapsed = (float)timeSinceLastUpdate / TimeSpan.TicksPerSecond;
            currentFps = (secondsElapsed > 0.001f) ? (frameCountSinceUpdate / secondsElapsed) : 0.0f;
            frameCountSinceUpdate = 0;
            lastFpsUpdateTimeTicks = elapsedTicks;
            Invalidate();
        }
        // --- End FPS Timer Update ---


        if (!graphicsInitialized || renderTarget is null || dwriteFactory is null)
        {
            if (!graphicsInitialized && Handle != nint.Zero)
            {
                InitializeGraphics();
                if (!graphicsInitialized || renderTarget is null || dwriteFactory is null)
                {
                    wasLeftMouseClickedThisFrame = false;
                    return;
                }
            }
            else
            {
                wasLeftMouseClickedThisFrame = false;
                return;
            }
        }

        try
        {
            renderTarget.BeginDraw();
            renderTarget.Clear(backgroundColor);

            var inputState = new InputState(
                currentMousePos,
                wasLeftMouseClickedThisFrame,
                isLeftMouseButtonDown
            );

            var drawingContext = new DrawingContext(renderTarget, dwriteFactory);

            // --- Draw Main UI Content ---
            DrawUIContent(drawingContext, inputState);

            // --- Draw FPS Counter ---
            if (fpsTextBrush is not null && fpsTextFormat is not null)
            {
                string fpsText = $"FPS: {currentFps:F1}";
                Rect fpsLayoutRect = new Rect(5f, 5f, 150f, 30f);
                renderTarget.DrawText(fpsText, fpsTextFormat, fpsLayoutRect, fpsTextBrush);
            }
            // --- End Draw FPS Counter ---


            Result endDrawResult = renderTarget.EndDraw();

            if (endDrawResult.Failure)
            {
                Console.WriteLine($"EndDraw failed: {endDrawResult.Description}");
                if (endDrawResult.Code == D2D.ResultCode.RecreateTarget.Code)
                {
                    Console.WriteLine("Render target needs recreation (Detected in EndDraw).");
                    graphicsInitialized = false;
                    CleanupGraphics();
                }
            }
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Render target needs recreation (Caught SharpGenException in OnPaint): {ex.Message}");
            graphicsInitialized = false;
            CleanupGraphics();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Rendering Error: {ex}");
            graphicsInitialized = false;
            CleanupGraphics();
        }
        finally
        {
            wasLeftMouseClickedThisFrame = false;
        }
    }

    protected virtual void DrawUIContent(DrawingContext context, InputState input)
    {
        // Base implementation does nothing.
    }

    protected override void OnSize(int width, int height)
    {
        if (graphicsInitialized && renderTarget is not null)
        {
            Console.WriteLine($"Window resized to {width}x{height}. Resizing render target...");
            try
            {
                var newPixelSize = new SizeI(width, height);
                fpsTextBrush?.Dispose();
                fpsTextBrush = null;

                renderTarget.Resize(newPixelSize);

                try
                {
                    if (renderTarget is not null)
                    {
                        fpsTextBrush = renderTarget.CreateSolidColorBrush(fpsTextColor);
                        Console.WriteLine("Recreated FPS brush after resize.");
                    }
                }
                catch (Exception brushEx)
                {
                    Console.WriteLine($"Warning: Failed to recreate FPS brush after resize: {brushEx.Message}");
                }

                Console.WriteLine($"Successfully resized render target.");
            }
            catch (SharpGenException ex)
            {
                Console.WriteLine($"Failed to resize Render Target (SharpGenException): {ex.Message} HRESULT: {ex.ResultCode}");
                if (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
                {
                    Console.WriteLine("Render target needs recreation (Detected in Resize Exception).");
                    graphicsInitialized = false;
                    CleanupGraphics();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to resize Render Target (General Exception): {ex}");
                graphicsInitialized = false;
                CleanupGraphics();
            }
        }
        else if (!graphicsInitialized && Handle != nint.Zero)
        {
            InitializeGraphics();
        }
    }

    protected override void OnMouseMove(int x, int y) { currentMousePos = new Vector2(x, y); Invalidate(); }

    protected override void OnMouseDown(MouseButton button, int x, int y)
    {
        currentMousePos = new Vector2(x, y);
        if (button == MouseButton.Left)
        {
            isLeftMouseButtonDown = true;
            wasLeftMouseClickedThisFrame = true;
        }
        Invalidate();
    }

    protected override void OnMouseUp(MouseButton button, int x, int y)
    {
        currentMousePos = new Vector2(x, y);
        if (button == MouseButton.Left)
        {
            isLeftMouseButtonDown = false;
        }
        Invalidate();
    }

    protected override void OnKeyDown(int keyCode)
    {
        if (keyCode == NativeMethods.VK_ESCAPE)
        {
            Close();
        }
        Invalidate();
    }

    protected override bool OnClose() { return true; }

    protected virtual bool InitializeGraphics()
    {
        if (graphicsInitialized) return true;
        if (Handle == nint.Zero) return false;

        Console.WriteLine($"Attempting Graphics Initialization for HWND {Handle}...");

        try
        {
            CleanupGraphics();

            Result factoryResult = D2D1.D2D1CreateFactory(D2DFactoryType.SingleThreaded, out d2dFactory);
            factoryResult.CheckError();
            if (d2dFactory is null) throw new InvalidOperationException("D2D Factory creation failed silently.");

            Result dwriteResult = DWrite.DWriteCreateFactory(DW.FactoryType.Shared, out dwriteFactory);
            dwriteResult.CheckError();
            if (dwriteFactory is null) throw new InvalidOperationException("DWrite Factory creation failed silently.");

            var clientRectSize = GetClientRectSize();
            if (clientRectSize.Width <= 0 || clientRectSize.Height <= 0)
            {
                Console.WriteLine($"Invalid client rect size ({clientRectSize.Width}x{clientRectSize.Height}). Aborting graphics initialization.");
                CleanupGraphics();
                return false;
            }

            var dxgiPixelFormat = new PixelFormat(Format.B8G8R8A8_UNorm, Vortice.DCommon.AlphaMode.Premultiplied);
            var renderTargetProperties = new RenderTargetProperties(dxgiPixelFormat);
            var hwndRenderTargetProperties = new HwndRenderTargetProperties
            {
                Hwnd = Handle,
                PixelSize = new SizeI(clientRectSize.Width, clientRectSize.Height),
                // --- CHANGE HERE ---
                PresentOptions = PresentOptions.Immediately // Attempt to disable VSync throttling
                // --- END CHANGE ---
            };

            renderTarget = d2dFactory.CreateHwndRenderTarget(renderTargetProperties, hwndRenderTargetProperties);
            if (renderTarget is null) throw new InvalidOperationException("Render target creation returned null unexpectedly.");

            renderTarget.TextAntialiasMode = D2D.TextAntialiasMode.Cleartype;

            // --- Initialize FPS Resources ---
            try
            {
                fpsTextFormat?.Dispose();
                fpsTextFormat = dwriteFactory.CreateTextFormat(fpsFontName, null, FontWeight.Normal, FontStyle.Normal, FontStretch.Normal, fpsFontSize, "en-us");
                fpsTextFormat.TextAlignment = DW.TextAlignment.Leading;
                fpsTextFormat.ParagraphAlignment = ParagraphAlignment.Near;

                fpsTextBrush?.Dispose();
                fpsTextBrush = renderTarget.CreateSolidColorBrush(fpsTextColor);
                Console.WriteLine("Created FPS drawing resources.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Warning: Failed to create FPS drawing resources: {ex.Message}");
                fpsTextFormat?.Dispose(); fpsTextFormat = null;
                fpsTextBrush?.Dispose(); fpsTextBrush = null;
            }
            // Reset and Start timer
            frameCountSinceUpdate = 0;
            currentFps = 0;
            lastFpsUpdateTimeTicks = 0;
            fpsTimer.Restart();
            // --- End Initialize FPS Resources ---


            Console.WriteLine($"Vortice Graphics initialized successfully for HWND {Handle}.");
            graphicsInitialized = true;
            return true;
        }
        catch (SharpGenException ex)
        {
            Console.WriteLine($"Graphics Initialization failed (SharpGenException): {ex.Message} HRESULT: {ex.ResultCode}");
            CleanupGraphics(); graphicsInitialized = false; return false;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Graphics Initialization failed (General Exception): {ex}");
            CleanupGraphics(); graphicsInitialized = false; return false;
        }
    }

    protected virtual void CleanupGraphics()
    {
        bool resourcesExisted = d2dFactory is not null || renderTarget is not null || dwriteFactory is not null;
        if (resourcesExisted) Console.WriteLine("Cleaning up Vortice Graphics resources...");

        fpsTimer.Stop();

        fpsTextBrush?.Dispose(); fpsTextBrush = null;
        fpsTextFormat?.Dispose(); fpsTextFormat = null;

        UI.CleanupResources();

        renderTarget?.Dispose(); renderTarget = null;
        dwriteFactory?.Dispose(); dwriteFactory = null;
        d2dFactory?.Dispose(); d2dFactory = null;
        graphicsInitialized = false;

        if (resourcesExisted) Console.WriteLine("Finished cleaning graphics resources.");
    }

    protected SizeI GetClientRectSize()
    {
        if (Handle != nint.Zero && NativeMethods.GetClientRect(Handle, out NativeMethods.RECT r))
        {
            int width = Math.Max(1, r.right - r.left);
            int height = Math.Max(1, r.bottom - r.top);
            return new SizeI(width, height);
        }
        int baseWidth = Math.Max(1, Width);
        int baseHeight = Math.Max(1, Height);
        if (Handle != nint.Zero)
        {
            Console.WriteLine($"GetClientRect failed. Falling back to stored size: {baseWidth}x{baseHeight}");
        }
        return new SizeI(baseWidth, baseHeight);
    }
}
</file>

<file path="DrawingContext.cs">
// DrawingContext.cs
using Vortice.Direct2D1;
using Vortice.DirectWrite;

namespace DirectUI;

// Holds rendering resources needed for UI drawing
public readonly struct DrawingContext
{
    public readonly ID2D1HwndRenderTarget RenderTarget;
    public readonly IDWriteFactory DWriteFactory;
    // Could potentially add D2DFactory later if needed

    public DrawingContext(ID2D1HwndRenderTarget renderTarget, IDWriteFactory dwriteFactory)
    {
        RenderTarget = renderTarget;
        DWriteFactory = dwriteFactory;
    }
}
</file>

<file path="InputState.cs">
// InputState.cs
using System.Numerics;

namespace DirectUI;

// Holds input state needed for UI processing in a single frame
public readonly struct InputState
{
    public readonly Vector2 MousePosition;
    public readonly bool WasLeftMousePressedThisFrame; // True if the left button went down this frame
    public readonly bool IsLeftMouseDown; // True if the left button is currently held down
    // Add fields for Right mouse button if ClickBehavior.Right/Both is used

    public InputState(Vector2 mousePosition, bool wasLeftMousePressedThisFrame, bool isLeftMouseDown)
    {
        MousePosition = mousePosition;
        WasLeftMousePressedThisFrame = wasLeftMousePressedThisFrame;
        IsLeftMouseDown = isLeftMouseDown;
    }
}
</file>

<file path="MyDirectUIApp.cs">
// MyDirectUIApp.cs
using System;
using System.Numerics;
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace DirectUI;

public class MyDirectUIApp : Direct2DAppWindow
{
    private readonly ButtonStylePack buttonTheme;
    private readonly ButtonStylePack specialButtonTheme;
    private readonly SliderStyle sliderTheme;
    private readonly ButtonStylePack sliderGrabberTheme;
    private float horizontalSliderValue = 0.5f;
    private float verticalSliderValue = 0.25f;
    private float nestedSliderValue = 0.75f;
    private float gridSlider1 = 0.1f;
    private float gridSlider2 = 0.9f;

    public MyDirectUIApp(string title = "My DirectUI App", int width = 800, int height = 600)
        : base(title, width, height)
    {
        // --- Button Theme (Corrected Initialization) ---
        // 1. Create the pack with global settings
        buttonTheme = new ButtonStylePack()
        {
            Roundness = 0f,
            BorderLength = 1.0f, // Sets all borders to 1.0f for ALL states initially
            FontSize = 14f,
        };

        // 2. NOW modify the existing Normal instance
        buttonTheme.Normal.BorderLengthBottom = 10.0f;
        // Now, buttonTheme.Normal should have:
        // - BorderLengthTop = 1.0f (from global setter)
        // - BorderLengthRight = 1.0f (from global setter)
        // - BorderLengthBottom = 10.0f (from explicit override)
        // - BorderLengthLeft = 1.0f (from global setter)
        // - Roundness = 0.0f (from global setter)
        // - FontSize = 14f (from global setter)
        // - Default Fill/Border/Font colors (from ButtonStylePack constructor defaults)

        // --- Special Theme ---
        // This initialization was already correct because it mainly set colors
        // after setting a global BorderLength = 0.0f.
        specialButtonTheme = new()
        {
            Roundness = 0.5f,
            BorderLength = 0.0f, // Sets all borders to 0 for all states
            FontSize = 14f,
            FontWeight = FontWeight.Bold,
            Normal = { FillColor = new Color4(0.3f, 0.5f, 0.3f, 1.0f), BorderColor = Colors.Transparent },
            Hover = { FillColor = new Color4(0.4f, 0.6f, 0.4f, 1.0f), BorderColor = Colors.Transparent },
            Pressed = { FillColor = new Color4(0.2f, 0.4f, 0.2f, 1.0f), BorderColor = Colors.Transparent },
            Disabled = { FillColor = DefaultTheme.DisabledFill, FontColor = DefaultTheme.DisabledText, BorderColor = Colors.Transparent }
        };

        // --- Slider Themes ---
        // These seem correct as they set global properties and then modify specific states.
        sliderTheme = new()
        {
            Background = 
            { 
                Roundness = 0.2f,
                FillColor = new Color4(0.2f, 0.2f, 0.25f, 1.0f),
                BorderLength = 0 
            },

            Foreground = 
            {
                Roundness = 0.2f,
                FillColor = DefaultTheme.Accent,
                BorderLength = 0
            }
        };

        // Slider Grabber Theme
        sliderGrabberTheme = new()
        {
            Roundness = 0.5f,
            BorderLength = 1.0f, // Set all borders to 1.0f for all states
            Normal = { FillColor = new Color4(0.6f, 0.6f, 0.65f, 1.0f), BorderColor = new Color4(0.8f, 0.8f, 0.8f, 1.0f) },
            Hover = { FillColor = new Color4(0.75f, 0.75f, 0.8f, 1.0f), BorderColor = Colors.WhiteSmoke },
            Pressed = { FillColor = Colors.WhiteSmoke, BorderColor = DefaultTheme.Accent }
        };
    }

    protected override void DrawUIContent(DrawingContext context, InputState input)
    {
        UI.BeginFrame(context, input);

        // --- HBox with Buttons (Top Row) ---
        UI.BeginHBoxContainer("ActionButtons", new Vector2(50, 50), gap: 10.0f);
        // These buttons use 'buttonTheme'. When not hovered/pressed, they should now show the 10px bottom border correctly.
        if (UI.Button("OkButton", new() { Size = new(84, 28), Text = "OK", Theme = buttonTheme })) { backgroundColor = Colors.DarkSlateGray; Invalidate(); }
        if (UI.Button("CancelButton", new() { Size = new(84, 28), Text = "Cancel", Theme = buttonTheme })) { /* log */ }
        UI.EndHBoxContainer();

        // --- Area for Grid ---
        float gridStartX = 50;
        float gridStartY = 100;
        float windowWidth = GetClientRectSize().Width;
        float windowHeight = GetClientRectSize().Height;
        float availableGridWidth = windowWidth - gridStartX - 50;
        float availableGridHeight = windowHeight - gridStartY - 50;
        Vector2 gridAvailableSize = new(float.Max(1, availableGridWidth), float.Max(1, availableGridHeight));
        int numberOfColumns = 3;
        Vector2 cellGap = new Vector2(10, 10);

        UI.BeginGridContainer("MainGrid", new Vector2(gridStartX, gridStartY), gridAvailableSize, numberOfColumns, cellGap);

        // Row 1
        UI.Button("GridBtn1", new() { Size = new(100, 30), Text = "Grid Cell 1", Theme = buttonTheme }); // Should have 10px bottom border
        gridSlider1 = UI.HSlider("GridSlider1", gridSlider1, new() { Size = new(150, 20), Theme = sliderTheme, GrabberTheme = sliderGrabberTheme });
        UI.Button("GridBtn2", new() { Size = new(100, 30), Text = "Grid Cell 3", Theme = buttonTheme }); // Should have 10px bottom border

        // Row 2
        UI.Button("GridBtn3", new() { Size = new(100, 50), Text = "Taller Button", Theme = buttonTheme }); // Should have 10px bottom border
        UI.Button("GridBtn4", new() { Size = new(100, 30), Text = "Grid Cell 5", Theme = buttonTheme }); // Should have 10px bottom border
        gridSlider2 = UI.VSlider("GridSlider2", gridSlider2, new() { Size = new(20, 80), Theme = sliderTheme, GrabberTheme = sliderGrabberTheme });

        // Row 3 (These use specialButtonTheme with BorderLength = 0)
        UI.Button("GridBtn5", new() 
        { 
            Size = new(80, 25), 
            Text = "Cell 7",
            Theme = specialButtonTheme 
        });

        UI.Button("GridBtn6",new()
        { 
            Size = new(120, 25),
            Text = "Cell 8 - Wider",
            Theme = specialButtonTheme 
        }); // Should have 0 border

        UI.Button("GridBtn7", new() 
        { 
            Size = new(80, 25), 
            Text = "Cell 9", 
            Theme = specialButtonTheme 
        }); // Should have 0 border

        UI.EndGridContainer();

        UI.EndFrame();
    }
}
</file>

<file path="NativeMethods.cs">
using System;
using System.Runtime.InteropServices;

// No changes needed here if it was correct from the previous step.
// Ensure these constants are defined:
// WM_NCCREATE, WM_CREATE, WM_NCDESTROY, WM_PAINT, WM_DESTROY, WM_SIZE,
// WM_CLOSE, WM_KEYDOWN, WM_LBUTTONDOWN, WM_LBUTTONUP, WM_MOUSEMOVE, WM_QUIT
// GWLP_USERDATA, VK_ESCAPE, etc.
// And the structs: WNDCLASSEX, MSG, POINT, RECT, CREATESTRUCT
// And the functions: RegisterClassEx, CreateWindowEx, GetMessage, etc.
// And the delegates: WndProc

namespace DirectUI;

internal static class NativeMethods
{
    // --- Constants ---
    public const uint CS_HREDRAW = 0x0002;
    public const uint CS_VREDRAW = 0x0001;
    public const uint CS_OWNDC = 0x0020;

    public const uint WS_OVERLAPPEDWINDOW = 0xCF0000;
    public const uint WS_VISIBLE = 0x10000000;

    public const int WM_NCCREATE = 0x0081;
    public const int WM_CREATE = 0x0001;
    public const int WM_NCDESTROY = 0x0082;
    public const int WM_PAINT = 0x000F;
    public const int WM_DESTROY = 0x0002;
    public const int WM_SIZE = 0x0005;
    public const int WM_CLOSE = 0x0010;
    public const int WM_KEYDOWN = 0x0100;
    public const int WM_LBUTTONDOWN = 0x0201;
    public const int WM_LBUTTONUP = 0x0202; // Ensure this exists
    public const int WM_MOUSEMOVE = 0x0200; // Ensure this exists
    public const int WM_QUIT = 0x0012;

    public const int CW_USEDEFAULT = unchecked((int)0x80000000);
    public const int SW_SHOWNORMAL = 1;
    public const int VK_ESCAPE = 0x1B;
    public const int GWLP_USERDATA = -21;

    // --- Structures ---
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
    public struct WNDCLASSEX
    { /* ... as before ... */
        public int cbSize;
        public uint style;
        public WndProc lpfnWndProc; // Use delegate type directly
        public int cbClsExtra;
        public int cbWndExtra;
        public IntPtr hInstance;
        public IntPtr hIcon;
        public IntPtr hCursor;
        public IntPtr hbrBackground;
        public string lpszMenuName;
        public string lpszClassName;
        public IntPtr hIconSm;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct MSG
    { /* ... as before ... */
        public IntPtr hwnd;
        public uint message;
        public IntPtr wParam;
        public IntPtr lParam;
        public uint time;
        public POINT pt;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct POINT
    { /* ... as before ... */
        public int X;
        public int Y;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct RECT
    { /* ... as before ... */
        public int left;
        public int top;
        public int right;
        public int bottom;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct CREATESTRUCT
    { /* ... as before ... */
        public IntPtr lpCreateParams;
        public IntPtr hInstance;
        public IntPtr hMenu;
        public IntPtr hwndParent;
        public int cy; // Height
        public int cx; // Width
        public int y;  // Top
        public int x;  // Left
        public int style;
        [MarshalAs(UnmanagedType.LPWStr)] // Assuming Unicode
        public string lpszName;
        [MarshalAs(UnmanagedType.LPWStr)] // Assuming Unicode
        public string lpszClass;
        public int dwExStyle;
    }

    // --- Delegates ---
    public delegate IntPtr WndProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam);

    // --- Functions ---
    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern ushort RegisterClassEx([In] ref WNDCLASSEX lpwcx);
    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern IntPtr CreateWindowEx(uint dwExStyle, string lpClassName, string lpWindowName, uint dwStyle, int x, int y, int nWidth, int nHeight, IntPtr hWndParent, IntPtr hMenu, IntPtr hInstance, IntPtr lpParam);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool UpdateWindow(IntPtr hWnd);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool DestroyWindow(IntPtr hWnd);
    [DllImport("user32.dll")]
    public static extern IntPtr DefWindowProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam);
    [DllImport("user32.dll")]
    public static extern void PostQuitMessage(int nExitCode);
    [DllImport("user32.dll")]
    public static extern bool GetMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax);
    [DllImport("user32.dll")]
    public static extern bool TranslateMessage([In] ref MSG lpMsg);
    [DllImport("user32.dll")]
    public static extern IntPtr DispatchMessage([In] ref MSG lpmsg);
    [DllImport("user32.dll")]
    public static extern bool GetClientRect(IntPtr hWnd, out RECT lpRect);
    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern IntPtr GetModuleHandle(string lpModuleName);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool InvalidateRect(IntPtr hWnd, IntPtr lpRect, bool bErase);
    [DllImport("user32.dll")]
    public static extern IntPtr LoadCursor(IntPtr hInstance, int lpCursorName);
    [DllImport("user32.dll")]
    public static extern IntPtr LoadIcon(IntPtr hInstance, IntPtr lpIconName);
    [DllImport("user32.dll", EntryPoint = "SetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr SetWindowLongPtr64(IntPtr hWnd, int nIndex, IntPtr dwNewLong);
    [DllImport("user32.dll", EntryPoint = "SetWindowLongW", SetLastError = true)]
    private static extern IntPtr SetWindowLong32(IntPtr hWnd, int nIndex, IntPtr dwNewLong);
    [DllImport("user32.dll", EntryPoint = "GetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr GetWindowLongPtr64(IntPtr hWnd, int nIndex);
    [DllImport("user32.dll", EntryPoint = "GetWindowLongW", SetLastError = true)]
    private static extern IntPtr GetWindowLong32(IntPtr hWnd, int nIndex);

    public static IntPtr SetWindowLongPtr(IntPtr hWnd, int nIndex, IntPtr dwNewLong)
    {
        if (IntPtr.Size == 8) return SetWindowLongPtr64(hWnd, nIndex, dwNewLong);
        else return SetWindowLong32(hWnd, nIndex, dwNewLong);
    }
    public static IntPtr GetWindowLongPtr(IntPtr hWnd, int nIndex)
    {
        if (IntPtr.Size == 8) return GetWindowLongPtr64(hWnd, nIndex);
        else return GetWindowLong32(hWnd, nIndex);
    }

    // --- Helpers ---
    public static short LoWord(IntPtr val) => unchecked((short)(long)val);
    public static short HiWord(IntPtr val) => unchecked((short)((long)val >> 16));
}
</file>

<file path="Program.cs">
using System;

namespace DirectUI;

public class Program
{
    [STAThread] // Important for COM (Direct2D) and Win32 APIs
    static void Main(string[] args)
    {
        Console.WriteLine("Starting Refactored Direct2D Application...");

        // Use 'using' to ensure Dispose is called automatically
        using (var appWindow = new MyDirectUIApp("My Refactored D2D App", 1024, 768))
        {
            try
            {
                appWindow.Run(); // Creates window, enters message loop
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Unhandled exception in Run: {ex}");
                // Log exception, show message box, etc.
            }
        } // appWindow.Dispose() is called here

        Console.WriteLine("Application finished.");
        // Console.ReadKey(); // Optional: Keep console open after exit
    }
}
</file>

<file path="UI.cs">
// MODIFIED: UI.cs
// Summary: Corrected input handling logic. SetPotentialInputTarget always updates potential target. TryCaptureInput validates against potential target and global state. ActivelyPressedElementId tracks held state. potentialInputTargetId is private.
using SharpGen.Runtime;
using System;
using System.Collections.Generic;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

public enum HSliderDirection { LeftToRight, RightToLeft }
public enum VSliderDirection { TopToBottom, BottomToTop }

public static class UI
{
    // --- State fields ---
    private static ID2D1HwndRenderTarget? currentRenderTarget;
    private static IDWriteFactory? currentDWriteFactory;
    private static InputState currentInputState;
    private static readonly Dictionary<string, object> uiElements = new();
    private static readonly Dictionary<Color4, ID2D1SolidColorBrush> brushCache = new();
    private static readonly Stack<object> containerStack = new();

    private static bool inputCapturedThisFrame = false; // True ONLY if a TryCaptureInput succeeded *this frame*. Reset every frame.
    private static string? inputCaptorId = null;        // ID of the element that captured the press *this frame*. Reset every frame.
    private static string? potentialInputTargetId = null; // ID of the last element hovered under the cursor this frame. Reset every frame.
    private static string? activelyPressedElementId = null; // ID of the element currently being held down (persists across frames until release).

    // --- Public Properties ---
    public static ID2D1HwndRenderTarget? CurrentRenderTarget => currentRenderTarget;
    public static IDWriteFactory? CurrentDWriteFactory => currentDWriteFactory;
    public static InputState CurrentInputState => currentInputState;
    // Read-only access to the currently held element, useful for widgets.
    public static string? ActivelyPressedElementId => activelyPressedElementId;

    // --- Frame Management ---
    public static void BeginFrame(DrawingContext context, InputState input)
    {
        currentRenderTarget = context.RenderTarget;
        currentDWriteFactory = context.DWriteFactory;
        currentInputState = input;
        containerStack.Clear();

        // Reset FRAME-SPECIFIC flags
        inputCapturedThisFrame = false;
        inputCaptorId = null;
        potentialInputTargetId = null;

        // Reset PERSISTENT active state ONLY if mouse is UP
        if (!input.IsLeftMouseDown) // Assuming left mouse button focus
        {
            activelyPressedElementId = null;
        }
    }

    public static void EndFrame()
    {
        if (containerStack.Count > 0)
        {
            Console.WriteLine($"Warning: Mismatch in Begin/End container calls. {containerStack.Count} containers left open at EndFrame.");
            containerStack.Clear();
        }
        currentRenderTarget = null;
        currentDWriteFactory = null;
    }

    // --- Input Capture & Targeting ---

    /// <summary>
    /// Checks if input focus is currently held by any element (persists across frames).
    /// Widgets should generally check this *before* attempting a new capture.
    /// </summary>
    public static bool IsElementActive()
    {
        return activelyPressedElementId is not null;
    }

    /// <summary>
    /// Checks if input was captured by *any* element earlier *within the current frame*.
    /// Used internally by TryCaptureInput.
    /// </summary>
    private static bool WasInputCapturedThisFrame() // Changed back to private, internal check
    {
        return inputCapturedThisFrame;
    }


    /// <summary>
    /// Called by hovered elements to declare themselves as the current potential input target.
    /// The last element processed that calls this in a frame becomes the target.
    /// </summary>
    internal static void SetPotentialInputTarget(string id)
    {
        // Always allow setting the potential target. Capture logic will verify later.
        potentialInputTargetId = id;
    }

    /// <summary>
    /// Attempts to capture a *new* press event for the element with the given ID.
    /// Succeeds only if no element is actively pressed, no *other* element captured input this frame,
    /// AND the calling element is the current potential target. Sets the actively pressed element on success.
    /// </summary>
    /// <returns>True if input was successfully captured by this element *this frame*, false otherwise.</returns>
    internal static bool TryCaptureInput(string id)
    {
        // Can only capture a NEW press if:
        // 1. Nothing is currently being held down (!IsElementActive())
        // 2. No other element has already captured the press *this frame* (!WasInputCapturedThisFrame())
        // 3. This specific element IS the last one that declared itself as potential target (potentialInputTargetId == id)
        if (!IsElementActive() && !WasInputCapturedThisFrame() && potentialInputTargetId == id)
        {
            inputCapturedThisFrame = true; // Mark capture for this frame only
            inputCaptorId = id;           // Record which element captured this frame's press
            activelyPressedElementId = id; // Set as the element being actively held down
            return true; // Successfully captured this frame
        }
        return false; // Failed to capture
    }

    /// <summary>
    /// Clears the actively pressed element state. Called by the element upon detecting its release.
    /// </summary>
    internal static void ClearActivePress(string id)
    {
        // Only clear if the calling element is the one currently marked as active
        if (activelyPressedElementId == id)
        {
            activelyPressedElementId = null;
        }
    }

    // --- Containers ---
    public static void BeginHBoxContainer(string id, Vector2 position, float gap = 5.0f)
    {
        Vector2 startPosition = ApplyLayout(position);
        var containerState = new HBoxContainerState(id, startPosition, gap);
        containerStack.Push(containerState);
    }
    public static void EndHBoxContainer()
    {
        if (containerStack.Count == 0 || containerStack.Peek() is not HBoxContainerState state)
        { Console.WriteLine("Error: EndHBoxContainer called without a matching BeginHBoxContainer."); return; }
        containerStack.Pop();
        if (IsInLayoutContainer())
        { AdvanceLayoutCursor(new Vector2(state.AccumulatedWidth, state.MaxElementHeight)); }
    }
    public static void BeginVBoxContainer(string id, Vector2 position, float gap = 5.0f)
    {
        Vector2 startPosition = ApplyLayout(position);
        var containerState = new VBoxContainerState(id, startPosition, gap);
        containerStack.Push(containerState);
    }
    public static void EndVBoxContainer()
    {
        if (containerStack.Count == 0 || containerStack.Peek() is not VBoxContainerState state)
        { Console.WriteLine("Error: EndVBoxContainer called without a matching BeginVBoxContainer."); return; }
        containerStack.Pop();
        if (IsInLayoutContainer())
        { AdvanceLayoutCursor(new Vector2(state.MaxElementWidth, state.AccumulatedHeight)); }
    }
    public static void BeginGridContainer(string id, Vector2 position, Vector2 availableSize, int numColumns, Vector2 gap)
    {
        Vector2 startPosition = ApplyLayout(position);
        var containerState = new GridContainerState(id, startPosition, availableSize, numColumns, gap);
        containerStack.Push(containerState);
    }
    public static void EndGridContainer()
    {
        if (containerStack.Count == 0 || containerStack.Peek() is not GridContainerState state)
        { Console.WriteLine("Error: EndGridContainer called without a matching BeginGridContainer."); return; }
        containerStack.Pop();
        if (IsInLayoutContainer())
        {
            if (state.RowHeights.Count > 0 && state.CurrentCellIndex > 0)
            {
                int lastPopulatedRowIndex = (state.CurrentCellIndex - 1) / state.NumColumns;
                if (lastPopulatedRowIndex < state.RowHeights.Count)
                { state.RowHeights[lastPopulatedRowIndex] = state.CurrentRowMaxHeight; }
                else { Console.WriteLine($"Warning: Grid '{state.Id}' - Row index mismatch during EndGridContainer."); }
                state.AccumulatedHeight = 0f; bool firstRowAdded = false;
                for (int i = 0; i < state.RowHeights.Count; i++) { if (state.RowHeights[i] > 0) { if (firstRowAdded) { state.AccumulatedHeight += state.Gap.Y; } state.AccumulatedHeight += state.RowHeights[i]; firstRowAdded = true; } }
            }
            Vector2 containerSize = state.GetTotalOccupiedSize();
            AdvanceLayoutCursor(containerSize);
        }
    }

    // --- Widgets ---
    public static bool Button(string id, ButtonDefinition definition)
    {
        if (!IsContextValid() || definition is null) return false;
        Button buttonInstance = GetOrCreateElement<Button>(id);
        Vector2 elementPosition = GetCurrentLayoutPositionInternal();
        buttonInstance.Position = elementPosition;
        ApplyButtonDefinition(buttonInstance, definition);
        bool pushedClip = false; Rect cellClipRect = Rect.Empty;
        if (IsInLayoutContainer() && containerStack.Peek() is GridContainerState grid)
        {
            float clipStartY = grid.CurrentDrawPosition.Y; float gridBottomY = grid.StartPosition.Y + grid.AvailableSize.Y;
            float clipHeight = Math.Max(0f, gridBottomY - clipStartY);
            cellClipRect = new Rect(grid.CurrentDrawPosition.X, clipStartY, Math.Max(0f, grid.CellWidth), clipHeight);
            if (CurrentRenderTarget is not null && cellClipRect.Width > 0 && cellClipRect.Height > 0)
            { CurrentRenderTarget.PushAxisAlignedClip(cellClipRect, D2D.AntialiasMode.Aliased); pushedClip = true; }
        }
        bool clicked = buttonInstance.Update(id);
        if (pushedClip && CurrentRenderTarget is not null)
        { CurrentRenderTarget.PopAxisAlignedClip(); }
        AdvanceLayout(buttonInstance.Size);
        return clicked;
    }

    public static float HSlider(string id, float currentValue, SliderDefinition definition)
    {
        if (!IsContextValid() || definition is null) return currentValue;
        InternalHSliderLogic sliderInstance = GetOrCreateElement<InternalHSliderLogic>(id);
        Vector2 elementPosition = GetCurrentLayoutPositionInternal();
        sliderInstance.Position = elementPosition;
        ApplySliderDefinition(sliderInstance, definition);
        sliderInstance.Direction = definition.HorizontalDirection;
        bool pushedClip = false; Rect cellClipRect = Rect.Empty;
        if (IsInLayoutContainer() && containerStack.Peek() is GridContainerState grid)
        {
            float clipStartY = grid.CurrentDrawPosition.Y; float gridBottomY = grid.StartPosition.Y + grid.AvailableSize.Y;
            float clipHeight = Math.Max(0f, gridBottomY - clipStartY);
            cellClipRect = new Rect(grid.CurrentDrawPosition.X, clipStartY, Math.Max(0f, grid.CellWidth), clipHeight);
            if (CurrentRenderTarget is not null && cellClipRect.Width > 0 && cellClipRect.Height > 0)
            { CurrentRenderTarget.PushAxisAlignedClip(cellClipRect, D2D.AntialiasMode.Aliased); pushedClip = true; }
        }
        float newValue = sliderInstance.UpdateAndDraw(id, CurrentInputState, GetCurrentDrawingContext(), currentValue);
        if (pushedClip && CurrentRenderTarget is not null)
        { CurrentRenderTarget.PopAxisAlignedClip(); }
        AdvanceLayout(sliderInstance.Size);
        return newValue;
    }

    public static float VSlider(string id, float currentValue, SliderDefinition definition)
    {
        if (!IsContextValid() || definition is null) return currentValue;
        InternalVSliderLogic sliderInstance = GetOrCreateElement<InternalVSliderLogic>(id);
        Vector2 elementPosition = GetCurrentLayoutPositionInternal();
        sliderInstance.Position = elementPosition;
        ApplySliderDefinition(sliderInstance, definition);
        sliderInstance.Direction = definition.VerticalDirection;
        bool pushedClip = false; Rect cellClipRect = Rect.Empty;
        if (IsInLayoutContainer() && containerStack.Peek() is GridContainerState grid)
        {
            float clipStartY = grid.CurrentDrawPosition.Y; float gridBottomY = grid.StartPosition.Y + grid.AvailableSize.Y;
            float clipHeight = Math.Max(0f, gridBottomY - clipStartY);
            cellClipRect = new Rect(grid.CurrentDrawPosition.X, clipStartY, Math.Max(0f, grid.CellWidth), clipHeight);
            if (CurrentRenderTarget is not null && cellClipRect.Width > 0 && cellClipRect.Height > 0)
            { CurrentRenderTarget.PushAxisAlignedClip(cellClipRect, D2D.AntialiasMode.Aliased); pushedClip = true; }
        }
        float newValue = sliderInstance.UpdateAndDraw(id, CurrentInputState, GetCurrentDrawingContext(), currentValue);
        if (pushedClip && CurrentRenderTarget is not null)
        { CurrentRenderTarget.PopAxisAlignedClip(); }
        AdvanceLayout(sliderInstance.Size);
        return newValue;
    }


    // --- Helper Methods ---
    private static bool IsContextValid()
    {
        if (CurrentRenderTarget is null || CurrentDWriteFactory is null) { Console.WriteLine($"Error: UI method called outside BeginFrame/EndFrame or context is invalid."); return false; }
        return true;
    }
    private static DrawingContext GetCurrentDrawingContext()
    {
        if (!IsContextValid()) { throw new InvalidOperationException("Attempted to get DrawingContext when UI context is invalid."); }
        return new DrawingContext(CurrentRenderTarget!, CurrentDWriteFactory!);
    }
    private static T GetOrCreateElement<T>(string id) where T : new()
    {
        if (uiElements.TryGetValue(id, out object? element) && element is T existingElement) { return existingElement; }
        else { T newElement = new(); uiElements[id] = newElement; return newElement; }
    }
    private static void ApplyButtonDefinition(Button instance, ButtonDefinition definition)
    {
        instance.Size = definition.Size; instance.Text = definition.Text; instance.Themes = definition.Theme ?? instance.Themes ?? new ButtonStylePack();
        instance.Origin = definition.Origin ?? Vector2.Zero; instance.TextAlignment = definition.TextAlignment ?? new Alignment(HAlignment.Center, VAlignment.Center);
        instance.TextOffset = definition.TextOffset ?? Vector2.Zero; instance.AutoWidth = definition.AutoWidth; instance.TextMargin = definition.TextMargin ?? new Vector2(10, 5);
        instance.Behavior = definition.Behavior; instance.LeftClickActionMode = definition.LeftClickActionMode; instance.Disabled = definition.Disabled; instance.UserData = definition.UserData;
    }
    private static void ApplySliderDefinition(InternalSliderLogic instance, SliderDefinition definition)
    {
        instance.Size = definition.Size; instance.MinValue = definition.MinValue; instance.MaxValue = definition.MaxValue; instance.Step = definition.Step;
        instance.Theme = definition.Theme ?? instance.Theme ?? new SliderStyle(); instance.GrabberTheme = definition.GrabberTheme ?? instance.GrabberTheme ?? new ButtonStylePack();
        instance.GrabberSize = definition.GrabberSize ?? instance.GrabberSize; instance.Origin = definition.Origin ?? Vector2.Zero; instance.Disabled = definition.Disabled; instance.UserData = definition.UserData;
    }


    // --- Layout Helpers ---
    private static Vector2 ApplyLayout(Vector2 defaultPosition) { return IsInLayoutContainer() ? GetCurrentLayoutPositionInternal() : defaultPosition; }
    private static void AdvanceLayout(Vector2 elementSize) { if (IsInLayoutContainer()) { AdvanceLayoutCursor(new Vector2(Math.Max(0, elementSize.X), Math.Max(0, elementSize.Y))); } }
    private static bool IsInLayoutContainer() => containerStack.Count > 0;
    private static Vector2 GetCurrentLayoutPositionInternal()
    {
        if (containerStack.Count == 0) return Vector2.Zero;
        object currentContainerState = containerStack.Peek();
        return currentContainerState switch { HBoxContainerState hbox => hbox.CurrentPosition, VBoxContainerState vbox => vbox.CurrentPosition, GridContainerState grid => grid.CurrentDrawPosition, _ => Vector2.Zero, };
    }
    public static Vector2 GetCurrentLayoutPosition() { return IsInLayoutContainer() ? GetCurrentLayoutPositionInternal() : Vector2.Zero; }
    private static void AdvanceLayoutCursor(Vector2 elementSize)
    {
        if (containerStack.Count == 0) return;
        object currentContainerState = containerStack.Peek();
        switch (currentContainerState)
        {
            case HBoxContainerState hbox: if (elementSize.Y > hbox.MaxElementHeight) hbox.MaxElementHeight = elementSize.Y; float advanceX = (hbox.AccumulatedWidth > 0 ? hbox.Gap : 0) + elementSize.X; hbox.CurrentPosition = new Vector2(hbox.CurrentPosition.X + advanceX, hbox.CurrentPosition.Y); hbox.AccumulatedWidth = hbox.CurrentPosition.X - hbox.StartPosition.X; break;
            case VBoxContainerState vbox: if (elementSize.X > vbox.MaxElementWidth) vbox.MaxElementWidth = elementSize.X; float advanceY = (vbox.AccumulatedHeight > 0 ? vbox.Gap : 0) + elementSize.Y; vbox.CurrentPosition = new Vector2(vbox.CurrentPosition.X, vbox.CurrentPosition.Y + advanceY); vbox.AccumulatedHeight = vbox.CurrentPosition.Y - vbox.StartPosition.Y; break;
            case GridContainerState grid: grid.MoveToNextCell(elementSize); break;
            default: Console.WriteLine("Error: AdvanceLayoutCursor called with unexpected container type."); break;
        }
    }

    // --- Brush Cache ---
    public static ID2D1SolidColorBrush GetOrCreateBrush(Color4 color)
    {
        if (CurrentRenderTarget is null) { Console.WriteLine("Error: GetOrCreateBrush called with no active render target."); return null!; }
        if (brushCache.TryGetValue(color, out ID2D1SolidColorBrush? brush) && brush is not null) { return brush; }
        else if (brush is null && brushCache.ContainsKey(color)) { brushCache.Remove(color); }
        try
        {
            brush = CurrentRenderTarget.CreateSolidColorBrush(color);
            if (brush is not null) { brushCache[color] = brush; return brush; }
            else { Console.WriteLine($"Warning: CreateSolidColorBrush returned null for color {color}"); return null!; }
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == ResultCode.RecreateTarget.Code) { Console.WriteLine($"Brush creation failed due to RecreateTarget error (Color: {color}). External cleanup needed."); return null!; }
        catch (Exception ex) { Console.WriteLine($"Error creating brush for color {color}: {ex.Message}"); return null!; }
    }

    // --- Resource Cleanup ---
    public static void CleanupResources()
    {
        Console.WriteLine("UI Resource Cleanup: Disposing cached brushes..."); int count = brushCache.Count;
        foreach (var pair in brushCache) { pair.Value?.Dispose(); }
        brushCache.Clear(); Console.WriteLine($"UI Resource Cleanup finished. Disposed {count} brushes."); containerStack.Clear();
    }

    // --- SHARED DRAWING HELPERS ---
    internal static void DrawBoxStyleHelper(ID2D1RenderTarget renderTarget, Vector2 pos, Vector2 size, BoxStyle style)
    {
        if (renderTarget is null || style is null || size.X <= 0 || size.Y <= 0) return;
        ID2D1SolidColorBrush fillBrush = GetOrCreateBrush(style.FillColor); ID2D1SolidColorBrush borderBrush = GetOrCreateBrush(style.BorderColor);
        bool hasVisibleFill = style.FillColor.A > 0 && fillBrush is not null;
        bool hasVisibleBorder = style.BorderColor.A > 0 && borderBrush is not null && (style.BorderLengthTop > 0 || style.BorderLengthRight > 0 || style.BorderLengthBottom > 0 || style.BorderLengthLeft > 0);
        if (!hasVisibleFill && !hasVisibleBorder) return;
        float borderTop = Math.Max(0f, style.BorderLengthTop); float borderRight = Math.Max(0f, style.BorderLengthRight); float borderBottom = Math.Max(0f, style.BorderLengthBottom); float borderLeft = Math.Max(0f, style.BorderLengthLeft);

        if (style.Roundness > 0.0f)
        {
            float avgHorizontalBorder = (borderLeft + borderRight) / 2.0f; float avgVerticalBorder = (borderTop + borderBottom) / 2.0f; float approxBorderThickness = Math.Max(avgHorizontalBorder, avgVerticalBorder); float halfApproxBorder = approxBorderThickness / 2.0f;
            Rect outerBounds = new Rect(pos.X, pos.Y, size.X, size.Y); float maxOuterRadius = Math.Min(outerBounds.Width * 0.5f, outerBounds.Height * 0.5f); float outerRadius = Math.Max(0f, maxOuterRadius * Math.Clamp(style.Roundness, 0.0f, 1.0f));
            if (float.IsFinite(outerRadius) && outerRadius >= 0)
            {
                if (hasVisibleFill)
                {
                    float fillInsetWidth = Math.Max(0f, outerBounds.Width - approxBorderThickness); float fillInsetHeight = Math.Max(0f, outerBounds.Height - approxBorderThickness);
                    if (fillInsetWidth > 0 && fillInsetHeight > 0) { Rect fillBounds = new Rect(outerBounds.X + halfApproxBorder, outerBounds.Y + halfApproxBorder, fillInsetWidth, fillInsetHeight); float fillRadius = Math.Max(0f, outerRadius - halfApproxBorder); System.Drawing.RectangleF fillRectF = new(fillBounds.X, fillBounds.Y, fillBounds.Width, fillBounds.Height); RoundedRectangle fillRoundedRect = new(fillRectF, fillRadius, fillRadius); renderTarget.FillRoundedRectangle(fillRoundedRect, fillBrush); }
                    else if (fillBrush is not null) { System.Drawing.RectangleF outerRectF = new(outerBounds.X, outerBounds.Y, outerBounds.Width, outerBounds.Height); RoundedRectangle outerRoundedRect = new(outerRectF, outerRadius, outerRadius); renderTarget.FillRoundedRectangle(outerRoundedRect, fillBrush); }
                }
                if (hasVisibleBorder && approxBorderThickness > 0)
                {
                    float borderPathWidth = Math.Max(0f, outerBounds.Width - approxBorderThickness); float borderPathHeight = Math.Max(0f, outerBounds.Height - approxBorderThickness);
                    if (borderPathWidth > 0 && borderPathHeight > 0) { Rect borderPathBounds = new Rect(outerBounds.X + halfApproxBorder, outerBounds.Y + halfApproxBorder, borderPathWidth, borderPathHeight); float borderPathRadius = Math.Max(0f, outerRadius - halfApproxBorder); System.Drawing.RectangleF borderPathRectF = new(borderPathBounds.X, borderPathBounds.Y, borderPathBounds.Width, borderPathBounds.Height); RoundedRectangle borderPathRoundedRect = new(borderPathRectF, borderPathRadius, borderPathRadius); renderTarget.DrawRoundedRectangle(borderPathRoundedRect, borderBrush, approxBorderThickness); }
                    else if (!hasVisibleFill || fillBrush is null) { System.Drawing.RectangleF outerRectF = new(outerBounds.X, outerBounds.Y, outerBounds.Width, outerBounds.Height); RoundedRectangle outerRoundedRect = new(outerRectF, outerRadius, outerRadius); renderTarget.FillRoundedRectangle(outerRoundedRect, borderBrush); }
                }
                return;
            }
        }
        if (hasVisibleFill)
        {
            float fillX = pos.X + borderLeft; float fillY = pos.Y + borderTop; float fillWidth = Math.Max(0f, size.X - borderLeft - borderRight); float fillHeight = Math.Max(0f, size.Y - borderTop - borderBottom);
            if (fillWidth > 0 && fillHeight > 0) { renderTarget.FillRectangle(new Rect(fillX, fillY, fillWidth, fillHeight), fillBrush); }
            else if (fillBrush is not null && borderLeft + borderRight >= size.X && borderTop + borderBottom >= size.Y) { renderTarget.FillRectangle(new Rect(pos.X, pos.Y, size.X, size.Y), fillBrush); }
        }
        if (hasVisibleBorder && borderBrush is not null)
        {
            if (borderTop > 0) renderTarget.FillRectangle(new Rect(pos.X, pos.Y, size.X, borderTop), borderBrush); if (borderBottom > 0) renderTarget.FillRectangle(new Rect(pos.X, pos.Y + size.Y - borderBottom, size.X, borderBottom), borderBrush);
            if (borderLeft > 0) { float leftHeight = Math.Max(0f, size.Y - borderTop - borderBottom); if (leftHeight > 0) renderTarget.FillRectangle(new Rect(pos.X, pos.Y + borderTop, borderLeft, leftHeight), borderBrush); }
            if (borderRight > 0) { float rightHeight = Math.Max(0f, size.Y - borderTop - borderBottom); if (rightHeight > 0) renderTarget.FillRectangle(new Rect(pos.X + size.X - borderRight, pos.Y + borderTop, borderRight, rightHeight), borderBrush); }
        }
    }
}
</file>

<file path="Win32Window.cs">
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Collections.Generic;

namespace DirectUI;

public abstract class Win32Window : IDisposable
{
    // --- Ensure this class is identical to the previous version ---
    // Including:
    // Fields: _windowClassName, _windowTitle, _initialWidth, _initialHeight, _hwnd, _hInstance, _wndProcDelegate, _isDisposed, RegisteredClassNames, _gcHandle
    // Properties: Handle, Width, Height
    // Constructor: Win32Window(...)
    // Methods: Run(), TryCreateWindow(), WindowProcedure(static), HandleMessage(virtual), Close(), Invalidate()
    // Virtual Methods: Initialize(), OnPaint(), OnSize(), OnMouseDown(), OnMouseUp(), OnMouseMove(), OnKeyDown(), OnClose(), OnDestroy(), Cleanup()
    // IDisposable: Dispose(), Dispose(bool), Finalizer ~Win32Window()

    // --- Class Members (example subset) ---
    private readonly string _windowClassName;
    private readonly string _windowTitle;
    private readonly int _initialWidth;
    private readonly int _initialHeight;
    private IntPtr _hwnd = IntPtr.Zero;
    private IntPtr _hInstance = IntPtr.Zero;
    private NativeMethods.WndProc _wndProcDelegate;
    private bool _isDisposed = false;
    private static readonly HashSet<string> RegisteredClassNames = new HashSet<string>();
    private GCHandle _gcHandle;

    public IntPtr Handle => _hwnd;
    public int Width { get; protected set; } // Changed to protected set
    public int Height { get; protected set; } // Changed to protected set

    // --- Constructor ---
    protected Win32Window(string title, int width, int height, string className = null)
    {
        _windowTitle = title ?? "Win32 Window";
        _initialWidth = width > 0 ? width : 800;
        _initialHeight = height > 0 ? height : 600;
        Width = _initialWidth;
        Height = _initialHeight;
        _windowClassName = className ?? ("Win32Window_" + Guid.NewGuid().ToString("N"));
        _wndProcDelegate = WindowProcedure; // Pin delegate
    }

    // --- Methods (Ensure Run, TryCreateWindow, WindowProcedure, HandleMessage are as before) ---
    public void Run()
    { /* ... as before ... */
        if (_hwnd != IntPtr.Zero) throw new InvalidOperationException("Window already created.");
        if (!TryCreateWindow()) { Console.WriteLine("Window creation failed."); Dispose(); return; }
        if (!Initialize()) { Console.WriteLine("Derived init failed."); Dispose(); return; }
        NativeMethods.ShowWindow(_hwnd, NativeMethods.SW_SHOWNORMAL);
        NativeMethods.UpdateWindow(_hwnd);
        NativeMethods.MSG msg;
        while (NativeMethods.GetMessage(out msg, IntPtr.Zero, 0, 0))
        { NativeMethods.TranslateMessage(ref msg); NativeMethods.DispatchMessage(ref msg); }
        Console.WriteLine("Exiting message loop.");
    }

    private bool TryCreateWindow()
    { /* ... as before ... */
        _hInstance = NativeMethods.GetModuleHandle(null);
        if (_hInstance == IntPtr.Zero) _hInstance = Process.GetCurrentProcess().Handle;
        lock (RegisteredClassNames)
        {
            if (!RegisteredClassNames.Contains(_windowClassName))
            {
                var wndClass = new NativeMethods.WNDCLASSEX
                { /* ... fill struct ... */
                    cbSize = Marshal.SizeOf(typeof(NativeMethods.WNDCLASSEX)),
                    style = NativeMethods.CS_HREDRAW | NativeMethods.CS_VREDRAW,
                    lpfnWndProc = _wndProcDelegate,
                    hInstance = _hInstance,
                    lpszClassName = _windowClassName,
                    hIcon = NativeMethods.LoadIcon(IntPtr.Zero, (IntPtr)32512),
                    hCursor = NativeMethods.LoadCursor(IntPtr.Zero, 32512),
                };
                if (NativeMethods.RegisterClassEx(ref wndClass) == 0) { Console.WriteLine($"RegisterClassEx failed: {Marshal.GetLastWin32Error()}"); return false; }
                RegisteredClassNames.Add(_windowClassName); Console.WriteLine($"Class '{_windowClassName}' registered.");
            }
        }
        _gcHandle = GCHandle.Alloc(this);
        _hwnd = NativeMethods.CreateWindowEx(0, _windowClassName, _windowTitle, NativeMethods.WS_OVERLAPPEDWINDOW | NativeMethods.WS_VISIBLE,
            NativeMethods.CW_USEDEFAULT, NativeMethods.CW_USEDEFAULT, _initialWidth, _initialHeight, IntPtr.Zero, IntPtr.Zero, _hInstance, GCHandle.ToIntPtr(_gcHandle));
        if (_hwnd == IntPtr.Zero) { Console.WriteLine($"CreateWindowEx failed: {Marshal.GetLastWin32Error()}"); if (_gcHandle.IsAllocated) _gcHandle.Free(); return false; }
        Console.WriteLine($"Window created: {_hwnd}"); return true;
    }

    private static IntPtr WindowProcedure(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    { /* ... as before ... */
        Win32Window window = null;
        if (msg == NativeMethods.WM_NCCREATE)
        {
            var cs = Marshal.PtrToStructure<NativeMethods.CREATESTRUCT>(lParam);
            var handle = GCHandle.FromIntPtr(cs.lpCreateParams); window = handle.Target as Win32Window;
            NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, GCHandle.ToIntPtr(handle));
            Console.WriteLine($"WM_NCCREATE: Associated instance with HWND {hWnd}");
        }
        else
        {
            IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA);
            if (ptr != IntPtr.Zero) { var handle = GCHandle.FromIntPtr(ptr); window = handle.Target as Win32Window; }
        }
        if (window != null) { try { return window.HandleMessage(hWnd, msg, wParam, lParam); } catch (Exception ex) { Console.WriteLine($"Error handling msg {msg}: {ex}"); } }
        return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
    }

    protected virtual IntPtr HandleMessage(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    { /* ... as before ... */
        switch (msg)
        {
            case NativeMethods.WM_PAINT: OnPaint(); return IntPtr.Zero;
            case NativeMethods.WM_SIZE: Width = NativeMethods.LoWord(lParam); Height = NativeMethods.HiWord(lParam); OnSize(Width, Height); return IntPtr.Zero;
            case NativeMethods.WM_MOUSEMOVE: OnMouseMove(NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam)); return IntPtr.Zero; // Ensure exists
            case NativeMethods.WM_LBUTTONDOWN: OnMouseDown(MouseButton.Left, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam)); return IntPtr.Zero; // Ensure exists
            case NativeMethods.WM_LBUTTONUP: OnMouseUp(MouseButton.Left, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam)); return IntPtr.Zero; // Ensure exists
            case NativeMethods.WM_KEYDOWN: OnKeyDown((int)wParam); return IntPtr.Zero;
            case NativeMethods.WM_CLOSE: if (OnClose()) { NativeMethods.DestroyWindow(hWnd); } return IntPtr.Zero;
            case NativeMethods.WM_DESTROY: Console.WriteLine($"WM_DESTROY for {hWnd}."); OnDestroy(); NativeMethods.PostQuitMessage(0); return IntPtr.Zero;
            case NativeMethods.WM_NCDESTROY: Console.WriteLine($"WM_NCDESTROY: Releasing GCHandle for {hWnd}."); IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA); if (ptr != IntPtr.Zero) { var handle = GCHandle.FromIntPtr(ptr); if (handle.IsAllocated) handle.Free(); NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, IntPtr.Zero); } if (_gcHandle.IsAllocated && GCHandle.ToIntPtr(_gcHandle) == ptr) { _gcHandle = default; } _hwnd = IntPtr.Zero; return IntPtr.Zero;
            default: return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
        }
    }

    public void Close() { if (_hwnd != IntPtr.Zero) NativeMethods.DestroyWindow(_hwnd); }
    public void Invalidate() { if (_hwnd != IntPtr.Zero) NativeMethods.InvalidateRect(_hwnd, IntPtr.Zero, false); }

    // --- Virtual Methods (Ensure all needed methods are declared) ---
    protected virtual bool Initialize() { return true; }
    protected virtual void OnPaint() { }
    protected virtual void OnSize(int width, int height) { }
    protected virtual void OnMouseDown(MouseButton button, int x, int y) { }
    protected virtual void OnMouseUp(MouseButton button, int x, int y) { }     // Ensure exists
    protected virtual void OnMouseMove(int x, int y) { }     // Ensure exists
    protected virtual void OnKeyDown(int keyCode) { }
    protected virtual bool OnClose() { return true; }
    protected virtual void OnDestroy() { }
    protected virtual void Cleanup() { }

    // --- IDisposable (Ensure implementation is as before) ---
    public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
    protected virtual void Dispose(bool disposing)
    { /* ... as before ... */
        if (!_isDisposed)
        {
            if (disposing) { Console.WriteLine("Disposing Win32Window (managed)..."); Cleanup(); }
            Console.WriteLine("Disposing Win32Window (unmanaged)...");
            if (_hwnd != IntPtr.Zero) { Console.WriteLine($"Destroying window {_hwnd} during Dispose..."); NativeMethods.DestroyWindow(_hwnd); _hwnd = IntPtr.Zero; }
            else { if (_gcHandle.IsAllocated) { Console.WriteLine("Freeing dangling GCHandle..."); _gcHandle.Free(); } }
            _isDisposed = true; Console.WriteLine("Win32Window disposed.");
        }
    }
    ~Win32Window() { Console.WriteLine("Win32Window Finalizer!"); Dispose(false); }
}

// Ensure MouseButton enum exists
public enum MouseButton { Left, Right, Middle, XButton1, XButton2 }
</file>

<file path="Containers\GridContainerState.cs">
// NEW: GridContainerState.cs
// Summary: State object for managing grid layout.
using System.Collections.Generic;
using System.Numerics;

namespace DirectUI;

internal class GridContainerState
{
    internal string Id { get; }
    internal Vector2 StartPosition { get; } // Top-left corner of the grid area
    internal int NumColumns { get; }
    internal Vector2 Gap { get; } // Gap between cells (X and Y)
    internal Vector2 AvailableSize { get; } // Total area the grid can occupy

    // Calculated layout values
    internal float CellWidth { get; }
    internal List<float> RowHeights { get; } = new(); // Store height of each completed row
    internal float CurrentRowMaxHeight { get; set; } = 0f; // Track max height of elements in the current row being built
    internal int CurrentCellIndex { get; set; } = 0; // 0-based index of the next cell to place an element in
    internal Vector2 CurrentDrawPosition { get; set; } // Calculated top-left for the next element

    // Tracking overall bounds occupied by elements
    internal float AccumulatedWidth { get; set; } = 0f;
    internal float AccumulatedHeight { get; set; } = 0f;


    internal GridContainerState(string id, Vector2 startPosition, Vector2 availableSize, int numColumns, Vector2 gap)
    {
        Id = id;
        StartPosition = startPosition;
        AvailableSize = availableSize;
        NumColumns = Math.Max(1, numColumns); // Ensure at least one column
        Gap = gap;

        // Calculate fixed cell width based on available space and gaps
        float totalHorizontalGap = Math.Max(0, NumColumns - 1) * Gap.X;
        float widthForCells = AvailableSize.X - totalHorizontalGap;
        CellWidth = (NumColumns > 0) ? Math.Max(0, widthForCells / NumColumns) : 0;

        // Initial position is the start position
        CurrentDrawPosition = startPosition;
        RowHeights.Add(0); // Add initial height for the first row (will be updated)
    }

    internal void MoveToNextCell(Vector2 elementSize)
    {
        // Update max height for the current row
        CurrentRowMaxHeight = Math.Max(CurrentRowMaxHeight, elementSize.Y);

        // Update total occupied width (conservative estimate using cell width)
        int currentCol = CurrentCellIndex % NumColumns;
        float currentWidth = (currentCol + 1) * CellWidth + currentCol * Gap.X;
        AccumulatedWidth = Math.Max(AccumulatedWidth, currentWidth);


        CurrentCellIndex++;
        int nextCol = CurrentCellIndex % NumColumns;

        if (nextCol == 0) // Moved to the start of a new row
        {
            // Finalize the height of the completed row
            RowHeights[^1] = CurrentRowMaxHeight; // Update last row's height
            AccumulatedHeight += CurrentRowMaxHeight + (RowHeights.Count > 1 ? Gap.Y : 0); // Add height and gap (if not first row)

            // Reset for the new row
            CurrentRowMaxHeight = 0f;
            RowHeights.Add(0); // Add placeholder height for the new row

            // Calculate Y position for the new row
            float newY = StartPosition.Y;
            for (int i = 0; i < RowHeights.Count - 1; i++) // Sum heights and gaps of completed rows
            {
                newY += RowHeights[i] + Gap.Y;
            }

            // Set position for the first cell of the new row
            CurrentDrawPosition = new Vector2(StartPosition.X, newY);

        }
        else // Moving to the next column in the same row
        {
            // Calculate X position for the next cell
            float currentX = StartPosition.X + nextCol * (CellWidth + Gap.X);
            CurrentDrawPosition = new Vector2(currentX, CurrentDrawPosition.Y); // Y stays the same
        }
    }

    internal Vector2 GetTotalOccupiedSize()
    {
        // Calculate final height including the current row being built
        float finalHeight = AccumulatedHeight + CurrentRowMaxHeight;
        return new Vector2(AccumulatedWidth, finalHeight);
    }
}
</file>

<file path="Containers\HBoxContainerState.cs">
// MODIFIED: HBoxContainerState.cs
// Summary: Added the missing StartPosition property.
using System.Numerics;

namespace DirectUI;

internal class HBoxContainerState
{
    internal string Id { get; }
    internal Vector2 StartPosition { get; } // Added missing property
    internal Vector2 CurrentPosition { get; set; }
    internal float Gap { get; }
    internal float MaxElementHeight { get; set; } = 0f;
    internal float AccumulatedWidth { get; set; } = 0f;

    internal HBoxContainerState(string id, Vector2 startPosition, float gap)
    {
        Id = id;
        StartPosition = startPosition; // Initialize the new property
        CurrentPosition = startPosition;
        Gap = gap;
    }
}
</file>

<file path="Containers\VBoxContainerState.cs">
// NEW: VBoxContainerState.cs
// Summary: State object to manage layout within a vertical container.
using System.Numerics;

namespace DirectUI;

internal class VBoxContainerState
{
    internal string Id { get; }
    internal Vector2 StartPosition { get; }
    internal Vector2 CurrentPosition { get; set; } // Top-left for the next element
    internal float Gap { get; }
    internal float MaxElementWidth { get; set; } = 0f; // Track width for container bounds
    internal float AccumulatedHeight { get; set; } = 0f; // Track height for container bounds

    internal VBoxContainerState(string id, Vector2 startPosition, float gap)
    {
        Id = id;
        StartPosition = startPosition;
        CurrentPosition = startPosition;
        Gap = gap;
    }
}
</file>

<file path="Styles\BoxStyle.cs">
// MODIFIED: Styles/BoxStyle.cs
// Summary: Replaced BorderThickness with BorderLengthTop, BorderLengthRight, BorderLengthBottom, BorderLengthLeft. Added convenience setter BorderLength.
using Vortice.Mathematics;

namespace DirectUI;

public class BoxStyle
{
    public float Roundness { get; set; } = 0.2f;
    public Color4 FillColor { get; set; } = DefaultTheme.NormalFill;
    public Color4 BorderColor { get; set; } = DefaultTheme.NormalBorder;

    public float BorderLengthTop { get; set; } = 1.0f;
    public float BorderLengthRight { get; set; } = 1.0f;
    public float BorderLengthBottom { get; set; } = 1.0f;
    public float BorderLengthLeft { get; set; } = 1.0f;

    public float BorderLength
    {
        set
        {
            BorderLengthTop = value;
            BorderLengthRight = value;
            BorderLengthBottom = value;
            BorderLengthLeft = value;
        }
    }
}
</file>

<file path="Styles\ButtonStyle.cs">
// ButtonStyle.cs
using Vortice.Mathematics;
using Vortice.DirectWrite; // For Font related enums eventually

namespace DirectUI;

public class ButtonStyle : BoxStyle
{
    // DirectWrite Font properties will be managed elsewhere (e.g., IDWriteTextFormat)
    // public float FontSpacing { get; set; } = 0; // Handled by TextFormat
    // public float FontSize { get; set; } = 16; // Handled by TextFormat
    // public Font? Font { get; set; } = null; // Represented by TextFormat
    public Color4 FontColor { get; set; } = DefaultTheme.Text;

    // Properties needed for creating IDWriteTextFormat
    public string FontName { get; set; } = "Segoe UI";
    public float FontSize { get; set; } = 16.0f;
    public FontWeight FontWeight { get; set; } = FontWeight.Normal;
    public FontStyle FontStyle { get; set; } = FontStyle.Normal;
    public FontStretch FontStretch { get; set; } = FontStretch.Normal;
}
</file>

<file path="Styles\ButtonStylePack.cs">
// MODIFIED: Styles/ButtonStylePack.cs
// Summary: Updated BorderThickness convenience setter to use the new BorderLength setter in BoxStyle.
using System.Collections.Generic;
using System;
using Vortice.Mathematics;
using Vortice.DirectWrite;

namespace DirectUI;

public sealed class ButtonStylePack
{
    public ButtonStyle Current { get; private set; }
    public ButtonStyle Normal { get; set; } = new();
    public ButtonStyle Hover { get; set; } = new();
    public ButtonStyle Pressed { get; set; } = new();
    public ButtonStyle Disabled { get; set; } = new();
    // public ButtonStyle Focused { get; set; } = new(); // Focus state not implemented yet

    public ButtonStylePack()
    {
        Hover.FillColor = DefaultTheme.HoverFill;
        Hover.BorderColor = DefaultTheme.HoverBorder;

        Pressed.FillColor = DefaultTheme.Accent;
        Pressed.BorderColor = DefaultTheme.AccentBorder;

        Disabled.FillColor = DefaultTheme.DisabledFill;
        Disabled.BorderColor = DefaultTheme.DisabledBorder;
        Disabled.FontColor = DefaultTheme.DisabledText;

        Current = Normal;
    }

    public void UpdateCurrentStyle(bool isHovering, bool isPressed, bool isDisabled /*, bool isFocused */)
    {
        if (isDisabled)
        {
            Current = Disabled;
        }
        else if (isPressed)
        {
            Current = Pressed;
        }
        else if (isHovering)
        {
            Current = Hover;
        }
        else
        {
            Current = Normal;
        }
    }

    private IEnumerable<ButtonStyle> AllStyles => [Normal, Hover, Pressed, Disabled /*, Focused*/];

    public string FontName
    {
        set => SetAll(s => s.FontName = value);
    }

    public float FontSize
    {
        set => SetAll(s => s.FontSize = value);
    }

    public FontWeight FontWeight
    {
        set => SetAll(s => s.FontWeight = value);
    }

    public FontStyle FontStyle
    {
        set => SetAll(s => s.FontStyle = value);
    }

    public FontStretch FontStretch
    {
        set => SetAll(s => s.FontStretch = value);
    }

    public Color4 FontColor
    {
        set => SetAll(s => s.FontColor = value);
    }

    public float Roundness
    {
        set => SetAll(s => s.Roundness = value);
    }

    // Updated setter
    public float BorderLength
    {
        set => SetAll(s => s.BorderLength = value);
    }

    // Obsolete - kept for backward compatibility or remove if breaking change is ok
    [Obsolete("Use BorderLength instead.")]
    public float BorderThickness
    {
        set => SetAll(s => s.BorderLength = value);
    }


    public Color4 FillColor
    {
        set => SetAll(s => s.FillColor = value);
    }

    public Color4 BorderColor
    {
        set => SetAll(s => s.BorderColor = value);
    }

    private void SetAll(Action<ButtonStyle> setter)
    {
        foreach (ButtonStyle style in AllStyles)
        {
            setter(style);
        }
        setter(Current);
    }
}
</file>

<file path="Styles\DefaultTheme.cs">
// DefaultTheme.cs
using Vortice.Mathematics;

namespace DirectUI;

// Defines default colors for the UI theme
public static class DefaultTheme
{
    // Basic Palette
    public static readonly Color4 White = Colors.White;
    public static readonly Color4 Black = Colors.Black;
    public static readonly Color4 Transparent = Colors.Transparent;

    // UI Element Colors (Examples, adjust as needed)
    public static readonly Color4 NormalFill = new Color4(0.25f, 0.25f, 0.3f, 1.0f);
    public static readonly Color4 NormalBorder = new Color4(0.4f, 0.4f, 0.45f, 1.0f);

    public static readonly Color4 HoverFill = new Color4(0.35f, 0.35f, 0.4f, 1.0f);
    public static readonly Color4 HoverBorder = new Color4(0.5f, 0.5f, 0.55f, 1.0f);

    public static readonly Color4 Accent = new Color4(0.2f, 0.4f, 0.8f, 1.0f); // Used for Pressed Fill
    public static readonly Color4 AccentBorder = new Color4(0.3f, 0.5f, 0.9f, 1.0f); // Used for Pressed Border

    public static readonly Color4 DisabledFill = new Color4(0.2f, 0.2f, 0.2f, 0.8f);
    public static readonly Color4 DisabledBorder = new Color4(0.3f, 0.3f, 0.3f, 0.8f);
    public static readonly Color4 DisabledText = new Color4(0.5f, 0.5f, 0.5f, 1.0f);

    public static readonly Color4 FocusBorder = Colors.LightSkyBlue; // Example focus color

    public static readonly Color4 Text = Colors.WhiteSmoke;
}
</file>

<file path="Styles\SliderStyle.cs">
// MODIFIED: Styles/SliderStyle.cs
// Summary: Updated default BoxStyle initializations to use BorderLength instead of BorderThickness.
using Vortice.Mathematics;

namespace DirectUI;

public class SliderStyle
{
    public BoxStyle Background { get; set; } = new()
    {
        FillColor = DefaultTheme.DisabledFill,
        BorderColor = DefaultTheme.NormalBorder,
        Roundness = 0.5f,
        BorderLength = 1.0f // Use new property
    };

    public BoxStyle Foreground { get; set; } = new()
    {
        FillColor = DefaultTheme.Accent,
        BorderColor = Colors.Transparent,
        Roundness = 0.5f,
        BorderLength = 0.0f // Use new property
    };
}
</file>

<file path="Widgets\Button.cs">
// CORRECTED: Button.cs
// Summary: Correctly uses UI interaction states. Visual state (IsPressed) mirrors global active state for this button's ID. Capture attempt respects potential target.
using System;
using System.Numerics;
using Vortice.DirectWrite;
using Vortice.Mathematics;
using Vortice.Direct2D1;
using SharpGen.Runtime;

namespace DirectUI;

public class Button
{
    public enum ActionMode { Release, Press }
    public enum ClickBehavior { Left, Right, Both }

    // --- Properties ---
    public Vector2 Position { get; set; } = Vector2.Zero;
    public Vector2 Size { get; set; } = new(84, 28);
    public Vector2 Origin { get; set; } = Vector2.Zero;
    public string Text { get; set; } = "";
    public Vector2 TextOffset { get; set; } = Vector2.Zero;
    public Alignment TextAlignment { get; set; } = new(HAlignment.Center, VAlignment.Center);
    public ButtonStylePack Themes { get; set; } = new();
    public ActionMode LeftClickActionMode { get; set; } = ActionMode.Release;
    public bool AutoWidth { get; set; } = false;
    public Vector2 TextMargin { get; set; } = new(10, 5);
    public ClickBehavior Behavior { get; set; } = Button.ClickBehavior.Left;
    public bool Disabled { get; set; } = false;
    public object? UserData { get; set; } = null;

    // Internal state managed locally
    public bool IsHovering { get; internal set; } = false;
    // IsPressed is now purely determined by the global active state below
    private bool isPressed = false; // Internal field for UpdateStyle

    public Rect GlobalBounds
    {
        get
        {
            float x = Position.X - Origin.X;
            float y = Position.Y - Origin.Y;
            float width = Math.Max(0, Size.X);
            float height = Math.Max(0, Size.Y);
            var calculatedBounds = new Rect(x, y, width, height);
            return calculatedBounds;
        }
    }

    // --- Main Update Method ---
    internal bool Update(string id)
    {
        ID2D1HwndRenderTarget? renderTarget = UI.CurrentRenderTarget;
        IDWriteFactory? dwriteFactory = UI.CurrentDWriteFactory;
        InputState input = UI.CurrentInputState;

        if (renderTarget is null || dwriteFactory is null) return false;

        Rect bounds = GlobalBounds;
        bool wasClickedThisFrame = false;
        isPressed = false; // Reset visual state assumption for the frame

        if (Disabled)
        {
            IsHovering = false;
            if (UI.ActivelyPressedElementId == id) UI.ClearActivePress(id);
        }
        else
        {
            // 1. Check Hover State & Set Potential Target
            IsHovering = bounds.Width > 0 && bounds.Height > 0 && bounds.Contains(input.MousePosition.X, input.MousePosition.Y);
            if (IsHovering)
            {
                UI.SetPotentialInputTarget(id); // Declare potential target if hovered
            }

            // Relevant Input States
            bool primaryActionPressedThisFrame = (Behavior is ClickBehavior.Left or ClickBehavior.Both) && input.WasLeftMousePressedThisFrame;
            bool primaryActionHeld = (Behavior is ClickBehavior.Left or ClickBehavior.Both) && input.IsLeftMouseDown;

            // 2. Handle Mouse Release Logic
            if (!primaryActionHeld && UI.ActivelyPressedElementId == id)
            {
                if (IsHovering && LeftClickActionMode is ActionMode.Release)
                {
                    wasClickedThisFrame = true;
                }
                UI.ClearActivePress(id); // Clear the global active state
            }

            // 3. Handle Mouse Press Attempt
            if (primaryActionPressedThisFrame)
            {
                // Only try capture if hovering *and* this element is the potential target *and* nothing is active/captured.
                // TryCaptureInput handles the active/captured/potential checks internally.
                if (IsHovering && UI.TryCaptureInput(id))
                {
                    // Successfully captured! This button is now the active element.
                    // The visual state (isPressed) will be set correctly in step 4.
                    if (LeftClickActionMode is ActionMode.Press)
                    {
                        wasClickedThisFrame = true; // Click happens on press
                    }
                }
            }

            // 4. Determine CURRENT Visual Pressed State
            // This button should appear pressed IF AND ONLY IF it is the active element globally.
            isPressed = (UI.ActivelyPressedElementId == id);

        } // End !Disabled block

        // --- Update Style & Size ---
        UpdateStyle(); // Uses local IsHovering and the correctly determined isPressed
        PerformAutoWidth(dwriteFactory);

        // --- Drawing ---
        try
        {
            if (GlobalBounds.Width > 0 && GlobalBounds.Height > 0)
            {
                DrawBackground(renderTarget);
                DrawText(renderTarget, dwriteFactory);
            }
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == ResultCode.RecreateTarget.Code)
        { Console.WriteLine($"Render target needs recreation: {ex.Message}"); UI.CleanupResources(); return false; }
        catch (Exception ex)
        { Console.WriteLine($"Error drawing button: {ex}"); return false; }

        return wasClickedThisFrame;
    }

    // --- Internal Logic Methods ---
    internal void UpdateStyle()
    {
        // Uses the local IsHovering and the internal isPressed field managed within Update()
        Themes?.UpdateCurrentStyle(IsHovering, isPressed, Disabled);
    }

    internal Vector2 MeasureText(IDWriteFactory dwriteFactory)
    {
        if (string.IsNullOrEmpty(Text) || Themes?.Current?.FontName is null || dwriteFactory is null) return Vector2.Zero;
        IDWriteTextFormat? textFormat = null;
        try
        {
            ButtonStyle style = Themes.Current;
            textFormat = dwriteFactory.CreateTextFormat(style.FontName, null, style.FontWeight, style.FontStyle, style.FontStretch, style.FontSize, "en-us");
            if (textFormat is null) { Console.WriteLine("Warning: Failed to create TextFormat for measurement."); return Vector2.Zero; }
            using IDWriteTextLayout textLayout = dwriteFactory.CreateTextLayout(Text, textFormat, float.MaxValue, float.MaxValue);
            TextMetrics textMetrics = textLayout.Metrics;
            return new Vector2(textMetrics.WidthIncludingTrailingWhitespace, textMetrics.Height);
        }
        catch (Exception ex) { Console.WriteLine($"Error measuring text: {ex.Message}"); return Vector2.Zero; }
        finally { textFormat?.Dispose(); }
    }

    internal void PerformAutoWidth(IDWriteFactory dwriteFactory)
    {
        if (!AutoWidth || dwriteFactory is null) return;
        Vector2 textSize = MeasureText(dwriteFactory); float desiredWidth = textSize.X + TextMargin.X * 2;
        if (desiredWidth > 0 && Math.Abs(Size.X - desiredWidth) > 0.1f) { Size = new Vector2(desiredWidth, Size.Y); }
        else if (desiredWidth <= 0 && Size.X != 0) { /* Optional: Reset size or set MinWidth */ }
    }

    // --- Drawing Methods ---
    private void DrawBackground(ID2D1RenderTarget renderTarget)
    {
        Rect bounds = GlobalBounds; ButtonStyle? style = Themes?.Current;
        if (style is null || bounds.Width <= 0 || bounds.Height <= 0) return;
        UI.DrawBoxStyleHelper(renderTarget, new Vector2(bounds.X, bounds.Y), new Vector2(bounds.Width, bounds.Height), style);
    }

    private void DrawText(ID2D1RenderTarget renderTarget, IDWriteFactory dwriteFactory)
    {
        if (string.IsNullOrEmpty(Text)) return; ButtonStyle? style = Themes?.Current; if (style is null) return;
        ID2D1SolidColorBrush textBrush = UI.GetOrCreateBrush(style.FontColor); if (textBrush is null) return;
        IDWriteTextFormat? textFormat = null;
        try
        {
            textFormat = dwriteFactory.CreateTextFormat(style.FontName, null, style.FontWeight, style.FontStyle, style.FontStretch, style.FontSize, "en-us");
            if (textFormat is null) return;
            textFormat.TextAlignment = TextAlignment.Horizontal switch { HAlignment.Left => Vortice.DirectWrite.TextAlignment.Leading, HAlignment.Center => Vortice.DirectWrite.TextAlignment.Center, HAlignment.Right => Vortice.DirectWrite.TextAlignment.Trailing, _ => Vortice.DirectWrite.TextAlignment.Leading };
            textFormat.ParagraphAlignment = TextAlignment.Vertical switch { VAlignment.Top => Vortice.DirectWrite.ParagraphAlignment.Near, VAlignment.Center => Vortice.DirectWrite.ParagraphAlignment.Center, VAlignment.Bottom => Vortice.DirectWrite.ParagraphAlignment.Far, _ => Vortice.DirectWrite.ParagraphAlignment.Near };
            Rect bounds = GlobalBounds; if (bounds.Width <= 0 || bounds.Height <= 0) return;
            Rect layoutRect = bounds; layoutRect.Left += TextOffset.X; layoutRect.Top += TextOffset.Y;
            renderTarget.DrawText(Text, textFormat, layoutRect, textBrush, DrawTextOptions.Clip);
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == ResultCode.RecreateTarget.Code) { Console.WriteLine($"Text Draw failed (RecreateTarget): {ex.Message}."); textFormat = null; }
        catch (Exception ex) { Console.WriteLine($"Error drawing button text: {ex.Message}"); }
        finally { textFormat?.Dispose(); }
    }
}
</file>

<file path="Widgets\ButtonDefinition.cs">
// ButtonDefinition.cs
using System.Numerics;
using Vortice.Mathematics; // For Color4 if needed directly, though ButtonStylePack handles colors

namespace DirectUI;

public class ButtonDefinition
{
    public Vector2 Position { get; set; } = Vector2.Zero;
    public Vector2 Size { get; set; } = new(84, 28); // Default size
    public string Text { get; set; } = "";
    public ButtonStylePack? Theme { get; set; } = null; // Optional theme override
    public Vector2? Origin { get; set; } = null; // Use null to indicate default (Vector2.Zero)
    public Alignment? TextAlignment { get; set; } = null; // Use null for default (Center, Center)
    public Vector2? TextOffset { get; set; } = null; // Use null for default (Vector2.Zero)
    public bool AutoWidth { get; set; } = false;
    public Vector2? TextMargin { get; set; } = null; // Use null for default (10, 5)
    public Button.ClickBehavior Behavior { get; set; } = Button.ClickBehavior.Left;
    public Button.ActionMode LeftClickActionMode { get; set; } = Button.ActionMode.Release;
    public bool Disabled { get; set; } = false;
    public object? UserData { get; set; } = null;
}
</file>

<file path="Widgets\InternalHSliderLogic.cs">
// MODIFIED: InternalHSliderLogic.cs
// Summary: Updated HandleInput to perform hover checks, call UI.SetPotentialInputTarget, and use UI.TryCaptureInput. Removed separate UpdateHoverStates call.
using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

internal class InternalHSliderLogic : InternalSliderLogic
{
    public HSliderDirection Direction { get; set; } = HSliderDirection.LeftToRight;

    protected override void CalculateTrackBounds()
    {
        trackMinBound = trackPosition.X;
        trackMaxBound = trackPosition.X + Size.X;
    }

    // This can potentially be removed if HandleInput does all necessary hover updates
    protected override void UpdateHoverStates(Vector2 mousePos) { }

    protected override float HandleInput(string id, InputState input, float currentValue)
    {
        float newValue = currentValue;
        Vector2 mousePos = input.MousePosition;

        // 1. Calculate Hover States & Set Potential Target
        Vector2 currentGrabberPos = CalculateGrabberPosition(currentValue);
        Rect currentGrabberBounds = new Rect(currentGrabberPos.X, currentGrabberPos.Y, GrabberSize.X, GrabberSize.Y);
        bool preciseGrabberHovered = currentGrabberBounds.Contains(mousePos.X, mousePos.Y);

        Rect trackBounds = new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y);
        bool basicTrackHovered = trackBounds.Contains(mousePos.X, mousePos.Y);

        // Update internal hover state fields used for theming
        isGrabberHovered = preciseGrabberHovered;
        isTrackHovered = basicTrackHovered; // Store basic track hover as well

        // If hovered over grabber OR track, declare as potential target
        if (isGrabberHovered || isTrackHovered)
        {
            UI.SetPotentialInputTarget(id);
        }

        // 2. Handle Mouse Release
        if (isGrabberPressed && !input.IsLeftMouseDown)
        {
            isGrabberPressed = false;
        }

        // 3. Handle Mouse Press
        if (!isGrabberPressed && input.WasLeftMousePressedThisFrame)
        {
            // Check if *any* part of the slider (track or grabber) is hovered
            bool isSliderHovered = isGrabberHovered || isTrackHovered;

            if (isSliderHovered)
            {
                // Try to capture input ONLY if this slider is the potential target
                if (UI.TryCaptureInput(id))
                {
                    // Successfully captured!
                    isGrabberPressed = true; // Always start press state

                    // If click was on track (not grabber), jump value immediately
                    if (isTrackHovered && !isGrabberHovered)
                    {
                        float clampedX = Math.Clamp(mousePos.X, trackMinBound, trackMaxBound);
                        newValue = ConvertPositionToValue(clampedX);
                        newValue = ApplyStep(newValue);
                    }
                    // No value change needed if click was directly on grabber
                }
                // else: Capture failed
            }
        }

        // 4. Handle Mouse Held/Drag
        if (isGrabberPressed && input.IsLeftMouseDown)
        {
            isGrabberPressed = true; // Maintain state

            float clampedX = Math.Clamp(mousePos.X, trackMinBound, trackMaxBound);
            newValue = ConvertPositionToValue(clampedX);
            newValue = ApplyStep(newValue);
        }
        // Ensure consistency if mouse released
        else if (!input.IsLeftMouseDown)
        {
            isGrabberPressed = false;
        }


        return Math.Clamp(newValue, MinValue, MaxValue);
    }

    // --- Other methods unchanged ---
    protected override float ConvertPositionToValue(float position)
    {
        if (trackMaxBound <= trackMinBound) return MinValue;

        float normalized = (position - trackMinBound) / (trackMaxBound - trackMinBound);
        normalized = Math.Clamp(normalized, 0.0f, 1.0f);

        if (Direction == HSliderDirection.RightToLeft)
        {
            normalized = 1.0f - normalized;
        }

        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return rawValue;
    }

    protected override Vector2 CalculateGrabberPosition(float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0;

        if (Direction == HSliderDirection.RightToLeft)
        {
            normalizedValue = 1.0f - normalizedValue;
        }

        float trackWidth = Size.X;
        float centerX = trackMinBound + normalizedValue * trackWidth;

        float xPos = centerX - (GrabberSize.X / 2.0f);
        float yPos = trackPosition.Y + (Size.Y / 2.0f) - (GrabberSize.Y / 2.0f);

        float minX = trackPosition.X;
        float maxX = trackPosition.X + Size.X - GrabberSize.X;
        if (maxX < minX) maxX = minX;
        xPos = Math.Clamp(xPos, minX, maxX);

        return new Vector2(xPos, yPos);
    }

    protected override void DrawForeground(ID2D1RenderTarget renderTarget, float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        if (valueRange <= 0 || renderTarget is null) return;

        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0.0f;
        float foregroundWidth = Size.X * normalizedValue;

        if (foregroundWidth <= 0.001f) return;

        Rect clipRect;
        if (Direction == HSliderDirection.RightToLeft)
        {
            clipRect = new Rect(trackPosition.X + Size.X - foregroundWidth, trackPosition.Y, foregroundWidth, Size.Y);
        }
        else // LeftToRight
        {
            clipRect = new Rect(trackPosition.X, trackPosition.Y, foregroundWidth, Size.Y);
        }

        renderTarget.PushAxisAlignedClip(clipRect, D2D.AntialiasMode.Aliased);
        UI.DrawBoxStyleHelper(renderTarget, trackPosition, Size, Theme.Foreground);
        renderTarget.PopAxisAlignedClip();
    }
}
</file>

<file path="Widgets\InternalSliderLogic.cs">
// MODIFIED: InternalSliderLogic.cs
// Summary: Updated UpdateAndDraw method signature (already done) and how HandleInput is called.
using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.Mathematics;

namespace DirectUI;

internal abstract class InternalSliderLogic
{
    // --- Configuration ---
    public Vector2 Position { get; set; }
    public Vector2 Size { get; set; }
    public Vector2 Origin { get; set; }
    public float MinValue { get; set; }
    public float MaxValue { get; set; }
    public float Step { get; set; }
    public SliderStyle Theme { get; set; } = new();
    public ButtonStylePack GrabberTheme { get; set; } = new();
    public Vector2 GrabberSize { get; set; } = new(16, 16);
    public bool Disabled { get; set; }
    public object? UserData { get; set; }

    // --- Internal State ---
    protected bool isGrabberPressed = false;
    protected bool isGrabberHovered = false;
    protected bool isTrackHovered = false;
    protected Vector2 trackPosition;
    protected float trackMinBound;
    protected float trackMaxBound;

    // --- Calculated Properties ---
    public Rect GlobalBounds => new(Position.X - Origin.X, Position.Y - Origin.Y, Size.X, Size.Y);

    // --- Abstract Methods ---
    protected abstract void CalculateTrackBounds();
    // UpdateHoverStates can be simplified or removed if HandleInput does all hover logic
    protected abstract void UpdateHoverStates(Vector2 mousePos);
    protected abstract float HandleInput(string id, InputState input, float currentValue);
    protected abstract float ConvertPositionToValue(float position);
    protected abstract Vector2 CalculateGrabberPosition(float currentValue);
    protected abstract void DrawForeground(ID2D1RenderTarget renderTarget, float currentValue);


    // --- Common Logic ---
    internal float UpdateAndDraw(string id, InputState input, DrawingContext context, float currentValue)
    {
        trackPosition = Position - Origin;
        CalculateTrackBounds();

        float newValue = currentValue;

        if (Disabled)
        {
            isGrabberHovered = false;
            isGrabberPressed = false;
            isTrackHovered = false;
        }
        else
        {
            // Hover states and potential target setting will now happen inside HandleInput
            newValue = HandleInput(id, input, currentValue);
        }

        // Update grabber theme based on the state set *within* HandleInput
        UpdateGrabberThemeStyle();

        if (context.RenderTarget is null)
        {
            Console.WriteLine("Error: RenderTarget is null during Slider UpdateAndDraw.");
            return newValue;
        }

        try
        {
            DrawBackground(context.RenderTarget);
            DrawForeground(context.RenderTarget, newValue);
            DrawGrabber(context.RenderTarget, newValue);
        }
        catch (SharpGen.Runtime.SharpGenException ex) when (ex.ResultCode.Code == Vortice.Direct2D1.ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Slider Draw failed (RecreateTarget): {ex.Message}. External cleanup needed.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error drawing slider: {ex.Message}");
        }

        return newValue;
    }

    // --- Helper Methods ---
    // No changes needed
    protected float ApplyStep(float value)
    {
        float clampedValue = Math.Clamp(value, MinValue, MaxValue);
        if (Step <= 0 || MaxValue <= MinValue)
        {
            return clampedValue;
        }

        float range = MaxValue - MinValue;
        if (range < Step && Step > 0)
        {
            return (value - MinValue < range / 2.0f) ? MinValue : MaxValue;
        }

        float stepsFromMin = (float)Math.Round((clampedValue - MinValue) / Step);
        float steppedValue = MinValue + stepsFromMin * Step;

        return Math.Clamp(steppedValue, MinValue, MaxValue);
    }


    protected void UpdateGrabberThemeStyle()
    {
        GrabberTheme.UpdateCurrentStyle(isGrabberHovered, isGrabberPressed, Disabled);
    }

    // --- Drawing Methods ---
    // No changes needed
    protected void DrawBackground(ID2D1RenderTarget renderTarget)
    {
        UI.DrawBoxStyleHelper(renderTarget, trackPosition, Size, Theme.Background);
    }

    protected void DrawGrabber(ID2D1RenderTarget renderTarget, float currentValue)
    {
        Vector2 grabberPos = CalculateGrabberPosition(currentValue);
        UI.DrawBoxStyleHelper(renderTarget, grabberPos, GrabberSize, GrabberTheme.Current);
    }
}
</file>

<file path="Widgets\InternalVSlider.cs">
// MODIFIED: InternalVSliderLogic.cs
// Summary: Updated HandleInput to perform hover checks, call UI.SetPotentialInputTarget, and use UI.TryCaptureInput. Removed separate UpdateHoverStates call.
using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

internal class InternalVSliderLogic : InternalSliderLogic
{
    public VSliderDirection Direction { get; set; } = VSliderDirection.TopToBottom;

    protected override void CalculateTrackBounds()
    {
        trackMinBound = trackPosition.Y;
        trackMaxBound = trackPosition.Y + Size.Y;
    }

    // This can potentially be removed if HandleInput does all necessary hover updates
    protected override void UpdateHoverStates(Vector2 mousePos) { }

    protected override float HandleInput(string id, InputState input, float currentValue)
    {
        float newValue = currentValue;
        Vector2 mousePos = input.MousePosition;

        // 1. Calculate Hover States & Set Potential Target
        Vector2 currentGrabberPos = CalculateGrabberPosition(currentValue);
        Rect currentGrabberBounds = new Rect(currentGrabberPos.X, currentGrabberPos.Y, GrabberSize.X, GrabberSize.Y);
        bool preciseGrabberHovered = currentGrabberBounds.Contains(mousePos.X, mousePos.Y);

        Rect trackBounds = new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y);
        bool basicTrackHovered = trackBounds.Contains(mousePos.X, mousePos.Y);

        isGrabberHovered = preciseGrabberHovered;
        isTrackHovered = basicTrackHovered;

        if (isGrabberHovered || isTrackHovered)
        {
            UI.SetPotentialInputTarget(id);
        }

        // 2. Handle Mouse Release
        if (isGrabberPressed && !input.IsLeftMouseDown)
        {
            isGrabberPressed = false;
        }

        // 3. Handle Mouse Press
        if (!isGrabberPressed && input.WasLeftMousePressedThisFrame)
        {
            bool isSliderHovered = isGrabberHovered || isTrackHovered;

            if (isSliderHovered)
            {
                if (UI.TryCaptureInput(id))
                {
                    isGrabberPressed = true;
                    if (isTrackHovered && !isGrabberHovered)
                    {
                        float clampedY = Math.Clamp(mousePos.Y, trackMinBound, trackMaxBound);
                        newValue = ConvertPositionToValue(clampedY);
                        newValue = ApplyStep(newValue);
                    }
                }
            }
        }

        // 4. Handle Mouse Held/Drag
        if (isGrabberPressed && input.IsLeftMouseDown)
        {
            isGrabberPressed = true;

            float clampedY = Math.Clamp(mousePos.Y, trackMinBound, trackMaxBound);
            newValue = ConvertPositionToValue(clampedY);
            newValue = ApplyStep(newValue);
        }
        else if (!input.IsLeftMouseDown)
        {
            isGrabberPressed = false;
        }

        return Math.Clamp(newValue, MinValue, MaxValue);
    }

    // --- Other methods unchanged ---
    protected override float ConvertPositionToValue(float position)
    {
        if (trackMaxBound <= trackMinBound) return MinValue;

        float normalized = (position - trackMinBound) / (trackMaxBound - trackMinBound);
        normalized = Math.Clamp(normalized, 0.0f, 1.0f);

        if (Direction == VSliderDirection.BottomToTop)
        {
            normalized = 1.0f - normalized;
        }

        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return rawValue;
    }

    protected override Vector2 CalculateGrabberPosition(float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0;

        if (Direction == VSliderDirection.BottomToTop)
        {
            normalizedValue = 1.0f - normalizedValue;
        }

        float trackHeight = Size.Y;
        float centerY = trackMinBound + normalizedValue * trackHeight;

        float yPos = centerY - (GrabberSize.Y / 2.0f);
        float xPos = trackPosition.X + (Size.X / 2.0f) - (GrabberSize.X / 2.0f);

        float minY = trackPosition.Y;
        float maxY = trackPosition.Y + Size.Y - GrabberSize.Y;
        if (maxY < minY) maxY = minY;
        yPos = Math.Clamp(yPos, minY, maxY);

        return new Vector2(xPos, yPos);
    }

    protected override void DrawForeground(ID2D1RenderTarget renderTarget, float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        if (valueRange <= 0 || renderTarget is null) return;

        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0.0f;
        float foregroundHeight = Size.Y * normalizedValue;

        if (foregroundHeight <= 0.001f) return;

        Rect clipRect;
        if (Direction == VSliderDirection.BottomToTop)
        {
            clipRect = new Rect(trackPosition.X, trackPosition.Y + Size.Y - foregroundHeight, Size.X, foregroundHeight);
        }
        else // TopToBottom
        {
            clipRect = new Rect(trackPosition.X, trackPosition.Y, Size.X, foregroundHeight);
        }

        renderTarget.PushAxisAlignedClip(clipRect, D2D.AntialiasMode.Aliased);
        UI.DrawBoxStyleHelper(renderTarget, trackPosition, Size, Theme.Foreground);
        renderTarget.PopAxisAlignedClip();
    }
}
</file>

<file path="Widgets\SliderDefinition.cs">
// NEW: SliderDefinition.cs
// Summary: Configuration object for creating immediate-mode sliders (HSlider/VSlider).
using System.Numerics;

namespace DirectUI;

// Enums for direction (can reuse or redefine if needed, assume reuse for now)
// public enum HSliderDirection { LeftToRight, RightToLeft } // Already exists if Cherris files were added
// public enum VSliderDirection { TopToBottom, BottomToTop } // Already exists if Cherris files were added


public class SliderDefinition
{
    public Vector2 Position { get; set; } = Vector2.Zero; // Used if not in a container
    public Vector2 Size { get; set; } = new(200, 16); // Default size (adjust as needed)
    public float MinValue { get; set; } = 0.0f;
    public float MaxValue { get; set; } = 1.0f;
    public float Step { get; set; } = 0.01f;

    public SliderStyle? Theme { get; set; } = null; // Optional override for track style
    public ButtonStylePack? GrabberTheme { get; set; } = null; // Optional override for grabber style
    public Vector2? GrabberSize { get; set; } = null; // Optional override for grabber size (e.g., new(16, 16))

    // Direction specific to slider type, ignored by the other type
    public HSliderDirection HorizontalDirection { get; set; } = HSliderDirection.LeftToRight;
    public VSliderDirection VerticalDirection { get; set; } = VSliderDirection.TopToBottom;

    public bool Disabled { get; set; } = false;
    public object? UserData { get; set; } = null;
    public Vector2? Origin { get; set; } = null; // Use null for default (Vector2.Zero)
}
</file>

