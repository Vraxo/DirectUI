<file path="Alignment.cs">
// Alignment.cs
// Alignment.cs
using DirectUI.Core; // Added using directive

namespace DirectUI;

public enum HAlignment { Left, Center, Right }
public enum VAlignment { Top, Center, Bottom }

public struct Alignment(HAlignment horizontal, VAlignment vertical)
{
    public HAlignment Horizontal { get; set; } = horizontal;
    public VAlignment Vertical { get; set; } = vertical;
}
</file>

<file path="AppEngine.cs">
// AppEngine.cs
using System;
using System.Diagnostics;
using System.Numerics;
using Vortice.Mathematics;
using DirectUI.Core; // For IRenderer, ITextService
using DirectUI.Drawing;
using DirectUI.Diagnostics;
using DirectUI.Input;

namespace DirectUI;

/// <summary>
/// Manages the application's core UI engine lifecycle, input state aggregation,
/// and frame timing. It is decoupled from any specific windowing or graphics backend.
/// </summary>
public class AppEngine
{
    private readonly Action<UIContext> _drawCallback;
    private readonly FpsCounter _fpsCounter;
    private readonly InputManager _inputManager;
    private readonly Stopwatch _frameTimer = new();
    private long _lastFrameTicks;

    public bool ShowFpsCounter { get; set; } = true;
    public InputManager Input => _inputManager;
    public Color4 BackgroundColor { get; }

    public AppEngine(Action<UIContext> drawCallback, Color4 backgroundColor)
    {
        _drawCallback = drawCallback ?? throw new ArgumentNullException(nameof(drawCallback));
        BackgroundColor = backgroundColor;
        _fpsCounter = new FpsCounter();
        _inputManager = new InputManager();

        _frameTimer.Start();
        _lastFrameTicks = _frameTimer.ElapsedTicks;
    }

    /// <summary>
    /// Initializes internal components like the FPS counter.
    /// This should be called once after the renderer and text service are ready.
    /// </summary>
    public void Initialize(ITextService textService, IRenderer renderer)
    {
        _fpsCounter.Initialize(textService, renderer);
    }

    /// <summary>
    /// Cleans up internal engine resources.
    /// </summary>
    public void Cleanup()
    {
        _fpsCounter.Cleanup();
    }

    /// <summary>
    /// Updates the engine state for a single frame and renders the UI.
    /// This method is called by the specific window host after it has prepared its drawing surface.
    /// </summary>
    /// <param name="renderer">The graphics renderer for this frame.</param>
    /// <param name="textService">The text service for this frame.</param>
    public void UpdateAndRender(IRenderer renderer, ITextService textService)
    {
        // Prevent re-entrant rendering calls.
        if (UI.IsRendering) return;

        // Calculate delta time for the frame
        long currentTicks = _frameTimer.ElapsedTicks;
        float deltaTime = (float)(currentTicks - _lastFrameTicks) / Stopwatch.Frequency;
        _lastFrameTicks = currentTicks;

        // Clamp delta time to avoid huge jumps (e.g., when debugging or window is moved)
        deltaTime = Math.Min(deltaTime, 1.0f / 15.0f); // Clamp to a minimum of 15 FPS

        _fpsCounter.Update(); // Update FPS counter once per render call.

        try
        {
            // Get the immutable input state for this frame from the InputManager
            var inputState = _inputManager.GetCurrentState();

            var uiContext = new UIContext(renderer, textService, inputState, deltaTime);
            UI.BeginFrame(uiContext);

            _drawCallback(uiContext);

            if (ShowFpsCounter)
            {
                _fpsCounter.Draw();
            }

            UI.EndFrame();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred during UI drawing: {ex}");
        }
        finally
        {
            _inputManager.PrepareNextFrame();
        }
    }

    public void UpdateAndRenderModal(IRenderer renderer, ITextService textService, Action<UIContext> modalDrawCallback)
    {
        if (UI.IsRendering) return;

        long currentTicks = _frameTimer.ElapsedTicks;
        float deltaTime = (float)(currentTicks - _lastFrameTicks) / Stopwatch.Frequency;
        _lastFrameTicks = currentTicks;
        deltaTime = Math.Min(deltaTime, 1.0f / 15.0f);

        try
        {
            InputState inputState = _inputManager.GetCurrentState();
            UIContext uiContext = new UIContext(renderer, textService, inputState, deltaTime);
            UI.BeginFrame(uiContext);

            // Execute the modal-specific drawing logic
            modalDrawCallback(uiContext);

            UI.EndFrame();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred during modal UI drawing: {ex}");
        }
        finally
        {
            _inputManager.PrepareNextFrame();
        }
    }
}
</file>

<file path="Application.cs">
namespace DirectUI;

public static class Application
{
    private static readonly List<Win32Window> windows = [];
    private static bool isRunning = false;

    static Application()
    {
        SharedGraphicsResources.Initialize();
    }

    public static void RegisterWindow(Win32Window window)
    {
        if (windows.Contains(window))
        {
            return;
        }

        windows.Add(window);
    }

    public static void UnregisterWindow(Win32Window window)
    {
        windows.Remove(window);

        if (windows.Count != 0)
        {
            return;
        }

        Exit();
    }

    public static void RunMessageLoop()
    {
        if (windows.Count == 0)
        {
            Console.WriteLine("Application.RunMessageLoop() called with no Win32 windows registered.");
            return;
        }

        isRunning = true;

        while (isRunning)
        {
            ProcessMessages();

            // After processing messages, if no WM_QUIT was posted and there are still windows,
            // yield control back to the specific Win32WindowHost for its frame update.
            // Note: In this architecture, the Win32WindowHost's RunLoop will call Application.RunMessageLoop.
            // The FrameUpdate logic should ideally live within the host's own loop.
            // For now, this is a simplified message pump.
        }

        SharedGraphicsResources.Cleanup();
    }

    internal static void ProcessMessages()
    {
        while (NativeMethods.PeekMessage(out var msg, IntPtr.Zero, 0, 0, NativeMethods.PM_REMOVE))
        {
            if (msg.message == NativeMethods.WM_QUIT)
            {
                isRunning = false;
                break;
            }

            NativeMethods.TranslateMessage(ref msg);
            NativeMethods.DispatchMessage(ref msg);
        }
    }

    public static void Exit()
    {
        if (!isRunning)
        {
            return;
        }

        isRunning = false;
        NativeMethods.PostQuitMessage(0);
    }
}
</file>

<file path="ApplicationRunner.cs">
using DirectUI.Backends.SDL3;
using DirectUI.Core; // Added for IWindowHost
using Raylib_cs;
using SDL3;
using GraphicsBackend = DirectUI.GraphicsBackend;

namespace DirectUI;

public static class ApplicationRunner
{
public static void Run(GraphicsBackend backend, Func<IWindowHost, IAppLogic> appLogicFactory)
    {
        IWindowHost? host = null;
        try
        {
            host = backend switch
            {
                GraphicsBackend.Raylib => new RaylibWindowHost("My Raylib App", 1024, 768, new Vortice.Mathematics.Color4(21 / 255f, 21 / 255f, 21 / 255f, 1.0f)),
                GraphicsBackend.Direct2D => new Win32WindowHost("My D2D App", 1024, 768),
                GraphicsBackend.SDL3 => new SDL3WindowHost("My SDL3 App", 1024, 768, new Vortice.Mathematics.Color4(21 / 255f, 21 / 255f, 21 / 255f, 1.0f)),
                _ => throw new ArgumentOutOfRangeException(nameof(backend), backend, "Unsupported graphics backend.")
            };

            Console.WriteLine($"Using {backend} Backend.");

            var appLogic = appLogicFactory(host);

            if (host.Initialize(appLogic.DrawUI, new Vortice.Mathematics.Color4(21 / 255f, 21 / 255f, 21 / 255f, 1.0f))) // #151515
            {
                host.RunLoop();
            }
            else
            {
                Console.WriteLine($"Failed to initialize {backend} application.");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An unhandled exception occurred: {ex}");
        }
        finally
        {
            host?.Cleanup();
            host?.Dispose();
        }
    }

    // Removed specific RunRaylib, RunDirect2D, RunSDL3 methods
    // as their logic is now encapsulated within their respective IWindowHost implementations.
}
</file>

<file path="AppServices.cs">
using DirectUI.Core;

namespace DirectUI;

public sealed class AppServices
{
    public AppEngine AppEngine { get; }
    public DuiGraphicsDevice GraphicsDevice { get; }
    public IRenderer Renderer { get; }
    public ITextService TextService { get; }

    internal AppServices(AppEngine appEngine, DuiGraphicsDevice graphicsDevice, IRenderer renderer, ITextService textService)
    {
        AppEngine = appEngine;
        GraphicsDevice = graphicsDevice;
        Renderer = renderer;
        TextService = textService;
    }
}
</file>

<file path="GlobalUsings.cs">
global using Color = DirectUI.Drawing.Color;
</file>

<file path="GraphicsBackend.cs">
namespace DirectUI;

public enum GraphicsBackend
{
    Direct2D,
    Raylib,
    SDL3
}
</file>

<file path="ModalWindow.cs">
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI;

public class ModalWindow : Win32Window
{
    private readonly Win32Window owner;
    private readonly Action<UIContext> drawCallback;
    private AppServices? appServices;

    public ModalWindow(Win32Window owner, string title, int width, int height, Action<UIContext> drawCallback)
        : base(title, width, height)
    {
        this.owner = owner ?? throw new ArgumentNullException(nameof(owner));
        this.drawCallback = drawCallback ?? throw new ArgumentNullException(nameof(drawCallback));
    }

    protected override bool Initialize()
    {
        Console.WriteLine("ModalWindow initializing...");

        try
        {
            appServices = Win32AppServicesInitializer.Initialize(
                Handle,
                GetClientRectSize(),
                drawCallback,
                new(37 / 255f, 37 / 255f, 38 / 255f, 1.0f));

            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to initialize modal window services: {ex.Message}");
            return false;
        }
    }

    protected override void Cleanup()
    {
        Console.WriteLine("ModalWindow cleaning up its resources...");
        appServices?.AppEngine.Cleanup();
        appServices?.TextService.Cleanup();
        (appServices?.Renderer as Backends.Direct2DRenderer)?.Cleanup();
        appServices?.GraphicsDevice.Cleanup();

        appServices = null;
    }

    protected override void OnPaint()
    {
        if (appServices is null || !appServices.GraphicsDevice.IsInitialized)
        {
            Console.WriteLine("Modal window render services not initialized. Skipping paint.");
            return;
        }

        appServices.GraphicsDevice.BeginDraw();

        try
        {
            if (appServices.AppEngine is not null && appServices.GraphicsDevice.RenderTarget is not null)
            {
                appServices.GraphicsDevice.RenderTarget.Clear(appServices.AppEngine.BackgroundColor);
            }

            appServices?.AppEngine?.UpdateAndRender(appServices.Renderer, appServices.TextService);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred during modal window drawing: {ex}");
            appServices.GraphicsDevice.Cleanup();
        }
        finally
        {
            appServices.GraphicsDevice.EndDraw();
        }
    }

    public override void FrameUpdate()
    {
        Invalidate();
    }

    protected override void OnSize(int width, int height)
    {
        appServices?.GraphicsDevice.Resize(new SizeI(width, height));
    }

    protected override void OnMouseMove(int x, int y)
    {
        appServices?.AppEngine.Input.SetMousePosition(x, y);
        Invalidate();
    }

    protected override void OnMouseDown(MouseButton button, int x, int y)
    {
        appServices?.AppEngine.Input.SetMousePosition(x, y);
        appServices?.AppEngine.Input.SetMouseDown(button);
        Invalidate();
    }

    protected override void OnMouseUp(MouseButton button, int x, int y)
    {
        appServices?.AppEngine.Input.SetMousePosition(x, y);
        appServices?.AppEngine.Input.SetMouseUp(button);
        Invalidate();
    }

    protected override void OnMouseWheel(float delta)
    {
        appServices?.AppEngine.Input.AddMouseWheelDelta(delta);
        Invalidate();
    }

    protected override void OnKeyDown(Keys key)
    {
        appServices?.AppEngine.Input.AddKeyPressed(key);

        if (key == Keys.Escape)
        {
            Close();
        }

        Invalidate();
    }

    protected override void OnKeyUp(Keys key)
    {
        appServices?.AppEngine.Input.AddKeyReleased(key);
        Invalidate();
    }

    protected override void OnChar(char c)
    {
        appServices?.AppEngine.Input.AddCharacterInput(c);
        Invalidate();
    }

    protected override bool OnClose() 
    { 
        return true; 
    }

    public bool CreateAsModal()
    {
        if (Handle != IntPtr.Zero)
        {
            return true;
        }

        uint style =
            NativeMethods.WS_POPUP |
            NativeMethods.WS_CAPTION |
            NativeMethods.WS_SYSMENU |
            NativeMethods.WS_VISIBLE |
            NativeMethods.WS_THICKFRAME;

        int? x = null;
        int? y = null;

        if (owner.Handle != IntPtr.Zero && owner.GetWindowRect(out NativeMethods.RECT ownerRect))
        {
            int ownerWidth = ownerRect.right - ownerRect.left;
            int ownerHeight = ownerRect.bottom - ownerRect.top;
            int modalWidth = Width;
            int modalHeight = Height;

            x = ownerRect.left + (ownerWidth - modalWidth) / 2;
            y = ownerRect.top + (ownerHeight - modalHeight) / 2;
        }

        if (!Create(owner.Handle, style, x, y))
        {
            return false;
        }

        if (Handle == IntPtr.Zero)
        {
            return false;
        }

        NativeMethods.EnableWindow(owner.Handle, false);

        return true;
    }

    protected override void OnDestroy()
    {
        if (owner.Handle != IntPtr.Zero)
        {
            NativeMethods.EnableWindow(owner.Handle, true);
        }

        base.OnDestroy();
    }

    protected SizeI GetClientRectSize()
    {
        if (Handle != nint.Zero && NativeMethods.GetClientRect(Handle, out NativeMethods.RECT r))
        {
            int width = int.Max(1, r.right - r.left);
            int height = int.Max(1, r.bottom - r.top);
            return new(width, height);
        }

        int baseWidth = int.Max(1, Width);
        int baseHeight = int.Max(1, Height);
        
        if (Handle != nint.Zero)
        {
            Console.WriteLine($"GetClientRect failed. Falling back to stored size: {baseWidth}x{baseHeight}");
        }

        return new(baseWidth, baseHeight);
    }
}
</file>

<file path="MouseButton.cs">
namespace DirectUI;

public enum MouseButton
{
    Left,
    Right,
    Middle,
    XButton1,
    XButton2
}
</file>

<file path="NativeMethods.cs">
// NativeMethods.cs
using System;
using System.Runtime.InteropServices;

// No changes needed here if it was correct from the previous step.
// Ensure these constants are defined:
// WM_NCCREATE, WM_CREATE, WM_NCDESTROY, WM_PAINT, WM_DESTROY, WM_SIZE,
// WM_CLOSE, WM_KEYDOWN, WM_LBUTTONDOWN, WM_LBUTTONUP, WM_MOUSEMOVE, WM_QUIT
// GWLP_USERDATA, VK_ESCAPE, etc.
// And the structs: WNDCLASSEX, MSG, POINT, RECT, CREATESTRUCT
// And the functions: RegisterClassEx, CreateWindowEx, GetMessage, etc.
// And the delegates: WndProc

namespace DirectUI;

public static class NativeMethods
{
    // --- Constants ---
    public const uint CS_HREDRAW = 0x0002;
    public const uint CS_VREDRAW = 0x0001;
    public const uint CS_OWNDC = 0x0020;

    public const uint WS_OVERLAPPED = 0x00000000;
    public const uint WS_CAPTION = 0x00C00000;
    public const uint WS_SYSMENU = 0x00080000;
    public const uint WS_THICKFRAME = 0x00040000;
    public const uint WS_MINIMIZEBOX = 0x00020000;
    public const uint WS_MAXIMIZEBOX = 0x00010000;
    public const uint WS_OVERLAPPEDWINDOW = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
    public const uint WS_VISIBLE = 0x10000000;
    public const uint WS_POPUP = 0x80000000;

    public const int WM_NCCREATE = 0x0081;
    public const int WM_CREATE = 0x0001;
    public const int WM_NCDESTROY = 0x0082;
    public const int WM_PAINT = 0x000F;
    public const int WM_DESTROY = 0x0002;
    public const int WM_SIZE = 0x0005;
    public const int WM_CLOSE = 0x0010;
    public const int WM_KEYDOWN = 0x0100;
    public const int WM_KEYUP = 0x0101;
    public const int WM_SYSKEYUP = 0x0105;
    public const int WM_LBUTTONDOWN = 0x0201;
    public const int WM_LBUTTONUP = 0x0202; // Ensure this exists
    public const int WM_RBUTTONDOWN = 0x0204;
    public const int WM_RBUTTONUP = 0x0205;
    public const int WM_MBUTTONDOWN = 0x0207;
    public const int WM_MBUTTONUP = 0x0208;
    public const int WM_XBUTTONDOWN = 0x020B;
    public const int WM_XBUTTONUP = 0x020C;
    public const int WM_MOUSEMOVE = 0x0200; // Ensure this exists
    public const int WM_MOUSEWHEEL = 0x020A;
    public const int WM_QUIT = 0x0012;
    public const int WM_CHAR = 0x0102;


    public const int CW_USEDEFAULT = unchecked((int)0x80000000);
    public const int SW_SHOWNORMAL = 1;
    public const int GWLP_USERDATA = -21;

    public const uint PM_REMOVE = 0x0001;

    // --- Structures ---
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
    public struct WNDCLASSEX
    { /* ... as before ... */
        public int cbSize;
        public uint style;
        public WndProc lpfnWndProc; // Use delegate type directly
        public int cbClsExtra;
        public int cbWndExtra;
        public IntPtr hInstance;
        public IntPtr hIcon;
        public IntPtr hCursor;
        public IntPtr hbrBackground;
        public string lpszMenuName;
        public string lpszClassName;
        public IntPtr hIconSm;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct MSG
    { /* ... as before ... */
        public IntPtr hwnd;
        public uint message;
        public IntPtr wParam;
        public IntPtr lParam;
        public uint time;
        public POINT pt;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct POINT
    { /* ... as before ... */
        public int X;
        public int Y;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct RECT
    { /* ... as before ... */
        public int left;
        public int top;
        public int right;
        public int bottom;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct CREATESTRUCT
    { /* ... as before ... */
        public IntPtr lpCreateParams;
        public IntPtr hInstance;
        public IntPtr hMenu;
        public IntPtr hwndParent;
        public int cy; // Height
        public int cx; // Width
        public int y;  // Top
        public int x;  // Left
        public int style;
        [MarshalAs(UnmanagedType.LPWStr)] // Assuming Unicode
        public string lpszName;
        [MarshalAs(UnmanagedType.LPWStr)] // Assuming Unicode
        public string lpszClass;
        public int dwExStyle;
    }

    // --- Delegates ---
    public delegate IntPtr WndProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam);

    // --- Functions ---
    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern ushort RegisterClassEx([In] ref WNDCLASSEX lpwcx);
    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern IntPtr CreateWindowEx(uint dwExStyle, string lpClassName, string lpWindowName, uint dwStyle, int x, int y, int nWidth, int nHeight, IntPtr hWndParent, IntPtr hMenu, IntPtr hInstance, IntPtr lpParam);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool UpdateWindow(IntPtr hWnd);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool DestroyWindow(IntPtr hWnd);
    [DllImport("user32.dll")]
    public static extern IntPtr DefWindowProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam);
    [DllImport("user32.dll")]
    public static extern void PostQuitMessage(int nExitCode);
    [DllImport("user32.dll")]
    public static extern bool GetMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax);
    [DllImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool PeekMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax, uint wRemoveMsg);
    [DllImport("user32.dll")]
    public static extern bool TranslateMessage([In] ref MSG lpMsg);
    [DllImport("user32.dll")]
    public static extern IntPtr DispatchMessage([In] ref MSG lpmsg);
    [DllImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)] // Add return type annotation
    public static extern bool PostMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam); // Added
    [DllImport("user32.dll")]
    public static extern bool GetClientRect(IntPtr hWnd, out RECT lpRect);
    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern IntPtr GetModuleHandle(string lpModuleName);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool InvalidateRect(IntPtr hWnd, IntPtr lpRect, bool bErase);
    [DllImport("user32.dll")]
    public static extern IntPtr LoadCursor(IntPtr hInstance, int lpCursorName);
    [DllImport("user32.dll")]
    public static extern IntPtr LoadIcon(IntPtr hInstance, IntPtr lpIconName);
    [DllImport("user32.dll", EntryPoint = "SetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr SetWindowLongPtr64(IntPtr hWnd, int nIndex, IntPtr dwNewLong);
    [DllImport("user32.dll", EntryPoint = "SetWindowLongW", SetLastError = true)]
    private static extern IntPtr SetWindowLong32(IntPtr hWnd, int nIndex, IntPtr dwNewLong);
    [DllImport("user32.dll", EntryPoint = "GetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr GetWindowLongPtr64(IntPtr hWnd, int nIndex);
    [DllImport("user32.dll", EntryPoint = "GetWindowLongW", SetLastError = true)]
    private static extern IntPtr GetWindowLong32(IntPtr hWnd, int nIndex);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr SetCapture(IntPtr hWnd);
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool ReleaseCapture();
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool EnableWindow(IntPtr hWnd, bool bEnable);
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool GetWindowRect(IntPtr hwnd, out RECT lpRect);


    public static IntPtr SetWindowLongPtr(IntPtr hWnd, int nIndex, IntPtr dwNewLong)
    {
        if (IntPtr.Size == 8) return SetWindowLongPtr64(hWnd, nIndex, dwNewLong);
        else return SetWindowLong32(hWnd, nIndex, dwNewLong);
    }
    public static IntPtr GetWindowLongPtr(IntPtr hWnd, int nIndex)
    {
        if (IntPtr.Size == 8) return GetWindowLongPtr64(hWnd, nIndex);
        else return GetWindowLong32(hWnd, nIndex);
    }

    // --- Helpers ---
    public static short LoWord(IntPtr val) => unchecked((short)(long)val);
    public static short HiWord(IntPtr val) => unchecked((short)((long)val >> 16));
}
</file>

<file path="SharedGraphicsResources.cs">
// SharedGraphicsResources.cs
using System;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using SharpGen.Runtime;
using D2D = Vortice.Direct2D1;
using DW = Vortice.DirectWrite;

namespace DirectUI;

/// <summary>
/// Manages graphics resources that are shared across the entire application,
/// such as the main Direct2D and DirectWrite factories.
/// </summary>
internal static class SharedGraphicsResources
{
    public static ID2D1Factory1? D2DFactory { get; private set; }
    public static IDWriteFactory? DWriteFactory { get; private set; }

    private static bool s_isInitialized = false;

    /// <summary>
    /// Initializes the shared factories. Should be called once at application startup.
    /// </summary>
    public static void Initialize()
    {
        if (s_isInitialized) return;

        try
        {
            Result factoryResult = D2D1.D2D1CreateFactory(D2D.FactoryType.SingleThreaded, out ID2D1Factory1? d2dFactory);
            factoryResult.CheckError();
            D2DFactory = d2dFactory ?? throw new InvalidOperationException("Shared D2D Factory creation failed silently.");

            Result dwriteResult = DW.DWrite.DWriteCreateFactory(DW.FactoryType.Shared, out IDWriteFactory? dwriteFactory);
            dwriteResult.CheckError();
            DWriteFactory = dwriteFactory ?? throw new InvalidOperationException("Shared DWrite Factory creation failed silently.");

            Console.WriteLine("Shared Graphics Factories Initialized.");
            s_isInitialized = true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"FATAL: Could not initialize shared graphics resources: {ex.Message}");
            Cleanup();
            throw;
        }
    }

    /// <summary>
    /// Disposes of the shared factories. Should be called once when the application is closing.
    /// </summary>
    public static void Cleanup()
    {
        if (!s_isInitialized) return;
        Console.WriteLine("Cleaning up shared graphics factories...");
        DWriteFactory?.Dispose();
        DWriteFactory = null;
        D2DFactory?.Dispose();
        D2DFactory = null;
        s_isInitialized = false;
        Console.WriteLine("Shared graphics factories cleaned up.");
    }
}
</file>

<file path="Containers\ComboboxState.cs">
namespace DirectUI;

internal class ComboboxState
{
    public bool IsOpen;
}
</file>

<file path="Containers\GridContainerState.cs">
using System.Numerics;

namespace DirectUI;

internal class GridContainerState : ILayoutContainer
{
    internal int Id { get; }
    internal Vector2 StartPosition { get; } // Top-left corner of the grid area
    internal int NumColumns { get; }
    internal Vector2 Gap { get; } // Gap between cells (X and Y)
    internal Vector2 AvailableSize { get; } // Total area the grid can occupy

    // Calculated layout values
    internal float CellWidth { get; }
    internal List<float> RowHeights { get; } = new(); // Store height of each completed row
    internal float CurrentRowMaxHeight { get; set; } = 0f; // Track max height of elements in the current row being built
    internal int CurrentCellIndex { get; set; } = 0; // 0-based index of the next cell to place an element in
    internal Vector2 CurrentDrawPosition { get; set; } // Calculated top-left for the next element

    // Tracking overall bounds occupied by elements
    internal float AccumulatedWidth { get; set; } = 0f;
    internal float AccumulatedHeight { get; set; } = 0f;


    internal GridContainerState(int id, Vector2 startPosition, Vector2 availableSize, int numColumns, Vector2 gap)
    {
        Id = id;
        StartPosition = startPosition;
        AvailableSize = availableSize;
        NumColumns = Math.Max(1, numColumns); // Ensure at least one column
        Gap = gap;

        // Calculate fixed cell width based on available space and gaps
        float totalHorizontalGap = Math.Max(0, NumColumns - 1) * Gap.X;
        float widthForCells = AvailableSize.X - totalHorizontalGap;
        CellWidth = (NumColumns > 0) ? Math.Max(0, widthForCells / NumColumns) : 0;

        // Initial position is the start position
        CurrentDrawPosition = startPosition;
        RowHeights.Add(0); // Add initial height for the first row (will be updated)
    }

    internal void MoveToNextCell(Vector2 elementSize)
    {
        // Update max height for the current row
        CurrentRowMaxHeight = Math.Max(CurrentRowMaxHeight, elementSize.Y);

        // Update total occupied width (conservative estimate using cell width)
        int currentCol = CurrentCellIndex % NumColumns;
        float currentWidth = (currentCol + 1) * CellWidth + currentCol * Gap.X;
        AccumulatedWidth = Math.Max(AccumulatedWidth, currentWidth);


        CurrentCellIndex++;
        int nextCol = CurrentCellIndex % NumColumns;

        if (nextCol == 0) // Moved to the start of a new row
        {
            // Finalize the height of the completed row
            RowHeights[^1] = CurrentRowMaxHeight; // Update last row's height
            AccumulatedHeight += CurrentRowMaxHeight + (RowHeights.Count > 1 ? Gap.Y : 0); // Add height and gap (if not first row)

            // Reset for the new row
            CurrentRowMaxHeight = 0f;
            RowHeights.Add(0); // Add placeholder height for the new row

            // Calculate Y position for the new row
            float newY = StartPosition.Y;
            for (int i = 0; i < RowHeights.Count - 1; i++) // Sum heights and gaps of completed rows
            {
                newY += RowHeights[i] + Gap.Y;
            }

            // Set position for the first cell of the new row
            CurrentDrawPosition = new Vector2(StartPosition.X, newY);

        }
        else // Moving to the next column in the same row
        {
            // Calculate X position for the next cell
            float currentX = StartPosition.X + nextCol * (CellWidth + Gap.X);
            CurrentDrawPosition = new Vector2(currentX, CurrentDrawPosition.Y); // Y stays the same
        }
    }

    internal Vector2 GetTotalOccupiedSize()
    {
        // Calculate final height including the current row being built
        float finalHeight = AccumulatedHeight + CurrentRowMaxHeight;
        return new Vector2(AccumulatedWidth, finalHeight);
    }

    public Vector2 GetCurrentPosition() => CurrentDrawPosition;

    public void Advance(Vector2 elementSize) => MoveToNextCell(elementSize);
}
</file>

<file path="Containers\HBoxContainerState.cs">
using System.Numerics;

namespace DirectUI;

public class HBoxContainerState : ILayoutContainer
{
    internal int Id { get; }
    internal Vector2 StartPosition { get; set; }
    internal Vector2 CurrentPosition { get; set; }
    internal float Gap { get; set; }
    internal float MaxElementHeight { get; set; } = 0f;
    internal float AccumulatedWidth { get; set; } = 0f;
    internal int ElementCount { get; set; } = 0;

    internal HBoxContainerState(int id)
    {
        Id = id;
    }

    public Vector2 GetCurrentPosition() => CurrentPosition;

    public void Advance(Vector2 elementSize)
    {
        if (elementSize.Y > MaxElementHeight)
        {
            MaxElementHeight = elementSize.Y;
        }

        AccumulatedWidth += elementSize.X;
        if (ElementCount > 0)
        {
            AccumulatedWidth += Gap;
        }
        float advanceX = elementSize.X + Gap;
        CurrentPosition = new Vector2(CurrentPosition.X + advanceX, CurrentPosition.Y);
        ElementCount++;
    }
}
</file>

<file path="Containers\ResizableHPanelState.cs">
using System.Numerics;

namespace DirectUI;

internal class ResizableHPanelState : ILayoutContainer
{
    internal int Id { get; }
    internal HBoxContainerState InnerHBox { get; }
    internal bool ClipRectWasPushed { get; }

    internal ResizableHPanelState(int id, HBoxContainerState innerHBox, bool clipPushed)
    {
        Id = id;
        InnerHBox = innerHBox;
        ClipRectWasPushed = clipPushed;
    }

    public Vector2 GetCurrentPosition() => InnerHBox.GetCurrentPosition();

    public void Advance(Vector2 elementSize) => InnerHBox.Advance(elementSize);
}
</file>

<file path="Containers\ResizablePanelState.cs">
using System.Numerics;

namespace DirectUI;

internal class ResizablePanelState : ILayoutContainer
{
    internal int Id { get; }
    internal VBoxContainerState InnerVBox { get; }
    internal bool ClipRectWasPushed { get; }

    internal ResizablePanelState(int id, VBoxContainerState innerVBox, bool clipPushed)
    {
        Id = id;
        InnerVBox = innerVBox;
        ClipRectWasPushed = clipPushed;
    }

    public Vector2 GetCurrentPosition() => InnerVBox.GetCurrentPosition();

    public void Advance(Vector2 elementSize) => InnerVBox.Advance(elementSize);
}
</file>

<file path="Containers\ScrollContainerState.cs">
using System.Numerics;

namespace DirectUI;

public class ScrollContainerState : ILayoutContainer
{
    // State managed by the UI system
    internal Vector2 CurrentScrollOffset { get; set; }

    // Per-frame calculated values
    internal int Id { get; set; }
    internal Vector2 Position { get; set; }
    internal Vector2 VisibleSize { get; set; }
    internal Vector2 ContentSize { get; set; }
    internal bool IsHovered { get; set; }
    internal VBoxContainerState ContentVBox { get; set; } = null!;

    // Public parameterless constructor required for GetOrCreateElement
    public ScrollContainerState() { }

    public Vector2 GetCurrentPosition() => ContentVBox.GetCurrentPosition();

    public void Advance(Vector2 elementSize) => ContentVBox.Advance(elementSize);
}
</file>

<file path="Containers\TreeViewState.cs">
namespace DirectUI;

internal class TreeViewState
{
    internal int Id { get; }
    internal TreeStyle Style { get; }
    internal Stack<bool> IndentLineState { get; } = new();

    internal TreeViewState(int id, TreeStyle style)
    {
        Id = id;
        Style = style;
    }
}
</file>

<file path="Containers\VBoxContainerState.cs">
using System.Numerics;

namespace DirectUI;

public class VBoxContainerState : ILayoutContainer
{
    internal int Id { get; }
    internal Vector2 StartPosition { get; set; }
    internal Vector2 CurrentPosition { get; set; } // Top-left for the next element
    internal float Gap { get; set; }
    internal float MaxElementWidth { get; set; } = 0f; // Track width for container bounds
    internal float AccumulatedHeight { get; set; } = 0f; // Track height for container bounds
    internal int ElementCount { get; set; } = 0;

    internal VBoxContainerState(int id)
    {
        Id = id;
    }

    public Vector2 GetCurrentPosition() => CurrentPosition;

    public void Advance(Vector2 elementSize)
    {
        if (elementSize.X > MaxElementWidth)
        {
            MaxElementWidth = elementSize.X;
        }

        AccumulatedHeight += elementSize.Y;
        if (ElementCount > 0)
        {
            AccumulatedHeight += Gap;
        }
        float advanceY = elementSize.Y + Gap;
        CurrentPosition = new Vector2(CurrentPosition.X, CurrentPosition.Y + advanceY);
        ElementCount++;
    }
}
</file>

<file path="Core\TextMetrics.cs">
// DirectUI/Core/TextMetrics.cs
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI.Core;

/// <summary>
/// Describes the metrics of a character position within a text layout.
/// This is a backend-agnostic struct.
/// </summary>
public readonly record struct TextHitTestMetrics(
    /// <summary>
    /// The top-left corner of the character position, relative to the layout's origin.
    /// </summary>
    Vector2 Point,

    /// <summary>
    /// The measured size of the character position.
    /// </summary>
    Vector2 Size
);

/// <summary>
/// The result of a point-based hit-test on a text layout.
/// This is a backend-agnostic struct.
/// </summary>
public readonly record struct TextHitTestResult(
    /// <summary>
    /// The character position that was hit.
    /// </summary>
    int TextPosition,

    /// <summary>
    /// A value indicating whether the hit occurred on the leading or trailing edge of the character.
    /// </summary>
    bool IsTrailingHit,

    /// <summary>
    /// A value indicating whether the hit occurred inside the text string.
    /// </summary>
    bool IsInside,

    /// <summary>
    /// The detailed metrics of the hit character position.
    /// </summary>
    TextHitTestMetrics Metrics
);
</file>

<file path="Core\UI.Button.cs">
using System.Numerics;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1; // Still used for AntialiasMode enum

namespace DirectUI;

public static partial class UI
{
    public static bool Button(
        string id,
        string text,
        Vector2 size = default,
        ButtonStylePack? theme = null,
        bool disabled = false,
        bool autoWidth = false,
        Vector2? textMargin = null,
        Button.ActionMode clickMode = DirectUI.Button.ActionMode.Release,
        Button.ClickBehavior clickBehavior = DirectUI.Button.ClickBehavior.Left,
        Alignment? textAlignment = null,
        Vector2? textOffset = null,
        Vector2? origin = null,
        object? userData = null)
    {
        if (!IsContextValid()) return false;

        int intId = id.GetHashCode();
        var finalTheme = theme ?? State.GetOrCreateElement<ButtonStylePack>(HashCode.Combine(intId, "theme"));
        State.SetUserData(intId, userData);

        Vector2 finalSize = size == default ? new Vector2(84, 28) : size;
        Vector2 finalOrigin = origin ?? Vector2.Zero;

        // Auto-width calculation must happen before culling.
        if (autoWidth)
        {
            var styleForMeasuring = finalTheme.Normal; // Measure against the normal style
            Vector2 measuredSize = Context.TextService.MeasureText(text, styleForMeasuring);
            Vector2 margin = textMargin ?? new Vector2(10, 5);
            finalSize.X = measuredSize.X + margin.X * 2;
        }

        Vector2 drawPos = Context.Layout.GetCurrentPosition();
        Rect widgetBounds = new Rect(drawPos.X - finalOrigin.X, drawPos.Y - finalOrigin.Y, finalSize.X, finalSize.Y);

        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(finalSize);
            return false;
        }

        bool pushedClip = false;
        if (Context.Layout.IsInLayoutContainer() && Context.Layout.PeekContainer() is GridContainerState grid)
        {
            float clipStartY = grid.CurrentDrawPosition.Y;
            float gridBottomY = grid.StartPosition.Y + grid.AvailableSize.Y;
            float clipHeight = Math.Max(0f, gridBottomY - clipStartY);
            Rect cellClipRect = new Rect(grid.CurrentDrawPosition.X, clipStartY, Math.Max(0f, grid.CellWidth), clipHeight);
            if (cellClipRect.Width > 0 && cellClipRect.Height > 0)
            {
                Context.Renderer.PushClipRect(cellClipRect, D2D.AntialiasMode.Aliased);
                pushedClip = true;
            }
        }

        bool clicked = DrawButtonPrimitive(
            intId,
            widgetBounds,
            text,
            finalTheme,
            disabled,
            textAlignment ?? new Alignment(HAlignment.Center, VAlignment.Center),
            clickMode,
            clickBehavior,
            textOffset ?? Vector2.Zero,
            isActive: false
        );

        if (pushedClip)
        {
            Context.Renderer.PopClipRect();
        }

        Context.Layout.AdvanceLayout(finalSize);
        return clicked;
    }
}
</file>

<file path="Core\UI.Checkbox.cs">
using System.Numerics;
using Vortice.Mathematics;
using Vortice.Direct2D1; // Still needed for AntialiasMode enum

namespace DirectUI;

public static partial class UI
{
    public static bool Checkbox(string id, string label, ref bool isChecked, bool disabled = false, Vector2? size = null)
    {
        if (!IsContextValid()) return false;

        int intId = id.GetHashCode();

        // --- Style and Sizing (UE5 Theme Adjustments) ---
        var boxSize = new Vector2(16, 16);
        var spacing = 5f;
        // Checkmark is now pure white.
        var checkmarkColor = Colors.White;
        // Background is a specific dark grey.
        var normalFillColor = new Color4(43 / 255f, 45 / 255f, 47 / 255f, 1.0f); // #2B2D2F
        var textColor = disabled ? DefaultTheme.DisabledText : DefaultTheme.Text;
        var textStyle = new ButtonStyle { FontColor = textColor }; // Use ButtonStyle for font properties.

        var labelSize = string.IsNullOrEmpty(label) ? Vector2.Zero : Context.TextService.MeasureText(label, textStyle);

        var contentWidth = boxSize.X + (labelSize.X > 0 ? spacing + labelSize.X : 0);
        var contentHeight = Math.Max(boxSize.Y, labelSize.Y);

        var finalWidgetHeight = size?.Y > 0 ? size.Value.Y : contentHeight;
        var finalWidgetWidth = size?.X > 0 ? size.Value.X : contentWidth;
        var totalSize = new Vector2(finalWidgetWidth, finalWidgetHeight);

        var drawPos = Context.Layout.GetCurrentPosition();

        var widgetBounds = new Rect(drawPos.X, drawPos.Y, totalSize.X, totalSize.Y);

        // --- Culling ---
        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(totalSize);
            return false;
        }

        // --- Interaction ---
        bool clicked = false;
        var input = Context.InputState;
        bool isHovering = !disabled && widgetBounds.Contains(input.MousePosition);

        if (isHovering)
        {
            State.SetPotentialInputTarget(intId);
        }

        if (!disabled && isHovering && input.WasLeftMousePressedThisFrame && State.PotentialInputTargetId == intId)
        {
            clicked = true;
            isChecked = !isChecked;
            State.SetFocus(intId);
        }

        // --- Drawing ---
        var renderer = Context.Renderer;
        // This calculation centers the box inside the widget's total height.
        // A small vertical adjustment is added to compensate for font metrics in DrawTextPrimitive,
        // ensuring the checkbox and text align perfectly.
        const float yOffsetCorrection = -1.5f;
        float boxY = drawPos.Y + (totalSize.Y - boxSize.Y) / 2 + yOffsetCorrection;
        var boxRect = new Rect(drawPos.X, boxY, boxSize.X, boxSize.Y);

        // Draw the box frame
        var boxStyle = new BoxStyle();
        if (disabled)
        {
            boxStyle.FillColor = DefaultTheme.DisabledFill;
            boxStyle.BorderColor = DefaultTheme.DisabledBorder;
        }
        else if (isHovering)
        {
            boxStyle.FillColor = DefaultTheme.HoverFill;
            boxStyle.BorderColor = DefaultTheme.HoverBorder;
        }
        else
        {
            // Use the specified dark grey for the normal background.
            boxStyle.FillColor = normalFillColor;
            boxStyle.BorderColor = DefaultTheme.NormalBorder;
        }

        if (State.FocusedElementId == intId)
        {
            boxStyle.BorderColor = DefaultTheme.FocusBorder;
        }
        boxStyle.Roundness = 0.2f;
        boxStyle.BorderLength = 1f;

        renderer.DrawBox(boxRect, boxStyle);

        // Draw the checkmark if checked
        if (isChecked)
        {
            // The checkmarkColor variable was changed above to pure white.
            // A simple checkmark drawn as two lines
            float pad = boxSize.X * 0.25f;
            var p1 = new Vector2(boxRect.Left + pad, boxRect.Top + boxSize.Y * 0.5f);
            var p2 = new Vector2(boxRect.Left + boxSize.X * 0.45f, boxRect.Bottom - pad);
            var p3 = new Vector2(boxRect.Right - pad, boxRect.Top + pad);
            renderer.DrawLine(p1, p2, checkmarkColor, 2.0f);
            renderer.DrawLine(p2, p3, checkmarkColor, 2.0f);
        }

        // Draw the label
        if (!string.IsNullOrEmpty(label))
        {
            var labelPos = new Vector2(boxRect.Right + spacing, drawPos.Y);
            var labelBounds = new Rect(labelPos.X, labelPos.Y, labelSize.X, totalSize.Y);
            DrawTextPrimitive(labelBounds, label, textStyle, new Alignment(HAlignment.Left, VAlignment.Center), Vector2.Zero);
        }

        Context.Layout.AdvanceLayout(totalSize);
        return clicked;
    }
}
</file>

<file path="Core\UI.ComboBox.cs">
using System.Numerics;

namespace DirectUI;

public static partial class UI
{
    public static bool Combobox(
        string id,
        ref int selectedIndex,
        string[] items,
        Vector2 size,
        Vector2 position = default,
        ButtonStylePack? theme = null,
        bool disabled = false)
    {
        if (!IsContextValid())
        {
            return false;
        }

        int intId = id.GetHashCode();
        Vector2 drawPos = Context.Layout.ApplyLayout(position);

        // Culling check
        if (!Context.Layout.IsRectVisible(new(drawPos.X, drawPos.Y, size.X, size.Y)))
        {
            Context.Layout.AdvanceLayout(size);
            return false;
        }

        var comboboxInstance = State.GetOrCreateElement<InternalComboboxLogic>(intId);
        int newIndex = comboboxInstance.UpdateAndDraw(intId, selectedIndex, items, drawPos, size, theme, disabled);

        bool valueChanged = newIndex != selectedIndex;
        if (valueChanged)
        {
            selectedIndex = newIndex;
        }

        Context.Layout.AdvanceLayout(size);
        return valueChanged;
    }
}
</file>

<file path="Core\UI.Containers.cs">
// Core/UI.Containers.cs
using System;
using System.Numerics;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

public static partial class UI
{
    public static void BeginHBoxContainer(string id, Vector2 position, float gap = 5.0f)
    {
        Context.Layout.BeginHBox(id.GetHashCode(), position, gap);
    }

    public static void EndHBoxContainer()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not HBoxContainerState state)
        { Console.WriteLine("Error: EndHBoxContainer called without a matching BeginHBoxContainer."); return; }
        Context.Layout.PopContainer();
        if (Context.Layout.IsInLayoutContainer())
        { Context.Layout.AdvanceContainerLayout(new Vector2(state.AccumulatedWidth, state.MaxElementHeight)); }
    }

    public static void BeginVBoxContainer(string id, Vector2 position, float gap = 5.0f)
    {
        Context.Layout.BeginVBox(id.GetHashCode(), position, gap);
    }

    public static void EndVBoxContainer()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not VBoxContainerState state)
        { Console.WriteLine("Error: EndVBoxContainer called without a matching BeginVBoxContainer."); return; }
        Context.Layout.PopContainer();
        if (Context.Layout.IsInLayoutContainer())
        { Context.Layout.AdvanceContainerLayout(new Vector2(state.MaxElementWidth, state.AccumulatedHeight)); }
    }

    public static void BeginGridContainer(string id, Vector2 position, Vector2 availableSize, int numColumns, Vector2 gap)
    {
        Context.Layout.PushContainer(new GridContainerState(id.GetHashCode(), position, availableSize, numColumns, gap));
    }

    public static void EndGridContainer()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not GridContainerState state)
        { Console.WriteLine("Error: EndGridContainer called without a matching BeginGridContainer."); return; }
        Context.Layout.PopContainer();
        if (Context.Layout.IsInLayoutContainer())
        {
            Vector2 containerSize = state.GetTotalOccupiedSize();
            Context.Layout.AdvanceContainerLayout(containerSize);
        }
    }

    public static void BeginScrollableRegion(string id, Vector2 size, out float availableInnerWidth)
    {
        if (!IsContextValid())
        {
            availableInnerWidth = size.X;
            return;
        }

        int intId = id.GetHashCode();
        Vector2 position = Context.Layout.GetCurrentPosition();
        Rect regionBounds = new Rect(position.X, position.Y, size.X, size.Y);

        var scrollState = State.GetOrCreateElement<ScrollContainerState>(intId);
        scrollState.Id = intId;
        scrollState.Position = position;
        scrollState.VisibleSize = size;
        scrollState.IsHovered = regionBounds.Contains(Context.InputState.MousePosition);

        // Predict if a scrollbar will be needed based on the previous frame's content size.
        // This is a common and effective pattern in immediate-mode UIs.
        const float scrollbarThickness = 12f; // Must match the value in EndScrollableRegion
        const float scrollbarGap = 4f; // Add a small gap between content and scrollbar
        bool scrollbarWillBeVisible = scrollState.ContentSize.Y > scrollState.VisibleSize.Y;
        // If scrollbar is visible, reduce the available width by its thickness and a small gap.
        availableInnerWidth = scrollbarWillBeVisible ? size.X - scrollbarThickness - scrollbarGap : size.X;


        // Handle scroll input
        if (scrollState.IsHovered && Context.InputState.ScrollDelta != 0)
        {
            var offset = scrollState.CurrentScrollOffset;
            offset.Y -= Context.InputState.ScrollDelta * 20; // Apply scroll wheel input
            scrollState.CurrentScrollOffset = offset;
        }

        // Clamp the offset *before* using it for layout. Use the content size from the *previous* frame for this.
        float maxScrollY = Math.Max(0, scrollState.ContentSize.Y - scrollState.VisibleSize.Y);
        var clampedOffset = scrollState.CurrentScrollOffset;
        clampedOffset.Y = Math.Clamp(clampedOffset.Y, 0, maxScrollY);
        scrollState.CurrentScrollOffset = clampedOffset;

        // Begin the inner container for content layout, offset by the now-clamped scroll position
        var contentVBoxId = HashCode.Combine(intId, "scroll_vbox");
        var contentVBox = Context.Layout.GetOrCreateVBoxState(contentVBoxId);
        contentVBox.StartPosition = position - scrollState.CurrentScrollOffset;
        contentVBox.CurrentPosition = position - scrollState.CurrentScrollOffset;
        contentVBox.Gap = 0; // The user can nest another VBox inside for gaps
        contentVBox.MaxElementWidth = 0f;
        contentVBox.AccumulatedHeight = 0f;
        contentVBox.ElementCount = 0;
        scrollState.ContentVBox = contentVBox;

        Context.Layout.PushClipRect(regionBounds);
        Context.Renderer.PushClipRect(regionBounds, D2D.AntialiasMode.Aliased);

        Context.Layout.PushContainer(scrollState);
    }

    public static void EndScrollableRegion()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not ScrollContainerState scrollState)
        { Console.WriteLine("Error: EndScrollableRegion called without a matching Begin."); return; }

        // Finalize content size based on what was rendered inside the container.
        // This new size will be used for clamping in the *next* frame.
        scrollState.ContentSize = new Vector2(scrollState.ContentVBox.MaxElementWidth, scrollState.ContentVBox.AccumulatedHeight);

        // Pop the container and clip rect so the scrollbar can be drawn outside the content's clipped area.
        Context.Layout.PopContainer();
        Context.Renderer.PopClipRect();
        Context.Layout.PopClipRect();

        // Draw scrollbar if needed. This will return a new, validated scroll offset.
        if (scrollState.ContentSize.Y > scrollState.VisibleSize.Y)
        {
            string scrollBarIdString = scrollState.Id + "_scrollbar";
            float scrollbarThickness = 12f;
            var scrollBarPos = new Vector2(scrollState.Position.X + scrollState.VisibleSize.X - scrollbarThickness, scrollState.Position.Y);

            // The VScrollBar handles all its own logic, including clamping the value against the new content size.
            float newScrollY = VScrollBar(
                id: scrollBarIdString,
                currentScrollOffset: scrollState.CurrentScrollOffset.Y,
                position: scrollBarPos,
                trackHeight: scrollState.VisibleSize.Y,
                contentHeight: scrollState.ContentSize.Y,
                visibleHeight: scrollState.VisibleSize.Y,
                thickness: scrollbarThickness);

            // Update the state with the value from the scrollbar for the next frame.
            scrollState.CurrentScrollOffset = new Vector2(scrollState.CurrentScrollOffset.X, newScrollY);
        }
        else
        {
            // If no scrollbar is needed, ensure the offset is zero.
            scrollState.CurrentScrollOffset = new Vector2(scrollState.CurrentScrollOffset.X, 0);
        }

        // After everything, advance the main layout cursor by the size of the scroll region itself.
        Context.Layout.AdvanceLayout(scrollState.VisibleSize);
    }

    public static void BeginResizableVPanel(
        string id,
        ref float currentWidth,
        HAlignment alignment = HAlignment.Left,
        float topOffset = 0f,
        float minWidth = 50f,
        float maxWidth = 500f,
        float resizeHandleWidth = 5f,
        BoxStyle? panelStyle = null,
        Vector2 padding = default,
        float gap = 5f,
        bool disabled = false)
    {
        if (!IsContextValid()) return;
        var intId = id.GetHashCode();

        Vector2 finalPadding = (padding == default) ? new Vector2(5, 5) : padding;

        var input = Context.InputState;
        var renderer = Context.Renderer;
        var windowWidth = renderer.RenderTargetSize.X;
        var windowHeight = renderer.RenderTargetSize.Y;
        var availableHeight = windowHeight - topOffset;

        if (!disabled)
        {
            float handleWidth = Math.Min(resizeHandleWidth, currentWidth);
            float panelX = (alignment == HAlignment.Right) ? windowWidth - currentWidth : 0;
            float handleX = (alignment == HAlignment.Right) ? panelX : panelX + currentWidth - handleWidth;
            Rect handleRect = new Rect(handleX, topOffset, handleWidth, availableHeight);

            bool isHoveringHandle = handleRect.Contains(input.MousePosition.X, input.MousePosition.Y);
            if (isHoveringHandle) State.SetPotentialInputTarget(intId);
            if (input.WasLeftMousePressedThisFrame && isHoveringHandle && State.PotentialInputTargetId == intId && !State.DragInProgressFromPreviousFrame) State.SetPotentialCaptorForFrame(intId);
            if (State.ActivelyPressedElementId == intId && !input.IsLeftMouseDown) State.ClearActivePress(intId);
            if (State.ActivelyPressedElementId == intId && input.IsLeftMouseDown)
            {
                if (alignment == HAlignment.Left) currentWidth = Math.Clamp(input.MousePosition.X, minWidth, maxWidth);
                else currentWidth = Math.Clamp(windowWidth - input.MousePosition.X, minWidth, maxWidth);
            }
        }

        var finalPanelStyle = panelStyle ?? new BoxStyle { FillColor = new(0.15f, 0.15f, 0.2f, 1.0f), BorderColor = DefaultTheme.NormalBorder, BorderLength = 1 };
        currentWidth = Math.Max(0, currentWidth);
        float finalPanelX = (alignment == HAlignment.Right) ? windowWidth - currentWidth : 0;
        Rect panelRect = new Rect(finalPanelX, topOffset, currentWidth, availableHeight);
        if (panelRect.Width > 0 && panelRect.Height > 0)
        {
            renderer.DrawBox(new Rect(panelRect.X, panelRect.Y, panelRect.Width, panelRect.Height), finalPanelStyle);
        }

        Vector2 contentStartPosition = new Vector2(finalPanelX + finalPadding.X, topOffset + finalPadding.Y);
        Rect contentClipRect = new Rect(contentStartPosition.X, contentStartPosition.Y, Math.Max(0, currentWidth - (finalPadding.X * 2)), Math.Max(0, availableHeight - (finalPadding.Y * 2)));
        bool clipPushed = false;
        if (contentClipRect.Width > 0 && contentClipRect.Height > 0)
        {
            renderer.PushClipRect(contentClipRect, D2D.AntialiasMode.Aliased);
            Context.Layout.PushClipRect(contentClipRect); // For culling
            clipPushed = true;
        }

        var vboxId = HashCode.Combine(intId, "_vbox");
        var vboxState = Context.Layout.GetOrCreateVBoxState(vboxId);
        vboxState.StartPosition = contentStartPosition;
        vboxState.CurrentPosition = contentStartPosition;
        vboxState.Gap = gap;
        vboxState.MaxElementWidth = 0f;
        vboxState.AccumulatedHeight = 0f;
        vboxState.ElementCount = 0;

        var panelState = new ResizablePanelState(intId, vboxState, clipPushed);
        Context.Layout.PushContainer(panelState);
    }

    public static void EndResizableVPanel()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not ResizablePanelState state)
        { Console.WriteLine("Error: EndResizableVPanel called without a matching BeginResizableVPanel."); return; }
        if (state.ClipRectWasPushed)
        {
            Context.Layout.PopClipRect(); // For culling
            Context.Renderer.PopClipRect();
        }
        Context.Layout.PopContainer();
    }

    public static void BeginResizableHPanel(
        string id,
        ref float currentHeight,
        float reservedLeftSpace,
        float reservedRightSpace,
        float topOffset = 0f,
        float minHeight = 50f,
        float maxHeight = 300f,
        float resizeHandleHeight = 5f,
        BoxStyle? panelStyle = null,
        Vector2 padding = default,
        float gap = 5f,
        bool disabled = false)
    {
        if (!IsContextValid()) return;
        var intId = id.GetHashCode();

        Vector2 finalPadding = (padding == default) ? new Vector2(5, 5) : padding;

        var input = Context.InputState;
        var renderer = Context.Renderer;
        var windowWidth = renderer.RenderTargetSize.X;
        var windowHeight = renderer.RenderTargetSize.Y;
        var availableWidth = Math.Max(0, windowWidth - reservedLeftSpace - reservedRightSpace);
        var maxAllowedHeight = windowHeight - topOffset;
        var effectiveMaxHeight = Math.Min(maxHeight, maxAllowedHeight);
        float clampMax = Math.Max(minHeight, effectiveMaxHeight);

        if (!disabled)
        {
            currentHeight = Math.Clamp(currentHeight, minHeight, clampMax);
            float panelY = windowHeight - currentHeight;
            float handleHeight = Math.Min(resizeHandleHeight, currentHeight);
            Rect handleRect = new Rect(reservedLeftSpace, panelY, availableWidth, handleHeight);

            bool isHoveringHandle = handleRect.Contains(input.MousePosition.X, input.MousePosition.Y);
            if (isHoveringHandle) State.SetPotentialInputTarget(intId);
            if (input.WasLeftMousePressedThisFrame && isHoveringHandle && State.PotentialInputTargetId == intId && !State.DragInProgressFromPreviousFrame) State.SetPotentialCaptorForFrame(intId);
            if (State.ActivelyPressedElementId == intId && !input.IsLeftMouseDown) State.ClearActivePress(intId);
            if (State.ActivelyPressedElementId == intId && input.IsLeftMouseDown)
            {
                float clampedMouseY = Math.Max(input.MousePosition.Y, topOffset);
                currentHeight = Math.Clamp(windowHeight - clampedMouseY, minHeight, clampMax);
            }
        }

        var finalPanelStyle = panelStyle ?? new BoxStyle { FillColor = new(0.15f, 0.15f, 0.2f, 1.0f), BorderColor = DefaultTheme.NormalBorder, BorderLength = 1 };
        currentHeight = Math.Clamp(currentHeight, minHeight, clampMax);
        float finalPanelY = windowHeight - currentHeight;
        Rect panelRect = new Rect(reservedLeftSpace, finalPanelY, availableWidth, currentHeight);
        if (panelRect.Width > 0 && panelRect.Height > 0)
        {
            renderer.DrawBox(new Rect(panelRect.X, panelRect.Y, panelRect.Width, panelRect.Height), finalPanelStyle);
        }

        Vector2 contentStartPosition = new Vector2(reservedLeftSpace + finalPadding.X, finalPanelY + finalPadding.Y);
        Rect contentClipRect = new Rect(contentStartPosition.X, contentStartPosition.Y, Math.Max(0, availableWidth - (finalPadding.X * 2)), Math.Max(0, currentHeight - (finalPadding.Y * 2)));
        bool clipPushed = false;
        if (contentClipRect.Width > 0 && contentClipRect.Height > 0)
        {
            renderer.PushClipRect(contentClipRect, D2D.AntialiasMode.Aliased);
            Context.Layout.PushClipRect(contentClipRect); // For culling
            clipPushed = true;
        }

        var hboxId = HashCode.Combine(intId, "_hbox");
        var hboxState = Context.Layout.GetOrCreateHBoxState(hboxId);
        hboxState.StartPosition = contentStartPosition;
        hboxState.CurrentPosition = contentStartPosition;
        hboxState.Gap = gap;
        hboxState.MaxElementHeight = 0f;
        hboxState.AccumulatedWidth = 0f;
        hboxState.ElementCount = 0;

        var panelState = new ResizableHPanelState(intId, hboxState, clipPushed);
        Context.Layout.PushContainer(panelState);
    }

    public static void EndResizableHPanel()
    {
        if (Context.Layout.ContainerStackCount == 0 || Context.Layout.PeekContainer() is not ResizableHPanelState state)
        { Console.WriteLine("Error: EndResizableHPanel called without a matching BeginResizableHPanel."); return; }
        if (state.ClipRectWasPushed)
        {
            Context.Layout.PopClipRect(); // For culling
            Context.Renderer.PopClipRect();
        }
        Context.Layout.PopContainer();
    }
}
</file>

<file path="Core\UI.cs">
using System;
using System.Numerics;

namespace DirectUI;

public static partial class UI
{
    // --- Core Components ---
    public static UIContext Context { get; private set; } = null!;
    public static UIPersistentState State { get; private set; } = null!;
    public static bool IsRendering
    {
        get; private set;
    } = false;
    
    // --- Frame Management ---
    public static void BeginFrame(UIContext context)
    {
        IsRendering = true;

        Context = context;
        State ??= new UIPersistentState();

        State.ResetFrameState(context.InputState);

        Context.Layout.ClearStack();
        Context.treeStateStack.Clear();
    }

    public static void EndFrame()
    {
        // If a click happened this frame but no UI element captured it, and no popup was open, clear focus.
        if (Context.InputState.WasLeftMousePressedThisFrame && State.InputCaptorId == 0 && !State.IsPopupOpen)
        {
            State.SetFocus(0);
        }

        HandlePopupLogic();

        if (Context.Layout.ContainerStackCount > 0)
        {
            Console.WriteLine($"Warning: Mismatch in Begin/End container calls. {Context.Layout.ContainerStackCount} containers left open at EndFrame.");
            Context.Layout.ClearStack();
        }
        if (Context.treeStateStack.Count > 0)
        {
            Console.WriteLine($"Warning: Mismatch in Begin/End Tree calls. {Context.treeStateStack.Count} trees left open at EndFrame.");
            Context.treeStateStack.Clear();
        }

        // It's important that IsRendering is set to false AFTER the context is cleared.
        Context = null!;
        IsRendering = false;
    }

    /// <summary>
    /// Handles popup logic at the end of a frame, ensuring they are drawn last and closed correctly.
    /// </summary>
    private static void HandlePopupLogic()
    {
        if (!State.IsPopupOpen) return;

        // If a mouse press occurred outside the popup's bounds, close the popup.
        if (Context.InputState.WasLeftMousePressedThisFrame)
        {
            if (!State.PopupBounds.Contains(Context.InputState.MousePosition))
            {
                State.ClearActivePopup();
                return; // Don't draw the popup since we just closed it.
            }
        }

        // Execute the callback to draw the popup content.
        State.PopupDrawCallback?.Invoke(Context);
    }


    // --- Helper Methods ---
    private static bool IsContextValid()
    {
        if (Context?.Renderer is null || Context?.TextService is null)
        {
            Console.WriteLine($"Error: UI method called outside BeginFrame/EndFrame or context is invalid.");
            return false;
        }
        return true;
    }
}
</file>

<file path="Core\UI.InputText.cs">
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static bool InputText(
        string id,
        ref string text,
        Vector2 size,
        Vector2 position = default,
        ButtonStylePack? theme = null,
        string placeholderText = "",
        bool isPassword = false,
        char passwordChar = '*',
        int maxLength = 1024,
        bool disabled = false,
        Vector2? textMargin = null)
    {
        if (!IsContextValid())
        {
            return false;
        }

        int intId = id.GetHashCode();
        Vector2 finalPosition = Context.Layout.ApplyLayout(position);
        Vector2 finalMargin = textMargin ?? new(4, 2);
        Rect widgetBounds = new(finalPosition.X, finalPosition.Y, size.X, size.Y);

        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(size);
            return false;
        }

        InputText lineEditInstance = State.GetOrCreateElement<InputText>(intId);
        var lineEditState = State.GetOrCreateElement<InputTextState>(HashCode.Combine(intId, "state"));

        bool textChanged = lineEditInstance.UpdateAndDraw(
            intId,
            ref text,
            lineEditState,
            finalPosition,
            size,
            theme,
            placeholderText,
            isPassword,
            passwordChar,
            maxLength,
            disabled,
            finalMargin);

        Context.Layout.AdvanceLayout(size);
        return textChanged;
    }
}
</file>

<file path="Core\UI.Label.cs">
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static void Text(string id, string text, Vector2? size = null, ButtonStyle? style = null, Alignment? textAlignment = null)
    {
        if (!IsContextValid() || string.IsNullOrEmpty(text))
        {
            return;
        }

        ButtonStyle finalStyle = style ?? new();
        finalStyle.FontColor = GetStyleColor(StyleColor.Text, finalStyle.FontColor);

        Alignment finalAlignment = textAlignment
            ?? new(HAlignment.Left, VAlignment.Center);

        Vector2 measuredSize = Context.TextService.MeasureText(text, finalStyle);

        Vector2 finalSize;
        if (size.HasValue)
        {
            finalSize = new Vector2(
                size.Value.X > 0 ? size.Value.X : measuredSize.X,
                size.Value.Y > 0 ? size.Value.Y : measuredSize.Y
            );
        }
        else
        {
            finalSize = measuredSize;
        }

        Vector2 drawPos = Context.Layout.GetCurrentPosition();
        Rect widgetBounds = new(drawPos.X, drawPos.Y, finalSize.X, finalSize.Y);

        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(finalSize);
            return;
        }

        DrawTextPrimitive(
            widgetBounds,
            text,
            finalStyle,
            finalAlignment,
            Vector2.Zero);

        Context.Layout.AdvanceLayout(finalSize);
    }
}
</file>

<file path="Core\UI.ScrollBar.cs">
// Core/UI.ScrollBar.cs
using System;
using System.Numerics;

namespace DirectUI;

public static partial class UI
{
    /// <summary>
    /// Draws a vertical scrollbar and handles its interaction.
    /// </summary>
    /// <param name="id">A unique identifier for the scrollbar.</param>
    /// <param name="currentScrollOffset">The current vertical scroll offset, which this control will modify.</param>
    /// <param name="position">The top-left position where the scrollbar will be drawn.</param>
    /// <param name="trackHeight">The total height of the scrollbar track.</param>
    /// <param name="contentHeight">The total height of the content being scrolled.</param>
    /// <param name="visibleHeight">The height of the visible portion of the content.</param>
    /// <param name="thickness">The width of the scrollbar.</param>
    /// <param name="theme">The style for the scrollbar's track.</param>
    /// <param name="thumbTheme">The style for the scrollbar's draggable thumb.</param>
    /// <returns>The new vertical scroll offset after user interaction.</returns>
    public static float VScrollBar(
        string id,
        float currentScrollOffset,
        Vector2 position,
        float trackHeight,
        float contentHeight,
        float visibleHeight,
        float thickness = 12f,
        SliderStyle? theme = null,
        ButtonStylePack? thumbTheme = null)
    {
        if (!IsContextValid()) return currentScrollOffset;

        int intId = id.GetHashCode();
        InternalScrollBarLogic scrollBarInstance = State.GetOrCreateElement<InternalScrollBarLogic>(intId);

        // Configure instance
        scrollBarInstance.Position = position;
        scrollBarInstance.TrackLength = trackHeight;
        scrollBarInstance.TrackThickness = thickness;
        scrollBarInstance.IsVertical = true;
        scrollBarInstance.ContentSize = contentHeight;
        scrollBarInstance.VisibleSize = visibleHeight;
        scrollBarInstance.Theme = theme ?? scrollBarInstance.Theme ?? new SliderStyle();
        scrollBarInstance.ThumbTheme = thumbTheme ?? scrollBarInstance.ThumbTheme ?? new ButtonStylePack();

        float newScrollOffset = scrollBarInstance.UpdateAndDraw(intId, currentScrollOffset);

        // A scrollbar, being an overlay, does not advance the main layout cursor.

        return newScrollOffset;
    }

    /// <summary>
    /// Draws a horizontal scrollbar and handles its interaction.
    /// </summary>
    /// <param name="id">A unique identifier for the scrollbar.</param>
    /// <param name="currentScrollOffset">The current horizontal scroll offset, which this control will modify.</param>
    /// <param name="position">The top-left position where the scrollbar will be drawn.</param>
    /// <param name="trackWidth">The total width of the scrollbar track.</param>
    /// <param name="contentWidth">The total width of the content being scrolled.</param>
    /// <param name="visibleWidth">The width of the visible portion of the content.</param>
    /// <param name="thickness">The height of the scrollbar.</param>
    /// <param name="theme">The style for the scrollbar's track.</param>
    /// <param name="thumbTheme">The style for the scrollbar's draggable thumb.</param>
    /// <returns>The new horizontal scroll offset after user interaction.</returns>
    public static float HScrollBar(
        string id,
        float currentScrollOffset,
        Vector2 position,
        float trackWidth,
        float contentWidth,
        float visibleWidth,
        float thickness = 12f,
        SliderStyle? theme = null,
        ButtonStylePack? thumbTheme = null)
    {
        if (!IsContextValid()) return currentScrollOffset;

        int intId = id.GetHashCode();
        InternalScrollBarLogic scrollBarInstance = State.GetOrCreateElement<InternalScrollBarLogic>(intId);

        // Configure instance
        scrollBarInstance.Position = position;
        scrollBarInstance.TrackLength = trackWidth;
        scrollBarInstance.TrackThickness = thickness;
        scrollBarInstance.IsVertical = false;
        scrollBarInstance.ContentSize = contentWidth;
        scrollBarInstance.VisibleSize = visibleWidth;
        scrollBarInstance.Theme = theme ?? scrollBarInstance.Theme ?? new SliderStyle();
        scrollBarInstance.ThumbTheme = thumbTheme ?? scrollBarInstance.ThumbTheme ?? new ButtonStylePack();

        float newScrollOffset = scrollBarInstance.UpdateAndDraw(intId, currentScrollOffset);

        return newScrollOffset;
    }
}
</file>

<file path="Core\UI.Separator.cs">
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static void Separator(float width, float thickness = 1f, float verticalPadding = 4f, Color4? color = null)
    {
        if (!IsContextValid())
        {
            return;
        }

        Color4 finalColor = color ?? DefaultTheme.NormalBorder;
        float totalHeight = thickness + (verticalPadding * 2);
        Vector2 size = new(width, totalHeight);

        Vector2 drawPos = Context.Layout.GetCurrentPosition();
        Rect widgetBounds = new(drawPos.X, drawPos.Y, size.X, size.Y);

        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(size);
            return;
        }

        float lineY = drawPos.Y + verticalPadding + (thickness * 0.5f);
        Vector2 lineStart = new(drawPos.X, lineY);
        Vector2 lineEnd = new(drawPos.X + width, lineY);

        // Use the renderer to draw the line
        Context.Renderer.DrawLine(lineStart, lineEnd, finalColor, thickness);

        Context.Layout.AdvanceLayout(size);
    }
}
</file>

<file path="Core\UI.Slider.cs">
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static float HSlider(
        string id,
        float currentValue,
        float minValue,
        float maxValue,
        Vector2 size,
        Vector2 position = default,
        float step = 0.01f,
        SliderStyle? theme = null,
        ButtonStylePack? grabberTheme = null,
        Vector2? grabberSize = null,
        HSliderDirection direction = HSliderDirection.LeftToRight,
        bool disabled = false,
        object? userData = null,
        Vector2? origin = null)
    {
        if (!IsContextValid()) return currentValue;

        int intId = id.GetHashCode();
        Vector2 drawPos = Context.Layout.ApplyLayout(position);

        // Culling Check
        Rect widgetBounds = new Rect(drawPos.X, drawPos.Y, size.X, size.Y);
        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(size);
            return currentValue;
        }

        InternalHSliderLogic sliderInstance = State.GetOrCreateElement<InternalHSliderLogic>(intId);
        sliderInstance.Position = drawPos;

        // Configure instance
        sliderInstance.Size = size;
        sliderInstance.MinValue = minValue;
        sliderInstance.MaxValue = maxValue;
        sliderInstance.Step = step;
        sliderInstance.Theme = theme ?? sliderInstance.Theme ?? new SliderStyle();
        sliderInstance.GrabberTheme = grabberTheme ?? sliderInstance.GrabberTheme ?? new ButtonStylePack();
        sliderInstance.GrabberSize = grabberSize ?? new Vector2(16, 16);
        sliderInstance.Origin = origin ?? Vector2.Zero;
        sliderInstance.Disabled = disabled;
        sliderInstance.UserData = userData;
        sliderInstance.Direction = direction;


        float newValue = sliderInstance.UpdateAndDraw(intId, currentValue);
        Context.Layout.AdvanceLayout(sliderInstance.Size);
        return newValue;
    }

    public static float VSlider(
        string id,
        float currentValue,
        float minValue,
        float maxValue,
        Vector2 size,
        Vector2 position = default,
        float step = 0.01f,
        SliderStyle? theme = null,
        ButtonStylePack? grabberTheme = null,
        Vector2? grabberSize = null,
        VSliderDirection direction = VSliderDirection.TopToBottom,
        bool disabled = false,
        object? userData = null,
        Vector2? origin = null)
    {
        if (!IsContextValid()) return currentValue;

        int intId = id.GetHashCode();
        Vector2 drawPos = Context.Layout.ApplyLayout(position);

        // Culling Check
        Rect widgetBounds = new Rect(drawPos.X, drawPos.Y, size.X, size.Y);
        if (!Context.Layout.IsRectVisible(widgetBounds))
        {
            Context.Layout.AdvanceLayout(size);
            return currentValue;
        }

        InternalVSliderLogic sliderInstance = State.GetOrCreateElement<InternalVSliderLogic>(intId);
        sliderInstance.Position = drawPos;

        // Configure instance
        sliderInstance.Size = size;
        sliderInstance.MinValue = minValue;
        sliderInstance.MaxValue = maxValue;
        sliderInstance.Step = step;
        sliderInstance.Theme = theme ?? sliderInstance.Theme ?? new SliderStyle();
        sliderInstance.GrabberTheme = grabberTheme ?? sliderInstance.GrabberTheme ?? new ButtonStylePack();
        sliderInstance.GrabberSize = grabberSize ?? new Vector2(16, 16);
        sliderInstance.Origin = origin ?? Vector2.Zero;
        sliderInstance.Disabled = disabled;
        sliderInstance.UserData = userData;
        sliderInstance.Direction = direction;

        float newValue = sliderInstance.UpdateAndDraw(intId, currentValue);
        Context.Layout.AdvanceLayout(sliderInstance.Size);
        return newValue;
    }
}
</file>

<file path="Core\UI.StatelessWidgets.cs">
using System.Numerics;
using DirectUI.Drawing;
using Vortice.Direct2D1; // Still used for AntialiasMode enum
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    /// <summary>
    /// The core, stateless primitive for drawing and interacting with a button.
    /// This is the single source of truth for all button-like controls.
    /// </summary>
    internal static bool DrawButtonPrimitive(
        int id,
        Vortice.Mathematics.Rect bounds,
        string text,
        ButtonStylePack theme,
        bool disabled,
        Alignment textAlignment,
        DirectUI.Button.ActionMode clickMode,
        DirectUI.Button.ClickBehavior clickBehavior,
        Vector2 textOffset,
        bool isActive = false)
    {
        var context = Context;
        var state = State;
        var renderer = context.Renderer;
        var textService = context.TextService;
        var input = context.InputState;

        // --- State Calculation ---
        bool isFocused = !disabled && state.FocusedElementId == id;
        bool isHovering = !disabled && bounds.Width > 0 && bounds.Height > 0 && bounds.Contains(input.MousePosition.X, input.MousePosition.Y);
        if (isHovering)
        {
            state.SetPotentialInputTarget(id);
        }

        // --- Click Detection ---
        bool wasClickedThisFrame = false;
        bool isPressed = state.ActivelyPressedElementId == id;

        bool primaryActionPressedThisFrame = (clickBehavior is DirectUI.Button.ClickBehavior.Left or DirectUI.Button.ClickBehavior.Both) && input.WasLeftMousePressedThisFrame;
        bool secondaryActionPressedThisFrame = (clickBehavior is DirectUI.Button.ClickBehavior.Right or DirectUI.Button.ClickBehavior.Both) && input.WasRightMousePressedThisFrame;
        bool anyActionPressedThisFrame = primaryActionPressedThisFrame || secondaryActionPressedThisFrame;

        bool primaryActionHeld = (clickBehavior is DirectUI.Button.ClickBehavior.Left or DirectUI.Button.ClickBehavior.Both) && input.IsLeftMouseDown;
        bool secondaryActionHeld = (clickBehavior is DirectUI.Button.ClickBehavior.Right or DirectUI.Button.ClickBehavior.Both) && input.IsRightMouseDown;
        bool anyActionHeld = primaryActionHeld || secondaryActionHeld;


        if (!anyActionHeld && isPressed)
        {
            if (isHovering && clickMode == DirectUI.Button.ActionMode.Release)
            {
                wasClickedThisFrame = true;
            }
            state.ClearActivePress(id);
            isPressed = false;
        }

        if (anyActionPressedThisFrame)
        {
            if (isHovering && state.PotentialInputTargetId == id && !state.DragInProgressFromPreviousFrame)
            {
                state.SetButtonPotentialCaptorForFrame(id);
                state.SetFocus(id);
                isPressed = true;
            }
        }

        if (!wasClickedThisFrame && clickMode == DirectUI.Button.ActionMode.Press && state.InputCaptorId == id)
        {
            wasClickedThisFrame = true;
        }

        // --- Style Resolution ---
        ButtonStyle currentStyle = ResolveButtonStylePrimitive(theme, isHovering, isPressed, disabled, isFocused, isActive);

        // --- Drawing ---
        if (bounds.Width > 0 && bounds.Height > 0)
        {
            // Draw Background
            renderer.DrawBox(bounds, currentStyle);

            // Draw Text
            DrawTextPrimitive(bounds, text, currentStyle, textAlignment, textOffset);
        }

        return wasClickedThisFrame;
    }

    /// <summary>
    /// Resolves the final ButtonStyle for the current frame by applying interaction state and style stack overrides.
    /// </summary>
    internal static ButtonStyle ResolveButtonStylePrimitive(ButtonStylePack theme, bool isHovering, bool isPressed, bool isDisabled, bool isFocused, bool isActive)
    {
        // Determine base style from interaction state
        theme.UpdateCurrentStyle(isHovering, isPressed, isDisabled, isFocused, isActive);
        ButtonStyle baseStyle = theme.Current;

        // Create a temporary, modifiable copy for this frame to apply style stack overrides
        var finalStyle = new ButtonStyle
        {
            FillColor = baseStyle.FillColor,
            BorderColor = baseStyle.BorderColor,
            FontColor = baseStyle.FontColor,
            BorderLengthTop = baseStyle.BorderLengthTop,
            BorderLengthRight = baseStyle.BorderLengthRight,
            BorderLengthBottom = baseStyle.BorderLengthBottom,
            BorderLengthLeft = baseStyle.BorderLengthLeft,
            Roundness = baseStyle.Roundness,
            FontName = baseStyle.FontName,
            FontSize = baseStyle.FontSize,
            FontWeight = baseStyle.FontWeight,
            FontStyle = baseStyle.FontStyle,
            FontStretch = baseStyle.FontStretch
        };

        // Override with values from the style stack if they exist
        if (isDisabled)
        {
            finalStyle.FillColor = GetStyleColor(StyleColor.ButtonDisabled, finalStyle.FillColor);
            finalStyle.BorderColor = GetStyleColor(StyleColor.BorderDisabled, finalStyle.BorderColor);
            finalStyle.FontColor = GetStyleColor(StyleColor.TextDisabled, finalStyle.FontColor);
        }
        else if (isPressed)
        {
            finalStyle.FillColor = GetStyleColor(StyleColor.ButtonPressed, finalStyle.FillColor);
            finalStyle.BorderColor = GetStyleColor(StyleColor.BorderPressed, finalStyle.BorderColor);
        }
        else if (isHovering && !isActive) // Don't apply button hover if it's an active tab/button
        {
            finalStyle.FillColor = GetStyleColor(StyleColor.ButtonHovered, finalStyle.FillColor);
            finalStyle.BorderColor = GetStyleColor(StyleColor.BorderHovered, finalStyle.BorderColor);
        }
        else if (isFocused && !isActive) // Don't apply focus border if it's an active tab/button
        {
            finalStyle.BorderColor = GetStyleColor(StyleColor.BorderFocused, finalStyle.BorderColor);
        }
        else if (!isActive) // Normal
        {
            finalStyle.FillColor = GetStyleColor(StyleColor.Button, finalStyle.FillColor);
            finalStyle.BorderColor = GetStyleColor(StyleColor.Border, finalStyle.BorderColor);
        }

        if (!isDisabled)
        {
            finalStyle.FontColor = GetStyleColor(StyleColor.Text, finalStyle.FontColor);
        }

        finalStyle.Roundness = GetStyleVar(StyleVar.FrameRounding, finalStyle.Roundness);
        finalStyle.BorderLength = GetStyleVar(StyleVar.FrameBorderSize, finalStyle.BorderLength);

        return finalStyle;
    }

    /// <summary>
    /// The single, unified primitive for drawing cached text within a bounding box.
    /// </summary>
    internal static void DrawTextPrimitive(
        Vortice.Mathematics.Rect bounds,
        string text,
        ButtonStyle style,
        Alignment textAlignment,
        Vector2 textOffset)
    {
        if (string.IsNullOrEmpty(text)) return;

        var renderer = Context.Renderer;

        // Calculate a clean drawing origin without backend-specific corrections.
        Vector2 drawOrigin = new Vector2(bounds.X + textOffset.X, bounds.Y + textOffset.Y);

        // Call the backend-agnostic DrawText method on the renderer.
        // The renderer is now responsible for any specific positional adjustments.
        renderer.DrawText(drawOrigin, text, style, textAlignment, new Vector2(bounds.Width, bounds.Height), style.FontColor);
    }
}
</file>

<file path="Core\UI.Style.cs">
using System;
using System.Collections.Generic;
using System.Numerics;
using DirectUI.Drawing;

namespace DirectUI;

public enum StyleVar
{
    FrameRounding,
    FrameBorderSize,
    // Future additions could include:
    // ItemSpacing,
    // FramePadding,
    // ButtonTextAlign,
}

public enum StyleColor
{
    Text,
    TextDisabled,
    Button,
    ButtonHovered,
    ButtonPressed,
    ButtonDisabled,
    Border,
    BorderHovered,
    BorderPressed,
    BorderDisabled,
    BorderFocused,
}

public static partial class UI
{
    // --- Style Stack API ---

    public static void PushStyleVar(StyleVar styleVar, float value)
    {
        Context.styleVarStack.Push((styleVar, value));
    }

    public static void PushStyleVar(StyleVar styleVar, Vector2 value)
    {
        Context.styleVarStack.Push((styleVar, value));
    }

    public static void PopStyleVar(int count = 1)
    {
        for (int i = 0; i < count; i++)
        {
            if (Context.styleVarStack.Count > 0)
            {
                Context.styleVarStack.Pop();
            }
        }
    }

    public static void PushStyleColor(StyleColor styleColor, Color color)
    {
        Context.styleColorStack.Push((styleColor, color));
    }

    public static void PopStyleColor(int count = 1)
    {
        for (int i = 0; i < count; i++)
        {
            if (Context.styleColorStack.Count > 0)
            {
                Context.styleColorStack.Pop();
            }
        }
    }

    // --- Style Accessors (for internal widget use) ---

    internal static T GetStyleVar<T>(StyleVar styleVar, T defaultValue)
    {
        foreach (var (key, value) in Context.styleVarStack)
        {
            if (key == styleVar && value is T typedValue)
            {
                return typedValue;
            }
        }
        return defaultValue;
    }

    internal static Color GetStyleColor(StyleColor styleColor, Color defaultValue)
    {
        foreach (var (key, value) in Context.styleColorStack)
        {
            if (key == styleColor)
            {
                return value;
            }
        }
        return defaultValue;
    }
}
</file>

<file path="Core\UI.TabBar.cs">
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static void TabBar(string id, string[] tabLabels, ref int activeIndex, ButtonStylePack? theme = null)
    {
        if (!IsContextValid() || tabLabels is null || tabLabels.Length == 0) return;

        int intId = id.GetHashCode();
        var themeId = HashCode.Combine(intId, "theme_default");
        var tabTheme = theme ?? State.GetOrCreateElement<ButtonStylePack>(themeId);
        var state = State.GetOrCreateElement<TabBarState>(intId);

        const float textMarginX = 15f;
        const float tabHeight = 30f;
        float uniformTabWidth;

        if (state.CachedUniformWidth < 0) // Not calculated yet, or invalidated.
        {
            float maxWidth = 0;
            var styleForMeasuring = tabTheme.Normal;
            foreach (var label in tabLabels)
            {
                // Use ITextService to measure text
                Vector2 measuredSize = Context.TextService.MeasureText(label, styleForMeasuring);
                if (measuredSize.X > maxWidth)
                {
                    maxWidth = measuredSize.X;
                }
            }
            uniformTabWidth = maxWidth + textMarginX * 2;
            state.CachedUniformWidth = uniformTabWidth;
        }
        else
        {
            uniformTabWidth = state.CachedUniformWidth;
        }

        var tabSize = new Vector2(uniformTabWidth, tabHeight);

        var hboxIdString = id + "_hbox";
        BeginHBoxContainer(hboxIdString, Context.Layout.GetCurrentPosition(), 0);
        for (int i = 0; i < tabLabels.Length; i++)
        {
            var buttonId = HashCode.Combine(intId, i);
            var position = Context.Layout.GetCurrentPosition();
            var bounds = new Rect(position.X, position.Y, tabSize.X, tabSize.Y);

            bool wasClicked = DrawButtonPrimitive(
                buttonId,
                bounds,
                tabLabels[i],
                tabTheme,
                disabled: false,
                textAlignment: new Alignment(HAlignment.Center, VAlignment.Center),
                clickMode: DirectUI.Button.ActionMode.Release,
                clickBehavior: DirectUI.Button.ClickBehavior.Left,
                textOffset: Vector2.Zero,
                isActive: i == activeIndex
            );

            if (wasClicked)
            {
                activeIndex = i;
            }
            Context.Layout.AdvanceLayout(tabSize);
        }
        EndHBoxContainer();
    }
}
</file>

<file path="Core\UI.Tree.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    public static void Tree<T>(string id, TreeNode<T> root, out TreeNode<T>? clickedNode, TreeStyle? style = null)
    {
        if (!IsContextValid() || root is null) { clickedNode = null; return; }

        clickedNode = null;
        int intId = id.GetHashCode();
        var styleId = HashCode.Combine(intId, "style");
        var treeStyle = style ?? State.GetOrCreateElement<TreeStyle>(styleId);

        var treeState = new TreeViewState(intId, treeStyle);
        Context.treeStateStack.Push(treeState);
        ProcessTreeNodeRecursive(intId, 0, root, ref clickedNode);
        Context.treeStateStack.Pop();
    }

    private static void ProcessTreeNodeRecursive<T>(int parentIdHash, int index, TreeNode<T> node, ref TreeNode<T>? clickedNode)
    {
        if (Context.treeStateStack.Count == 0) return;
        var treeState = Context.treeStateStack.Peek();
        var style = treeState.Style;
        var renderer = Context.Renderer;

        var startLayoutPos = Context.Layout.GetCurrentPosition();

        // Draw indent lines
        int i = 0;
        foreach (var shouldDrawLine in treeState.IndentLineState)
        {
            if (shouldDrawLine)
            {
                float x = startLayoutPos.X + (i * style.Indent) + (style.Indent * 0.5f);
                renderer.DrawLine(new Vector2(x, startLayoutPos.Y), new Vector2(x, startLayoutPos.Y + style.RowHeight), style.LineColor, 1.0f);
            }
            i++;
        }
        if (treeState.IndentLineState.Count > 0)
        {
            float hLineXStart = startLayoutPos.X + ((treeState.IndentLineState.Count - 1) * style.Indent) + (style.Indent * 0.5f);
            float hLineY = startLayoutPos.Y + style.RowHeight * 0.5f;
            renderer.DrawLine(new Vector2(hLineXStart, hLineY), new Vector2(hLineXStart + style.Indent * 0.5f, hLineY), style.LineColor, 1.0f);
        }

        float indentSize = treeState.IndentLineState.Count * style.Indent;
        var nodeRowStartPos = startLayoutPos + new Vector2(indentSize, 0);
        float currentX = nodeRowStartPos.X;
        float gap = 5;

        int nodeHash = node.GetHashCode();
        int toggleId = HashCode.Combine(parentIdHash, index, nodeHash, 0);
        int labelId = HashCode.Combine(parentIdHash, index, nodeHash, 1);

        float toggleWidth = style.RowHeight - 4;
        if (node.Children.Count > 0)
        {
            var bounds = new Vortice.Mathematics.Rect(currentX, nodeRowStartPos.Y, toggleWidth, style.RowHeight);
            if (DrawButtonPrimitive(toggleId, bounds, node.IsExpanded ? "-" : "+", style.ToggleStyle, false, new Alignment(HAlignment.Center, VAlignment.Center), DirectUI.Button.ActionMode.Release, DirectUI.Button.ClickBehavior.Left, Vector2.Zero, false))
            {
                node.IsExpanded = !node.IsExpanded;
            }
        }
        currentX += toggleWidth;

        currentX += gap;
        var labelStyle = style.NodeLabelStyle;
        var labelTextAlignment = new Alignment(HAlignment.Left, VAlignment.Center);
        float labelMargin = 4;
        // Use ITextService to measure text
        var labelSize = Context.TextService.MeasureText(node.Text, labelStyle.Normal);
        float labelWidth = labelSize.X + labelMargin * 2;
        var labelOffset = new Vector2(labelMargin, 0);
        var labelBounds = new Vortice.Mathematics.Rect(currentX, nodeRowStartPos.Y, labelWidth, style.RowHeight);
        if (DrawButtonPrimitive(labelId, labelBounds, node.Text, labelStyle, false, labelTextAlignment, DirectUI.Button.ActionMode.Press, DirectUI.Button.ClickBehavior.Left, labelOffset, false))
        {
            clickedNode = node;
        }
        currentX += labelWidth;

        Context.Layout.AdvanceLayout(new Vector2((currentX - nodeRowStartPos.X), style.RowHeight));

        if (node.IsExpanded && node.Children.Count > 0)
        {
            for (int childIdx = 0; childIdx < node.Children.Count; childIdx++)
            {
                bool isLastChild = childIdx == node.Children.Count - 1;
                treeState.IndentLineState.Push(!isLastChild);
                ProcessTreeNodeRecursive(toggleId, childIdx, node.Children[childIdx], ref clickedNode);
                treeState.IndentLineState.Pop();
            }
        }
    }
}
</file>

<file path="Core\UIContext.cs">
// Core/UIContext.cs
using System.Collections.Generic;
using DirectUI.Core;
using DirectUI.Drawing;

namespace DirectUI;

public class UIContext
{
    // Per-frame services and state
    public IRenderer Renderer { get; }
    public ITextService TextService { get; }
    public InputState InputState { get; }
    public float DeltaTime { get; }

    // Layout and state management
    public UILayoutManager Layout { get; }
    internal readonly Stack<TreeViewState> treeStateStack = new();
    internal readonly Stack<(StyleVar, object)> styleVarStack = new();
    internal readonly Stack<(StyleColor, Color)> styleColorStack = new();

    public UIContext(IRenderer renderer, ITextService textService, InputState inputState, float deltaTime)
    {
        Renderer = renderer;
        TextService = textService;
        InputState = inputState;
        DeltaTime = deltaTime;
        Layout = new UILayoutManager();
    }
}
</file>

<file path="Core\UILayoutManager.cs">
using System.Numerics;
using Vortice.Mathematics;
using System;

namespace DirectUI;

public class UILayoutManager
{
    private readonly Stack<ILayoutContainer> _containerStack = new();
    private readonly Dictionary<int, object> _containerStateCache = new();
    private readonly Stack<Rect> _clipRectStack = new();

    public int ContainerStackCount => _containerStack.Count;
    public bool IsInLayoutContainer() => _containerStack.Count > 0;

    public void PushContainer(ILayoutContainer containerState) => _containerStack.Push(containerState);
    public ILayoutContainer PopContainer() => _containerStack.Pop();
    public ILayoutContainer PeekContainer() => _containerStack.Peek();
    public void ClearStack()
    {
        _containerStack.Clear();
        _clipRectStack.Clear();
    }

    public void PushClipRect(Rect rect) => _clipRectStack.Push(rect);
    public void PopClipRect()
    {
        if (_clipRectStack.Count > 0)
        {
            _clipRectStack.Pop();
        }
    }

    public Rect GetCurrentClipRect()
    {
        if (_clipRectStack.Count > 0)
        {
            return _clipRectStack.Peek();
        }
        // Return a very large rectangle representing no clipping
        return new Rect(float.MinValue / 2, float.MinValue / 2, float.MaxValue, float.MaxValue);
    }

    public bool IsRectVisible(Rect rect)
    {
        if (_clipRectStack.Count == 0) return true;

        var currentClip = GetCurrentClipRect();

        // Basic intersection test
        return rect.X < currentClip.X + currentClip.Width &&
               rect.X + rect.Width > currentClip.X &&
               rect.Y < currentClip.Y + currentClip.Height &&
               rect.Y + rect.Height > currentClip.Y;
    }

    public HBoxContainerState GetOrCreateHBoxState(int id)
    {
        if (!_containerStateCache.TryGetValue(id, out var state) || state is not HBoxContainerState hboxState)
        {
            hboxState = new HBoxContainerState(id);
            _containerStateCache[id] = hboxState;
        }
        return hboxState;
    }

    public VBoxContainerState GetOrCreateVBoxState(int id)
    {
        if (!_containerStateCache.TryGetValue(id, out var state) || state is not VBoxContainerState vboxState)
        {
            vboxState = new VBoxContainerState(id);
            _containerStateCache[id] = vboxState;
        }
        return vboxState;
    }

    public void BeginHBox(int id, Vector2 startPosition, float gap)
    {
        var hboxState = GetOrCreateHBoxState(id);

        // Reset per-frame properties
        hboxState.StartPosition = startPosition;
        hboxState.CurrentPosition = startPosition;
        hboxState.Gap = gap;
        hboxState.MaxElementHeight = 0f;
        hboxState.AccumulatedWidth = 0f;
        hboxState.ElementCount = 0;

        PushContainer(hboxState);
    }

    public void BeginVBox(int id, Vector2 startPosition, float gap)
    {
        VBoxContainerState vboxState = GetOrCreateVBoxState(id);

        // Reset per-frame properties
        vboxState.StartPosition = startPosition;
        vboxState.CurrentPosition = startPosition;
        vboxState.Gap = gap;
        vboxState.MaxElementWidth = 0f;
        vboxState.AccumulatedHeight = 0f;
        vboxState.ElementCount = 0;

        PushContainer(vboxState);
    }

    public Vector2 ApplyLayout(Vector2 defaultPosition)
    {
        return IsInLayoutContainer() ? GetCurrentPosition() : defaultPosition;
    }

    public void AdvanceLayout(Vector2 elementSize)
    {
        if (IsInLayoutContainer())
        {
            AdvanceContainerLayout(new Vector2(Math.Max(0, elementSize.X), Math.Max(0, elementSize.Y)));
        }
    }

    public Vector2 GetCurrentPosition()
    {
        if (_containerStack.Count == 0)
        {
            return Vector2.Zero;
        }
        // Polymorphic call to the container at the top of the stack.
        return _containerStack.Peek().GetCurrentPosition();
    }

    public void AdvanceContainerLayout(Vector2 elementSize)
    {
        if (_containerStack.Count == 0) return;

        // Polymorphic call to the container at the top of the stack.
        _containerStack.Peek().Advance(elementSize);
    }
}
</file>

<file path="Core\UIPersistentState.cs">
using System;
using System.Collections.Generic;
using Vortice.Mathematics;

namespace DirectUI;

/// <summary>
/// Manages state that persists across frames, such as UI element instances
/// and input capture state (e.g., which element is currently being pressed).
/// </summary>
public class UIPersistentState
{
    // --- Persistent Element State ---
    private readonly Dictionary<int, object> uiElements = new();
    private readonly Dictionary<int, object?> _userData = new();

    // --- Popup/Overlay State ---
    private int _activePopupId;
    private Action<UIContext>? _popupDrawCallback;
    private Rect _popupBounds;

    // Staging area for results from the previous frame to be read in the current one.
    private int _nextFramePopupResult;
    private bool _nextFramePopupResultAvailable;
    private int _nextFramePopupResultOwnerId;

    public int PopupResult { get; private set; }
    public bool PopupResultAvailable { get; private set; }
    public int PopupResultOwnerId { get; private set; }


    public T GetOrCreateElement<T>(int id) where T : new()
    {
        if (uiElements.TryGetValue(id, out object? element) && element is T existingElement)
        {
            return existingElement;
        }

        T newElement = new();
        uiElements[id] = newElement;
        return newElement;
    }

    public void SetUserData(int id, object? data)
    {
        if (data is not null)
        {
            _userData[id] = data;
        }
        else
        {
            _userData.Remove(id);
        }
    }

    public object? GetUserData(int id)
    {
        return _userData.TryGetValue(id, out var data) ? data : null;
    }


    // --- Input State (persists across frames until interaction ends) ---
    public int ActivelyPressedElementId { get; private set; } = 0;
    public bool DragInProgressFromPreviousFrame { get; private set; } = false;
    public int FocusedElementId { get; private set; } = 0;

    // --- Input State (reset each frame) ---
    public int PotentialInputTargetId { get; private set; } = 0;
    public int InputCaptorId { get; private set; } = 0;
    private bool captureAttemptedThisFrame = false;
    public bool NonSliderElementClaimedPress { get; private set; } = false;


    /// <summary>
    /// Resets the per-frame state variables. Called once at the beginning of each frame.
    /// </summary>
    public void ResetFrameState(InputState input)
    {
        DragInProgressFromPreviousFrame = input.IsLeftMouseDown && ActivelyPressedElementId != 0;
        PotentialInputTargetId = 0;
        InputCaptorId = 0;
        captureAttemptedThisFrame = false;
        NonSliderElementClaimedPress = false;

        // At the start of the frame, transfer the popup result from the previous frame
        // to the current frame's readable state.
        PopupResult = _nextFramePopupResult;
        PopupResultAvailable = _nextFramePopupResultAvailable;
        PopupResultOwnerId = _nextFramePopupResultOwnerId;

        // Clear the "next frame" state, making it ready for this frame's popups to write to.
        _nextFramePopupResult = 0;
        _nextFramePopupResultAvailable = false;
        _nextFramePopupResultOwnerId = 0;
    }

    // --- Popup Management ---
    public bool IsPopupOpen => _activePopupId != 0;
    public int ActivePopupId => _activePopupId;
    public Rect PopupBounds => _popupBounds;
    public Action<UIContext>? PopupDrawCallback => _popupDrawCallback;

    public void SetActivePopup(int ownerId, Action<UIContext> drawCallback, Rect bounds)
    {
        _activePopupId = ownerId;
        _popupDrawCallback = drawCallback;
        _popupBounds = bounds;
    }

    public void SetPopupResult(int ownerId, int result)
    {
        // This sets the data that will become available at the start of the *next* frame.
        _nextFramePopupResultOwnerId = ownerId;
        _nextFramePopupResult = result;
        _nextFramePopupResultAvailable = true;
    }

    public void ClearActivePopup()
    {
        _activePopupId = 0;
        _popupDrawCallback = null;
        _popupBounds = default;
    }


    // --- Input Capture && Targeting ---
    public bool IsElementActive()
    {
        return ActivelyPressedElementId != 0;
    }

    public void SetPotentialInputTarget(int id)
    {
        // Don't allow elements to become potential targets if a popup is open and the cursor is outside it.
        if (IsPopupOpen && !_popupBounds.Contains(UI.Context.InputState.MousePosition))
        {
            return;
        }
        PotentialInputTargetId = id;
    }

    public void SetPotentialCaptorForFrame(int id)
    {
        captureAttemptedThisFrame = true;
        InputCaptorId = id;
        ActivelyPressedElementId = id;
    }

    public void SetButtonPotentialCaptorForFrame(int id)
    {
        captureAttemptedThisFrame = true;
        InputCaptorId = id;
        ActivelyPressedElementId = id;
        NonSliderElementClaimedPress = true;
    }

    public void ClearActivePress(int id)
    {
        if (ActivelyPressedElementId == id)
        {
            ActivelyPressedElementId = 0;
        }
    }

    // --- Focus Management ---
    public void SetFocus(int id)
    {
        FocusedElementId = id;
    }
}
</file>

<file path="Diagnostics\FpsCounter.cs">
// DirectUI/Diagnostics/FpsCounter.cs
using System;
using System.Diagnostics;
using DirectUI.Core;
using Vortice.Mathematics;
using Vortice.DirectWrite;
using System.Numerics; // Still used for TextAlignment and ParagraphAlignment enums

namespace DirectUI.Diagnostics;

public class FpsCounter
{
    // Configuration
    private readonly Color4 _textColor = DefaultTheme.Text;
    private readonly string _fontName = "Consolas";
    private readonly float _fontSize = 14.0f;
    private const int UpdatesPerSecond = 2; // Update twice a second

    // State
    private readonly Stopwatch _timer = new();
    private long _lastUpdateTimeTicks = 0;
    private int _frameCountSinceUpdate = 0;
    private float _currentFps = 0.0f;
    private long _updateIntervalInStopwatchTicks;

    // DirectUI Service references
    private ITextService? _textService;
    private IRenderer? _renderer;
    // Removed ITextLayout? _fpsTextLayout; // No longer cached here for drawing

    public void Initialize(ITextService textService, IRenderer renderer)
    {
        _textService = textService ?? throw new ArgumentNullException(nameof(textService));
        _renderer = renderer ?? throw new ArgumentNullException(nameof(renderer));

        Cleanup(); // Ensure any old resources are released

        try
        {
            // Calculate the update interval based on the Stopwatch's actual frequency.
            if (Stopwatch.IsHighResolution)
            {
                _updateIntervalInStopwatchTicks = Stopwatch.Frequency / UpdatesPerSecond;
            }
            else
            {
                // Fallback for low-resolution timer
                _updateIntervalInStopwatchTicks = TimeSpan.TicksPerSecond / UpdatesPerSecond;
            }

            _frameCountSinceUpdate = 0;
            _currentFps = 0;
            _lastUpdateTimeTicks = 0;
            _timer.Restart();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Warning: Failed to initialize FPS counter: {ex.Message}");
            Cleanup(); // Clean up partial resources on failure
        }
    }

    public void Cleanup()
    {
        _timer.Stop();
        // Removed _fpsTextLayout?.Dispose();
        // Removed _fpsTextLayout = null;
    }

    /// <summary>
    /// Updates the frame count and recalculates the FPS value if the update interval has passed.
    /// This should be called once per rendered frame.
    /// </summary>
    public void Update()
    {
        if (!_timer.IsRunning) _timer.Start();

        _frameCountSinceUpdate++;
        long elapsedTicks = _timer.ElapsedTicks;
        long timeSinceLastUpdate = elapsedTicks - _lastUpdateTimeTicks;

        if (timeSinceLastUpdate >= _updateIntervalInStopwatchTicks)
        {
            long frequency = Stopwatch.IsHighResolution ? Stopwatch.Frequency : TimeSpan.TicksPerSecond;
            float secondsElapsed = (float)timeSinceLastUpdate / frequency;

            _currentFps = (secondsElapsed > 0.001f) ? (_frameCountSinceUpdate / secondsElapsed) : 0.0f;
            _frameCountSinceUpdate = 0;
            _lastUpdateTimeTicks = elapsedTicks;

            // No longer invalidate the cached text layout here, as renderer handles its own caching.
        }
    }

    public void Draw()
    {
        if (_textService is null || _renderer is null)
        {
            return;
        }

        string fpsText = $"FPS: {_currentFps:F1}";

        // The FpsCounter no longer needs to create/cache an ITextLayout for drawing.
        // It simply provides the text and style, and the renderer draws it.
        var style = new ButtonStyle
        {
            FontName = _fontName,
            FontSize = _fontSize,
            FontWeight = FontWeight.Normal,
            FontStyle = FontStyle.Normal,
            FontStretch = FontStretch.Normal,
            FontColor = _textColor
        };
        // Use a large max size as FPS counter typically won't wrap
        // The IRenderer.DrawText method requires a maxSize and alignment for its internal layout logic.
        _renderer.DrawText(new Vector2(5f, 5f), fpsText, style, new Alignment(HAlignment.Left, VAlignment.Top), new Vector2(150f, 30f), _textColor);
    }
}
</file>

<file path="Drawing\Color.cs">
using System.Runtime.InteropServices;

namespace DirectUI.Drawing;

[StructLayout(LayoutKind.Sequential)]
public struct Color
{
    public byte R;
    public byte G;
    public byte B;
    public byte A;

    public Color(byte r, byte g, byte b, byte a)
    {
        R = r;
        G = g;
        B = b;
        A = a;
    }

    public Color(float r, float g, float b, float a)
    {
        R = (byte)(r * 255.0f);
        G = (byte)(g * 255.0f);
        B = (byte)(b * 255.0f);
        A = (byte)(a * 255.0f);
    }

    public static implicit operator Raylib_cs.Color(Color color)
    {
        return new Raylib_cs.Color(color.R, color.G, color.B, color.A);
    }

    public static implicit operator Vortice.Mathematics.Color4(Color color)
    {
        return new Vortice.Mathematics.Color4(color.R / 255.0f, color.G / 255.0f, color.B / 255.0f, color.A / 255.0f);
    }

    public static implicit operator Color(Vortice.Mathematics.Color4 color)
    {
        return new Color((byte)(color.R * 255), (byte)(color.G * 255), (byte)(color.B * 255), (byte)(color.A * 255));
    }
}
</file>

<file path="Drawing\FontManager.cs">
// DirectUI/Drawing/FontManager.cs
using Raylib_cs;
using System;
using System.Collections.Generic;
using Vortice.DirectWrite;

namespace DirectUI.Drawing
{
    /// <summary>
    /// Manages loading and caching of fonts for the Raylib backend.
    /// Fonts are registered by family and loaded on-demand at specific sizes and weights.
    /// </summary>
    public static class FontManager
    {
        // Caches the actual loaded Raylib Font objects. Key is (family name, font size, font weight).
        private static readonly Dictionary<(string, int, FontWeight), Font> s_loadedFontsCache = new();

        // Stores registered font families. Key is family name (e.g., "Segoe UI").
        // Value is a dictionary mapping a FontWeight to its file path.
        private static readonly Dictionary<string, Dictionary<FontWeight, string>> s_fontFamilies = new();
        private static bool s_isInitialized = false;

        /// <summary>
        /// Initializes the FontManager.
        /// </summary>
        public static void Initialize()
        {
            if (s_isInitialized) return;
            s_isInitialized = true;
        }

        /// <summary>
        /// Registers a specific font variant (a file path for a given weight) to a font family.
        /// </summary>
        /// <param name="familyName">The logical name for the font family (e.g., "Segoe UI").</param>
        /// <param name="weight">The weight of this font variant.</param>
        /// <param name="filePath">The path to the font file for this variant.</param>
        public static void RegisterFontVariant(string familyName, FontWeight weight, string filePath)
        {
            if (!s_isInitialized)
            {
                Console.WriteLine("FontManager not initialized. Call FontManager.Initialize() first.");
                return;
            }
            if (!s_fontFamilies.TryGetValue(familyName, out var variants))
            {
                variants = new Dictionary<FontWeight, string>();
                s_fontFamilies[familyName] = variants;
            }
            variants[weight] = filePath;
        }

        /// <summary>
        /// Attempts to retrieve the file path for a registered font variant.
        /// </summary>
        /// <param name="familyName">The logical name for the font family.</param>
        /// <param name="weight">The desired weight of the font.</param>
        /// <param name="filePath">When this method returns, contains the file path if found; otherwise, null.</param>
        /// <returns>True if the font file path was found, false otherwise.</returns>
        public static bool TryGetFontFilePath(string familyName, FontWeight weight, out string? filePath)
        {
            filePath = null;
            if (!s_isInitialized) return false;

            if (s_fontFamilies.TryGetValue(familyName, out var variants))
            {
                return variants.TryGetValue(weight, out filePath);
            }
            return false;
        }

        /// <summary>
        /// Retrieves a font at a specific size and weight. If not cached, it's loaded from its registered path.
        /// </summary>
        /// <param name="familyName">The name of the registered font family.</param>
        /// <param name="fontSize">The desired size of the font.</param>
        /// <param name="weight">The desired weight of the font.</param>
        /// <returns>The Raylib Font object. Returns the default font if the requested font cannot be loaded.</returns>
        public static Font GetFont(string familyName, int fontSize, FontWeight weight)
        {
            if (!s_isInitialized)
            {
                return Raylib.GetFontDefault();
            }
            if (fontSize <= 0)
            {
                fontSize = 10; // Use a default small size for safety.
            }

            var cacheKey = (familyName, fontSize, weight);
            if (s_loadedFontsCache.TryGetValue(cacheKey, out var font))
            {
                return font;
            }

            if (!TryGetFontFilePath(familyName, weight, out string? filePath) && !TryGetFontFilePath(familyName, FontWeight.Normal, out filePath))
            {
                Console.WriteLine($"Font family '{familyName}' does not have a variant for weight {weight} or a Normal fallback. Returning default font.");
                return Raylib.GetFontDefault();
            }

            try
            {
                // Load the font at the exact size requested for the atlas.
                Font newFont = Raylib.LoadFontEx(filePath, fontSize, null, 0);

                // Use Point filtering for sharp, 1:1 pixel rendering from the atlas.
                // This avoids the blurriness/shagginess of Bilinear filtering when not oversampling.
                // MSAA should handle smoothing the final glyph edges.
                Raylib.SetTextureFilter(newFont.Texture, TextureFilter.Point);

                s_loadedFontsCache[cacheKey] = newFont;
                return newFont;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to load font '{familyName}' (weight {weight}) at size {fontSize} from '{filePath}'. Reason: {ex.Message}. Returning default font.");
                return Raylib.GetFontDefault();
            }
        }

        /// <summary>
        /// Unloads all loaded fonts and clears all caches.
        /// </summary>
        public static void UnloadAll()
        {
            var defaultFont = Raylib.GetFontDefault();
            foreach (var font in s_loadedFontsCache.Values)
            {
                // Do not unload the default font, Raylib manages it.
                if (font.Texture.Id != defaultFont.Texture.Id)
                {
                    Raylib.UnloadFont(font);
                }
            }
            s_loadedFontsCache.Clear();
            s_fontFamilies.Clear();
            s_isInitialized = false;
        }
    }
}
</file>

<file path="Input\InputManager.cs">
using System.Numerics;
using System.Runtime.InteropServices; // Added for Marshal
using Raylib_cs; // Added for Raylib backend
using SDL3;
using static SDL3.SDL; // Added for SDL3 backend

namespace DirectUI.Input;

public class InputManager
{
    // Persistent state (held across frames)
    private Vector2 _currentMousePos = new(-1, -1);
    private bool _isLeftMouseButtonDown;
    private bool _isRightMouseButtonDown;
    private readonly HashSet<Keys> _heldKeys = new();

    // Per-frame state (reset every frame)
    private bool _wasLeftMouseClickedThisFrame;
    private bool _wasRightMouseClickedThisFrame;
    private float _scrollDeltaThisFrame;
    private readonly Queue<char> _typedCharsThisFrame = new();
    private readonly List<Keys> _pressedKeysThisFrame = new();
    private readonly List<Keys> _releasedKeysThisFrame = new();
    private readonly List<MouseButton> _pressedMouseButtonsThisFrame = new();

    public InputState GetCurrentState()
    {
        return new(
            _currentMousePos,
            _wasLeftMouseClickedThisFrame,
            _isLeftMouseButtonDown,
            _wasRightMouseClickedThisFrame,
            _isRightMouseButtonDown,
            _scrollDeltaThisFrame,
            [.. _typedCharsThisFrame], // Create a copy for the readonly list
            _pressedKeysThisFrame,
            _releasedKeysThisFrame,
            _heldKeys,
            [.. _pressedMouseButtonsThisFrame] // Create a copy for the readonly list
        );
    }

    public void PrepareNextFrame()
    {
        _wasLeftMouseClickedThisFrame = false;
        _wasRightMouseClickedThisFrame = false;
        _scrollDeltaThisFrame = 0f;
        _typedCharsThisFrame.Clear();
        _pressedKeysThisFrame.Clear();
        _releasedKeysThisFrame.Clear();
        _pressedMouseButtonsThisFrame.Clear();
    }

    public void SetMousePosition(int x, int y)
    {
        _currentMousePos = new Vector2(x, y);
    }

    public void AddMouseWheelDelta(float delta)
    {
        _scrollDeltaThisFrame += delta;
    }

    public void SetMouseDown(MouseButton button)
    {
        _pressedMouseButtonsThisFrame.Add(button);

        if (button == MouseButton.Left)
        {
            _isLeftMouseButtonDown = true;
            _wasLeftMouseClickedThisFrame = true;
        }
        else if (button == MouseButton.Right)
        {
            _isRightMouseButtonDown = true;
            _wasRightMouseClickedThisFrame = true;
        }
    }

    public void SetMouseUp(MouseButton button)
    {
        if (button == MouseButton.Left)
        {
            _isLeftMouseButtonDown = false;
        }
        else if (button == MouseButton.Right)
        {
            _isRightMouseButtonDown = false;
        }
    }

    public void AddCharacterInput(char c)
    {
        // Filter out control characters except for tab and newline which might be useful in text boxes.
        if (!char.IsControl(c) || c == '\t' || c == '\n')
        {
            _typedCharsThisFrame.Enqueue(c);
        }
    }

    public void AddKeyPressed(Keys key)
    {
        if (!_heldKeys.Contains(key))
        {
            _pressedKeysThisFrame.Add(key);
            _heldKeys.Add(key);
        }
    }

    public void AddKeyReleased(Keys key)
    {
        if (_heldKeys.Contains(key))
        {
            _releasedKeysThisFrame.Add(key);
            _heldKeys.Remove(key);
        }
    }

    public void ProcessVeldridInput(Veldrid.InputSnapshot snapshot)
    {
        SetMousePosition((int)snapshot.MousePosition.X, (int)snapshot.MousePosition.Y);
        AddMouseWheelDelta(snapshot.WheelDelta);

        foreach (Veldrid.KeyEvent keyEvent in snapshot.KeyEvents)
        {
            Keys mappedKey = MapVeldridKeyToDirectUIKey(keyEvent.Key);
            if (mappedKey == Keys.Unknown) continue;

            if (keyEvent.Down)
            {
                AddKeyPressed(mappedKey);
            }
            else
            {
                AddKeyReleased(mappedKey);
            }
        }

        foreach (var mouseEvent in snapshot.MouseEvents)
        {
            MouseButton mappedButton = MapVeldridMouseButtonToDirectUIButton(mouseEvent.MouseButton);
            if (mouseEvent.Down)
            {
                SetMouseDown(mappedButton);
            }
            else
            {
                SetMouseUp(mappedButton);
            }
        }

        foreach (char c in snapshot.KeyCharPresses)
        {
            AddCharacterInput(c);
        }
    }

    private Keys MapVeldridKeyToDirectUIKey(Veldrid.Key key)
    {
        throw new NotImplementedException();
    }

    public void ProcessRaylibInput()
    {
        // Mouse position
        Vector2 mousePos = Raylib.GetMousePosition();
        SetMousePosition((int)mousePos.X, (int)mousePos.Y);

        // Mouse buttons
        if (Raylib.IsMouseButtonPressed(Raylib_cs.MouseButton.Left)) SetMouseDown(MouseButton.Left);
        if (Raylib.IsMouseButtonReleased(Raylib_cs.MouseButton.Left)) SetMouseUp(MouseButton.Left);
        if (Raylib.IsMouseButtonPressed(Raylib_cs.MouseButton.Right)) SetMouseDown(MouseButton.Right);
        if (Raylib.IsMouseButtonReleased(Raylib_cs.MouseButton.Right)) SetMouseUp(MouseButton.Right);
        if (Raylib.IsMouseButtonPressed(Raylib_cs.MouseButton.Middle)) SetMouseDown(MouseButton.Middle);
        if (Raylib.IsMouseButtonReleased(Raylib_cs.MouseButton.Middle)) SetMouseUp(MouseButton.Middle);

        // Mouse wheel
        float wheelMove = Raylib.GetMouseWheelMove();
        if (wheelMove != 0) AddMouseWheelDelta(wheelMove);

        // Keyboard keys
        foreach (KeyboardKey rlKey in Enum.GetValues(typeof(KeyboardKey)))
        {
            if (rlKey == KeyboardKey.Null) continue; // Skip NULL key

            Keys mappedKey = MapRaylibKeyToDirectUIKey(rlKey);
            if (mappedKey == Keys.Unknown) continue;

            if (Raylib.IsKeyPressed(rlKey)) AddKeyPressed(mappedKey);
            if (Raylib.IsKeyReleased(rlKey)) AddKeyReleased(mappedKey);
        }

        // Character input
        int charValue = Raylib.GetCharPressed();
        while (charValue > 0)
        {
            AddCharacterInput((char)charValue);
            charValue = Raylib.GetCharPressed();
        }
    }
    public unsafe void ProcessSDL3Event(Event sdlEvent)
    {
        switch ((EventType)sdlEvent.Type)
        {
            case EventType.MouseButtonDown:
                SetMousePosition((int)sdlEvent.Button.X, (int)sdlEvent.Button.Y); // Update position on click
                SetMouseDown(MapSDL3MouseButtonToDirectUIButton(sdlEvent.Button.Button)); // Pass byte directly
                break;
            case EventType.MouseButtonUp:
                SetMousePosition((int)sdlEvent.Button.X, (int)sdlEvent.Button.Y); // Update position on release
                SetMouseUp(MapSDL3MouseButtonToDirectUIButton(sdlEvent.Button.Button)); // Pass byte directly
                break;
            case EventType.MouseMotion: // ADDED: Handle mouse motion to update position
                SetMousePosition((int)sdlEvent.Motion.X, (int)sdlEvent.Motion.Y);
                break;
            case EventType.MouseWheel:
                // SDL wheel delta is usually in integers (e.g., 1 or -1)
                // Normalize it similar to Win32/Veldrid
                float deltaY = sdlEvent.Wheel.Y;
                AddMouseWheelDelta(deltaY);
                break;
            case EventType.KeyDown:
                Keys mappedKeyDown = MapSDL3ScanCodeToDirectUIKey(sdlEvent.Key.Scancode);
                if (mappedKeyDown != Keys.Unknown) AddKeyPressed(mappedKeyDown);
                break;
            case EventType.KeyUp:
                Keys mappedKeyUp = MapSDL3ScanCodeToDirectUIKey(sdlEvent.Key.Scancode);
                if (mappedKeyUp != Keys.Unknown) AddKeyReleased(mappedKeyUp);
                break;
            case EventType.TextInput:
                // Correct way to get character input from SDL3 when `text` is exposed as `nint`
                // `sdlEvent.Text.text` is already an unmanaged pointer (`nint`).
                string typedText = Marshal.PtrToStringUTF8(sdlEvent.Text.Text);
                if (!string.IsNullOrEmpty(typedText))
                {
                    foreach (char c in typedText)
                    {
                        AddCharacterInput(c);
                    }
                }
                break;
        }
    }

    private static MouseButton MapVeldridMouseButtonToDirectUIButton(Veldrid.MouseButton vdButton)
    {
        return vdButton switch
        {
            Veldrid.MouseButton.Left => MouseButton.Left,
            Veldrid.MouseButton.Right => MouseButton.Right,
            Veldrid.MouseButton.Middle => MouseButton.Middle,
            Veldrid.MouseButton.Button1 => MouseButton.XButton1, // Assuming Button1 is XButton1
            Veldrid.MouseButton.Button2 => MouseButton.XButton2, // Assuming Button2 is XButton2
            _ => MouseButton.Left, // Default case
        };
    }

    private static Keys MapRaylibKeyToDirectUIKey(KeyboardKey rlKey)
    {
        // Updated to use PascalCase enum members without the KEY_ prefix
        return rlKey switch
        {
            KeyboardKey.Backspace => Keys.Backspace,
            KeyboardKey.Tab => Keys.Tab,
            KeyboardKey.Enter => Keys.Enter,
            KeyboardKey.LeftShift => Keys.Shift,
            KeyboardKey.RightShift => Keys.Shift,
            KeyboardKey.LeftControl => Keys.Control,
            KeyboardKey.RightControl => Keys.Control,
            KeyboardKey.LeftAlt => Keys.Alt,
            KeyboardKey.RightAlt => Keys.Alt,
            KeyboardKey.Pause => Keys.Pause,
            KeyboardKey.CapsLock => Keys.CapsLock,
            KeyboardKey.Escape => Keys.Escape,
            KeyboardKey.Space => Keys.Space,
            KeyboardKey.PageUp => Keys.PageUp,
            KeyboardKey.PageDown => Keys.PageDown,
            KeyboardKey.End => Keys.End,
            KeyboardKey.Home => Keys.Home,
            KeyboardKey.Left => Keys.LeftArrow,
            KeyboardKey.Up => Keys.UpArrow,
            KeyboardKey.Right => Keys.RightArrow,
            KeyboardKey.Down => Keys.DownArrow,
            KeyboardKey.Insert => Keys.Insert,
            KeyboardKey.Delete => Keys.Delete,
            KeyboardKey.Zero => Keys.D0,
            KeyboardKey.One => Keys.D1,
            KeyboardKey.Two => Keys.D2,
            KeyboardKey.Three => Keys.D3,
            KeyboardKey.Four => Keys.D4,
            KeyboardKey.Five => Keys.D5,
            KeyboardKey.Six => Keys.D6,
            KeyboardKey.Seven => Keys.D7,
            KeyboardKey.Eight => Keys.D8,
            KeyboardKey.Nine => Keys.D9,
            KeyboardKey.A => Keys.A,
            KeyboardKey.B => Keys.B,
            KeyboardKey.C => Keys.C,
            KeyboardKey.D => Keys.D,
            KeyboardKey.E => Keys.E,
            KeyboardKey.F => Keys.F,
            KeyboardKey.G => Keys.G,
            KeyboardKey.H => Keys.H,
            KeyboardKey.I => Keys.I,
            KeyboardKey.J => Keys.J,
            KeyboardKey.K => Keys.K,
            KeyboardKey.L => Keys.L,
            KeyboardKey.M => Keys.M,
            KeyboardKey.N => Keys.N,
            KeyboardKey.O => Keys.O,
            KeyboardKey.P => Keys.P,
            KeyboardKey.Q => Keys.Q,
            KeyboardKey.R => Keys.R,
            KeyboardKey.S => Keys.S,
            KeyboardKey.T => Keys.T,
            KeyboardKey.U => Keys.U,
            KeyboardKey.V => Keys.V,
            KeyboardKey.W => Keys.W,
            KeyboardKey.X => Keys.X,
            KeyboardKey.Y => Keys.Y,
            KeyboardKey.Z => Keys.Z,
            KeyboardKey.F1 => Keys.F1,
            KeyboardKey.F2 => Keys.F2,
            KeyboardKey.F3 => Keys.F3,
            KeyboardKey.F4 => Keys.F4,
            KeyboardKey.F5 => Keys.F5,
            KeyboardKey.F6 => Keys.F6,
            KeyboardKey.F7 => Keys.F7,
            KeyboardKey.F8 => Keys.F8,
            KeyboardKey.F9 => Keys.F9,
            KeyboardKey.F10 => Keys.F10,
            KeyboardKey.F11 => Keys.F11,
            KeyboardKey.F12 => Keys.F12,
            _ => Keys.Unknown,
        };
    }

    private static MouseButton MapSDL3MouseButtonToDirectUIButton(byte sdlButton) // Changed parameter type to byte
    {
        return sdlButton switch
        {
            SDL.ButtonLeft => MouseButton.Left,
            SDL.ButtonMiddle => MouseButton.Middle,
            SDL.ButtonRight => MouseButton.Right,
            SDL.ButtonX1 => MouseButton.XButton1,
            SDL.ButtonX2 => MouseButton.XButton2,
            _ => MouseButton.Left, // Fallback, though ideally all used buttons are mapped.
        };
    }
    private static Keys MapSDL3ScanCodeToDirectUIKey(Scancode sdlScancode)
    {
        return sdlScancode switch
        {
            Scancode.Backspace => Keys.Backspace,
            Scancode.Tab => Keys.Tab,
            Scancode.Return => Keys.Enter, // RETURN is Enter
            Scancode.LShift => Keys.Shift,
            Scancode.RShift => Keys.Shift,
            Scancode.LCtrl => Keys.Control,
            Scancode.RCtrl => Keys.Control,
            Scancode.LAlt => Keys.Alt,
            Scancode.RAlt => Keys.Alt,
            Scancode.Pause => Keys.Pause,
            Scancode.Capslock => Keys.CapsLock,
            Scancode.Escape => Keys.Escape,
            Scancode.Space => Keys.Space,
            Scancode.Pageup => Keys.PageUp,
            Scancode.Pagedown => Keys.PageDown,
            Scancode.End => Keys.End,
            Scancode.Home => Keys.Home,
            Scancode.Left => Keys.LeftArrow,
            Scancode.Up => Keys.UpArrow,
            Scancode.Right => Keys.RightArrow,
            Scancode.Down => Keys.DownArrow,
            Scancode.Insert => Keys.Insert,
            Scancode.Delete => Keys.Delete,
            //Scancode.Num0 => Keys.D0,
            //Scancode.Num1 => Keys.D1,
            //Scancode.Num2 => Keys.D2,
            //Scancode.Num3 => Keys.D3,
            //Scancode.Num4 => Keys.D4,
            //Scancode.Num5 => Keys.D5,
            //Scancode.Num6 => Keys.D6,
            //Scancode.Num7 => Keys.D7,
            //Scancode.Num8 => Keys.D8,
            //Scancode.Num9 => Keys.D9,
            Scancode.A => Keys.A,
            Scancode.B => Keys.B,
            Scancode.C => Keys.C,
            Scancode.D => Keys.D,
            Scancode.E => Keys.E,
            Scancode.F => Keys.F,
            Scancode.G => Keys.G,
            Scancode.H => Keys.H,
            Scancode.I => Keys.I,
            Scancode.J => Keys.J,
            Scancode.K => Keys.K,
            Scancode.L => Keys.L,
            Scancode.M => Keys.M,
            Scancode.N => Keys.N,
            Scancode.O => Keys.O,
            Scancode.P => Keys.P,
            Scancode.Q => Keys.Q,
            Scancode.R => Keys.R,
            Scancode.S => Keys.S,
            Scancode.T => Keys.T,
            Scancode.U => Keys.U,
            Scancode.V => Keys.V,
            Scancode.W => Keys.W,
            Scancode.X => Keys.X,
            Scancode.Y => Keys.Y,
            Scancode.Z => Keys.Z,
            Scancode.F1 => Keys.F1,
            Scancode.F2 => Keys.F2,
            Scancode.F3 => Keys.F3,
            Scancode.F4 => Keys.F4,
            Scancode.F5 => Keys.F5,
            Scancode.F6 => Keys.F6,
            Scancode.F7 => Keys.F7,
            Scancode.F8 => Keys.F8,
            Scancode.F9 => Keys.F9,
            Scancode.F10 => Keys.F10,
            Scancode.F11 => Keys.F11,
            Scancode.F12 => Keys.F12,
            Scancode.LGUI => Keys.LeftWindows, // Left GUI key (Windows, Command, etc.)
            Scancode.RGUI => Keys.RightWindows, // Right GUI key
            Scancode.Application => Keys.Menu, // Application key (right-click menu)
            _ => Keys.Unknown,
        };
    }
}
</file>

<file path="Input\InputState.cs">
// InputState.cs
using System.Collections.Generic;
using System.Numerics;

namespace DirectUI;

// Holds input state needed for UI processing in a single frame
public readonly struct InputState
{
    public readonly Vector2 MousePosition;
    public readonly bool WasLeftMousePressedThisFrame; // True if the left button went down this frame
    public readonly bool IsLeftMouseDown; // True if the left button is currently held down
    public readonly bool WasRightMousePressedThisFrame; // True if the right button went down this frame
    public readonly bool IsRightMouseDown; // True if the right button is currently held down
    public readonly float ScrollDelta; // Mouse wheel scroll amount this frame
    public readonly IReadOnlyList<char> TypedCharacters; // Characters typed this frame
    public readonly IReadOnlyList<Keys> PressedKeys; // Keys pressed down this frame
    public readonly IReadOnlyList<Keys> ReleasedKeys; // Keys released this frame
    public readonly IReadOnlyCollection<Keys> HeldKeys; // Keys currently held down
    public readonly IReadOnlyList<MouseButton> PressedMouseButtons; // Mouse buttons pressed down this frame

    public InputState(
        Vector2 mousePosition,
        bool wasLeftMousePressedThisFrame,
        bool isLeftMouseDown,
        bool wasRightMousePressedThisFrame,
        bool isRightMouseDown,
        float scrollDelta,
        IReadOnlyList<char> typedCharacters,
        IReadOnlyList<Keys> pressedKeys,
        IReadOnlyList<Keys> releasedKeys,
        IReadOnlyCollection<Keys> heldKeys,
        IReadOnlyList<MouseButton> pressedMouseButtons)
    {
        MousePosition = mousePosition;
        WasLeftMousePressedThisFrame = wasLeftMousePressedThisFrame;
        IsLeftMouseDown = isLeftMouseDown;
        WasRightMousePressedThisFrame = wasRightMousePressedThisFrame;
        IsRightMouseDown = isRightMouseDown;
        ScrollDelta = scrollDelta;
        TypedCharacters = typedCharacters;
        PressedKeys = pressedKeys;
        ReleasedKeys = releasedKeys;
        HeldKeys = heldKeys;
        PressedMouseButtons = pressedMouseButtons;
    }
}
</file>

<file path="Input\Keys.cs">
namespace DirectUI;

/// <summary>
/// Defines keyboard keys for use in application-level input handling.
/// The values correspond to Win32 Virtual-Key Codes.
/// </summary>
public enum Keys
{
    /// <summary>
    /// The key is not recognized.
    /// </summary>
    Unknown = 0,

    // Action Keys
    /// <summary>The BACKSPACE key.</summary>
    Backspace = 0x08,
    /// <summary>The TAB key.</summary>
    Tab = 0x09,
    /// <summary>The ENTER key.</summary>
    Enter = 0x0D,
    /// <summary>The SHIFT key.</summary>
    Shift = 0x10,
    /// <summary>The CTRL key.</summary>
    Control = 0x11,
    /// <summary>The ALT key.</summary>
    Alt = 0x12,
    /// <summary>The PAUSE key.</summary>
    Pause = 0x13,
    /// <summary>The CAPS LOCK key.</summary>
    CapsLock = 0x14,
    /// <summary>The ESC key.</summary>
    Escape = 0x1B,
    /// <summary>The SPACEBAR key.</summary>
    Space = 0x20,
    /// <summary>The PAGE UP key.</summary>
    PageUp = 0x21,
    /// <summary>The PAGE DOWN key.</summary>
    PageDown = 0x22,
    /// <summary>The END key.</summary>
    End = 0x23,
    /// <summary>The HOME key.</summary>
    Home = 0x24,
    /// <summary>The LEFT ARROW key.</summary>
    LeftArrow = 0x25,
    /// <summary>The UP ARROW key.</summary>
    UpArrow = 0x26,
    /// <summary>The RIGHT ARROW key.</summary>
    RightArrow = 0x27,
    /// <summary>The DOWN ARROW key.</summary>
    DownArrow = 0x28,
    /// <summary>The INSERT key.</summary>
    Insert = 0x2D,
    /// <summary>The DELETE key.</summary>
    Delete = 0x2E,

    // Digit Keys
    /// <summary>The 0 key.</summary>
    D0 = 0x30,
    /// <summary>The 1 key.</summary>
    D1 = 0x31,
    /// <summary>The 2 key.</summary>
    D2 = 0x32,
    /// <summary>The 3 key.</summary>
    D3 = 0x33,
    /// <summary>The 4 key.</summary>
    D4 = 0x34,
    /// <summary>The 5 key.</summary>
    D5 = 0x35,
    /// <summary>The 6 key.</summary>
    D6 = 0x36,
    /// <summary>The 7 key.</summary>
    D7 = 0x37,
    /// <summary>The 8 key.</summary>
    D8 = 0x38,
    /// <summary>The 9 key.</summary>
    D9 = 0x39,

    // Letter Keys
    /// <summary>The A key.</summary>
    A = 0x41,
    /// <summary>The B key.</summary>
    B = 0x42,
    /// <summary>The C key.</summary>
    C = 0x43,
    /// <summary>The D key.</summary>
    D = 0x44,
    /// <summary>The E key.</summary>
    E = 0x45,
    /// <summary>The F key.</summary>
    F = 0x46,
    /// <summary>The G key.</summary>
    G = 0x47,
    /// <summary>The H key.</summary>
    H = 0x48,
    /// <summary>The I key.</summary>
    I = 0x49,
    /// <summary>The J key.</summary>
    J = 0x4A,
    /// <summary>The K key.</summary>
    K = 0x4B,
    /// <summary>The L key.</summary>
    L = 0x4C,
    /// <summary>The M key.</summary>
    M = 0x4D,
    /// <summary>The N key.</summary>
    N = 0x4E,
    /// <summary>The O key.</summary>
    O = 0x4F,
    /// <summary>The P key.</summary>
    P = 0x50,
    /// <summary>The Q key.</summary>
    Q = 0x51,
    /// <summary>The R key.</summary>
    R = 0x52,
    /// <summary>The S key.</summary>
    S = 0x53,
    /// <summary>The T key.</summary>
    T = 0x54,
    /// <summary>The U key.</summary>
    U = 0x55,
    /// <summary>The V key.</summary>
    V = 0x56,
    /// <summary>The W key.</summary>
    W = 0x57,
    /// <summary>The X key.</summary>
    X = 0x58,
    /// <summary>The Y key.</summary>
    Y = 0x59,
    /// <summary>The Z key.</summary>
    Z = 0x5A,

    // Function Keys
    /// <summary>The F1 key.</summary>
    F1 = 0x70,
    /// <summary>The F2 key.</summary>
    F2 = 0x71,
    /// <summary>The F3 key.</summary>
    F3 = 0x72,
    /// <summary>The F4 key.</summary>
    F4 = 0x73,
    /// <summary>The F5 key.</summary>
    F5 = 0x74,
    /// <summary>The F6 key.</summary>
    F6 = 0x75,
    /// <summary>The F7 key.</summary>
    F7 = 0x76,
    /// <summary>The F8 key.</summary>
    F8 = 0x77,
    /// <summary>The F9 key.</summary>
    F9 = 0x78,
    /// <summary>The F10 key.</summary>
    F10 = 0x79,
    /// <summary>The F11 key.</summary>
    F11 = 0x7A,
    /// <summary>The F12 key.</summary>
    F12 = 0x7B,

    // Special Keys
    /// <summary>The left Windows logo key (Microsoft Natural Keyboard).</summary>
    LeftWindows = 0x5B,
    /// <summary>The right Windows logo key (Microsoft Natural Keyboard).</summary>
    RightWindows = 0x5C,
    /// <summary>The Application key (Microsoft Natural Keyboard).</summary>
    Menu = 0x5D,
}
</file>

<file path="Styles\BoxStyle.cs">
using DirectUI.Drawing;

namespace DirectUI;

public class BoxStyle
{
    public float Roundness { get; set; } = 0.2f;
    public Color FillColor { get; set; } = DefaultTheme.NormalFill;
    public Color BorderColor { get; set; } = DefaultTheme.NormalBorder;

    public float BorderLengthTop { get; set; } = 1.0f;
    public float BorderLengthRight { get; set; } = 1.0f;
    public float BorderLengthBottom { get; set; } = 1.0f;
    public float BorderLengthLeft { get; set; } = 1.0f;

    public float BorderLength
    {
        get => BorderLengthTop; // Return a representative value
        set
        {
            BorderLengthTop = value;
            BorderLengthRight = value;
            BorderLengthBottom = value;
            BorderLengthLeft = value;
        }
    }

    public BoxStyle() { }

    protected BoxStyle(BoxStyle other)
    {
        this.Roundness = other.Roundness;
        this.FillColor = other.FillColor;
        this.BorderColor = other.BorderColor;
        this.BorderLengthTop = other.BorderLengthTop;
        this.BorderLengthRight = other.BorderLengthRight;
        this.BorderLengthBottom = other.BorderLengthBottom;
        this.BorderLengthLeft = other.BorderLengthLeft;
    }
}
</file>

<file path="Styles\ButtonStyle.cs">
// ButtonStyle.cs
using DirectUI.Drawing;
using Vortice.DirectWrite; // For Font related enums eventually

namespace DirectUI;

public class ButtonStyle : BoxStyle
{
    // DirectWrite Font properties will be managed elsewhere (e.g., IDWriteTextFormat)
    // public float FontSpacing { get; set; } = 0; // Handled by TextFormat
    // public float FontSize { get; set; } = 16; // Handled by TextFormat
    // public Font? Font { get; set; } = null; // Represented by TextFormat
    public Color FontColor { get; set; } = DefaultTheme.Text;

    // Properties needed for creating IDWriteTextFormat
    public string FontName { get; set; } = "Segoe UI";
    public float FontSize { get; set; } = 14.0f;
    public FontWeight FontWeight { get; set; } = FontWeight.Normal;
    public FontStyle FontStyle { get; set; } = FontStyle.Normal;
    public FontStretch FontStretch { get; set; } = FontStretch.Normal;

    public ButtonStyle() { }

    public ButtonStyle(ButtonStyle other) : base(other)
    {
        this.FontColor = other.FontColor;
        this.FontName = other.FontName;
        this.FontSize = other.FontSize;
        this.FontWeight = other.FontWeight;
        this.FontStyle = other.FontStyle;
        this.FontStretch = other.FontStretch;
    }
}
</file>

<file path="Styles\ButtonStylePack.cs">
using System.Collections.Generic;
using System;
using Vortice.Mathematics;
using Vortice.DirectWrite;

namespace DirectUI;

public sealed class ButtonStylePack
{
    public ButtonStyle Current { get; internal set; }
    public ButtonStyle Normal { get; set; } = new();
    public ButtonStyle Hover { get; set; } = new();
    public ButtonStyle Pressed { get; set; } = new();
    public ButtonStyle Disabled { get; set; } = new();
    public ButtonStyle Focused { get; set; } = new();
    public ButtonStyle Active { get; set; } = new();
    public ButtonStyle ActiveHover { get; set; } = new();

    public ButtonStylePack()
    {
        Hover.FillColor = DefaultTheme.HoverFill;
        Hover.BorderColor = DefaultTheme.HoverBorder;

        Pressed.FillColor = DefaultTheme.Accent;
        Pressed.BorderColor = DefaultTheme.AccentBorder;

        Disabled.FillColor = DefaultTheme.DisabledFill;
        Disabled.BorderColor = DefaultTheme.DisabledBorder;
        Disabled.FontColor = DefaultTheme.DisabledText;

        Focused.FillColor = DefaultTheme.NormalFill;
        Focused.BorderColor = DefaultTheme.FocusBorder;
        Focused.BorderLength = 1;

        // Styles for 'Active' state, taken from the old TabStylePack
        var panelBg = new Color4(37 / 255f, 37 / 255f, 38 / 255f, 1.0f);
        Active.FillColor = panelBg;
        Active.BorderColor = DefaultTheme.HoverBorder;
        Active.BorderLengthTop = 1f; Active.BorderLengthLeft = 1f; Active.BorderLengthRight = 1f; Active.BorderLengthBottom = 0f;
        Active.Roundness = 0f;

        ActiveHover.FillColor = panelBg;
        ActiveHover.BorderColor = DefaultTheme.AccentBorder;
        ActiveHover.BorderLengthTop = 1f; ActiveHover.BorderLengthLeft = 1f; ActiveHover.BorderLengthRight = 1f; ActiveHover.BorderLengthBottom = 0f;
        ActiveHover.Roundness = 0f;

        Current = Normal;
    }

    public void UpdateCurrentStyle(bool isHovering, bool isPressed, bool isDisabled, bool isFocused, bool isActive = false)
    {
        if (isDisabled)
        {
            Current = Disabled;
        }
        else if (isPressed)
        {
            Current = Pressed;
        }
        else if (isActive)
        {
            Current = isHovering ? ActiveHover : Active;
        }
        else if (isHovering)
        {
            Current = Hover;
        }
        else if (isFocused)
        {
            Current = Focused;
        }
        else
        {
            Current = Normal;
        }
    }

    private IEnumerable<ButtonStyle> AllStyles => [Normal, Hover, Pressed, Disabled, Focused, Active, ActiveHover];

    public string FontName
    {
        set => SetAll(s => s.FontName = value);
    }

    public float FontSize
    {
        set => SetAll(s => s.FontSize = value);
    }

    public FontWeight FontWeight
    {
        set => SetAll(s => s.FontWeight = value);
    }

    public FontStyle FontStyle
    {
        set => SetAll(s => s.FontStyle = value);
    }

    public FontStretch FontStretch
    {
        set => SetAll(s => s.FontStretch = value);
    }

    public Color4 FontColor
    {
        set => SetAll(s => s.FontColor = value);
    }

    public float Roundness
    {
        set => SetAll(s => s.Roundness = value);
    }

    public float BorderLength
    {
        set => SetAll(s => s.BorderLength = value);
    }

    public Color4 FillColor
    {
        set => SetAll(s => s.FillColor = value);
    }

    public Color4 BorderColor
    {
        set => SetAll(s => s.BorderColor = value);
    }

    private void SetAll(Action<ButtonStyle> setter)
    {
        foreach (ButtonStyle style in AllStyles)
        {
            setter(style);
        }
    }
}
</file>

<file path="Styles\DefaultTheme.cs">
// DefaultTheme.cs
using DirectUI.Drawing;

namespace DirectUI;

// Defines default colors for the UI theme
public static class DefaultTheme
{
    // --- Theme Color Definitions ---

    private static class Ue5ThemeColors
    {
        // Palette based on Unreal Engine 5 Editor
        public static readonly Color Fill = new Color(42, 42, 42, 255);        // #2A2A2A
        public static readonly Color FillLighter = new Color(58, 58, 58, 255);  // #3A3A3A
        public static readonly Color Border = new Color(21, 21, 21, 255);      // #151515 (Matches window background)

        // --- CHANGE HERE ---
        // Changed from blue to a light gray for a more authentic UE5 feel.
        public static readonly Color Hover = new Color(160, 160, 160, 255);   // #A0A0A0
        // --- END CHANGE ---

        public static readonly Color Accent = new Color(255, 171, 0, 255);     // Orange #FFAB00
        public static readonly Color AccentBorder = new Color(255, 187, 51, 255); // Lighter Orange

        public static readonly Color DisabledFill = new Color(32, 32, 32, (byte)(255 * 0.8f));
        public static readonly Color DisabledBorder = new Color(48, 48, 48, (byte)(255 * 0.8f));
        public static readonly Color DisabledText = new Color(128, 128, 128, 255);

        public static readonly Color Text = new Color(240, 240, 240, 255);     // #F0F0F0
    }

    private static class OriginalColors
    {
        public static readonly Color NormalFill = new Color(64, 64, 77, 255);
        public static readonly Color NormalBorder = new Color(102, 102, 115, 255);
        public static readonly Color HoverFill = new Color(89, 89, 102, 255);
        public static readonly Color HoverBorder = new Color(128, 128, 140, 255);
        public static readonly Color Accent = new Color(51, 102, 204, 255);
        public static readonly Color AccentBorder = new Color(77, 128, 230, 255);
        public static readonly Color DisabledFill = new Color(51, 51, 51, (byte)(255 * 0.8f));
        public static readonly Color DisabledBorder = new Color(77, 77, 77, (byte)(255 * 0.8f));
        public static readonly Color DisabledText = new Color(128, 128, 128, 255);
        public static readonly Color Text = new Color(245, 245, 245, 255); // WhiteSmoke
    }

    private static class UnityEditorThemeColors
    {
        // Palette based on Unity Editor's default dark theme (Pro skin)
        public static readonly Color Fill = new Color(56, 56, 56, 255);         // #383838 - Standard control background
        public static readonly Color Border = new Color(35, 35, 35, 255);        // #232323 - Dark, subtle border
        public static readonly Color SelectionBlue = new Color(62, 95, 150, 255); // #3E5F96 - The iconic blue for selections/presses
        public static readonly Color SelectionBlueBorder = new Color(75, 116, 185, 255); // #4B74B9 - Brighter blue for hover/focus borders

        public static readonly Color DisabledFill = new Color(56, 56, 56, (byte)(255 * 0.8f));
        public static readonly Color DisabledBorder = new Color(32, 32, 32, (byte)(255 * 0.8f));
        public static readonly Color DisabledText = new Color(128, 128, 128, 255);

        public static readonly Color Text = new Color(207, 207, 207, 255);       // #CFCFCF
    }


    // --- Current Active Theme ---
    // Change the assignments here to swap themes.

    // Basic Palette
    public static readonly Color White = new Color(255, 255, 255, 255);
    public static readonly Color Black = new Color(0, 0, 0, 255);
    public static readonly Color Transparent = new Color(0, 0, 0, 0);

    /*
    // --- ACTIVE THEME: UE5 ---
    public static readonly Color NormalFill = Ue5ThemeColors.Fill;
    public static readonly Color NormalBorder = Ue5ThemeColors.Border;
    public static readonly Color HoverFill = Ue5ThemeColors.FillLighter;
    public static readonly Color HoverBorder = Ue5ThemeColors.Hover;
    public static readonly Color Accent = Ue5ThemeColors.Accent;
    public static readonly Color AccentBorder = Ue5ThemeColors.AccentBorder;
    public static readonly Color DisabledFill = Ue5ThemeColors.DisabledFill;
    public static readonly Color DisabledBorder = Ue5ThemeColors.DisabledBorder;
    public static readonly Color DisabledText = Ue5ThemeColors.DisabledText;
    public static readonly Color FocusBorder = Ue5ThemeColors.Hover;
    public static readonly Color Text = Ue5ThemeColors.Text;
    */

    // --- ACTIVE THEME: Unity Editor (Dark) ---
    public static readonly Color NormalFill = UnityEditorThemeColors.Fill;
    public static readonly Color NormalBorder = UnityEditorThemeColors.Border;
    public static readonly Color HoverFill = UnityEditorThemeColors.Fill; // Fill does not change on hover in Unity
    public static readonly Color HoverBorder = UnityEditorThemeColors.SelectionBlueBorder; // Border becomes blue on hover
    public static readonly Color Accent = UnityEditorThemeColors.SelectionBlue; // Accent is the pressed/active color
    public static readonly Color AccentBorder = UnityEditorThemeColors.SelectionBlueBorder;
    public static readonly Color DisabledFill = UnityEditorThemeColors.DisabledFill;
    public static readonly Color DisabledBorder = UnityEditorThemeColors.DisabledBorder;
    public static readonly Color DisabledText = UnityEditorThemeColors.DisabledText;
    public static readonly Color FocusBorder = UnityEditorThemeColors.SelectionBlueBorder; // Focus also uses the blue border
    public static readonly Color Text = UnityEditorThemeColors.Text;


    /*
    // --- BACKUP THEME: Original ---
    // To restore the original theme, comment out the "UE5" block above
    // and uncomment this block below.
    public static readonly Color NormalFill = OriginalColors.NormalFill;
    public static readonly Color NormalBorder = OriginalColors.NormalBorder;
    public static readonly Color HoverFill = OriginalColors.HoverFill;
    public static readonly Color HoverBorder = OriginalColors.HoverBorder;
    public static readonly Color Accent = OriginalColors.Accent;
    public static readonly Color AccentBorder = OriginalColors.AccentBorder;
    public static readonly Color DisabledFill = OriginalColors.DisabledFill;
    public static readonly Color DisabledBorder = OriginalColors.DisabledBorder;
    public static readonly Color DisabledText = OriginalColors.DisabledText;
    public static readonly Color FocusBorder = new Color(135, 206, 250, 255); // LightSkyBlue
    public static readonly Color Text = OriginalColors.Text;
    */
}
</file>

<file path="Styles\SliderStyle.cs">
namespace DirectUI;

public class SliderStyle
{
    public BoxStyle Background { get; set; } = new()
    {
        FillColor = DefaultTheme.DisabledFill,
        BorderColor = DefaultTheme.NormalBorder,
        Roundness = 0.5f,
        BorderLength = 1.0f
    };

    public BoxStyle Foreground { get; set; } = new()
    {
        FillColor = DefaultTheme.Accent,
        BorderColor = DefaultTheme.Transparent,
        Roundness = 0.5f,
        BorderLength = 0.0f
    };
}
</file>

<file path="Styles\TabStyle.cs">
namespace DirectUI;

public class TabStyle : ButtonStyle
{
    // For now, this is a marker class. It can hold tab-specific style properties later.
}
</file>

<file path="Styles\TabStylePack.cs">
using Vortice.Mathematics;

namespace DirectUI;

public sealed class TabStylePack
{
    public TabStyle Current { get; private set; }
    public TabStyle Normal { get; set; } = new();
    public TabStyle Hover { get; set; } = new();
    public TabStyle Active { get; set; } = new();
    public TabStyle ActiveHover { get; set; } = new();
    public TabStyle Disabled { get; set; } = new();

    public TabStylePack()
    {
        var panelBg = new Color4(37 / 255f, 37 / 255f, 38 / 255f, 1.0f);
        var hoverBorder = DefaultTheme.HoverBorder;
        var accentBorder = DefaultTheme.AccentBorder;

        string fontName = "Segoe UI";
        float fontSize = 14f;

        // Inactive tab
        Normal.FillColor = DefaultTheme.NormalFill;
        Normal.BorderColor = DefaultTheme.NormalBorder;
        Normal.BorderLength = 1f;
        Normal.Roundness = 0f;
        Normal.FontName = fontName; Normal.FontSize = fontSize;

        // Inactive tab, hovered
        Hover.FillColor = DefaultTheme.HoverFill;
        Hover.BorderColor = hoverBorder;
        Hover.BorderLength = 1f;
        Hover.Roundness = 0f;
        Hover.FontName = fontName; Hover.FontSize = fontSize;

        // Active tab
        Active.FillColor = panelBg;
        Active.BorderColor = hoverBorder;
        Active.BorderLengthTop = 1f; Active.BorderLengthLeft = 1f; Active.BorderLengthRight = 1f; Active.BorderLengthBottom = 0f;
        Active.Roundness = 0f;
        Active.FontName = fontName; Active.FontSize = fontSize;

        // Active tab, hovered
        ActiveHover.FillColor = panelBg;
        ActiveHover.BorderColor = accentBorder;
        ActiveHover.BorderLengthTop = 1f; ActiveHover.BorderLengthLeft = 1f; ActiveHover.BorderLengthRight = 1f; ActiveHover.BorderLengthBottom = 0f;
        ActiveHover.Roundness = 0f;
        ActiveHover.FontName = fontName; ActiveHover.FontSize = fontSize;

        Disabled.FillColor = DefaultTheme.DisabledFill;
        Disabled.BorderColor = DefaultTheme.DisabledBorder;
        Disabled.FontColor = DefaultTheme.DisabledText;
        Disabled.FontName = fontName; Disabled.FontSize = fontSize;

        Current = Normal;
    }

    public void UpdateCurrentStyle(bool isHovering, bool isActive, bool isDisabled, bool isFocused)
    {
        if (isDisabled)
        {
            Current = Disabled;
        }
        else if (isActive) Current = isHovering ? ActiveHover : Active;
        else if (isHovering) Current = Hover;
        else
        {
            Current = Normal;
        }
    }
}
</file>

<file path="Styles\TreeStyle.cs">
using DirectUI.Drawing;

namespace DirectUI;

public class TreeStyle
{
    public float Indent { get; set; } = 19f;
    public float RowHeight { get; set; } = 24f; // Increased from 22f to accommodate font descenders
    public Color LineColor { get; set; } = DefaultTheme.HoverBorder;
    public ButtonStylePack ToggleStyle { get; set; }
    public ButtonStylePack NodeLabelStyle { get; set; }

    public TreeStyle()
    {
        ToggleStyle = new ButtonStylePack
        {
            Roundness = 0.2f,
            BorderLength = 1f,
            FontName = "Consolas",
            FontSize = 14
        };
        ToggleStyle.Normal.FillColor = DefaultTheme.NormalFill;
        ToggleStyle.Normal.BorderColor = DefaultTheme.NormalBorder;
        ToggleStyle.Hover.FillColor = DefaultTheme.HoverFill;
        ToggleStyle.Hover.BorderColor = DefaultTheme.HoverBorder;
        ToggleStyle.Pressed.FillColor = DefaultTheme.Accent;
        ToggleStyle.Pressed.BorderColor = DefaultTheme.AccentBorder;

        NodeLabelStyle = new ButtonStylePack
        {
            Roundness = 0f,
            BorderLength = 0f,
            FontName = "Segoe UI",
            FontSize = 14
        };
        NodeLabelStyle.Normal.FillColor = DefaultTheme.Transparent;
        NodeLabelStyle.Normal.FontColor = DefaultTheme.Text;
        NodeLabelStyle.Hover.FillColor = new Color(64, 64, 64, 128); // Semi-transparent gray
        NodeLabelStyle.Hover.FontColor = DefaultTheme.Text;
        NodeLabelStyle.Pressed.FillColor = DefaultTheme.Accent;
        NodeLabelStyle.Pressed.FontColor = DefaultTheme.White;
        NodeLabelStyle.Pressed.BorderColor = DefaultTheme.AccentBorder;
    }
}
</file>

<file path="Widgets\Button.cs">
namespace DirectUI;

public static class Button
{
    public enum ActionMode { Release, Press }
    public enum ClickBehavior { Left, Right, Both }
}
</file>

<file path="Widgets\InputText.cs">
// Widgets/LineEdit.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using DirectUI.Core;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1; // Still used for AntialiasMode enum
using Vortice.DirectWrite; // Still used for WordWrapping, TextAlignment, ParagraphAlignment

namespace DirectUI;

// Logic and drawing for an immediate-mode LineEdit control. This class is STATELESS.
// All persistent state is managed in a separate LineEditState object.
internal class InputText
{
    // === MAIN UPDATE && DRAW METHOD ===
    public bool UpdateAndDraw(
        int intId,
        ref string text,
        InputTextState state, // The state is now passed in
        Vector2 position,
        Vector2 size,
        ButtonStylePack? theme,
        string placeholderText,
        bool isPassword,
        char passwordChar,
        int maxLength,
        bool disabled,
        Vector2 textMargin)
    {
        var context = UI.Context;
        var uiState = UI.State;
        var renderer = context.Renderer;
        var textService = context.TextService;
        var input = context.InputState;

        var themeId = HashCode.Combine(intId, "theme");
        var finalTheme = theme ?? uiState.GetOrCreateElement<ButtonStylePack>(themeId);

        // If no specific theme was provided, configure the default one for a LineEdit look.
        if (theme is null)
        {
            // This setup runs once per widget instance and is then cached.
            finalTheme.Roundness = 0f;
            finalTheme.BorderLength = 1f;

            // Normal state (inset look)
            finalTheme.Normal.FillColor = DefaultTheme.NormalBorder; // Very dark, same as window border
            finalTheme.Normal.BorderColor = Colors.Black;

            // Hover state (subtle brightening)
            finalTheme.Hover.FillColor = new Color4(35 / 255f, 35 / 255f, 35 / 255f, 1.0f);
            finalTheme.Hover.BorderColor = Colors.Black;

            // Focused state (bright border)
            finalTheme.Focused.FillColor = finalTheme.Normal.FillColor;
            finalTheme.Focused.BorderColor = DefaultTheme.FocusBorder;

            // Disabled state
            finalTheme.Disabled.FillColor = finalTheme.Normal.FillColor;
            finalTheme.Disabled.BorderColor = new Color4(48 / 255f, 48 / 255f, 48 / 255f, 1.0f);
        }

        Rect bounds = new(position.X, position.Y, size.X, size.Y);
        bool textChanged = false;

        // --- Focus Management && Caret Placement on Click ---
        bool isHovering = bounds.Contains(input.MousePosition.X, input.MousePosition.Y);
        bool isActive = uiState.ActivelyPressedElementId == intId;

        // BUG FIX: Handle losing active press state on mouse up.
        // Without this, the control would lock all other input after being clicked.
        if (isActive && !input.IsLeftMouseDown)
        {
            uiState.ClearActivePress(intId);
        }

        if (input.WasLeftMousePressedThisFrame && isHovering && !disabled)
        {
            uiState.SetFocus(intId);
            uiState.SetPotentialCaptorForFrame(intId); // Claim the press

            // --- BEGIN: Caret positioning logic on click ---
            // We need to temporarily calculate drawing info here for hit-testing.
            // This is the only place we need to do this, as keyboard input moves the caret programmatically.
            finalTheme.UpdateCurrentStyle(isHovering, false, disabled, true); // We are now focused
            var styleForHitTest = finalTheme.Current;
            var textForHitTest = isPassword ? new string(passwordChar, text.Length) : text;
            var contentRectForHitTest = new Rect(
                bounds.X + textMargin.X,
                bounds.Y + textMargin.Y,
                Math.Max(0, bounds.Width - textMargin.X * 2),
                Math.Max(0, bounds.Height - textMargin.Y * 2)
            );

            // Use ITextService to get the text layout
            var textLayout = textService.GetTextLayout(textForHitTest, styleForHitTest, new(float.MaxValue, size.Y), new Alignment(HAlignment.Left, VAlignment.Center));
            if (textLayout is not null)
            {
                float relativeClickX = input.MousePosition.X - contentRectForHitTest.Left + state.ScrollPixelOffset;
                float relativeClickY = input.MousePosition.Y - contentRectForHitTest.Top;

                var hitTestResult = textLayout.HitTestPoint(new Vector2(relativeClickX, relativeClickY));

                int newCaretPos = hitTestResult.TextPosition;
                if (hitTestResult.IsTrailingHit)
                {
                    newCaretPos++;
                }

                state.CaretPosition = Math.Clamp(newCaretPos, 0, text.Length);

                // Reset blink and update scroll to show caret.
                state.IsBlinkOn = true;
                state.BlinkTimer = 0;
                UpdateView(text, state, size, textMargin);
            }
            // --- END: Caret positioning logic on click ---
        }

        // --- Input Processing ---
        if (uiState.FocusedElementId == intId && !disabled)
        {
            textChanged = ProcessInput(ref text, state, size, maxLength, textMargin, input);
        }

        // --- Drawing ---
        finalTheme.UpdateCurrentStyle(isHovering, false, disabled, uiState.FocusedElementId == intId);
        renderer.DrawBox(bounds, finalTheme.Current);

        // Define content area and clip to it
        Rect contentRect = new Rect(
            bounds.X + textMargin.X,
            bounds.Y + textMargin.Y,
            Math.Max(0, bounds.Width - textMargin.X * 2),
            Math.Max(0, bounds.Height - textMargin.Y * 2)
        );
        renderer.PushClipRect(contentRect, D2D.AntialiasMode.PerPrimitive);

        string textToDraw;
        ButtonStyle styleToDraw;

        if (string.IsNullOrEmpty(text) && !(uiState.FocusedElementId == intId))
        {
            textToDraw = placeholderText;
            styleToDraw = new ButtonStyle(finalTheme.Disabled)
            {
                FontColor = new Color4(100 / 255f, 100 / 255f, 100 / 255f, 1.0f) // Custom placeholder color
            };
        }
        else
        {
            textToDraw = isPassword ? new string(passwordChar, text.Length) : text;
            styleToDraw = finalTheme.Current;
        }

        DrawVisibleText(textToDraw, state, size, styleToDraw, contentRect.TopLeft);

        if (uiState.FocusedElementId == intId && state.IsBlinkOn)
        {
            DrawCaret(textToDraw, state, size, finalTheme.Current, contentRect);
        }

        renderer.PopClipRect();

        return textChanged;
    }

    private bool ProcessInput(ref string text, InputTextState state, Vector2 size, int maxLength, Vector2 textMargin, InputState input)
    {
        bool textChanged = false;

        state.BlinkTimer += UI.Context.DeltaTime;

        if (state.BlinkTimer > 0.5f)
        {
            state.BlinkTimer = 0;
            state.IsBlinkOn = !state.IsBlinkOn;
        }

        bool isCtrlHeld = input.HeldKeys.Contains(Keys.Control);

        if (input.TypedCharacters.Any())
        {
            PushUndoState(text, state);

            foreach (char c in input.TypedCharacters)
            {
                if (text.Length >= maxLength)
                {
                    continue;
                }

                text = text.Insert(state.CaretPosition, c.ToString());
                state.CaretPosition++;
                textChanged = true;
            }
        }

        foreach (var key in input.PressedKeys)
        {
            bool hasChanged = true;
            PushUndoState(text, state); // Push on first key press
            switch (key)
            {
                case Keys.Backspace:
                    if (state.CaretPosition > 0)
                    {
                        int removeCount = 1;
                        if (isCtrlHeld) removeCount = state.CaretPosition - FindPreviousWordStart(text, state.CaretPosition);
                        text = text.Remove(state.CaretPosition - removeCount, removeCount);
                        state.CaretPosition -= removeCount;
                    }
                    break;
                case Keys.Delete:
                    if (state.CaretPosition < text.Length)
                    {
                        int removeCount = 1;
                        if (isCtrlHeld) removeCount = FindNextWordEnd(text, state.CaretPosition) - state.CaretPosition;
                        text = text.Remove(state.CaretPosition, removeCount);
                    }
                    break;
                case Keys.LeftArrow:
                    state.CaretPosition = isCtrlHeld ? FindPreviousWordStart(text, state.CaretPosition) : state.CaretPosition - 1;
                    break;
                case Keys.RightArrow:
                    state.CaretPosition = isCtrlHeld ? FindNextWordEnd(text, state.CaretPosition) : state.CaretPosition + 1;
                    break;
                case Keys.Home: state.CaretPosition = 0; break;
                case Keys.End: state.CaretPosition = text.Length; break;
                case Keys.Z when isCtrlHeld: Undo(ref text, state); break;
                case Keys.Y when isCtrlHeld: Redo(ref text, state); break;
                default: hasChanged = false; break;
            }
            if (hasChanged) textChanged = true;
        }

        state.CaretPosition = Math.Clamp(state.CaretPosition, 0, text.Length);

        if (textChanged || input.PressedKeys.Any(k => k is Keys.LeftArrow or Keys.RightArrow or Keys.Home or Keys.End))
        {
            UpdateView(text, state, size, textMargin);
            state.IsBlinkOn = true;
            state.BlinkTimer = 0;
        }

        return textChanged;
    }

    private static int FindPreviousWordStart(string text, int currentPos)
    {
        if (currentPos == 0)
        {
            return 0;
        }

        int pos = currentPos - 1;
        while (pos > 0 && char.IsWhiteSpace(text[pos])) pos--;
        while (pos > 0 && !char.IsWhiteSpace(text[pos - 1])) pos--;
        return pos;
    }

    private static int FindNextWordEnd(string text, int currentPos)
    {
        if (currentPos >= text.Length)
        {
            return text.Length;
        }

        int pos = currentPos;
        while (pos < text.Length && !char.IsWhiteSpace(text[pos])) pos++;
        while (pos < text.Length && char.IsWhiteSpace(text[pos])) pos++;
        return pos;
    }

    private void DrawVisibleText(string fullText, InputTextState state, Vector2 size, ButtonStyle style, Vector2 contentTopLeft)
    {
        if (string.IsNullOrEmpty(fullText))
        {
            return;
        }

        var context = UI.Context;
        var renderer = context.Renderer;
        var textService = context.TextService;

        // The LineEdit widget uses ITextLayout for hit-testing and caret position calculations.
        // Even though IRenderer now takes raw text for drawing, ITextLayout is still relevant for widget logic.
        var textLayout = textService.GetTextLayout(fullText, style, new(float.MaxValue, size.Y), new Alignment(HAlignment.Left, VAlignment.Center));

        if (textLayout is null) return;

        // A small vertical adjustment to compensate for font metrics making text appear slightly too low when using ParagraphAlignment.Center.
        const float yOffsetCorrection = -1.5f;

        // Calculate the drawing origin by applying scroll offset directly.
        Vector2 drawOrigin = new Vector2(contentTopLeft.X - state.ScrollPixelOffset, contentTopLeft.Y + yOffsetCorrection);

        // Renderer's DrawText method now takes full text parameters.
        renderer.DrawText(drawOrigin, fullText, style, new Alignment(HAlignment.Left, VAlignment.Center), new Vector2(float.MaxValue, size.Y), style.FontColor);
    }

    private void DrawCaret(string text, InputTextState state, Vector2 size, ButtonStyle style, Rect contentRect)
    {
        var textService = UI.Context.TextService;
        var renderer = UI.Context.Renderer;

        // Use ITextService to get the text layout
        var textLayout = textService.GetTextLayout(text, style, new(float.MaxValue, size.Y), new Alignment(HAlignment.Left, VAlignment.Center));
        if (textLayout is null) return;

        // HitTestTextPosition on the ITextLayout (DirectWriteTextLayout provides this)
        var hitTestMetrics = textLayout.HitTestTextPosition(state.CaretPosition, false);

        float caretX = contentRect.Left + hitTestMetrics.Point.X - state.ScrollPixelOffset;
        Rect caretRect = new Rect(caretX, contentRect.Top, 1, contentRect.Height);

        renderer.DrawBox(caretRect, new BoxStyle { FillColor = style.FontColor, Roundness = 0f, BorderLength = 0f });
    }

    private ITextLayout? GetTextLayout(string text, Vector2 size, ButtonStyle style, float maxWidth)
    {
        // LineEdit needs to re-layout text based on user input, so it requests a fresh layout from the service.
        // The ITextService handles the caching internally for performance.
        return UI.Context.TextService.GetTextLayout(text, style, new(maxWidth, size.Y), new Alignment(HAlignment.Left, VAlignment.Center));
    }

    private void UpdateView(string text, InputTextState state, Vector2 size, Vector2 textMargin)
    {
        float availableWidth = size.X - textMargin.X * 2;
        var style = new ButtonStyle(); // A default style is fine for measuring

        var textLayout = UI.Context.TextService.GetTextLayout(text, style, new(float.MaxValue, size.Y), new Alignment(HAlignment.Left, VAlignment.Center));
        if (textLayout is null) return;

        var hitTestMetrics = textLayout.HitTestTextPosition(state.CaretPosition, false);
        float caretAbsoluteX = hitTestMetrics.Point.X;

        if (caretAbsoluteX - state.ScrollPixelOffset > availableWidth)
        {
            state.ScrollPixelOffset = caretAbsoluteX - availableWidth;
        }
        else if (caretAbsoluteX - state.ScrollPixelOffset < 0)
        {
            state.ScrollPixelOffset = caretAbsoluteX;
        }

        float maxScroll = Math.Max(0, textLayout.Size.X - availableWidth);
        state.ScrollPixelOffset = Math.Clamp(state.ScrollPixelOffset, 0, maxScroll);
    }

    private static void PushUndoState(string text, InputTextState state)
    {
        var lastState = state.UndoStack.Count > 0 ? state.UndoStack.Peek() : default;
        if (state.UndoStack.Count > 0 && lastState.Text == text && lastState.CaretPosition == state.CaretPosition) return;

        if (state.UndoStack.Count >= InputTextState.HistoryLimit) state.UndoStack.Pop();
        state.UndoStack.Push(new LineEditUndoRecord(text, state.CaretPosition, state.ScrollPixelOffset));
        state.RedoStack.Clear();
    }

    private static void Undo(ref string text, InputTextState state)
    {
        if (state.UndoStack.Count == 0) return;
        state.RedoStack.Push(new LineEditUndoRecord(text, state.CaretPosition, state.ScrollPixelOffset));
        var lastState = state.UndoStack.Pop();
        text = lastState.Text;
        state.CaretPosition = lastState.CaretPosition;
        state.ScrollPixelOffset = lastState.ScrollPixelOffset;
    }

    private static void Redo(ref string text, InputTextState state)
    {
        if (state.RedoStack.Count == 0) return;
        state.UndoStack.Push(new LineEditUndoRecord(text, state.CaretPosition, state.ScrollPixelOffset));
        var nextState = state.RedoStack.Pop();
        text = nextState.Text;
        state.CaretPosition = nextState.CaretPosition;
        state.ScrollPixelOffset = nextState.ScrollPixelOffset;
    }
}
</file>

<file path="Widgets\InputTextState.cs">
using System.Collections.Generic;

namespace DirectUI;

internal record struct LineEditUndoRecord(string Text, int CaretPosition, float ScrollPixelOffset);

internal class InputTextState
{
    internal int CaretPosition;
    internal float ScrollPixelOffset;

    internal float BlinkTimer;
    internal bool IsBlinkOn = true;

    internal readonly Stack<LineEditUndoRecord> UndoStack = new();
    internal readonly Stack<LineEditUndoRecord> RedoStack = new();
    internal const int HistoryLimit = 50;
}
</file>

<file path="Widgets\InternalComboboxLogic.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

/// <summary>
/// Provides the internal logic for the combobox widget, including managing popup state.
/// </summary>
internal class InternalComboboxLogic
{
    public int UpdateAndDraw(
        int id,
        int selectedIndex,
        string[] items,
        Vector2 position,
        Vector2 size,
        ButtonStylePack? theme,
        bool disabled)
    {
        var context = UI.Context;
        var state = UI.State;
        var renderer = context.Renderer; // Get the renderer from the context

        int newSelectedIndex = selectedIndex;

        // If a selection was made in the popup during the last frame's EndFrame,
        // the result will be available now for us to consume.
        if (state.PopupResultAvailable && state.PopupResultOwnerId == id)
        {
            newSelectedIndex = state.PopupResult;
        }

        var comboboxState = state.GetOrCreateElement<ComboboxState>(id);
        var themeId = HashCode.Combine(id, "theme");
        var finalTheme = theme ?? state.GetOrCreateElement<ButtonStylePack>(themeId);

        // Sync local open state with global popup state
        if (comboboxState.IsOpen && state.ActivePopupId != id)
        {
            comboboxState.IsOpen = false;
        }

        // The text on the button should reflect the potentially new index
        string currentItemText = (newSelectedIndex >= 0 && newSelectedIndex < items.Length)
            ? items[newSelectedIndex]
            : string.Empty;

        // Draw the main button
        var bounds = new Rect(position.X, position.Y, size.X, size.Y);
        bool clicked = UI.DrawButtonPrimitive(
            id,
            bounds,
            currentItemText,
            finalTheme,
            disabled,
            new Alignment(HAlignment.Left, VAlignment.Center),
            Button.ActionMode.Release,
            Button.ClickBehavior.Left,
            new Vector2(5, 0)
        );

        if (clicked && !disabled)
        {
            if (comboboxState.IsOpen)
            {
                // If it was already open for us, clicking again closes it.
                state.ClearActivePopup();
                comboboxState.IsOpen = false;
            }
            else
            {
                // Request to open the popup.
                // First, ensure any other popups are closed.
                state.ClearActivePopup();

                // Calculate popup properties
                float popupY = position.Y + size.Y + 2;
                float itemHeight = size.Y; // Items are same height as the button
                float popupHeight = items.Length * itemHeight;
                var popupBounds = new Rect(position.X, popupY, size.X, popupHeight);

                // Define the draw callback for the popup, which runs at EndFrame
                Action<UIContext> drawCallback = (ctx) =>
                {
                    // Draw popup background using the renderer
                    var popupStyle = new BoxStyle { FillColor = DefaultTheme.NormalFill, BorderColor = DefaultTheme.FocusBorder, BorderLength = 1f, Roundness = 0f };
                    ctx.Renderer.DrawBox(popupBounds, popupStyle);

                    // Draw items
                    for (int i = 0; i < items.Length; i++)
                    {
                        var itemBounds = new Rect(popupBounds.X, popupBounds.Y + i * itemHeight, popupBounds.Width, itemHeight);
                        var itemTheme = new ButtonStylePack { Roundness = 0f, BorderLength = 0f };
                        itemTheme.Normal.FillColor = Colors.Transparent;
                        itemTheme.Hover.FillColor = DefaultTheme.HoverFill;
                        itemTheme.Pressed.FillColor = DefaultTheme.Accent;

                        int itemId = HashCode.Combine(id, "item", i);

                        if (UI.DrawButtonPrimitive(itemId, itemBounds, items[i], itemTheme, false, new Alignment(HAlignment.Left, VAlignment.Center), Button.ActionMode.Release, Button.ClickBehavior.Left, new Vector2(5, 0)))
                        {
                            // A selection was made. Post the result to be picked up next frame.
                            state.SetPopupResult(id, i);

                            // Close the popup.
                            state.ClearActivePopup();
                        }
                    }
                };

                state.SetActivePopup(id, drawCallback, popupBounds);
                comboboxState.IsOpen = true;
            }
        }

        return newSelectedIndex;
    }
}
</file>

<file path="Widgets\InternalHSliderLogic.cs">
// Widgets/InternalHSliderLogic.cs
using System;
using System.Numerics;
using DirectUI.Core;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

internal class InternalHSliderLogic : InternalSliderLogic
{
    public HSliderDirection Direction { get; set; } = HSliderDirection.LeftToRight;

    protected override void CalculateTrackBounds()
    {
        trackMinBound = trackPosition.X;
        trackMaxBound = trackPosition.X + Size.X;
    }

    protected override float HandleInput(InputState input, float currentValue)
    {
        float newValue = currentValue;
        Vector2 mousePos = input.MousePosition;
        var state = UI.State;

        Vector2 currentGrabberPos = CalculateGrabberPosition(currentValue);
        Rect currentGrabberBounds = new Rect(currentGrabberPos.X, currentGrabberPos.Y, GrabberSize.X, GrabberSize.Y);
        isGrabberHovered = currentGrabberBounds.Contains(mousePos.X, mousePos.Y);

        Rect trackBoundsRect = new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y);
        isTrackHovered = trackBoundsRect.Contains(mousePos.X, mousePos.Y);

        bool isSliderHovered = isGrabberHovered || isTrackHovered;

        if (isSliderHovered)
        {
            state.SetPotentialInputTarget(GlobalIntId);
        }

        if (state.ActivelyPressedElementId == GlobalIntId && !input.IsLeftMouseDown)
        {
            state.ClearActivePress(GlobalIntId);
        }

        if (input.WasLeftMousePressedThisFrame)
        {
            if (isSliderHovered && state.PotentialInputTargetId == GlobalIntId && !state.DragInProgressFromPreviousFrame)
            {
                state.SetButtonPotentialCaptorForFrame(GlobalIntId);
                state.SetFocus(GlobalIntId);

                if (isTrackHovered && !isGrabberHovered)
                {
                    pendingTrackClickValueJump = true;
                    trackClickPosition = Math.Clamp(mousePos.X, trackMinBound, trackMaxBound);
                }
            }
        }

        if (state.ActivelyPressedElementId == GlobalIntId && input.IsLeftMouseDown)
        {
            if (!pendingTrackClickValueJump)
            {
                float clampedX = Math.Clamp(mousePos.X, trackMinBound, trackMaxBound);
                newValue = ConvertPositionToValue(clampedX);
                newValue = ApplyStep(newValue);
                newValue = Math.Clamp(newValue, MinValue, MaxValue);
            }
        }

        return newValue;
    }

    protected override float ConvertPositionToValue(float position)
    {
        if (trackMaxBound <= trackMinBound) return MinValue;
        float normalized = (position - trackMinBound) / (trackMaxBound - trackMinBound);
        normalized = Math.Clamp(normalized, 0.0f, 1.0f);
        if (Direction == HSliderDirection.RightToLeft) { normalized = 1.0f - normalized; }
        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return rawValue;
    }
    protected override Vector2 CalculateGrabberPosition(float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0;
        if (Direction == HSliderDirection.RightToLeft) { normalizedValue = 1.0f - normalizedValue; }
        float trackWidth = Size.X;
        float centerX = trackMinBound + normalizedValue * trackWidth;
        float xPos = centerX - (GrabberSize.X / 2.0f);
        float yPos = trackPosition.Y + (Size.Y / 2.0f) - (GrabberSize.Y / 2.0f);
        float minX = trackPosition.X;
        float maxX = trackPosition.X + Size.X - GrabberSize.X;
        if (maxX < minX) maxX = minX;
        xPos = Math.Clamp(xPos, minX, maxX);
        return new Vector2(xPos, yPos);
    }
    protected override void DrawForeground(IRenderer renderer, float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        if (valueRange <= 0 || renderer is null) return;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0.0f;
        float foregroundWidth = Size.X * normalizedValue;
        if (foregroundWidth <= 0.001f) return;
        Rect clipRect;
        if (Direction == HSliderDirection.RightToLeft) { clipRect = new Rect(trackPosition.X + Size.X - foregroundWidth, trackPosition.Y, foregroundWidth, Size.Y); }
        else { clipRect = new Rect(trackPosition.X, trackPosition.Y, foregroundWidth, Size.Y); }

        renderer.PushClipRect(clipRect, D2D.AntialiasMode.Aliased);
        // Changed to explicitly pass float components for Rect constructor
        renderer.DrawBox(new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y), Theme.Foreground);
        renderer.PopClipRect();
    }
}
</file>

<file path="Widgets\InternalScrollBarLogic.cs">
// Widgets/InternalScrollBarLogic.cs
using System;
using System.Numerics;
using Vortice.Mathematics;
using DirectUI.Core; // Ensure this is present for IRenderer

namespace DirectUI;

/// <summary>
/// Internal class that encapsulates the state, logic, and drawing for a proportional scrollbar.
/// </summary>
internal class InternalScrollBarLogic
{
    // --- Configuration (set per-frame) ---
    public Vector2 Position { get; set; }
    public float TrackLength { get; set; }
    public float TrackThickness { get; set; }
    public bool IsVertical { get; set; }
    public float ContentSize { get; set; }
    public float VisibleSize { get; set; }
    public SliderStyle Theme { get; set; } = new();
    public ButtonStylePack ThumbTheme { get; set; } = new();

    // --- Internal State ---
    private int _id;
    private bool _isThumbHovered;
    private bool _isThumbPressed;
    private bool _isFocused;
    private float _dragStartMousePos;
    private float _dragStartScrollOffset;

    /// <summary>
    /// The main update and draw entry point called by the public UI method.
    /// </summary>
    public float UpdateAndDraw(int id, float currentScrollOffset)
    {
        if (VisibleSize >= ContentSize) return 0; // No scrolling needed, offset must be 0.

        _id = id;
        var context = UI.Context;
        var state = UI.State;
        var input = context.InputState;
        var renderer = context.Renderer;

        _isFocused = state.FocusedElementId == _id;
        float newScrollOffset = HandleInput(input, currentScrollOffset);

        _isThumbPressed = state.ActivelyPressedElementId == _id;
        ThumbTheme.UpdateCurrentStyle(_isThumbHovered, _isThumbPressed, false, _isFocused);

        if (renderer is not null) // Check if renderer is available
        {
            Draw(renderer, newScrollOffset); // Pass the renderer instance
        }

        return newScrollOffset;
    }

    private Rect GetTrackBounds()
    {
        return IsVertical
            ? new Rect(Position.X, Position.Y, TrackThickness, TrackLength)
            : new Rect(Position.X, Position.Y, TrackLength, TrackThickness);
    }

    private Rect GetThumbBounds(float currentScrollOffset, out float thumbLength)
    {
        thumbLength = 0;
        if (VisibleSize >= ContentSize) return new Rect();

        float viewRatio = VisibleSize / ContentSize;
        thumbLength = TrackLength * viewRatio;
        float minThumbLength = 20f; // Ensure thumb is always grabbable
        thumbLength = Math.Max(minThumbLength, thumbLength);

        float maxScrollOffset = ContentSize - VisibleSize;
        float scrollableTrackLength = TrackLength - thumbLength;

        if (scrollableTrackLength <= 0) return GetTrackBounds();

        float scrollRatio = (maxScrollOffset > 0) ? currentScrollOffset / maxScrollOffset : 0;
        float thumbOffsetInTrack = scrollableTrackLength * scrollRatio;

        return IsVertical
            ? new Rect(Position.X, Position.Y + thumbOffsetInTrack, TrackThickness, thumbLength)
            : new Rect(Position.X + thumbOffsetInTrack, Position.Y, thumbLength, TrackThickness);
    }

    private float HandleInput(InputState input, float currentScrollOffset)
    {
        var state = UI.State;
        var trackBounds = GetTrackBounds();
        var thumbBounds = GetThumbBounds(currentScrollOffset, out float thumbLength);

        _isThumbHovered = thumbBounds.Contains(input.MousePosition);
        bool isTrackHovered = trackBounds.Contains(input.MousePosition);

        if (_isThumbHovered || isTrackHovered)
        {
            state.SetPotentialInputTarget(_id);
        }

        _isThumbPressed = state.ActivelyPressedElementId == _id;

        if (_isThumbPressed && !input.IsLeftMouseDown)
        {
            state.ClearActivePress(_id);
            _isThumbPressed = false;
        }

        if (input.WasLeftMousePressedThisFrame && state.PotentialInputTargetId == _id)
        {
            state.SetButtonPotentialCaptorForFrame(_id);
            state.SetFocus(_id);
            _isThumbPressed = true;

            if (_isThumbHovered)
            {
                _dragStartMousePos = IsVertical ? input.MousePosition.Y : input.MousePosition.X;
                _dragStartScrollOffset = currentScrollOffset;
            }
            else // Clicked on track
            {
                float mousePosOnTrack = IsVertical ? input.MousePosition.Y : input.MousePosition.X;
                float thumbStart = IsVertical ? thumbBounds.Y : thumbBounds.X;
                float thumbEnd = thumbStart + thumbLength;

                float pageAmount = VisibleSize;
                if (mousePosOnTrack < thumbStart)
                {
                    return Math.Max(0, currentScrollOffset - pageAmount);
                }
                else if (mousePosOnTrack > thumbEnd)
                {
                    float maxScroll = ContentSize - VisibleSize;
                    return Math.Min(maxScroll, currentScrollOffset + pageAmount);
                }
            }
        }

        if (_isThumbPressed && input.IsLeftMouseDown)
        {
            float maxScrollOffset = ContentSize - VisibleSize;
            float scrollableTrackLength = TrackLength - thumbLength;
            if (scrollableTrackLength <= 0) return currentScrollOffset;

            float currentMousePos = IsVertical ? input.MousePosition.Y : input.MousePosition.X;
            float mouseDelta = currentMousePos - _dragStartMousePos;

            float scrollDelta = mouseDelta * (maxScrollOffset / scrollableTrackLength);

            float newScrollOffset = _dragStartScrollOffset + scrollDelta;
            return Math.Clamp(newScrollOffset, 0, maxScrollOffset);
        }

        return currentScrollOffset;
    }

    private void Draw(IRenderer renderer, float currentScrollOffset) // Changed ID2D1RenderTarget to IRenderer
    {
        // Draw Track
        renderer.DrawBox(GetTrackBounds(), Theme.Background);

        // Draw Thumb
        var thumbBounds = GetThumbBounds(currentScrollOffset, out _);
        if (thumbBounds.Width > 0 && thumbBounds.Height > 0)
        {
            var thumbStyle = new BoxStyle
            {
                FillColor = ThumbTheme.Current.FillColor,
                BorderColor = ThumbTheme.Current.BorderColor,
                BorderLength = ThumbTheme.Current.BorderLength,
                Roundness = ThumbTheme.Current.Roundness
            };
            // Convert Vortice.Mathematics.Rect to System.Numerics.Vector2 for size
            renderer.DrawBox(new Rect(thumbBounds.X, thumbBounds.Y, thumbBounds.Width, thumbBounds.Height), thumbStyle);
        }
    }
}
</file>

<file path="Widgets\InternalSliderLogic.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;
using DirectUI.Core;

namespace DirectUI;

internal abstract class InternalSliderLogic
{
    // --- Configuration ---
    public Vector2 Position { get; set; }
    public Vector2 Size { get; set; }
    public Vector2 Origin { get; set; }
    public float MinValue { get; set; }
    public float MaxValue { get; set; }
    public float Step { get; set; }
    public SliderStyle Theme { get; set; } = new();
    public ButtonStylePack GrabberTheme { get; set; } = new();
    public Vector2 GrabberSize { get; set; } = new(16, 16);
    public bool Disabled { get; set; }
    public object? UserData { get; set; }

    // --- Internal State ---
    protected bool isGrabberPressed = false;
    protected bool isGrabberHovered = false;
    protected bool isTrackHovered = false;
    protected bool isFocused = false;
    protected Vector2 trackPosition;
    protected float trackMinBound;
    protected float trackMaxBound;
    protected bool pendingTrackClickValueJump = false;
    protected float trackClickPosition = 0f;
    protected int GlobalIntId { get; private set; } = 0;


    // --- Calculated Properties ---
    public Rect GlobalBounds => new(Position.X - Origin.X, Position.Y - Origin.Y, Size.X, Size.Y);

    // --- Abstract Methods ---
    protected abstract void CalculateTrackBounds();
    protected abstract float HandleInput(InputState input, float currentValue);
    protected abstract float ConvertPositionToValue(float position);
    protected abstract Vector2 CalculateGrabberPosition(float currentValue);
    protected abstract void DrawForeground(IRenderer renderer, float currentValue);


    // --- Common Logic ---
    internal float UpdateAndDraw(int id, float currentValue)
    {
        var context = UI.Context;
        var state = UI.State;
        var renderer = context.Renderer;

        GlobalIntId = id;
        isFocused = state.FocusedElementId == GlobalIntId;
        trackPosition = Position - Origin;
        CalculateTrackBounds();

        pendingTrackClickValueJump = false;
        float newValue = currentValue;

        if (Disabled)
        {
            isGrabberHovered = false;
            isGrabberPressed = false;
            isTrackHovered = false;
            if (state.ActivelyPressedElementId == GlobalIntId) state.ClearActivePress(GlobalIntId);
        }
        else
        {
            newValue = HandleInput(context.InputState, currentValue);
        }

        if (pendingTrackClickValueJump && state.InputCaptorId == GlobalIntId && !state.NonSliderElementClaimedPress)
        {
            newValue = ConvertPositionToValue(trackClickPosition);
            newValue = ApplyStep(newValue);
            newValue = Math.Clamp(newValue, MinValue, MaxValue);
        }
        pendingTrackClickValueJump = false;

        UpdateGrabberThemeStyle();

        if (renderer is null)
        {
            Console.WriteLine("Error: Renderer is null during Slider UpdateAndDraw.");
            return newValue;
        }

        try
        {
            DrawBackground(renderer);
            DrawForeground(renderer, newValue);
            DrawGrabber(renderer, newValue);
        }
        catch (SharpGen.Runtime.SharpGenException ex) when (ex.ResultCode.Code == Vortice.Direct2D1.ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Slider Draw failed (RecreateTarget): {ex.Message}. External cleanup needed.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error drawing slider: {ex.Message}");
        }

        return newValue;
    }

    // --- Helper Methods ---
    protected float ApplyStep(float value)
    {
        float clampedValue = Math.Clamp(value, MinValue, MaxValue);
        if (Step <= 0 || MaxValue <= MinValue)
        {
            return clampedValue;
        }

        float range = MaxValue - MinValue;
        if (range < Step && Step > 0)
        {
            return (value - MinValue < range / 2.0f) ? MinValue : MaxValue;
        }

        float stepsFromMin = (float)Math.Round((clampedValue - MinValue) / Step);
        float steppedValue = MinValue + stepsFromMin * Step;

        return Math.Clamp(steppedValue, MinValue, MaxValue);
    }


    protected void UpdateGrabberThemeStyle()
    {
        isGrabberPressed = UI.State.ActivelyPressedElementId == GlobalIntId;
        isFocused = UI.State.FocusedElementId == GlobalIntId;
        GrabberTheme.UpdateCurrentStyle(isGrabberHovered, isGrabberPressed, Disabled, isFocused);
    }


    // --- Drawing Methods ---
    protected void DrawBackground(IRenderer renderer)
    {
        // Explicitly pass X, Y, Width, Height components to Rect constructor
        renderer.DrawBox(new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y), Theme.Background);
    }

    protected void DrawGrabber(IRenderer renderer, float currentValue)
    {
        Vector2 grabberPos = CalculateGrabberPosition(currentValue);
        // Explicitly pass X, Y, Width, Height components to Rect constructor
        renderer.DrawBox(new Rect(grabberPos.X, grabberPos.Y, GrabberSize.X, GrabberSize.Y), GrabberTheme.Current);
    }
}
</file>

<file path="Widgets\InternalVSlider.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;
using DirectUI.Core; // Added for IRenderer
using D2D = Vortice.Direct2D1; // Added this using directive

namespace DirectUI;

internal class InternalVSliderLogic : InternalSliderLogic
{
    public VSliderDirection Direction { get; set; } = VSliderDirection.TopToBottom;

    protected override void CalculateTrackBounds()
    {
        trackMinBound = trackPosition.Y;
        trackMaxBound = trackPosition.Y + Size.Y;
    }

    protected override float HandleInput(InputState input, float currentValue)
    {
        float newValue = currentValue;
        Vector2 mousePos = input.MousePosition;
        var state = UI.State;

        Vector2 currentGrabberPos = CalculateGrabberPosition(currentValue);
        Rect currentGrabberBounds = new Rect(currentGrabberPos.X, currentGrabberPos.Y, GrabberSize.X, GrabberSize.Y);
        isGrabberHovered = currentGrabberBounds.Contains(mousePos.X, mousePos.Y);

        Rect trackBoundsRect = new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y);
        isTrackHovered = trackBoundsRect.Contains(mousePos.X, mousePos.Y);

        bool isSliderHovered = isGrabberHovered || isTrackHovered;

        if (isSliderHovered)
        {
            state.SetPotentialInputTarget(GlobalIntId);
        }

        if (state.ActivelyPressedElementId == GlobalIntId && !input.IsLeftMouseDown)
        {
            state.ClearActivePress(GlobalIntId);
        }

        if (input.WasLeftMousePressedThisFrame)
        {
            if (isSliderHovered && state.PotentialInputTargetId == GlobalIntId && !state.DragInProgressFromPreviousFrame)
            {
                state.SetButtonPotentialCaptorForFrame(GlobalIntId);
                state.SetFocus(GlobalIntId);

                if (isTrackHovered && !isGrabberHovered)
                {
                    pendingTrackClickValueJump = true;
                    trackClickPosition = Math.Clamp(mousePos.Y, trackMinBound, trackMaxBound);
                }
            }
        }

        if (state.ActivelyPressedElementId == GlobalIntId && input.IsLeftMouseDown)
        {
            if (!pendingTrackClickValueJump)
            {
                float clampedY = Math.Clamp(mousePos.Y, trackMinBound, trackMaxBound);
                newValue = ConvertPositionToValue(clampedY);
                newValue = ApplyStep(newValue);
                newValue = Math.Clamp(newValue, MinValue, MaxValue);
            }
        }

        return newValue;
    }

    protected override float ConvertPositionToValue(float position)
    {
        if (trackMaxBound <= trackMinBound) return MinValue;
        float normalized = (position - trackMinBound) / (trackMaxBound - trackMinBound);
        normalized = Math.Clamp(normalized, 0.0f, 1.0f);
        if (Direction == VSliderDirection.BottomToTop) { normalized = 1.0f - normalized; }
        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return rawValue;
    }
    protected override Vector2 CalculateGrabberPosition(float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0;
        if (Direction == VSliderDirection.BottomToTop) { normalizedValue = 1.0f - normalizedValue; }
        float trackHeight = Size.Y;
        float centerY = trackMinBound + normalizedValue * trackHeight;
        float yPos = centerY - (GrabberSize.Y / 2.0f);
        float xPos = trackPosition.X + (Size.X / 2.0f) - (GrabberSize.X / 2.0f);
        float minY = trackPosition.Y;
        float maxY = trackPosition.Y + Size.Y - GrabberSize.Y;
        if (maxY < minY) maxY = minY;
        yPos = Math.Clamp(yPos, minY, maxY);
        return new Vector2(xPos, yPos);
    }
    protected override void DrawForeground(IRenderer renderer, float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        if (valueRange <= 0 || renderer is null) return;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0.0f;
        float foregroundHeight = Size.Y * normalizedValue;
        if (foregroundHeight <= 0.001f) return;
        Rect clipRect;
        if (Direction == VSliderDirection.BottomToTop) { clipRect = new Rect(trackPosition.X, trackPosition.Y + Size.Y - foregroundHeight, Size.X, foregroundHeight); }
        else { clipRect = new Rect(trackPosition.X, trackPosition.Y, Size.X, foregroundHeight); }
        renderer.PushClipRect(clipRect, D2D.AntialiasMode.Aliased);
        renderer.DrawBox(new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y), Theme.Foreground);
        renderer.PopClipRect();
    }
}
</file>

<file path="Widgets\SliderDirection.cs">
namespace DirectUI;

public enum HSliderDirection { LeftToRight, RightToLeft }
public enum VSliderDirection { TopToBottom, BottomToTop }
</file>

<file path="Widgets\TabBarState.cs">
namespace DirectUI;

internal class TabBarState
{
    internal float CachedUniformWidth = -1f;
}
</file>

<file path="Widgets\TreeNode.cs">
using System.Collections.Generic;

namespace DirectUI;

/// <summary>
/// Represents a node in a generic tree structure.
/// </summary>
/// <typeparam name="T">The type of the user data associated with the node.</typeparam>
public class TreeNode<T>
{
    public string Text { get; set; }
    public T UserData { get; set; }
    public bool IsExpanded { get; set; }
    public List<TreeNode<T>> Children { get; } = new();

    public TreeNode(string text, T userData, bool expanded = false)
    {
        Text = text;
        UserData = userData;
        IsExpanded = expanded;
    }

    /// <summary>
    /// Adds a new child node to this node.
    /// </summary>
    /// <param name="text">The display text of the child node.</param>
    /// <param name="userData">The user data associated with the child node.</param>
    /// <param name="expanded">Whether the child node is expanded by default.</param>
    /// <returns>The newly created child node.</returns>
    public TreeNode<T> AddChild(string text, T userData, bool expanded = false)
    {
        var child = new TreeNode<T>(text, userData, expanded);
        Children.Add(child);
        return child;
    }

    /// <summary>
    /// Adds an existing TreeNode as a child of this node.
    /// </summary>
    /// <param name="child">The child node to add.</param>
    /// <returns>The added child node.</returns>
    public TreeNode<T> AddChild(TreeNode<T> child)
    {
        Children.Add(child);
        return child;
    }
}
</file>

<file path="Backends\Direct2D\Direct2DRenderer.cs">
using System.Numerics;
using DirectUI.Core;
using SharpGen.Runtime;
using Vortice.Direct2D1;
using Vortice.Direct3D;
using Vortice.Direct3D11;
using Vortice.DirectWrite;
using Vortice.DXGI;
using Vortice.Mathematics;
using InputElementDescription = Vortice.Direct3D11.InputElementDescription;

namespace DirectUI.Backends;

/// <summary>
/// A rendering backend that uses Direct2D to implement the IRenderer interface.
/// It manages its own cache of Direct2D brushes and text layouts.
/// </summary>
public class Direct2DRenderer : IRenderer
{
    private readonly ID2D1RenderTarget _renderTarget;
    private readonly IDWriteFactory _dwriteFactory;
    private readonly ID3D11Device _d3dDevice;
    private readonly ID3D11DeviceContext _d3dContext;
    private readonly IDXGISwapChain _swapChain;
    private readonly ID3D11DepthStencilView _depthStencilView;
    private readonly Dictionary<Color, ID2D1SolidColorBrush> _brushCache = new();

    // D3D resources for the cube
    private ID3D11Buffer? _cubeVertexBuffer;
    private ID3D11Buffer? _cubeIndexBuffer;
    private ID3D11Buffer? _cubeConstantBuffer;
    private ID3D11VertexShader? _cubeVertexShader;
    private ID3D11PixelShader? _cubePixelShader;
    private ID3D11InputLayout? _cubeInputLayout;
    private ID3D11RasterizerState? _cubeRasterizerState;
    private ID3D11DepthStencilState? _cubeDepthStencilState;


    // Internal text layout cache for DrawText method
    private readonly Dictionary<TextLayoutCacheKey, IDWriteTextLayout> _textLayoutCache = new();
    private readonly Dictionary<FontKey, IDWriteTextFormat> _textFormatCache = new(); // Added text format cache

    // Internal cache key for text layouts (similar to UIResources.TextLayoutCacheKey)
    private readonly struct TextLayoutCacheKey : IEquatable<TextLayoutCacheKey>
    {
        public readonly string Text;
        public readonly FontKey FontKey;
        public readonly Vector2 MaxSize;
        public readonly HAlignment HAlign;
        public readonly VAlignment VAlign;

        public TextLayoutCacheKey(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment)
        {
            Text = text;
            FontKey = new FontKey(style);
            MaxSize = maxSize;
            HAlign = alignment.Horizontal;
            VAlign = alignment.Vertical;
        }

        public bool Equals(TextLayoutCacheKey other) => Text == other.Text && MaxSize.Equals(other.MaxSize) && HAlign == other.HAlign && VAlign == other.VAlign && FontKey.Equals(other.FontKey);
        public override bool Equals(object? obj) => obj is TextLayoutCacheKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(Text, FontKey, MaxSize, HAlign, VAlign);
    }

    private readonly struct FontKey : IEquatable<FontKey>
    {
        public readonly string FontName;
        public readonly float FontSize;
        public readonly FontWeight FontWeight;
        public readonly FontStyle FontStyle;
        public readonly FontStretch FontStretch;

        public FontKey(ButtonStyle style)
        {
            FontName = style.FontName;
            FontSize = style.FontSize;
            FontWeight = style.FontWeight;
            FontStyle = style.FontStyle;
            FontStretch = style.FontStretch;
        }

        public bool Equals(FontKey other) => FontName == other.FontName && FontSize.Equals(other.FontSize) && FontWeight == other.FontWeight && FontStyle == other.FontStyle && FontStretch == other.FontStretch;
        public override bool Equals(object? obj) => obj is FontKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(FontName, FontSize, FontWeight, FontStyle, FontStretch);
    }


    public Vector2 RenderTargetSize => new(_renderTarget.Size.Width, _renderTarget.Size.Height);

    public Direct2DRenderer(ID2D1RenderTarget renderTarget, IDWriteFactory dwriteFactory, ID3D11Device d3dDevice, ID3D11DeviceContext d3dContext, IDXGISwapChain swapChain, ID3D11DepthStencilView depthStencilView)
    {
        _renderTarget = renderTarget ?? throw new ArgumentNullException(nameof(renderTarget));
        _dwriteFactory = dwriteFactory ?? throw new ArgumentNullException(nameof(dwriteFactory));
        _d3dDevice = d3dDevice ?? throw new ArgumentNullException(nameof(d3dDevice));
        _d3dContext = d3dContext ?? throw new ArgumentNullException(nameof(d3dContext));
        _swapChain = swapChain ?? throw new ArgumentNullException(nameof(swapChain));
        _depthStencilView = depthStencilView ?? throw new ArgumentNullException(nameof(depthStencilView));

        CreateCubeResources();
    }

    public void DrawLine(Vector2 p1, Vector2 p2, Drawing.Color color, float strokeWidth)
    {
        var brush = GetOrCreateBrush(color);
        if (brush is null) return;
        _renderTarget.DrawLine(p1, p2, brush, strokeWidth);
    }

    public void DrawBox(Vortice.Mathematics.Rect rect, BoxStyle style)
    {
        if (_renderTarget is null || style is null || rect.Width <= 0 || rect.Height <= 0) return;

        var pos = rect.TopLeft;
        var size = new Vector2(rect.Width, rect.Height);

        ID2D1SolidColorBrush? fillBrush = GetOrCreateBrush(style.FillColor);
        ID2D1SolidColorBrush? borderBrush = GetOrCreateBrush(style.BorderColor);

        float borderTop = Math.Max(0f, style.BorderLengthTop);
        float borderRight = Math.Max(0f, style.BorderLengthRight);
        float borderBottom = Math.Max(0f, style.BorderLengthBottom);
        float borderLeft = Math.Max(0f, style.BorderLengthLeft);

        bool hasVisibleFill = style.FillColor.A > 0 && fillBrush is not null;
        bool hasVisibleBorder = style.BorderColor.A > 0 && borderBrush is not null && (borderTop > 0 || borderRight > 0 || borderBottom > 0 || borderLeft > 0);

        if (!hasVisibleFill && !hasVisibleBorder) return;

        if (style.Roundness > 0.0f)
        {
            Vortice.Mathematics.Rect outerBounds = new Vortice.Mathematics.Rect(pos.X, pos.Y, size.X, size.Y);
            float maxRadius = Math.Min(outerBounds.Width * 0.5f, outerBounds.Height * 0.5f);
            float radius = Math.Max(0f, maxRadius * Math.Clamp(style.Roundness, 0.0f, 1.0f));

            if (float.IsFinite(radius) && radius >= 0)
            {
                if (hasVisibleBorder)
                {
                    System.Drawing.RectangleF outerRectF = new(outerBounds.X, outerBounds.Y, outerBounds.Width, outerBounds.Height);
                    _renderTarget.FillRoundedRectangle(new RoundedRectangle(outerRectF, radius, radius), borderBrush);
                }
                if (hasVisibleFill)
                {
                    float fillX = pos.X + borderLeft;
                    float fillY = pos.Y + borderTop;
                    float fillWidth = Math.Max(0f, size.X - borderLeft - borderRight);
                    float fillHeight = Math.Max(0f, size.Y - borderTop - borderBottom);
                    if (fillWidth > 0 && fillHeight > 0)
                    {
                        float avgBorderX = (borderLeft + borderRight) * 0.5f;
                        float avgBorderY = (borderTop + borderBottom) * 0.5f;
                        float innerRadiusX = Math.Max(0f, radius - avgBorderX);
                        float innerRadiusY = Math.Max(0f, radius - avgBorderY);
                        System.Drawing.RectangleF fillRectF = new(fillX, fillY, fillWidth, fillHeight);
                        _renderTarget.FillRoundedRectangle(new RoundedRectangle(fillRectF, innerRadiusX, innerRadiusY), fillBrush);
                    }
                    else if (!hasVisibleBorder && fillBrush is not null)
                    {
                        System.Drawing.RectangleF outerRectF = new(outerBounds.X, outerBounds.Y, outerBounds.Width, outerBounds.Height);
                        _renderTarget.FillRoundedRectangle(new RoundedRectangle(outerRectF, radius, radius), fillBrush);
                    }
                }
                return;
            }
        }
        if (hasVisibleBorder && borderBrush is not null)
        {
            _renderTarget.FillRectangle(rect, borderBrush);
        }
        if (hasVisibleFill)
        {
            float fillX = pos.X + borderLeft;
            float fillY = pos.Y + borderTop;
            float fillWidth = Math.Max(0f, size.X - borderLeft - borderRight);
            float fillHeight = Math.Max(0f, size.Y - borderTop - borderBottom);
            if (fillWidth > 0 && fillHeight > 0)
            {
                _renderTarget.FillRectangle(new Vortice.Mathematics.Rect(fillX, fillY, fillWidth, fillHeight), fillBrush);
            }
            else if (!hasVisibleBorder && fillBrush is not null)
            {
                _renderTarget.FillRectangle(rect, fillBrush);
            }
        }
    }

    public void DrawText(Vector2 origin, string text, ButtonStyle style, Alignment alignment, Vector2 maxSize, Drawing.Color color)
    {
        if (string.IsNullOrEmpty(text)) return;

        var textBrush = GetOrCreateBrush(color);
        if (textBrush is null) return;

        var layoutKey = new TextLayoutCacheKey(text, style, maxSize, alignment);
        if (!_textLayoutCache.TryGetValue(layoutKey, out var textLayout))
        {
            var textFormat = GetOrCreateTextFormat(style);
            if (textFormat is null) return;

            textLayout = _dwriteFactory.CreateTextLayout(text, textFormat, maxSize.X, maxSize.Y);
            textLayout.TextAlignment = alignment.Horizontal switch
            {
                HAlignment.Left => Vortice.DirectWrite.TextAlignment.Leading,
                HAlignment.Center => Vortice.DirectWrite.TextAlignment.Center,
                HAlignment.Right => Vortice.DirectWrite.TextAlignment.Trailing,
                _ => Vortice.DirectWrite.TextAlignment.Leading
            };
            textLayout.ParagraphAlignment = alignment.Vertical switch
            {
                VAlignment.Top => ParagraphAlignment.Near,
                VAlignment.Center => ParagraphAlignment.Center,
                VAlignment.Bottom => ParagraphAlignment.Far,
                _ => ParagraphAlignment.Near
            };
            _textLayoutCache[layoutKey] = textLayout;
        }

        // A small vertical adjustment to compensate for font metrics making text appear slightly too low when using ParagraphAlignment.Center.
        float yOffsetCorrection = (alignment.Vertical == VAlignment.Center) ? -1.5f : 0f;

        _renderTarget.DrawTextLayout(new Vector2(origin.X, origin.Y + yOffsetCorrection), textLayout, textBrush, Vortice.Direct2D1.DrawTextOptions.None);
    }

    public void PushClipRect(Vortice.Mathematics.Rect rect, AntialiasMode antialiasMode)
    {
        _renderTarget.PushAxisAlignedClip(rect, antialiasMode);
    }

    public void PopClipRect()
    {
        _renderTarget.PopAxisAlignedClip();
    }

    public void Flush()
    {
        // Direct2D is an immediate-mode API in this context, no flush needed.
    }

    public void Cleanup()
    {
        foreach (var pair in _brushCache)
        {
            pair.Value?.Dispose();
        }
        _brushCache.Clear();

        foreach (var pair in _textLayoutCache)
        {
            pair.Value?.Dispose();
        }
        _textLayoutCache.Clear();

        foreach (var pair in _textFormatCache) // Dispose text formats
        {
            pair.Value?.Dispose();
        }
        _textFormatCache.Clear();

        _cubeVertexBuffer?.Dispose();
        _cubeIndexBuffer?.Dispose();
        _cubeConstantBuffer?.Dispose();
        _cubeVertexShader?.Dispose();
        _cubePixelShader?.Dispose();
        _cubeInputLayout?.Dispose();
        _cubeRasterizerState?.Dispose();
        _cubeDepthStencilState?.Dispose();
    }

    private ID2D1SolidColorBrush? GetOrCreateBrush(Drawing.Color color)
    {
        if (_renderTarget is null)
        {
            Console.WriteLine("Error: GetOrCreateBrush called with no active render target.");
            return null;
        }

        if (_brushCache.TryGetValue(color, out var brush) && brush is not null)
        {
            return brush;
        }

        if (brush is null && _brushCache.ContainsKey(color))
        {
            _brushCache.Remove(color);
        }

        try
        {
            Vortice.Mathematics.Color4 color4 = color;
            brush = _renderTarget.CreateSolidColorBrush(color4);
            if (brush is not null)
            {
                _brushCache[color] = brush;
                return brush;
            }

            Console.WriteLine($"Warning: CreateSolidColorBrush returned null for color {color}");
            return null;
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == Vortice.Direct2D1.ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Brush creation failed due to RecreateTarget error (Color: {color}). External cleanup needed.");
            return null;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error creating brush for color {color}: {ex.Message}");
            return null;
        }
    }

    private IDWriteTextFormat? GetOrCreateTextFormat(ButtonStyle style)
    {
        if (_dwriteFactory is null) return null;

        var key = new FontKey(style);
        if (_textFormatCache.TryGetValue(key, out var format)) // Use the member field
        {
            return format;
        }

        try
        {
            var newFormat = _dwriteFactory.CreateTextFormat(style.FontName, null, style.FontWeight, style.FontStyle, style.FontStretch, style.FontSize, "en-us");
            if (newFormat is not null) { _textFormatCache[key] = newFormat; } // Add to the member field
            return newFormat;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error creating text format for font '{style.FontName}': {ex.Message}");
            return null;
        }
    }

    private void CreateCubeResources()
    {
        var vertices = new[]
        {
            new Vector4(-1.0f, 1.0f, -1.0f, 1.0f), new Vector4(1.0f, 0.0f, 0.0f, 1.0f),
            new Vector4(1.0f, 1.0f, -1.0f, 1.0f), new Vector4(0.0f, 1.0f, 0.0f, 1.0f),
            new Vector4(1.0f, 1.0f, 1.0f, 1.0f), new Vector4(0.0f, 0.0f, 1.0f, 1.0f),
            new Vector4(-1.0f, 1.0f, 1.0f, 1.0f), new Vector4(1.0f, 1.0f, 0.0f, 1.0f),
            new Vector4(-1.0f, -1.0f, -1.0f, 1.0f), new Vector4(1.0f, 0.0f, 1.0f, 1.0f),
            new Vector4(1.0f, -1.0f, -1.0f, 1.0f), new Vector4(0.0f, 1.0f, 1.0f, 1.0f),
            new Vector4(1.0f, -1.0f, 1.0f, 1.0f), new Vector4(1.0f, 1.0f, 1.0f, 1.0f),
            new Vector4(-1.0f, -1.0f, 1.0f, 1.0f), new Vector4(0.0f, 0.0f, 0.0f, 1.0f)
        };

        var indices = new ushort[]
        {
            3, 1, 0, 2, 1, 3,
            0, 5, 4, 1, 5, 0,
            3, 4, 7, 0, 4, 3,
            1, 6, 5, 2, 6, 1,
            2, 7, 6, 3, 7, 2,
            6, 4, 5, 7, 4, 6
        };

        _cubeVertexBuffer = _d3dDevice.CreateBuffer(vertices, BindFlags.VertexBuffer);
        _cubeIndexBuffer = _d3dDevice.CreateBuffer(indices, BindFlags.IndexBuffer);

        using var vertexShaderByteCode = ShaderCompiler.Compile(
@"
cbuffer ConstantBuffer : register(b0)
{
    matrix WorldViewProjection;
}

struct VS_Input
{
    float4 Position : POSITION;
    float4 Color : COLOR;
};

struct PS_Input
{
    float4 Position : SV_POSITION;
    float4 Color : COLOR;
};

PS_Input VS(VS_Input input)
{
    PS_Input output;
    output.Position = mul(input.Position, WorldViewProjection);
    output.Color = input.Color;
    return output;
}
", "VS", "vs_5_0");

        using var pixelShaderByteCode = ShaderCompiler.Compile(
@"
struct PS_Input
{
    float4 Position : SV_POSITION;
    float4 Color : COLOR;
};

float4 PS(PS_Input input) : SV_TARGET
{
    return input.Color;
}
", "PS", "ps_5_0");

        byte[] vsBytes = vertexShaderByteCode.AsBytes();
        byte[] psBytes = pixelShaderByteCode.AsBytes();

        _cubeVertexShader = _d3dDevice.CreateVertexShader(vsBytes);
        _cubePixelShader = _d3dDevice.CreatePixelShader(psBytes);

        var inputElements = new[]
        {
            new InputElementDescription("POSITION", 0, Format.R32G32B32A32_Float, 0, 0),
            new InputElementDescription("COLOR", 0, Format.R32G32B32A32_Float, 16, 0)
        };

        _cubeInputLayout = _d3dDevice.CreateInputLayout(inputElements, vsBytes);
        _cubeConstantBuffer = _d3dDevice.CreateBuffer(new BufferDescription(64, BindFlags.ConstantBuffer));

        var rasterizerDesc = new RasterizerDescription(CullMode.Back, Vortice.Direct3D11.FillMode.Solid);
        _cubeRasterizerState = _d3dDevice.CreateRasterizerState(rasterizerDesc);

        var depthStencilDesc = new DepthStencilDescription
        {
            DepthEnable = true,
            DepthWriteMask = DepthWriteMask.All,
            DepthFunc = ComparisonFunction.Less,
            StencilEnable = false
        };
        _cubeDepthStencilState = _d3dDevice.CreateDepthStencilState(depthStencilDesc);
    }


    public void DrawCube()
    {
        if (_cubeConstantBuffer is null || _cubeInputLayout is null || _cubeVertexShader is null || _cubePixelShader is null || _cubeVertexBuffer is null || _cubeIndexBuffer is null || _cubeRasterizerState is null || _cubeDepthStencilState is null)
        {
            return;
        }

        var view = Matrix4x4.CreateLookAt(new Vector3(0, 0, -5), Vector3.Zero, Vector3.UnitY);
        var proj = Matrix4x4.CreatePerspectiveFieldOfView((float)Math.PI / 4.0f, RenderTargetSize.X / RenderTargetSize.Y, 0.1f, 100.0f);
        var world = Matrix4x4.CreateFromYawPitchRoll(
            (float)DateTime.Now.TimeOfDay.TotalSeconds,
            (float)DateTime.Now.TimeOfDay.TotalSeconds / 2f,
            (float)DateTime.Now.TimeOfDay.TotalSeconds / 3f);

        var worldViewProj = Matrix4x4.Transpose(world * view * proj);
        _d3dContext.UpdateSubresource(worldViewProj, _cubeConstantBuffer);

        _d3dContext.RSSetViewport(new Viewport(RenderTargetSize.X, RenderTargetSize.Y));
        _d3dContext.RSSetState(_cubeRasterizerState);
        _d3dContext.OMSetDepthStencilState(_cubeDepthStencilState);

        _d3dContext.IASetPrimitiveTopology(PrimitiveTopology.TriangleList);
        _d3dContext.IASetInputLayout(_cubeInputLayout);
        _d3dContext.VSSetShader(_cubeVertexShader);
        _d3dContext.VSSetConstantBuffer(0, _cubeConstantBuffer);
        _d3dContext.PSSetShader(_cubePixelShader);
        _d3dContext.IASetVertexBuffer(0, _cubeVertexBuffer, 32);
        _d3dContext.IASetIndexBuffer(_cubeIndexBuffer, Format.R16_UInt, 0);

        using (var backBuffer = _swapChain.GetBuffer<ID3D11Texture2D>(0))
        {
            using var renderTargetView = _d3dDevice.CreateRenderTargetView(backBuffer);
            _d3dContext.ClearRenderTargetView(renderTargetView, Colors.CornflowerBlue);
            _d3dContext.ClearDepthStencilView(_depthStencilView, DepthStencilClearFlags.Depth, 1.0f, 0);
            _d3dContext.OMSetRenderTargets([renderTargetView], _depthStencilView);
            _d3dContext.DrawIndexed(36, 0, 0);
        }

        // Unbind render targets before flushing, to release control for Direct2D
        _d3dContext.OMSetRenderTargets(new ID3D11RenderTargetView(0));

        // Flush the 3D commands to ensure they are executed before D2D begins drawing.
        _d3dContext.Flush();
    }
}
</file>

<file path="Backends\Direct2D\DirectWriteTextLayout.cs">
// DirectUI/Backends/DirectWriteTextLayout.cs
using System;
using System.Numerics;
using DirectUI.Core;
using Vortice.DirectWrite;
using SharpGen.Runtime;

namespace DirectUI.Backends;

/// <summary>
/// A DirectWrite-specific implementation of the ITextLayout interface.
/// This class wraps an IDWriteTextLayout object. It is internal to the backend.
/// </summary>
internal class DirectWriteTextLayout : ITextLayout
{
    public IDWriteTextLayout DWriteLayout { get; }

    public Vector2 Size { get; }
    public string Text { get; }

    public DirectWriteTextLayout(IDWriteTextLayout dwriteLayout, string text) // Added 'string text' parameter
    {
        DWriteLayout = dwriteLayout;
        Size = new Vector2(dwriteLayout.Metrics.WidthIncludingTrailingWhitespace, dwriteLayout.Metrics.Height);
        Text = text; // Assign the provided text
    }

    public TextHitTestMetrics HitTestTextPosition(int textPosition, bool isTrailingHit)
    {
        DWriteLayout.HitTestTextPosition((uint)textPosition, isTrailingHit, out float x, out float y, out var metrics);
        return new TextHitTestMetrics(new Vector2(x, y), new Vector2(metrics.Width, metrics.Height));
    }

    public TextHitTestResult HitTestPoint(Vector2 point)
    {
        DWriteLayout.HitTestPoint(point.X, point.Y, out RawBool isTrailingHit, out RawBool isInside, out var hitTestMetrics);

        var metrics = new TextHitTestMetrics(
            new Vector2(hitTestMetrics.Left, hitTestMetrics.Top),
            new Vector2(hitTestMetrics.Width, hitTestMetrics.Height)
        );

        return new TextHitTestResult(
            (int)hitTestMetrics.TextPosition,
            isTrailingHit,
            isInside,
            metrics
        );
    }

    public void Dispose()
    {
        DWriteLayout.Dispose();
        GC.SuppressFinalize(this);
    }

    ~DirectWriteTextLayout()
    {
        Dispose();
    }
}
</file>

<file path="Backends\Direct2D\DirectWriteTextService.cs">
// DirectUI/Backends/DirectWriteTextService.cs
using System;
using System.Collections.Generic;
using System.Numerics;
using DirectUI.Core;
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace DirectUI.Backends;

/// <summary>
/// An implementation of ITextService that uses DirectWrite.
/// It manages caches for text formats, layouts, and measured sizes.
/// </summary>
public class DirectWriteTextService : ITextService
{
    private readonly IDWriteFactory _dwriteFactory;
    private readonly Dictionary<FontKey, IDWriteTextFormat> _textFormatCache = new();
    private readonly Dictionary<TextLayoutCacheKey, ITextLayout> _textLayoutCache = new();
    private readonly Dictionary<(string, FontKey), Vector2> _textSizeCache = new();

    // Internal cache key structs
    internal readonly struct FontKey(ButtonStyle style) : IEquatable<FontKey>
    {
        private readonly string FontName = style.FontName;
        private readonly float FontSize = style.FontSize;
        private readonly FontWeight FontWeight = style.FontWeight;
        private readonly FontStyle FontStyle = style.FontStyle;
        private readonly FontStretch FontStretch = style.FontStretch;
        public bool Equals(FontKey other) => FontName == other.FontName && FontSize.Equals(other.FontSize) && FontWeight == other.FontWeight && FontStyle == other.FontStyle && FontStretch == other.FontStretch;
        public override bool Equals(object? obj) => obj is FontKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(FontName, FontSize, FontWeight, FontStyle, FontStretch);
    }

    internal readonly struct TextLayoutCacheKey(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment) : IEquatable<TextLayoutCacheKey>
    {
        private readonly string Text = text;
        private readonly FontKey FontKey = new(style);
        private readonly Vector2 MaxSize = maxSize;
        private readonly HAlignment HAlign = alignment.Horizontal;
        private readonly VAlignment VAlign = alignment.Vertical;
        public bool Equals(TextLayoutCacheKey other) => Text == other.Text && MaxSize.Equals(other.MaxSize) && HAlign == other.HAlign && VAlign == other.VAlign && FontKey.Equals(other.FontKey);
        public override bool Equals(object? obj) => obj is TextLayoutCacheKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(Text, FontKey, MaxSize, HAlign, VAlign);
    }

    public DirectWriteTextService(IDWriteFactory dwriteFactory)
    {
        _dwriteFactory = dwriteFactory ?? throw new ArgumentNullException(nameof(dwriteFactory));
    }

    public Vector2 MeasureText(string text, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(text) || style is null) return Vector2.Zero;

        var fontKey = new FontKey(style);
        var cacheKey = (text, fontKey);
        if (_textSizeCache.TryGetValue(cacheKey, out var cachedSize)) return cachedSize;

        IDWriteTextFormat? textFormat = GetOrCreateTextFormat(style);
        if (textFormat is null)
        {
            Console.WriteLine("Warning: Failed to create/get TextFormat for measurement.");
            return Vector2.Zero;
        }

        using var textLayout = _dwriteFactory.CreateTextLayout(text, textFormat, float.MaxValue, float.MaxValue);
        TextMetrics textMetrics = textLayout.Metrics;
        var measuredSize = new Vector2(textMetrics.WidthIncludingTrailingWhitespace, textMetrics.Height);
        _textSizeCache[cacheKey] = measuredSize;
        return measuredSize;
    }

    public ITextLayout GetTextLayout(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment)
    {
        var layoutKey = new TextLayoutCacheKey(text, style, maxSize, alignment);
        if (_textLayoutCache.TryGetValue(layoutKey, out var cachedLayout))
        {
            return cachedLayout;
        }

        var textFormat = GetOrCreateTextFormat(style);
        if (textFormat is null) return null!; // Should ideally return a null object or throw.

        var dwriteLayout = _dwriteFactory.CreateTextLayout(text, textFormat, maxSize.X, maxSize.Y);
        dwriteLayout.TextAlignment = alignment.Horizontal switch
        {
            HAlignment.Left => TextAlignment.Leading,
            HAlignment.Center => TextAlignment.Center,
            HAlignment.Right => TextAlignment.Trailing,
            _ => TextAlignment.Leading
        };
        dwriteLayout.ParagraphAlignment = alignment.Vertical switch
        {
            VAlignment.Top => ParagraphAlignment.Near,
            VAlignment.Center => ParagraphAlignment.Center,
            VAlignment.Bottom => ParagraphAlignment.Far,
            _ => ParagraphAlignment.Near
        };

        var newLayout = new DirectWriteTextLayout(dwriteLayout, text); // Passed 'text' as the second argument
        _textLayoutCache[layoutKey] = newLayout;
        return newLayout;
    }

    private IDWriteTextFormat? GetOrCreateTextFormat(ButtonStyle style)
    {
        var key = new FontKey(style);
        if (_textFormatCache.TryGetValue(key, out var format))
        {
            return format;
        }

        try
        {
            var newFormat = _dwriteFactory.CreateTextFormat(style.FontName, null, style.FontWeight, style.FontStyle, style.FontStretch, style.FontSize, "en-us");
            if (newFormat is not null)
            {
                _textFormatCache[key] = newFormat;
            }
            return newFormat;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error creating text format for font '{style.FontName}': {ex.Message}");
            return null;
        }
    }

    public void Cleanup()
    {
        Console.WriteLine("DirectWriteTextService Cleanup: Disposing cached resources...");
        foreach (var pair in _textFormatCache) { pair.Value?.Dispose(); }
        _textFormatCache.Clear();
        foreach (var pair in _textLayoutCache) { pair.Value?.Dispose(); }
        _textLayoutCache.Clear();
        _textSizeCache.Clear();
        Console.WriteLine("DirectWriteTextService Cleanup finished.");
    }
}
</file>

<file path="Backends\Direct2D\DuiGraphicsDevice.cs">
// GraphicsDevice.cs
using System;
using Vortice.Direct2D1;
using Vortice.Direct3D;
using Vortice.Direct3D11;
using Vortice.DirectWrite;
using Vortice.DXGI;
using SharpGen.Runtime;
using Vortice.Mathematics;
using Vortice.DCommon;
using D2D = Vortice.Direct2D1;
using DW = Vortice.DirectWrite;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI;

public class DuiGraphicsDevice : IDisposable
{
    public ID2D1Factory1? D2DFactory => SharedGraphicsResources.D2DFactory;
    public IDWriteFactory? DWriteFactory => SharedGraphicsResources.DWriteFactory;
    public ID2D1RenderTarget? RenderTarget { get; private set; }
    public ID3D11Device? D3DDevice { get; private set; }
    public ID3D11DeviceContext? D3DContext { get; private set; }
    public IDXGISwapChain? SwapChain { get; private set; }
    public ID3D11DepthStencilView? DepthStencilView { get; private set; } // Added
    public bool IsInitialized { get; private set; } = false;

    private ID3D11Texture2D? _depthStencilBuffer; // Added
    private bool _isDisposed = false;

    public bool Initialize(IntPtr hwnd, SizeI size)
    {
        if (IsInitialized) return true;
        if (hwnd == IntPtr.Zero) return false;

        Console.WriteLine($"Attempting Graphics Initialization for HWND {hwnd} with size {size}...");
        try
        {
            // Clean up any previous (potentially invalid) instance resources
            CleanupRenderTarget();

            if (D2DFactory is null || DWriteFactory is null)
            {
                throw new InvalidOperationException("Shared graphics factories are not initialized. Application.Run() must be called first.");
            }

            if (size.Width <= 0 || size.Height <= 0)
            {
                Console.WriteLine($"Invalid client rect size ({size}). Aborting graphics initialization.");
                return false;
            }

            var swapChainDesc = new SwapChainDescription()
            {
                BufferCount = 1,
                BufferDescription = new ModeDescription((uint)size.Width, (uint)size.Height, Format.B8G8R8A8_UNorm),
                BufferUsage = Usage.RenderTargetOutput,
                OutputWindow = hwnd,
                SampleDescription = new SampleDescription(1, 0),
                Windowed = true
            };

            D3D11.D3D11CreateDeviceAndSwapChain(
                null,
                DriverType.Hardware,
                DeviceCreationFlags.BgraSupport,
                null,
                swapChainDesc,
                out var swapChain,
                out var d3dDevice,
                out _,
                out var d3dContext).CheckError();

            SwapChain = swapChain;
            D3DDevice = d3dDevice;
            D3DContext = d3dContext;

            using (var backBuffer = SwapChain.GetBuffer<ID3D11Texture2D>(0))
            using (var surface = backBuffer.QueryInterface<IDXGISurface>())
            {
                var renderTargetProperties = new RenderTargetProperties(new PixelFormat(Format.B8G8R8A8_UNorm, Vortice.DCommon.AlphaMode.Premultiplied));
                RenderTarget = D2DFactory.CreateDxgiSurfaceRenderTarget(surface, renderTargetProperties);
            }

            CreateDepthStencilView(size); // Create depth buffer

            if (RenderTarget is null) throw new InvalidOperationException("Render target creation returned null unexpectedly.");

            RenderTarget.TextAntialiasMode = D2D.TextAntialiasMode.Cleartype;

            Console.WriteLine($"Vortice Graphics initialized successfully for HWND {hwnd}.");
            IsInitialized = true;
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Graphics Initialization failed: {ex.Message}");
            Cleanup(); // Ensures we are in a clean state after failure
            return false;
        }
    }

    private void CreateDepthStencilView(SizeI size)
    {
        if (D3DDevice is null) return;

        // Clean up old resources first
        _depthStencilBuffer?.Dispose();
        DepthStencilView?.Dispose();

        var depthStencilDesc = new Texture2DDescription
        {
            Width = size.Width,
            Height = size.Height,
            MipLevels = 1,
            ArraySize = 1,
            Format = Format.D24_UNorm_S8_UInt,
            SampleDescription = new SampleDescription(1, 0),
            Usage = ResourceUsage.Default,
            BindFlags = BindFlags.DepthStencil,
        };
        _depthStencilBuffer = D3DDevice.CreateTexture2D(depthStencilDesc);
        DepthStencilView = D3DDevice.CreateDepthStencilView(_depthStencilBuffer);
    }


    public void Resize(SizeI newSize)
    {
        if (!IsInitialized || RenderTarget is null || SwapChain is null) return;

        try
        {
            Console.WriteLine($"Resizing render target to {newSize}...");
            RenderTarget.Dispose();

            // Also dispose depth resources before resizing
            DepthStencilView?.Dispose();
            _depthStencilBuffer?.Dispose();

            SwapChain.ResizeBuffers(1, (uint)newSize.Width, (uint)newSize.Height, Format.B8G8R8A8_UNorm, 0);
            using (var backBuffer = SwapChain.GetBuffer<ID3D11Texture2D>(0))
            using (var surface = backBuffer.QueryInterface<IDXGISurface>())
            {
                var renderTargetProperties = new RenderTargetProperties(new PixelFormat(Format.B8G8R8A8_UNorm, Vortice.DCommon.AlphaMode.Premultiplied));
                RenderTarget = D2DFactory.CreateDxgiSurfaceRenderTarget(surface, renderTargetProperties);
            }

            // Recreate depth resources with the new size
            CreateDepthStencilView(newSize);

            Console.WriteLine("Successfully resized render target.");
        }
        catch (SharpGenException ex)
        {
            Console.WriteLine($"Failed to resize Render Target (SharpGenException): {ex.Message} HRESULT: {ex.ResultCode}");
            if (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
            {
                Console.WriteLine("Render target needs recreation (Detected in Resize Exception).");
                MarkAsLost();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to resize Render Target (General Exception): {ex}");
            MarkAsLost();
        }
    }

    public void BeginDraw()
    {
        if (!IsInitialized || RenderTarget is null)
        {
            return;
        }
        RenderTarget.BeginDraw();
    }

    public void EndDraw()
    {
        if (!IsInitialized || RenderTarget is null) return;

        try
        {
            Result endDrawResult = RenderTarget.EndDraw();
            if (endDrawResult.Failure)
            {
                Console.WriteLine($"EndDraw failed: {endDrawResult.Description}");
                if (endDrawResult.Code == D2D.ResultCode.RecreateTarget.Code)
                {
                    Console.WriteLine("Render target needs recreation (Detected in EndDraw).");
                    MarkAsLost();
                }
            }
            SwapChain?.Present(1, 0);
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Render target needs recreation (Caught SharpGenException in EndDraw): {ex.Message}");
            MarkAsLost();
        }
    }

    private void MarkAsLost()
    {
        if (!IsInitialized) return;
        Console.WriteLine("Marking graphics device as lost. Resources will be recreated on next opportunity.");
        Cleanup();
    }

    private void CleanupRenderTarget()
    {
        RenderTarget?.Dispose();
        RenderTarget = null;
    }

    public void Cleanup()
    {
        bool resourcesExisted = RenderTarget is not null;
        if (resourcesExisted) Console.WriteLine("Cleaning up GraphicsDevice instance resources...");

        CleanupRenderTarget();
        DepthStencilView?.Dispose();
        DepthStencilView = null;
        _depthStencilBuffer?.Dispose();
        _depthStencilBuffer = null;
        D3DContext?.Dispose();
        D3DContext = null;
        D3DDevice?.Dispose();
        D3DDevice = null;
        SwapChain?.Dispose();
        SwapChain = null;
        IsInitialized = false;

        if (resourcesExisted) Console.WriteLine("Finished cleaning GraphicsDevice instance resources.");
    }

    public void Dispose()
    {
        if (_isDisposed) return;
        Cleanup();
        _isDisposed = true;
        GC.SuppressFinalize(this);
    }

    ~DuiGraphicsDevice()
    {
        Dispose();
    }
}
</file>

<file path="Backends\Direct2D\ShaderCompiler.cs">
using SharpGen.Runtime;
using Vortice.D3DCompiler;
using Vortice.Direct3D;

namespace DirectUI.Backends;

public static class ShaderCompiler
{
    public static Blob Compile(string source, string entryPoint, string profile)
    {
        // Calling the overload with positional arguments to avoid naming errors.
        // This is the 10-argument overload.
        // The error suggests the entryPoint and sourceFileName parameters are swapped in the user's library version.
        Result compileResult = Compiler.Compile(
            source,          // 1: string sourceCode
            null,            // 2: ShaderMacro[] defines
            null,            // 3: Include include
            entryPoint,      // 4: string entryPoint (was "ShaderSource")
            "ShaderSource",  // 5: string sourceFileName (was entryPoint)
            profile,         // 6: string profile
            ShaderFlags.None,// 7: ShaderFlags shaderFlags
            EffectFlags.None,// 8: EffectFlags effectFlags
            out Blob? code,  // 9: out Blob result
            out Blob? error  // 10: out Blob errorBlob
        );

        // Check if the compilation failed.
        if (compileResult.Failure)
        {
            string errorMessage = "Shader compilation failed";
            if (error != null)
            {
                // The error blob contains detailed diagnostics from the compiler.
                errorMessage = error.AsString();
                error.Dispose();
            }
            code?.Dispose(); // Clean up the code blob if it was created.

            // Log the detailed error to the console before throwing.
            Console.WriteLine($"--- SHADER COMPILATION FAILED ---");
            Console.WriteLine($"Entry Point: {entryPoint}");
            Console.WriteLine($"Profile: {profile}");
            Console.WriteLine($"Error: {errorMessage}");
            Console.WriteLine("--- Shader Source ---");
            Console.WriteLine(source);
            Console.WriteLine("---------------------");

            // Throw an exception with the detailed message from the compiler.
            throw new SharpGenException(compileResult, errorMessage);
        }

        // On success, the error blob is usually null, but dispose it just in case.
        error?.Dispose();

        if (code is null)
        {
            // This should not happen if compilation succeeded, but it's a good safeguard.
            throw new InvalidOperationException("Shader compilation succeeded but the resulting blob is null.");
        }

        return code;
    }
}
</file>

<file path="Backends\Direct2D\Win32AppServicesInitializer.cs">
using Vortice.Mathematics;

namespace DirectUI;

public static class Win32AppServicesInitializer
{
    public static AppServices Initialize(IntPtr hwnd, SizeI clientSize, Action<UIContext> uiDrawCallback, Color4 backgroundColor)
    {
        var appEngine = new AppEngine(uiDrawCallback, backgroundColor);
        var graphicsDevice = new DuiGraphicsDevice();

        if (!graphicsDevice.Initialize(hwnd, clientSize))
        {
            throw new InvalidOperationException("Failed to initialize DuiGraphicsDevice.");
        }

        if (graphicsDevice.RenderTarget is null || graphicsDevice.DWriteFactory is null || graphicsDevice.D3DDevice is null || graphicsDevice.D3DContext is null || graphicsDevice.SwapChain is null || graphicsDevice.DepthStencilView is null)
        {
            throw new InvalidOperationException("CRITICAL: GraphicsDevice did not provide valid RenderTarget, DWriteFactory, D3DDevice, D3DContext, SwapChain, or DepthStencilView for Direct2D backend initialization.");
        }

        var renderer = new Backends.Direct2DRenderer(graphicsDevice.RenderTarget, graphicsDevice.DWriteFactory, graphicsDevice.D3DDevice, graphicsDevice.D3DContext, graphicsDevice.SwapChain, graphicsDevice.DepthStencilView);
        var textService = new Backends.DirectWriteTextService(graphicsDevice.DWriteFactory);

        appEngine.Initialize(textService, renderer);

        Console.WriteLine($"Win32AppServices Initializer: Services created for HWND {hwnd}.");
        return new AppServices(appEngine, graphicsDevice, renderer, textService);
    }
}
</file>

<file path="Backends\Direct2D\Win32Window.cs">
// Win32Window.cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;
using DirectUI.Core; // Added for IWindowHost

namespace DirectUI;

public abstract class Win32Window : IDisposable
{
    private readonly string _windowClassName;
    private readonly string _windowTitle;
    private readonly int _initialWidth;
    private readonly int _initialHeight;
    private IntPtr _hwnd = IntPtr.Zero;
    private IntPtr _hInstance = IntPtr.Zero;
    private NativeMethods.WndProc _wndProcDelegate;
    private bool _isDisposed = false;
    private static readonly HashSet<string> RegisteredClassNames = new HashSet<string>();
    private GCHandle _gcHandle;

    private readonly Dictionary<uint, Func<IntPtr, IntPtr, IntPtr, IntPtr>> _messageHandlers;

    public IntPtr Handle => _hwnd;
    public string Title => _windowTitle;
    public int Width { get; protected set; }
    public int Height { get; protected set; }
    protected IntPtr OwnerHandle { get; private set; } = IntPtr.Zero;

    protected Win32Window(string title, int width, int height, string className = null)
    {
        _windowTitle = title ?? "Win32 Window";
        _initialWidth = width > 0 ? width : 800;
        _initialHeight = height > 0 ? height : 600;
        Width = _initialWidth;
        Height = _initialHeight;
        _windowClassName = className ?? ("Win32Window_" + Guid.NewGuid().ToString("N"));
        _wndProcDelegate = WindowProcedure;

        _messageHandlers = new Dictionary<uint, Func<IntPtr, IntPtr, IntPtr, IntPtr>>();
        InitializeMessageHandlers();
    }

    private void InitializeMessageHandlers()
    {
        _messageHandlers.Add(NativeMethods.WM_PAINT, Handle_WmPaint);
        _messageHandlers.Add(NativeMethods.WM_SIZE, Handle_WmSize);
        _messageHandlers.Add(NativeMethods.WM_MOUSEMOVE, Handle_WmMouseMove);
        _messageHandlers.Add(NativeMethods.WM_LBUTTONDOWN, (h, w, l) => Handle_WmMouseButton(MouseButton.Left, h, w, l, true));
        _messageHandlers.Add(NativeMethods.WM_LBUTTONUP, (h, w, l) => Handle_WmMouseButton(MouseButton.Left, h, w, l, false));
        _messageHandlers.Add(NativeMethods.WM_RBUTTONDOWN, (h, w, l) => Handle_WmMouseButton(MouseButton.Right, h, w, l, true));
        _messageHandlers.Add(NativeMethods.WM_MBUTTONDOWN, (h, w, l) => Handle_WmMouseButton(MouseButton.Middle, h, w, l, true));
        _messageHandlers.Add(NativeMethods.WM_MBUTTONUP, (h, w, l) => Handle_WmMouseButton(MouseButton.Middle, h, w, l, false));
        _messageHandlers.Add(NativeMethods.WM_XBUTTONDOWN, (h, w, l) => Handle_WmXMouseButton(h, w, l, true));
        _messageHandlers.Add(NativeMethods.WM_XBUTTONUP, (h, w, l) => Handle_WmXMouseButton(h, w, l, false));
        _messageHandlers.Add(NativeMethods.WM_MOUSEWHEEL, Handle_WmMouseWheel);
        _messageHandlers.Add(NativeMethods.WM_KEYDOWN, (h, w, l) => Handle_WmKey(true, h, w, l));
        _messageHandlers.Add(NativeMethods.WM_KEYUP, (h, w, l) => Handle_WmKey(false, h, w, l));
        _messageHandlers.Add(NativeMethods.WM_SYSKEYUP, (h, w, l) => Handle_WmKey(false, h, w, l));
        _messageHandlers.Add(NativeMethods.WM_CHAR, Handle_WmChar);
        _messageHandlers.Add(NativeMethods.WM_CLOSE, Handle_WmClose);
        _messageHandlers.Add(NativeMethods.WM_DESTROY, Handle_WmDestroy);
        _messageHandlers.Add(NativeMethods.WM_NCDESTROY, Handle_WmNcDestroy);
    }

    public bool Create(IntPtr owner = default, uint? style = null, int? x = null, int? y = null)
    {
        OwnerHandle = owner;

        if (_hwnd != IntPtr.Zero)
        {
            return true;
        }

        if (!TryCreateWindow(owner, style, x, y))
        {
            Console.WriteLine("Window creation failed.");
            Dispose();
            return false;
        }

        if (!Initialize())
        {
            Console.WriteLine("Derived init failed.");
            Dispose();
            return false;
        }

        NativeMethods.ShowWindow(_hwnd, NativeMethods.SW_SHOWNORMAL);
        NativeMethods.UpdateWindow(_hwnd);

        return true;
    }

    private bool TryCreateWindow(IntPtr owner, uint? style, int? x, int? y)
    {
        _hInstance = NativeMethods.GetModuleHandle(null);

        if (_hInstance == IntPtr.Zero)
        {
            _hInstance = Process.GetCurrentProcess().Handle;
        }

        Application.RegisterWindow(this);

        lock (RegisteredClassNames)
        {
            if (!RegisteredClassNames.Contains(_windowClassName))
            {
                NativeMethods.WNDCLASSEX wndClass = new()
                {
                    cbSize = Marshal.SizeOf(typeof(NativeMethods.WNDCLASSEX)),
                    style = NativeMethods.CS_HREDRAW | NativeMethods.CS_VREDRAW,
                    lpfnWndProc = _wndProcDelegate,
                    hInstance = _hInstance,
                    lpszClassName = _windowClassName,
                    hIcon = NativeMethods.LoadIcon(IntPtr.Zero, (IntPtr)32512),
                    hCursor = NativeMethods.LoadCursor(IntPtr.Zero, 32512),
                };

                if (NativeMethods.RegisterClassEx(ref wndClass) == 0)
                {
                    Console.WriteLine($"RegisterClassEx failed: {Marshal.GetLastWin32Error()}");
                    return false;
                }

                RegisteredClassNames.Add(_windowClassName);
                Console.WriteLine($"Class '{_windowClassName}' registered.");
            }
        }

        _gcHandle = GCHandle.Alloc(this, GCHandleType.Normal); // Explicitly specify Normal type

        uint windowStyle = style ?? (NativeMethods.WS_OVERLAPPEDWINDOW | NativeMethods.WS_VISIBLE);

        int finalX = x ?? NativeMethods.CW_USEDEFAULT;
        int finalY = y ?? NativeMethods.CW_USEDEFAULT;

        _hwnd = NativeMethods.CreateWindowEx(
            0,
            _windowClassName,
            _windowTitle,
            windowStyle,
            finalX,
            finalY,
            _initialWidth,
            _initialHeight,
            owner,
            IntPtr.Zero,
            _hInstance,
            GCHandle.ToIntPtr(_gcHandle));

        if (_hwnd == IntPtr.Zero)
        {
            Console.WriteLine($"CreateWindowEx failed: {Marshal.GetLastWin32Error()}");

            if (_gcHandle.IsAllocated)
            {
                _gcHandle.Free();
            }

            return false;
        }

        Console.WriteLine($"Window created: {_hwnd}"); return true;
    }

    private static IntPtr WindowProcedure(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        Win32Window? window = null;

        if (msg == NativeMethods.WM_NCCREATE)
        {
            var cs = Marshal.PtrToStructure<NativeMethods.CREATESTRUCT>(lParam);
            var handle = GCHandle.FromIntPtr(cs.lpCreateParams);
            window = handle.Target as Win32Window;

            NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, GCHandle.ToIntPtr(handle));
            Console.WriteLine($"WM_NCCREATE: Associated instance with HWND {hWnd}");
        }
        else
        {
            IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA);

            if (ptr != IntPtr.Zero)
            {
                var handle = GCHandle.FromIntPtr(ptr);
                window = handle.Target as Win32Window;
            }
        }

        if (window is null)
        {
            return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
        }

        try
        {
            return window.HandleMessage(hWnd, msg, wParam, lParam);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling msg {msg}: {ex}");
        }

        return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
    }

    protected virtual IntPtr HandleMessage(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        if (_messageHandlers.TryGetValue(msg, out var handler))
        {
            return handler(hWnd, wParam, lParam);
        }
        return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
    }

    private IntPtr Handle_WmPaint(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        OnPaint();
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmSize(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        Width = NativeMethods.LoWord(lParam);
        Height = NativeMethods.HiWord(lParam);
        OnSize(Width, Height);
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmMouseMove(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        OnMouseMove(NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmMouseButton(MouseButton button, IntPtr hWnd, IntPtr wParam, IntPtr lParam, bool isDown)
    {
        if (isDown) NativeMethods.SetCapture(hWnd);
        else NativeMethods.ReleaseCapture();

        if (isDown) OnMouseDown(button, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
        else OnMouseUp(button, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmXMouseButton(IntPtr hWnd, IntPtr wParam, IntPtr lParam, bool isDown)
    {
        short xButton = NativeMethods.HiWord(wParam);
        MouseButton button = (xButton == 1) ? MouseButton.XButton1 : MouseButton.XButton2;

        if (isDown) NativeMethods.SetCapture(hWnd);
        else NativeMethods.ReleaseCapture();

        if (isDown) OnMouseDown(button, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
        else OnMouseUp(button, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmMouseWheel(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        short wheelDelta = NativeMethods.HiWord(wParam);
        OnMouseWheel((float)wheelDelta / 120.0f); // Normalize delta
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmKey(bool isDown, IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        Keys key = (Keys)wParam;
        if (isDown) OnKeyDown(key);
        else OnKeyUp(key);
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmChar(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        OnChar((char)wParam);
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmClose(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        if (OnClose())
        {
            NativeMethods.DestroyWindow(hWnd);
        }
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmDestroy(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        Console.WriteLine($"WM_DESTROY for {_hwnd}.");
        Application.UnregisterWindow(this);
        OnDestroy();

        if (OwnerHandle == IntPtr.Zero)
        {
            Application.Exit();
        }
        return IntPtr.Zero;
    }

    private IntPtr Handle_WmNcDestroy(IntPtr hWnd, IntPtr wParam, IntPtr lParam)
    {
        Console.WriteLine($"WM_NCDESTROY: Releasing GCHandle for {hWnd}.");

        IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA);

        if (ptr != IntPtr.Zero)
        {
            var handle = GCHandle.FromIntPtr(ptr);

            if (handle.IsAllocated)
            {
                handle.Free();
            }

            NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, IntPtr.Zero);
        }

        if (_gcHandle.IsAllocated)
        {
            _gcHandle.Free();
            _gcHandle = default;
        }

        _hwnd = IntPtr.Zero;
        return IntPtr.Zero;
    }


    public void Close()
    {
        if (_hwnd == IntPtr.Zero)
        {
            return;
        }

        NativeMethods.DestroyWindow(_hwnd);
    }

    public void Invalidate()
    {
        if (_hwnd == IntPtr.Zero)
        {
            return;
        }

        NativeMethods.InvalidateRect(_hwnd, IntPtr.Zero, false);
    }

    public virtual void FrameUpdate()
    {

    }

    internal bool GetWindowRect(out NativeMethods.RECT rect)
    {
        if (Handle == IntPtr.Zero)
        {
            rect = default;
            return false;
        }

        return NativeMethods.GetWindowRect(Handle, out rect);
    }

    protected virtual bool Initialize()
    {
        return true;
    }

    protected abstract void OnPaint();

    protected virtual void OnSize(int width, int height)
    {

    }

    protected virtual void OnMouseDown(MouseButton button, int x, int y)
    {

    }

    protected virtual void OnMouseUp(MouseButton button, int x, int y)
    {

    }

    protected virtual void OnMouseMove(int x, int y)
    {

    }

    protected virtual void OnKeyDown(Keys key)
    {

    }

    protected virtual void OnKeyUp(Keys key)
    {

    }

    protected virtual void OnMouseWheel(float delta)
    {

    }

    protected virtual void OnChar(char c)
    {

    }

    protected virtual bool OnClose()
    {
        return true;
    }

    protected virtual void OnDestroy()
    {

    }

    protected virtual void Cleanup()
    {

    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (_isDisposed)
        {
            return;
        }

        if (disposing)
        {
            Console.WriteLine("Disposing Win32Window (managed)...");
            Cleanup();
        }

        Console.WriteLine("Disposing Win32Window (unmanaged)...");

        if (_hwnd != IntPtr.Zero)
        {
            Console.WriteLine($"Destroying window {_hwnd} during Dispose...");
            NativeMethods.DestroyWindow(_hwnd);
            _hwnd = IntPtr.Zero;
        }
        else
        {
            // If _hwnd is already zero, it means DestroyWindow was likely called via WM_DESTROY/WM_NCDESTROY.
            // In that case, the GCHandle should have already been freed by Handle_WmNcDestroy.
            // Only free it here if it's still allocated and _hwnd is zero, indicating a Dispose() call
            // that didn't go through the full Win32 message loop shutdown for some reason.
            if (_gcHandle.IsAllocated)
            {
                Console.WriteLine("Freeing dangling GCHandle during Dispose (unexpected, but cleaning up).");
                _gcHandle.Free();
                _gcHandle = default;
            }
        }

        _isDisposed = true;

        Console.WriteLine("Win32Window disposed.");
    }

    ~Win32Window()
    {
        Console.WriteLine("Win32Window Finalizer!");
        Dispose(false);
    }
}
</file>

<file path="Backends\Direct2D\Win32WindowHost.cs">
using DirectUI.Core;
using DirectUI.Input;
using Vortice.Mathematics;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI;

public class Win32WindowHost : Win32Window, IWindowHost, IModalWindowService
{
    private AppServices? appServices;

    private ModalWindow? activeModalWindow;
    private int modalResultCode;
    private Action<int>? onModalClosedCallback;
    private bool _isModalClosing;

    public bool IsModalWindowOpen
    {
        get
        {
            return activeModalWindow is not null
                && activeModalWindow.Handle != IntPtr.Zero;
        }
    }

    public Win32WindowHost(string title = "DirectUI Win32 Host", int width = 800, int height = 600)
        : base(title, width, height)
    {
    }

    public InputManager Input => appServices?.AppEngine.Input ?? new();
    public SizeI ClientSize => GetClientRectSize();

    public bool ShowFpsCounter
    {
        get
        {
            return appServices?.AppEngine.ShowFpsCounter ?? false;
        }

        set
        {
            if (appServices is null)
            {
                return;
            }

            appServices.AppEngine.ShowFpsCounter = value;
        }
    }

    public IModalWindowService ModalWindowService => this;

    public bool Initialize(Action<UIContext> uiDrawCallback, Color4 backgroundColor)
    {
        Console.WriteLine("Win32WindowHost initializing...");

        // Create the window before initializing services, as the window handle is required.
        if (!base.Create())
        {
            Console.WriteLine("Win32WindowHost failed to create its window handle.");
            return false;
        }

        try
        {
            appServices = Win32AppServicesInitializer.Initialize(Handle, GetClientRectSize(), uiDrawCallback, backgroundColor);
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to initialize Win32WindowHost services: {ex.Message}");
            return false;
        }
    }

    void IWindowHost.Cleanup()
    {
        Cleanup();
    }

    protected override void Cleanup()
    {
        if (_isModalClosing)
        {
            return;
        }

        Console.WriteLine("Win32WindowHost cleaning up its resources...");
        appServices?.AppEngine.Cleanup();
        appServices?.TextService.Cleanup();
        (appServices?.Renderer as Backends.Direct2DRenderer)?.Cleanup();
        appServices?.GraphicsDevice.Cleanup();

        appServices = null;
        activeModalWindow = null;

        base.Cleanup();
    }

    public void RunLoop()
    {
        Application.RunMessageLoop();
    }

    protected override void OnPaint()
    {
        if (appServices is null || !appServices.GraphicsDevice.IsInitialized)
        {
            Console.WriteLine("Render services not initialized. Skipping paint.");
            return;
        }

        appServices.GraphicsDevice.BeginDraw();

        try
        {
            if (appServices.AppEngine is not null && appServices.GraphicsDevice.RenderTarget is not null)
            {
                appServices.GraphicsDevice.RenderTarget.Clear(appServices.AppEngine.BackgroundColor);
            }

            appServices?.AppEngine?.UpdateAndRender(appServices.Renderer, appServices.TextService);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred during drawing: {ex}");
            appServices.GraphicsDevice.Cleanup();
        }
        finally
        {
            appServices.GraphicsDevice.EndDraw();
        }
    }

    public override void FrameUpdate()
    {
        Invalidate();
        HandleModalLifecycle();
    }

    protected override void OnSize(int width, int height)
    {
        appServices?.GraphicsDevice.Resize(new SizeI(width, height));
    }

    protected override void OnMouseMove(int x, int y)
    {
        appServices?.AppEngine.Input.SetMousePosition(x, y);
        Invalidate();
    }

    protected override void OnMouseDown(MouseButton button, int x, int y)
    {
        appServices?.AppEngine.Input.SetMousePosition(x, y);
        appServices?.AppEngine.Input.SetMouseDown(button);
        Invalidate();
    }

    protected override void OnMouseUp(MouseButton button, int x, int y)
    {
        appServices?.AppEngine.Input.SetMousePosition(x, y);
        appServices?.AppEngine.Input.SetMouseUp(button);
        Invalidate();
    }

    protected override void OnMouseWheel(float delta)
    {
        appServices?.AppEngine.Input.AddMouseWheelDelta(delta);
        Invalidate();
    }

    protected override void OnKeyDown(Keys key)
    {
        appServices?.AppEngine.Input.AddKeyPressed(key);

        if (key == Keys.Escape)
        {
            Close();
        }

        if (key == Keys.F3 && appServices?.AppEngine is not null)
        {
            appServices.AppEngine.ShowFpsCounter = !appServices.AppEngine.ShowFpsCounter;
        }

        Invalidate();
    }

    protected override void OnKeyUp(Keys key)
    {
        appServices?.AppEngine.Input.AddKeyReleased(key);
        Invalidate();
    }

    protected override void OnChar(char c)
    {
        appServices?.AppEngine.Input.AddCharacterInput(c);
        Invalidate();
    }

    protected override bool OnClose()
    {
        return true;
    }

    protected override void OnDestroy()
    {
        base.OnDestroy();

        if (activeModalWindow is null || activeModalWindow.Handle == IntPtr.Zero)
        {
            return;
        }

        activeModalWindow.Close();
    }

    private SizeI GetClientRectSize()
    {
        if (Handle == nint.Zero || !NativeMethods.GetClientRect(Handle, out NativeMethods.RECT r))
        {
            return new(Width, Height);
        }

        int width = int.Max(1, r.right - r.left);
        int height = int.Max(1, r.bottom - r.top);

        return new(width, height);
    }

    public void OpenModalWindow(string title, int width, int height, Action<UIContext> drawCallback, Action<int>? onClosedCallback = null)
    {
        if (activeModalWindow is not null && activeModalWindow.Handle != IntPtr.Zero)
        {
            Console.WriteLine("Warning: Cannot open a new modal window while another is already active.");
            return;
        }

        activeModalWindow = new(this, title, width, height, drawCallback);

        if (activeModalWindow.CreateAsModal())
        {
            onModalClosedCallback = onClosedCallback;
            modalResultCode = -1;
            Console.WriteLine("Modal window opened successfully.");
        }
        else
        {
            Console.WriteLine("Failed to create modal window.");
            activeModalWindow.Dispose();
            activeModalWindow = null;
            onClosedCallback?.Invoke(-1);
        }
    }

    public void CloseModalWindow(int resultCode = 0)
    {
        if (activeModalWindow is null || activeModalWindow.Handle == IntPtr.Zero)
        {
            return;
        }

        modalResultCode = resultCode;
        activeModalWindow.Close();
    }

    private void HandleModalLifecycle()
    {
        if (activeModalWindow is null)
        {
            return;
        }

        if (activeModalWindow.Handle != IntPtr.Zero || _isModalClosing)
        {
            return;
        }

        _isModalClosing = true;

        Console.WriteLine($"Modal window closed. Result: {modalResultCode}");
        onModalClosedCallback?.Invoke(modalResultCode);

        activeModalWindow.Dispose();
        activeModalWindow = null;
        onModalClosedCallback = null;
        modalResultCode = 0;
        _isModalClosing = false;
    }
}
</file>

<file path="Backends\Raylib\RaylibRenderer.cs">
// DirectUI/Backends/Raylib/RaylibRenderer.cs
using System;
using System.Collections.Generic;
using System.Numerics;
using DirectUI.Core;
using DirectUI.Drawing;
using Vortice.Direct2D1; // For AntialiasMode enum, even if not used by Raylib
using Raylib_cs; // Raylib specific library

namespace DirectUI.Backends;

/// <summary>
/// A rendering backend that uses Raylib to implement the IRenderer interface.
/// </summary>
public class RaylibRenderer : IRenderer
{
    // This factor compensates for the perceptual size difference between DirectWrite and FreeType rendering.
    // DirectWrite text tends to appear slightly larger/bolder for the same point size.
    private const float FONT_SCALE_FACTOR = 1.125f;
    private readonly Stack<Rectangle> _clipRectStack = new();

    public Vector2 RenderTargetSize
    {
        get
        {
            return new(
                Raylib.GetScreenWidth(),
                Raylib.GetScreenHeight());
        }
    }

    public RaylibRenderer()
    {
        // Raylib is typically initialized externally (e.g., in Program.cs or AppHost)
        // No Raylib-specific initialization needed here in the constructor.
    }

    public void DrawLine(Vector2 p1, Vector2 p2, Drawing.Color color, float strokeWidth)
    {
        // Raylib draws lines with thickness 1 by default, or you can use DrawLineEx for thicker lines
        Raylib.DrawLineEx(p1, p2, strokeWidth, color);
    }

    public void DrawBox(Vortice.Mathematics.Rect rect, BoxStyle style)
    {
        Raylib_cs.Color fillColor = style.FillColor;
        Raylib_cs.Color borderColor = style.BorderColor;

        // Round coordinates to align to the pixel grid for sharper rendering.
        float roundedX = MathF.Round(rect.X);
        float roundedY = MathF.Round(rect.Y);
        // Round the right/bottom edges and calculate width/height to avoid shimmering/gaps.
        float roundedWidth = MathF.Round(rect.X + rect.Width) - roundedX;
        float roundedHeight = MathF.Round(rect.Y + rect.Height) - roundedY;

        // Use this rounded rectangle for all drawing operations.
        Raylib_cs.Rectangle rlRect = new(roundedX, roundedY, roundedWidth, roundedHeight);

        // Border
        if (style.BorderColor.A > 0 && (style.BorderLengthTop > 0 || style.BorderLengthRight > 0 || style.BorderLengthBottom > 0 || style.BorderLengthLeft > 0))
        {
            if (style.Roundness > 0)
            {
                // Draw the outer rounded rectangle for the border
                Raylib.DrawRectangleRounded(rlRect, style.Roundness, 0, borderColor);

                // Calculate the inner rectangle for the fill
                var fillRect = new Raylib_cs.Rectangle(
                    rlRect.X + style.BorderLengthLeft,
                    rlRect.Y + style.BorderLengthTop,
                    rlRect.Width - style.BorderLengthLeft - style.BorderLengthRight,
                    rlRect.Height - style.BorderLengthTop - style.BorderLengthBottom
                );

                // Calculate the inner roundness
                float innerRoundness = style.Roundness; // This might need more sophisticated calculation

                // Draw the inner rounded rectangle for the fill color, effectively creating the border
                if (style.FillColor.A > 0 && fillRect.Width > 0 && fillRect.Height > 0)
                {
                    Raylib.DrawRectangleRounded(fillRect, innerRoundness, 0, fillColor);
                }
            }
            else
            {
                // Use original line-by-line drawing for non-rounded rectangles with rounded coordinates
                float right = rlRect.X + rlRect.Width;
                float bottom = rlRect.Y + rlRect.Height;

                // Top border
                if (style.BorderLengthTop > 0) Raylib.DrawLineEx(new Vector2(rlRect.X, rlRect.Y), new Vector2(right, rlRect.Y), style.BorderLengthTop, borderColor);
                // Right border
                if (style.BorderLengthRight > 0) Raylib.DrawLineEx(new Vector2(right, rlRect.Y), new Vector2(right, bottom), style.BorderLengthRight, borderColor);
                // Bottom border
                if (style.BorderLengthBottom > 0) Raylib.DrawLineEx(new Vector2(right, bottom), new Vector2(rlRect.X, bottom), style.BorderLengthBottom, borderColor);
                // Left border
                if (style.BorderLengthLeft > 0) Raylib.DrawLineEx(new Vector2(rlRect.X, bottom), new Vector2(rlRect.X, rlRect.Y), style.BorderLengthLeft, borderColor);

                // Now, draw the fill rectangle inside the borders
                if (style.FillColor.A > 0)
                {
                    var fillRect = new Raylib_cs.Rectangle(
                        rlRect.X + style.BorderLengthLeft,
                        rlRect.Y + style.BorderLengthTop,
                        rlRect.Width - style.BorderLengthLeft - style.BorderLengthRight,
                        rlRect.Height - style.BorderLengthTop - style.BorderLengthBottom
                    );
                    if (fillRect.Width > 0 && fillRect.Height > 0)
                    {
                        Raylib.DrawRectangleRec(fillRect, fillColor);
                    }
                }
            }
        }
        else if (style.FillColor.A > 0) // No border, just fill
        {
            if (style.Roundness > 0)
            {
                Raylib.DrawRectangleRounded(rlRect, style.Roundness, 0, fillColor);
            }
            else
            {
                Raylib.DrawRectangleRec(rlRect, fillColor);
            }
        }
    }

    public void DrawText(Vector2 origin, string text, ButtonStyle style, Alignment alignment, Vector2 maxSize, Drawing.Color color)
    {
        if (string.IsNullOrEmpty(text))
        {
            return;
        }

        float finalFontSize = style.FontSize * FONT_SCALE_FACTOR;
        int atlasSize = (int)Math.Round(finalFontSize);
        if (atlasSize <= 0) atlasSize = 1; // Prevent loading font at size 0.

        Raylib_cs.Color rlColor = color;

        // Use the FontManager to get the appropriate font, loaded at the native resolution and correct weight.
        Font rlFont = FontManager.GetFont(style.FontName, atlasSize, style.FontWeight);

        // The font size passed to Raylib should be the integer size the font atlas was generated with
        // to ensure 1:1 pixel rendering and avoid scaling artifacts.
        Vector2 measuredSize = Raylib.MeasureTextEx(rlFont, text, atlasSize, atlasSize / 10f);

        Vector2 textDrawPos = origin;

        // Apply horizontal alignment
        if (maxSize.X > 0 && measuredSize.X < maxSize.X)
        {
            switch (alignment.Horizontal)
            {
                case HAlignment.Center:
                    textDrawPos.X += (maxSize.X - measuredSize.X) / 2f;
                    break;
                case HAlignment.Right:
                    textDrawPos.X += (maxSize.X - measuredSize.X);
                    break;
            }
        }

        // Apply vertical alignment
        if (maxSize.Y > 0)
        {
            switch (alignment.Vertical)
            {
                case VAlignment.Center:
                    textDrawPos.Y += (maxSize.Y - measuredSize.Y) / 2f;
                    break;
                case VAlignment.Bottom:
                    textDrawPos.Y += (maxSize.Y - measuredSize.Y);
                    break;
            }
        }

        // Round the final position to the nearest whole pixel to prevent sub-pixel "wobble".
        textDrawPos = new Vector2(MathF.Round(textDrawPos.X), MathF.Round(textDrawPos.Y));

        // Draw using the integer atlas size to prevent scaling.
        Raylib.DrawTextEx(rlFont, text, textDrawPos, atlasSize, atlasSize / 10f, rlColor);
    }

    public void PushClipRect(Vortice.Mathematics.Rect rect, AntialiasMode antialiasMode)
    {
        // Store the original float rect on our stack to preserve precision.
        _clipRectStack.Push(new Raylib_cs.Rectangle(rect.X, rect.Y, rect.Width, rect.Height));
        ApplyScissorFromRect(rect);
    }

    public void PopClipRect()
    {
        if (_clipRectStack.Count <= 0)
        {
            return;
        }

        _clipRectStack.Pop();

        if (_clipRectStack.Count > 0)
        {
            // Re-apply the previous clip rect from the stack.
            var prevRect = _clipRectStack.Peek();
            ApplyScissorFromRect(new Vortice.Mathematics.Rect(prevRect.X, prevRect.Y, prevRect.Width, prevRect.Height));
        }
        else
        {
            // If stack is empty, end scissor mode entirely.
            Raylib.EndScissorMode();
        }
    }

    private void ApplyScissorFromRect(Vortice.Mathematics.Rect rect)
    {
        // Raylib's scissor mode is integer-based. To avoid clipping artifacts with
        // fractional coordinates, we calculate an integer-based bounding box that
        // fully contains the desired float-based rectangle.
        int x = (int)MathF.Floor(rect.X);
        int y = (int)MathF.Floor(rect.Y);
        // Add the fractional part of the origin back to the size before ceiling to ensure the rect is fully covered.
        int width = (int)MathF.Ceiling(rect.Width + (rect.X - x));
        int height = (int)MathF.Ceiling(rect.Height + (rect.Y - y));

        Raylib.BeginScissorMode(x, y, width, height);
    }

    public void Flush()
    {
        // Raylib is an immediate-mode API, no flush needed.
    }

    // Raylib specific cleanup (if any resources like fonts were loaded dynamically)
    public void Cleanup()
    {
        // No Raylib-specific font objects to dispose that are loaded here per layout.
        // If fonts were loaded with LoadFontEx, they would need UnloadFont.
        _clipRectStack.Clear();
    }
}
</file>

<file path="Backends\Raylib\RaylibTextLayout.cs">
// DirectUI/Backends/Raylib/RaylibTextLayout.cs
using System;
using System.Numerics;
using DirectUI.Core;
using Vortice.Mathematics; // For Color4, Rect
using Raylib_cs; // Raylib specific library

namespace DirectUI.Backends;

/// <summary>
/// A Raylib-specific implementation of the ITextLayout interface.
/// This class stores text and provides approximate metrics.
/// </summary>
internal class RaylibTextLayout : ITextLayout
{
    public Vector2 Size { get; }
    public string Text { get; }

    private readonly Font _raylibFont;

    public RaylibTextLayout(string text, Font preloadedFont, int atlasSize)
    {
        Text = text;
        _raylibFont = preloadedFont;

        // Measure using the integer size the font was generated with to ensure 1:1 metrics.
        Size = Raylib.MeasureTextEx(_raylibFont, text, atlasSize, atlasSize / 10f);
    }

    public TextHitTestMetrics HitTestTextPosition(int textPosition, bool isTrailingHit)
    {
        // Raylib doesn't provide fine-grained text metrics per character easily.
        // This is a rough approximation based on overall text width.
        if (string.IsNullOrEmpty(Text)) return new TextHitTestMetrics(Vector2.Zero, Vector2.Zero);

        float approxCharWidth = Size.X / Text.Length;
        float x = textPosition * approxCharWidth;
        float width = approxCharWidth;

        // Adjust x if it's a trailing hit, to measure the position AFTER the character
        if (isTrailingHit) x += approxCharWidth;

        // Clamp to prevent out-of-bounds positions
        x = Math.Clamp(x, 0, Size.X);

        return new TextHitTestMetrics(new Vector2(x, 0), new Vector2(width, Size.Y));
    }

    public TextHitTestResult HitTestPoint(Vector2 point)
    {
        // This is a rough approximation for hit testing in Raylib
        if (string.IsNullOrEmpty(Text))
        {
            return new TextHitTestResult(0, false, false, new TextHitTestMetrics(Vector2.Zero, Vector2.Zero));
        }

        bool isInside = point.X >= 0 && point.X <= Size.X && point.Y >= 0 && point.Y <= Size.Y;

        float approxCharWidth = (Text.Length > 0) ? Size.X / Text.Length : 0;
        int textPosition = 0;
        bool isTrailingHit = false;

        if (approxCharWidth > 0)
        {
            textPosition = (int)(point.X / approxCharWidth);
            isTrailingHit = (point.X % approxCharWidth) > (approxCharWidth / 2f);
        }

        // Caret position can be one past the last character (i.e., at the end of the string).
        textPosition = Math.Clamp(textPosition, 0, Text.Length);
        if (isTrailingHit && textPosition < Text.Length) // If it's a trailing hit and not at the very end
        {
            textPosition++;
        }
        textPosition = Math.Clamp(textPosition, 0, Text.Length); // Final clamp

        // Recalculate metrics for the specific hit position
        float hitMetricX = (textPosition == 0) ? 0 : (textPosition * approxCharWidth);
        if (isTrailingHit && textPosition > 0) hitMetricX -= approxCharWidth; // Adjust if hit is trailing edge

        return new TextHitTestResult(textPosition, isTrailingHit, isInside,
            new TextHitTestMetrics(new Vector2(hitMetricX, 0), new Vector2(approxCharWidth, Size.Y)));
    }

    public void Dispose()
    {
        // This object doesn't own the font resource, so it does not dispose it.
        // FontManager is responsible for unloading fonts.
    }
}
</file>

<file path="Backends\Raylib\RaylibTextService.cs">
// DirectUI/Backends/Raylib/RaylibTextService.cs
using System;
using System.Collections.Generic;
using System.Numerics;
using DirectUI.Core;
using DirectUI.Drawing;
using Vortice.Mathematics; // For Color4, Rect
using Raylib_cs; // Raylib specific library

namespace DirectUI.Backends;

/// <summary>
/// An implementation of ITextService that uses Raylib.
/// It manages caches for text layouts.
/// </summary>
public class RaylibTextService : ITextService
{
    // This factor compensates for the perceptual size difference between DirectWrite and FreeType rendering.
    // DirectWrite text tends to appear slightly larger/bolder for the same point size.
    private const float FONT_SCALE_FACTOR = 1.125f;

    private readonly Dictionary<TextLayoutCacheKey, ITextLayout> _textLayoutCache = new();
    private readonly Dictionary<(string, FontKey), Vector2> _textSizeCache = new();

    // Internal cache key structs (re-defined or referenced from a common place)
    internal readonly struct FontKey(ButtonStyle style) : IEquatable<FontKey>
    {
        private readonly string FontName = style.FontName;
        private readonly float FontSize = style.FontSize;
        private readonly Vortice.DirectWrite.FontWeight FontWeight = style.FontWeight;
        private readonly Vortice.DirectWrite.FontStyle FontStyle = style.FontStyle;
        private readonly Vortice.DirectWrite.FontStretch FontStretch = style.FontStretch;
        public bool Equals(FontKey other) => FontName == other.FontName && FontSize.Equals(other.FontSize) && FontWeight == other.FontWeight && FontStyle == other.FontStyle && FontStretch == other.FontStretch;
        public override bool Equals(object? obj) => obj is FontKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(FontName, FontSize, FontWeight, FontStyle, FontStretch);
    }

    internal readonly struct TextLayoutCacheKey(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment) : IEquatable<TextLayoutCacheKey>
    {
        private readonly string Text = text;
        private readonly FontKey FontKey = new(style);
        private readonly Vector2 MaxSize = maxSize;
        private readonly HAlignment HAlign = alignment.Horizontal;
        private readonly VAlignment VAlign = alignment.Vertical;
        public bool Equals(TextLayoutCacheKey other) => Text == other.Text && MaxSize.Equals(other.MaxSize) && HAlign == other.HAlign && VAlign == other.VAlign && FontKey.Equals(other.FontKey);
        public override bool Equals(object? obj) => obj is TextLayoutCacheKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(Text, FontKey, MaxSize, HAlign, VAlign);
    }

    public RaylibTextService()
    {
        // No specific Raylib font factory initialization needed here
    }

    public Vector2 MeasureText(string text, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(text) || style is null) return Vector2.Zero;

        var fontKey = new FontKey(style);
        var cacheKey = (text, fontKey);
        if (_textSizeCache.TryGetValue(cacheKey, out var cachedSize)) return cachedSize;

        float finalFontSize = style.FontSize * FONT_SCALE_FACTOR;
        int atlasSize = (int)Math.Round(finalFontSize);
        if (atlasSize <= 0) atlasSize = 1;

        // Use the FontManager to get the appropriate font at the native resolution and correct weight.
        Font rlFont = FontManager.GetFont(style.FontName, atlasSize, style.FontWeight);

        // Measure using the integer atlas size for accurate, non-scaled metrics.
        Vector2 measuredSize = Raylib.MeasureTextEx(rlFont, text, atlasSize, atlasSize / 10f);
        _textSizeCache[cacheKey] = measuredSize;
        return measuredSize;
    }

    public ITextLayout GetTextLayout(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment)
    {
        var layoutKey = new TextLayoutCacheKey(text, style, maxSize, alignment);
        if (_textLayoutCache.TryGetValue(layoutKey, out var cachedLayout))
        {
            return cachedLayout;
        }

        float finalFontSize = style.FontSize * FONT_SCALE_FACTOR;
        int atlasSize = (int)Math.Round(finalFontSize);
        if (atlasSize <= 0) atlasSize = 1;

        // Fetch the font at the correct, native atlas resolution and weight.
        var font = FontManager.GetFont(style.FontName, atlasSize, style.FontWeight);

        // Pass the pre-loaded font and the integer atlas size to the layout constructor.
        var newLayout = new RaylibTextLayout(text, font, atlasSize);
        _textLayoutCache[layoutKey] = newLayout;
        return newLayout;
    }

    public void Cleanup()
    {
        Console.WriteLine("RaylibTextService Cleanup: Clearing cached resources...");
        foreach (var pair in _textLayoutCache) { pair.Value?.Dispose(); } // Dispose the ITextLayout instances
        _textLayoutCache.Clear();
        _textSizeCache.Clear();
        Console.WriteLine("RaylibTextService Cleanup finished.");
    }
}
</file>

<file path="Backends\Raylib\RaylibWindowHost.cs">
// DirectUI/RaylibWindowHost.cs
using System;
using System.Numerics;
using DirectUI.Core; // For IWindowHost, IModalWindowService
using DirectUI.Drawing;
using DirectUI.Input;
using Raylib_cs;
using Vortice.Mathematics;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI;

/// <summary>
/// A concrete implementation of <see cref="IWindowHost"/> for the Raylib backend.
/// </summary>
public class RaylibWindowHost : IWindowHost
{
    private readonly string _title;
    private readonly int _width;
    private readonly int _height;
    private readonly Color4 _backgroundColor;

    private AppEngine? _appEngine;
    private IRenderer? _renderer;
    private ITextService? _textService;
    private bool _isDisposed = false;

    // Raylib doesn't have a native window handle like Win32 or SDL, so this will be IntPtr.Zero.
    public IntPtr Handle => IntPtr.Zero;
    public InputManager Input => _appEngine?.Input ?? new InputManager();
    public SizeI ClientSize => new SizeI(Raylib.GetScreenWidth(), Raylib.GetScreenHeight());

    public bool ShowFpsCounter
    {
        get => _appEngine?.ShowFpsCounter ?? false;
        set { if (_appEngine is not null) _appEngine.ShowFpsCounter = value; }
    }

    public IModalWindowService ModalWindowService { get; } = new RaylibDummyModalWindowService();

    public RaylibWindowHost(string title, int width, int height, Color4 backgroundColor)
    {
        _title = title;
        _width = width;
        _height = height;
        _backgroundColor = backgroundColor;
    }

    public bool Initialize(Action<UIContext> uiDrawCallback, Color4 backgroundColor)
    {
        Console.WriteLine("RaylibWindowHost initializing...");
        try
        {
            Raylib.SetConfigFlags(ConfigFlags.Msaa4xHint);
            Raylib.InitWindow(_width, _height, _title);
            Raylib.SetTargetFPS(60);

            _appEngine = new AppEngine(uiDrawCallback, backgroundColor);
            _renderer = new DirectUI.Backends.RaylibRenderer();
            _textService = new DirectUI.Backends.RaylibTextService();

            // Raylib-specific font initialization and registration
            FontManager.Initialize();
            FontManager.RegisterFontVariant("Segoe UI", Vortice.DirectWrite.FontWeight.Normal, "C:/Windows/Fonts/segoeui.ttf");
            FontManager.RegisterFontVariant("Segoe UI", Vortice.DirectWrite.FontWeight.SemiBold, "C:/Windows/Fonts/seguisb.ttf");
            FontManager.RegisterFontVariant("Consolas", Vortice.DirectWrite.FontWeight.Normal, "C:/Windows/Fonts/consola.ttf");
            FontManager.RegisterFontVariant("Consolas", Vortice.DirectWrite.FontWeight.Bold, "C:/Windows/Fonts/consolab.ttf");

            _appEngine.Initialize(_textService, _renderer);
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to initialize RaylibWindowHost: {ex.Message}");
            Cleanup(); // Ensure partial initialization is cleaned up
            return false;
        }
    }

    public void RunLoop()
    {
        while (!Raylib.WindowShouldClose())
        {
            // Process Raylib input events directly
            _appEngine?.Input.ProcessRaylibInput();

            // Begin drawing
            Raylib.BeginDrawing();
            Raylib.ClearBackground(new Raylib_cs.Color(
                (byte)(_backgroundColor.R * 255),
                (byte)(_backgroundColor.G * 255),
                (byte)(_backgroundColor.B * 255),
                (byte)(_backgroundColor.A * 255)
            ));

            // Update and render the UI through the AppEngine
            if (_renderer is not null && _textService is not null && _appEngine is not null)
            {
                _appEngine.UpdateAndRender(_renderer, _textService);
            }

            // End drawing
            Raylib.EndDrawing();
        }
    }

    public void Cleanup()
    {
        if (_isDisposed) return;
        Console.WriteLine("RaylibWindowHost cleaning up its resources...");
        _appEngine?.Cleanup();
        (_renderer as DirectUI.Backends.RaylibRenderer)?.Cleanup(); // Explicit cast for Cleanup
        (_textService as DirectUI.Backends.RaylibTextService)?.Cleanup(); // Explicit cast for Cleanup
        FontManager.UnloadAll(); // Unload all Raylib fonts

        if (Raylib.IsWindowReady())
        {
            Raylib.CloseWindow();
        }
        _appEngine = null;
        _renderer = null;
        _textService = null;
        _isDisposed = true;
        GC.SuppressFinalize(this);
    }

    public void Dispose()
    {
        Cleanup();
    }

    private class RaylibDummyModalWindowService : IModalWindowService
    {
        public bool IsModalWindowOpen => false;

        public void OpenModalWindow(string title, int width, int height, Action<UIContext> drawCallback, Action<int>? onClosedCallback = null)
        {
            Console.WriteLine($"Modal window '{title}' requested but not supported in Raylib backend.");
            onClosedCallback?.Invoke(-1); // Immediately report as closed/failed
        }

        public void CloseModalWindow(int resultCode = 0)
        {
            // Do nothing as no modal windows are opened.
        }
    }
}
</file>

<file path="Backends\SDL3\SDL3Renderer.cs">
using System.Numerics;
using DirectUI.Core;
using SDL3;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace DirectUI.Backends.SDL3;

public unsafe class SDL3Renderer : IRenderer
{
    private readonly nint _rendererPtr;
    private readonly nint _windowPtr;

    private int _windowWidth;
    private int _windowHeight;

    private readonly Stack<Rect> _clipRectStack = new();
    private readonly Dictionary<TextRenderCacheKey, nint> _textTextureCache = new();

    private const float FONT_SCALE_FACTOR = 1.125f;

    private readonly struct TextRenderCacheKey : IEquatable<TextRenderCacheKey>
    {
        public readonly string Text;
        public readonly float FontSize;
        public readonly FontWeight FontWeight;
        public readonly FontStyle FontStyle;
        public readonly FontStretch FontStretch;
        public readonly Color Color;

        public TextRenderCacheKey(string text, ButtonStyle style, Color color)
        {
            Text = text;
            FontSize = style.FontSize;
            FontWeight = style.FontWeight;
            FontStyle = style.FontStyle;
            FontStretch = style.FontStretch;
            Color = color;
        }

        public bool Equals(TextRenderCacheKey other)
        {
            return Text == other.Text 
                && FontSize.Equals(other.FontSize) 
                && FontWeight == other.FontWeight 
                && FontStyle == other.FontStyle 
                && FontStretch == other.FontStretch 
                && Color.Equals(other.Color);
        }

        public override bool Equals(object? obj)
        {
            return obj is TextRenderCacheKey other && Equals(other);
        }

        public override int GetHashCode()
        {
            return HashCode.Combine(
                Text,
                FontSize,
                FontWeight,
                FontStyle,
                FontStretch,
                Color);
        }
    }

    public Vector2 RenderTargetSize
    {
        get
        {
            SDL.GetWindowSize(_windowPtr, out _windowWidth, out _windowHeight);
            return new(_windowWidth, _windowHeight);
        }
    }

    public SDL3Renderer(nint rendererPtr, nint windowPtr)
    {
        _rendererPtr = rendererPtr;
        _windowPtr = windowPtr;

        SDL.GetWindowSize(_windowPtr, out _windowWidth, out _windowHeight);
    }

    internal void UpdateWindowSize(int width, int height)
    {
        _windowWidth = width;
        _windowHeight = height;
    }

    public void DrawLine(Vector2 p1, Vector2 p2, Drawing.Color color, float strokeWidth)
    {
        SDL.SetRenderDrawColor(_rendererPtr, color.R, color.G, color.B, color.A);

        if (strokeWidth <= 1.0f)
        {
            // Draw 1-pixel thin line
            SDL.RenderLine(_rendererPtr, (int)p1.X, (int)p1.Y, (int)p2.X, (int)p2.Y);
        }
        else
        {
            // For thicker lines, approximate with a filled rectangle.
            // This is a basic approximation, primarily for axis-aligned or near-axis-aligned lines.
            // For general diagonal lines with thickness, more complex geometry (like a rotated rectangle or two triangles)
            // or a dedicated library (e.g., SDL_gfx or custom shader) would be required.

            float halfStroke = strokeWidth / 2f;
            float dx = p2.X - p1.X;
            float dy = p2.Y - p1.Y;

            // If it's more horizontal
            if (Math.Abs(dx) >= Math.Abs(dy))
            {
                SDL.FRect rectangle = new()
                {
                    X = Math.Min(p1.X, p2.X),
                    Y = (p1.Y + p2.Y) / 2f - halfStroke, // Center Y on the line's average Y
                    W = Math.Abs(dx),
                    H = strokeWidth
                };
                SDL.RenderFillRect(_rendererPtr, rectangle);
            }
            // If it's more vertical
            else
            {
                SDL.FRect rectangle = new()
                {
                    X = (p1.X + p2.X) / 2f - halfStroke, // Center X on the line's average X
                    Y = Math.Min(p1.Y, p2.Y),
                    W = strokeWidth,
                    H = Math.Abs(dy)
                };
                SDL.RenderFillRect(_rendererPtr, rectangle);
            }
        }
    }

    public void DrawBox(Vortice.Mathematics.Rect rect, BoxStyle style)
    {
        // Convert Vortice.Mathematics.Rect to SDL.FRect for drawing
        SDL.FRect outerRect = new()
        {
            X = rect.X,
            Y = rect.Y,
            W = rect.Width,
            H = rect.Height
        };

        // 1. Draw the border background (entire rectangle with border color)
        // If border color is transparent or all border lengths are zero, this step effectively does nothing visually.
        if (style.BorderColor.A > 0 && (style.BorderLengthTop > 0 || style.BorderLengthRight > 0 || style.BorderLengthBottom > 0 || style.BorderLengthLeft > 0))
        {
            SDL.SetRenderDrawColor(_rendererPtr, style.BorderColor.R, style.BorderColor.G, style.BorderColor.B, style.BorderColor.A);
            SDL.RenderFillRect(_rendererPtr, outerRect);
        }

        // 2. Draw the inner fill rectangle (inset by border lengths)
        if (style.FillColor.A > 0)
        {
            float fillX = rect.X + style.BorderLengthLeft;
            float fillY = rect.Y + style.BorderLengthTop;
            float fillWidth = Math.Max(0f, rect.Width - style.BorderLengthLeft - style.BorderLengthRight);
            float fillHeight = Math.Max(0f, rect.Height - style.BorderLengthTop - style.BorderLengthBottom);

            if (fillWidth > 0 && fillHeight > 0)
            {
                SDL.FRect fillRect = new()
                {
                    X = fillX,
                    Y = fillY,
                    W = fillWidth,
                    H = fillHeight
                };

                SDL.SetRenderDrawColor(_rendererPtr, style.FillColor.R, style.FillColor.G, style.FillColor.B, style.FillColor.A);
                SDL.RenderFillRect(_rendererPtr, fillRect);
            }
            // Special case: If no border is defined (all lengths 0) and the fill itself is opaque,
            // the above fillRect might be invalid (e.g. if original rect had 0 width/height)
            // In such a scenario, we still want to draw the full outerRect with the fill color if it's visible.
            else if (style.BorderLengthTop == 0 && style.BorderLengthRight == 0 && style.BorderLengthBottom == 0 && style.BorderLengthLeft == 0 && (outerRect.W > 0 && outerRect.H > 0))
            {
                SDL.SetRenderDrawColor(_rendererPtr, style.FillColor.R, style.FillColor.G, style.FillColor.B, style.FillColor.A);
                SDL.RenderFillRect(_rendererPtr, outerRect);
            }
        }
        // Roundness is not natively supported by SDL's basic renderer. It will be drawn as square corners.
    }

    public void DrawText(Vector2 origin, string text, ButtonStyle style, Alignment alignment, Vector2 maxSize, Drawing.Color color)
    {
        if (string.IsNullOrEmpty(text))
        {
            return;
        }

        if (UI.Context.TextService is not SDL3TextService textService)
        {
            Console.WriteLine("Error: SDL3TextService not available for text rendering.");
            return;
        }

        // Get the font
        float effectiveFontSize = style.FontSize * FONT_SCALE_FACTOR;
        nint fontPtr = textService.GetOrCreateFont(style.FontName, (int)Math.Round(effectiveFontSize), style.FontWeight);

        if (fontPtr == nint.Zero)
        {
            Console.WriteLine($"Error: Font '{style.FontName}' could not be loaded.");
            return;
        }

        TextRenderCacheKey cacheKey = new(text, style, color);
        
        if (!_textTextureCache.TryGetValue(cacheKey, out nint textTexture))
        {
            SDL.Color sdlColor = new() { R = color.R, G = color.G, B = color.B, A = color.A };
            nint textSurface = TTF.RenderTextBlended(fontPtr, text, 0, sdlColor);

            if (textSurface == nint.Zero)
            {
                Console.WriteLine($"Error rendering text surface: {SDL.GetError()}");
                return;
            }

            textTexture = SDL.CreateTextureFromSurface(_rendererPtr, textSurface);
            SDL.DestroySurface(textSurface);

            if (textTexture == nint.Zero)
            {
                Console.WriteLine($"Error creating text texture: {SDL.GetError()}");
                return;
            }

            _textTextureCache[cacheKey] = textTexture;
        }

        //  SDL3-compatible way to get texture dimensions

        if (!SDL.GetTextureSize(textTexture, out float texW, out float texH))
        {
            Console.WriteLine($"Error getting texture size: {SDL.GetError()}");
            return;
        }

        Vector2 measuredSize = new(texW, texH);
        Vector2 textDrawPos = origin;

        // Horizontal alignment
        if (maxSize.X > 0 && measuredSize.X < maxSize.X)
        {
            switch (alignment.Horizontal)
            {
                case HAlignment.Center:
                    textDrawPos.X += (maxSize.X - measuredSize.X) / 2f;
                    break;
                case HAlignment.Right:
                    textDrawPos.X += (maxSize.X - measuredSize.X);
                    break;
            }
        }

        // Vertical alignment
        if (maxSize.Y > 0)
        {
            switch (alignment.Vertical)
            {
                case VAlignment.Center:
                    textDrawPos.Y += (maxSize.Y - measuredSize.Y) / 2f;
                    break;
                case VAlignment.Bottom:
                    textDrawPos.Y += (maxSize.Y - measuredSize.Y);
                    break;
            }
        }

        SDL.FRect dstRect = new()
        {
            X = textDrawPos.X,
            Y = textDrawPos.Y,
            W = texW,
            H = texH
        };

        SDL.RenderTexture(_rendererPtr, textTexture, nint.Zero, dstRect);
    }

    public void PushClipRect(Rect rect, AntialiasMode antialiasMode)
    {
        _clipRectStack.Push(rect);
        ApplyClipRect(rect);
    }

    public void PopClipRect()
    {
        if (_clipRectStack.Count <= 0)
        {
            return;
        }

        _clipRectStack.Pop();

        if (_clipRectStack.Count > 0)
        {
            ApplyClipRect(_clipRectStack.Peek());
        }
        else
        {
            // Clear clip rect
            SDL.Rect rect = new()
            {
                X = 0,
                Y = 0,
                W = _windowWidth,
                H = _windowHeight,
            };

            SDL.SetRenderClipRect(_rendererPtr, rect);
        }
    }

    private void ApplyClipRect(Rect rect)
    {
        SDL.Rect clipRect = new()
        {
            X = (int)float.Floor(rect.X),
            Y = (int)float.Floor(rect.Y),
            W = (int)float.Ceiling(rect.Width + (rect.X - float.Floor(rect.X))),
            H = (int)float.Ceiling(rect.Height + (rect.Y - float.Floor(rect.Y)))
        };

        SDL.SetRenderClipRect(_rendererPtr, clipRect);
    }

    public void Flush()
    {
        // SDL's 2D renderer typically renders commands immediately to an internal buffer.
        // The SDL_RenderPresent call (handled by SDL3UIHost) does the actual flush to screen.
    }

    public void Cleanup()
    {
        _clipRectStack.Clear();

        foreach (nint texture in _textTextureCache.Values)
        {
            SDL.DestroyTexture(texture);
        }

        _textTextureCache.Clear();
        // The renderer and window are managed and destroyed by ApplicationRunner.
    }
}
</file>

<file path="Backends\SDL3\SDL3TextLayout.cs">
using System;
using System.Numerics;
using DirectUI.Core;
using SDL3;
using Vortice.DirectWrite; // For FontWeight, etc.

namespace DirectUI.Backends.SDL3;

/// <summary>
/// A minimal implementation of ITextLayout for SDL3.
/// This will be expanded in a later step.
/// </summary>
internal unsafe class SDL3TextLayout : ITextLayout
{
    public Vector2 Size { get; }
    public string Text { get; }

    private readonly nint _fontPtr; // Pointer to the TTF.Font object

    public SDL3TextLayout(string text, nint fontPtr)
    {
        Text = text;
        _fontPtr = fontPtr;

        // SDL3_ttf: Use TTF.GetStringSize instead of deprecated TTF.SizeUTF8
        if (!string.IsNullOrEmpty(text) && fontPtr != nint.Zero)
        {
            if (TTF.GetStringSize(fontPtr, text, 0, out int w, out int h))
            {
                Size = new Vector2(w, h);
            }
            else
            {
                Console.WriteLine($"Error measuring text '{text}': {SDL.GetError()}");
                Size = Vector2.Zero;
            }
        }
        else
        {
            Size = Vector2.Zero;
        }
    }

    public TextHitTestMetrics HitTestTextPosition(int textPosition, bool isTrailingHit)
    {
        // Placeholder implementation as SDL_ttf does not provide direct hit-testing.
        if (string.IsNullOrEmpty(Text)) return new TextHitTestMetrics(Vector2.Zero, Vector2.Zero);

        float approxCharWidth = Size.X / Math.Max(1, Text.Length);
        float x = textPosition * approxCharWidth;
        float width = approxCharWidth;

        // Adjust x if it's a trailing hit, to measure the position AFTER the character
        if (isTrailingHit) x += approxCharWidth;

        // Clamp to prevent out-of-bounds positions
        x = Math.Clamp(x, 0, Size.X);

        return new TextHitTestMetrics(new Vector2(x, 0), new Vector2(width, Size.Y));
    }

    public TextHitTestResult HitTestPoint(Vector2 point)
    {
        // Placeholder implementation as SDL_ttf does not provide direct hit-testing.
        if (string.IsNullOrEmpty(Text))
        {
            return new TextHitTestResult(0, false, false, new TextHitTestMetrics(Vector2.Zero, Vector2.Zero));
        }

        bool isInside = point.X >= 0 && point.X <= Size.X && point.Y >= 0 && point.Y <= Size.Y;

        float approxCharWidth = (Text.Length > 0) ? Size.X / Text.Length : 0;
        int textPosition = 0;
        bool isTrailingHit = false;

        if (approxCharWidth > 0)
        {
            textPosition = (int)(point.X / approxCharWidth);
            isTrailingHit = (point.X % approxCharWidth) > (approxCharWidth / 2f);
        }

        // Caret position can be one past the last character (i.e., at the end of the string).
        textPosition = Math.Clamp(textPosition, 0, Text.Length);
        if (isTrailingHit && textPosition < Text.Length) // If it's a trailing hit and not at the very end
        {
            textPosition++;
        }
        textPosition = Math.Clamp(textPosition, 0, Text.Length); // Final clamp

        // Recalculate metrics for the specific hit position
        float hitMetricX = (textPosition == 0) ? 0 : (textPosition * approxCharWidth);
        if (isTrailingHit && textPosition > 0) hitMetricX -= approxCharWidth; // Adjust if hit is trailing edge

        return new TextHitTestResult(textPosition, isTrailingHit, isInside,
            new TextHitTestMetrics(new Vector2(hitMetricX, 0), new Vector2(approxCharWidth, Size.Y)));
    }

    public void Dispose()
    {
        // This object does not own the font pointer; it's owned by SDL3TextService.
    }
}
</file>

<file path="Backends\SDL3\SDL3TextService.cs">
using System;
using System.Collections.Generic;
using System.IO;
using System.Numerics;
using DirectUI.Core;
using DirectUI.Drawing;
using SDL3;
using Vortice.DirectWrite; // For FontWeight, FontStyle, FontStretch

namespace DirectUI.Backends.SDL3;

public unsafe class SDL3TextService : ITextService
{
    private readonly Dictionary<FontKey, nint> _fontCache = new();
    private readonly Dictionary<TextLayoutCacheKey, ITextLayout> _textLayoutCache = new();
    private readonly Dictionary<(string, FontKey), Vector2> _textSizeCache = new();

    // This factor compensates for the perceptual size difference between DirectWrite and FreeType rendering.
    private const float FONT_SCALE_FACTOR = 1.125f;

    // Internal static dictionary for font file paths for SDL3
    private static readonly Dictionary<string, Dictionary<FontWeight, string>> s_sdlFontFilePaths = new();
    private static bool s_defaultFontsRegistered = false; // Flag to ensure registration happens only once

    // Internal cache key structs
    internal readonly struct FontKey(string fontName, int fontSize, FontWeight fontWeight) : IEquatable<FontKey>
    {
        private readonly string FontName = fontName;
        private readonly int FontSize = fontSize; // Stored as integer atlas size
        private readonly FontWeight FontWeight = fontWeight;
        // FontStyle and FontStretch are not directly supported by TTF.OpenFont,
        // so we omit them from the key or map them to file paths.

        public bool Equals(FontKey other) => FontName == other.FontName && FontSize.Equals(other.FontSize) && FontWeight == other.FontWeight;
        public override bool Equals(object? obj) => obj is FontKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(FontName, FontSize, FontWeight);
    }

    internal readonly struct TextLayoutCacheKey(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment) : IEquatable<TextLayoutCacheKey>
    {
        private readonly string Text = text;
        private readonly FontKey FontKey = new(style.FontName, (int)Math.Round(style.FontSize * FONT_SCALE_FACTOR), style.FontWeight); // Cache by actual font properties
        private readonly Vector2 MaxSize = maxSize;
        private readonly HAlignment HAlign = alignment.Horizontal;
        private readonly VAlignment VAlign = alignment.Vertical;
        public bool Equals(TextLayoutCacheKey other) => Text == other.Text && MaxSize.Equals(other.MaxSize) && HAlign == other.HAlign && VAlign == other.VAlign && FontKey.Equals(other.FontKey);
        public override bool Equals(object? obj) => obj is TextLayoutCacheKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(Text, FontKey, MaxSize, HAlign, VAlign);
    }

    public SDL3TextService()
    {
        // TTF.Init() should be called globally ONCE, not per instance.
        // It's handled by SDL3WindowHost now.
    }

    /// <summary>
    /// Registers default font paths for SDL_ttf. This should be called once globally.
    /// </summary>
    internal static void RegisterDefaultFonts()
    {
        if (s_defaultFontsRegistered) return;

        s_sdlFontFilePaths["Segoe UI"] = new Dictionary<FontWeight, string>
        {
            { FontWeight.Normal, "C:/Windows/Fonts/segoeui.ttf" },
            { FontWeight.SemiBold, "C:/Windows/Fonts/seguisb.ttf" }
        };
        s_sdlFontFilePaths["Consolas"] = new Dictionary<FontWeight, string>
        {
            { FontWeight.Normal, "C:/Windows/Fonts/consola.ttf" },
            { FontWeight.Bold, "C:/Windows/Fonts/consolab.ttf" }
        };
        s_sdlFontFilePaths["Arial"] = new Dictionary<FontWeight, string>
        {
            { FontWeight.Normal, "C:/Windows/Fonts/arial.ttf" }
        };

        s_defaultFontsRegistered = true;
    }

    /// <summary>
    /// Attempts to retrieve the file path for a registered font variant for SDL_ttf.
    /// </summary>
    internal static bool TryGetSdlFontFilePath(string familyName, FontWeight weight, out string? filePath)
    {
        filePath = null;
        if (s_sdlFontFilePaths.TryGetValue(familyName, out var variants))
        {
            if (variants.TryGetValue(weight, out filePath))
            {
                return true;
            }
            // Fallback to Normal weight if specific weight not found
            if (variants.TryGetValue(FontWeight.Normal, out filePath))
            {
                return true;
            }
        }
        // Fallback to Arial if original family not found
        if (s_sdlFontFilePaths.TryGetValue("Arial", out var arialVariants) && arialVariants.TryGetValue(FontWeight.Normal, out filePath))
        {
            Console.WriteLine($"Warning: Font family '{familyName}' (weight {weight}) not found. Falling back to Arial.");
            return true;
        }
        return false;
    }


    public nint GetOrCreateFont(string familyName, int fontSize, FontWeight weight)
    {
        FontKey key = new(familyName, fontSize, weight);

        if (_fontCache.TryGetValue(key, out nint fontPtr))
        {
            return fontPtr;
        }

        if (!TryGetSdlFontFilePath(familyName, weight, out string? filePath))
        {
            Console.WriteLine($"Warning: Could not find font file for family '{familyName}' (weight {weight}) or a fallback. Returning null font pointer.");
            return nint.Zero;
        }

        // Open font using SDL_ttf
        fontPtr = TTF.OpenFont(filePath, fontSize);

        if (fontPtr == nint.Zero)
        {
            Console.WriteLine($"Error opening font '{filePath}' at size {fontSize}: {SDL.GetError()}");
            return nint.Zero;
        }

        _fontCache[key] = fontPtr;
        return fontPtr;
    }

    public Vector2 MeasureText(string text, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(text) || style is null)
            return Vector2.Zero;

        float effectiveFontSize = style.FontSize * FONT_SCALE_FACTOR;
        int atlasSize = Math.Max(1, (int)Math.Round(effectiveFontSize));

        var fontKey = new FontKey(style.FontName, atlasSize, style.FontWeight);
        var cacheKey = (text, fontKey);
        if (_textSizeCache.TryGetValue(cacheKey, out var cachedSize))
            return cachedSize;

        nint fontPtr = GetOrCreateFont(style.FontName, atlasSize, style.FontWeight);
        if (fontPtr == nint.Zero)
            return Vector2.Zero;

        if (TTF.GetStringSize(fontPtr, text, 0, out int w, out int h))
        {
            var measuredSize = new Vector2(w, h);
            _textSizeCache[cacheKey] = measuredSize;
            return measuredSize;
        }
        else
        {
            Console.WriteLine($"Error measuring text '{text}': {SDL.GetError()}");
            return Vector2.Zero;
        }
    }

    public ITextLayout GetTextLayout(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment)
    {
        var layoutKey = new TextLayoutCacheKey(text, style, maxSize, alignment);
        if (_textLayoutCache.TryGetValue(layoutKey, out var cachedLayout))
        {
            return cachedLayout;
        }

        float effectiveFontSize = style.FontSize * FONT_SCALE_FACTOR;
        int atlasSize = (int)Math.Round(effectiveFontSize);
        if (atlasSize <= 0) atlasSize = 1;

        nint fontPtr = GetOrCreateFont(style.FontName, atlasSize, style.FontWeight);
        if (fontPtr == nint.Zero)
        {
            Console.WriteLine($"Error: Font not found for text layout '{text}'");
            return new SDL3TextLayout("", nint.Zero); // Return a dummy layout
        }

        var newLayout = new SDL3TextLayout(text, fontPtr);
        _textLayoutCache[layoutKey] = newLayout;
        return newLayout;
    }

    public void Cleanup()
    {
        Console.WriteLine("SDL3TextService Cleanup: Disposing cached resources...");
        // Close fonts for this specific instance's cache
        foreach (var fontPtr in _fontCache.Values)
        {
            if (fontPtr != nint.Zero)
            {
                TTF.CloseFont(fontPtr);
            }
        }
        _fontCache.Clear();
        _textLayoutCache.Clear();
        _textSizeCache.Clear();

        // TTF.Quit() is now handled globally by SDL3WindowHost
        Console.WriteLine("SDL3TextService Cleanup finished.");
    }
}
</file>

<file path="Backends\SDL3\SDL3WindowHost.cs">
using DirectUI.Core;
using DirectUI.Input;
using SDL3;
using Vortice.Mathematics;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI.Backends.SDL3;

public unsafe class SDL3WindowHost : IWindowHost, IModalWindowService
{
    private readonly string _title;
    private readonly int _initialWidth;
    private readonly int _initialHeight;
    private readonly Color4 _backgroundColor;

    private nint _windowPtr;
    private nint _rendererPtr;

    private AppEngine? _appEngine;
    private SDL3Renderer? _renderer;
    private SDL3TextService? _textService;
    private bool _isDisposed;

    private static int s_sdlInitCount = 0;
    private static int s_ttfInitCount = 0;

    private SDL3WindowHost? _activeModalWindow;
    private Action<UIContext>? _modalDrawCallback;
    private Action<int>? _onModalClosedCallback;
    private int _modalResultCode;
    private bool _isModalClosing;

    public IntPtr Handle => _windowPtr;
    public InputManager Input => _appEngine?.Input ?? new();
    public SizeI ClientSize
    {
        get
        {
            SDL.GetWindowSize(_windowPtr, out int w, out int h);
            return new SizeI(w, h);
        }
    }

    public bool ShowFpsCounter
    {
        get
        {
            return _appEngine?.ShowFpsCounter ?? false;
        }

        set
        {
            if (_appEngine is null)
            {
                return;
            }

            _appEngine.ShowFpsCounter = value;
        }
    }

    public IModalWindowService ModalWindowService => this;

    public SDL3WindowHost(string title, int width, int initialHeight, Color4 backgroundColor)
    {
        _title = title;
        _initialWidth = width;
        _initialHeight = initialHeight;
        _backgroundColor = backgroundColor;
    }

    public bool Initialize(Action<UIContext> uiDrawCallback, Color4 backgroundColor)
    {
        Console.WriteLine($"SDL3WindowHost initializing for '{_title}'...");
        
        try
        {
            Interlocked.Increment(ref s_sdlInitCount);
            
            if (s_sdlInitCount == 1)
            {
                if (!SDL.Init(SDL.InitFlags.Video))
                {
                    Console.WriteLine($"SDL could not initialize! SDL_Error: {SDL.GetError()}");
                    return false;
                }
            }

            Interlocked.Increment(ref s_ttfInitCount);
            
            if (s_ttfInitCount == 1)
            {
                if (!TTF.Init())
                {
                    Console.WriteLine($"SDL_ttf could not initialize! SDL_Error: {SDL.GetError()}");
                    return false;
                }
                SDL3TextService.RegisterDefaultFonts();
            }

            _windowPtr = SDL.CreateWindow(_title, _initialWidth, _initialHeight, SDL.WindowFlags.Resizable);

            if (_windowPtr == nint.Zero)
            {
                Console.WriteLine($"Window could not be created! SDL_Error: {SDL.GetError()}");
                return false;
            }

            _rendererPtr = SDL.CreateRenderer(_windowPtr, null);
            
            if (_rendererPtr == nint.Zero)
            {
                Console.WriteLine($"Renderer could not be created! SDL Error: {SDL.GetError()}");
                SDL.DestroyWindow(_windowPtr);
                return false;
            }

            _appEngine = new(uiDrawCallback, backgroundColor);
            _renderer = new(_rendererPtr, _windowPtr);
            _textService = new();
            _appEngine.Initialize(_textService, _renderer);

            Console.WriteLine($"SDL3WindowHost '{_title}' initialized successfully. (SDL_Init count: {s_sdlInitCount}, TTF_Init count: {s_ttfInitCount})");
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred during SDL3WindowHost initialization: {ex.Message}");
            Cleanup();
            return false;
        }
    }

    public void RunLoop()
    {
        bool running = true;

        while (running)
        {
            if (IsModalWindowOpen && _activeModalWindow is not null)
            {
                _activeModalWindow.ModalRunLoop();
                HandleModalLifecycle();
            }
            else
            {
                while (SDL.PollEvent(out SDL.Event ev))
                {
                    if (ev.Type == (uint)SDL.EventType.Quit)
                    {
                        running = false;
                        break;
                    }

                    Input.ProcessSDL3Event(ev);
                }

                RenderFrame();
            }
        }
    }

    private void ModalRunLoop()
    {
        bool modalRunning = true;
        
        while (modalRunning)
        {
            while (SDL.PollEvent(out SDL.Event ev))
            {
                if (ev.Type == (uint)SDL.EventType.Quit)
                {
                    modalRunning = false;
                    _modalResultCode = -1;
                    break;
                }
                else if (ev.Type == (uint)SDL.EventType.WindowCloseRequested)
                {
                    if (ev.Window.WindowID == SDL.GetWindowID(_windowPtr))
                    {
                        modalRunning = false;
                        _modalResultCode = -1;
                        break;
                    }
                }

                Input.ProcessSDL3Event(ev);
            }

            if (_isModalClosing)
            {
                modalRunning = false;
            }

            ModalRenderFrame();
        }

        _isModalClosing = true;
    }

    private void RenderFrame()
    {
        SDL.SetRenderDrawColor(_rendererPtr, (byte)(_backgroundColor.R * 255), (byte)(_backgroundColor.G * 255), (byte)(_backgroundColor.B * 255), (byte)(_backgroundColor.A * 255));
        SDL.RenderClear(_rendererPtr);

        if (_renderer is not null && _textService is not null && _appEngine is not null)
        {
            _appEngine.UpdateAndRender(_renderer, _textService);
        }

        SDL.RenderPresent(_rendererPtr);
    }

    private void ModalRenderFrame()
    {
        SDL.SetRenderDrawColor(_rendererPtr, (byte)(_backgroundColor.R * 255), (byte)(_backgroundColor.G * 255), (byte)(_backgroundColor.B * 255), (byte)(_backgroundColor.A * 255));
        SDL.RenderClear(_rendererPtr);

        if (_renderer is not null && _textService is not null && _appEngine is not null && _modalDrawCallback is not null)
        {
            _appEngine.UpdateAndRenderModal(_renderer, _textService, _modalDrawCallback);
        }

        SDL.RenderPresent(_rendererPtr);
    }

    public void Cleanup()
    {
        if (_isDisposed) return;
        Console.WriteLine($"SDL3WindowHost cleanup for '{_title}'...");

        _activeModalWindow?.Cleanup();

        _appEngine?.Cleanup();
        _renderer?.Cleanup();
        _textService?.Cleanup();

        if (_rendererPtr != nint.Zero)
        {
            SDL.DestroyRenderer(_rendererPtr);
            _rendererPtr = nint.Zero;
        }

        if (_windowPtr != nint.Zero)
        {
            SDL.DestroyWindow(_windowPtr);
            _windowPtr = nint.Zero;
        }

        Interlocked.Decrement(ref s_ttfInitCount);

        if (s_ttfInitCount == 0)
        {
            Console.WriteLine("Final TTF.Quit().");
            TTF.Quit();
        }

        Interlocked.Decrement(ref s_sdlInitCount);
        
        if (s_sdlInitCount == 0)
        {
            Console.WriteLine("Final SDL.Quit()..");
            SDL.Quit();
        }

        _isDisposed = true;
        
        GC.SuppressFinalize(this);
        Console.WriteLine($"SDL3WindowHost '{_title}' cleaned up. (SDL_Init count: {s_sdlInitCount}, TTF_Init count: {s_ttfInitCount})");
    }

    public void Dispose()
    {
        Cleanup();
    }

    public bool IsModalWindowOpen
    {
        get
        {
            return _activeModalWindow is not null;
        }
    }

    public void OpenModalWindow(string title, int width, int height, Action<UIContext> drawCallback, Action<int>? onClosedCallback = null)
    {
        if (_activeModalWindow is not null)
        {
            Console.WriteLine("Warning: Cannot open a new modal window while another is already active.");
            return;
        }

        _activeModalWindow = new SDL3WindowHost(title, width, height, _backgroundColor);
        _activeModalWindow._modalDrawCallback = drawCallback;
        _onModalClosedCallback = onClosedCallback;
        _modalResultCode = -1;

        if (!_activeModalWindow.InitializeModalInternal())
        {
            Console.WriteLine("Failed to initialize modal SDL window.");
            _activeModalWindow.Dispose();
            _activeModalWindow = null;
            onClosedCallback?.Invoke(-1);
            return;
        }

        if (!SDL.SetWindowParent(_activeModalWindow._windowPtr, _windowPtr))
        {
            Console.WriteLine($"Failed to set window parent: {SDL.GetError()}");
            _activeModalWindow.Dispose();
            _activeModalWindow = null;
            onClosedCallback?.Invoke(-1);
            return;
        }

        if (!SDL.SetWindowModal(_activeModalWindow._windowPtr, true))
        {
            Console.WriteLine($"Failed to set modal flag on window: {SDL.GetError()}");
            _activeModalWindow.Dispose();
            _activeModalWindow = null;
            onClosedCallback?.Invoke(-1);
            return;
        }

        Console.WriteLine("Modal window opened successfully.");
    }

    private bool InitializeModalInternal()
    {
        return Initialize(_modalDrawCallback!, _backgroundColor);
    }

    public void CloseModalWindow(int resultCode = 0)
    {
        if (_activeModalWindow is null)
        {
            return;
        }

        _activeModalWindow._modalResultCode = resultCode;
        _activeModalWindow._isModalClosing = true;
    }

    private void HandleModalLifecycle()
    {
        if (_activeModalWindow is null)
        {
            return;
        }

        if (!_activeModalWindow._isModalClosing)
        {
            return;
        }

        Console.WriteLine($"Modal window closed. Result: {_activeModalWindow._modalResultCode}");
        _onModalClosedCallback?.Invoke(_activeModalWindow._modalResultCode);

        if (_windowPtr != nint.Zero)
        {
            SDL.RaiseWindow(_windowPtr);
        }

        _activeModalWindow.Dispose();
        _activeModalWindow = null;
        _onModalClosedCallback = null;
        _modalResultCode = 0;
        _isModalClosing = false;
    }
}
</file>

<file path="Core\Interface\IAppLogic.cs">
namespace DirectUI.Core;

public interface IAppLogic
{
    void DrawUI(UIContext context);
}
</file>

<file path="Core\Interface\ILayoutContainer.cs">
using System.Numerics;

namespace DirectUI;

public interface ILayoutContainer
{
    Vector2 GetCurrentPosition();
    void Advance(Vector2 elementSize);
}
</file>

<file path="Core\Interface\IModalWindowService.cs">
// DirectUI/Core/IModalWindowService.cs
using System;
using Vortice.Mathematics;

namespace DirectUI.Core;

/// <summary>
/// Defines the contract for a service that can open modal windows.
/// This allows application UI logic to request a modal window without
/// knowing the underlying platform's windowing specifics.
/// </summary>
public interface IModalWindowService
{
    /// <summary>
    /// Opens a modal window with the specified properties.
    /// </summary>
    /// <param name="title">The title of the modal window.</param>
    /// <param name="width">The width of the modal window.</param>
    /// <param name="height">The height of the modal window.</param>
    /// <param name="drawCallback">The UI drawing logic for the content of the modal window.</param>
    /// <param name="onClosedCallback">An action to be invoked when the modal window is closed. Receives a result code (0 for success, non-zero for error/cancel).</param>
    void OpenModalWindow(string title, int width, int height, Action<UIContext> drawCallback, Action<int>? onClosedCallback = null);

    /// <summary>
    /// Closes the currently active modal window, if any, with a specified result code.
    /// </summary>
    /// <param name="resultCode">A code indicating the outcome of the modal interaction (e.g., 0 for OK, 1 for Cancel).</param>
    void CloseModalWindow(int resultCode = 0);

    /// <summary>
    /// Checks if a modal window is currently open.
    /// </summary>
    bool IsModalWindowOpen { get; }
}
</file>

<file path="Core\Interface\IRenderer.cs">
// DirectUI/Core/IRenderer.cs
using System.Numerics;
using DirectUI.Drawing;
using Vortice.Direct2D1; // Required for AntialiasMode
using Vortice.Mathematics;

namespace DirectUI.Core;

/// <summary>
/// Defines the abstract contract for a rendering backend.
/// The UI library uses this interface to issue all drawing commands.
/// </summary>
public interface IRenderer
{
    /// <summary>
    /// Gets the current size of the render target.
    /// </summary>
    Vector2 RenderTargetSize { get; }

    /// <summary>
    /// Draws a line between two points.
    /// </summary>
    void DrawLine(Vector2 p1, Vector2 p2, Color color, float strokeWidth);

    /// <summary>
    /// Draws a box with fill, border, and rounding based on a style.
    /// </summary>
    void DrawBox(Vortice.Mathematics.Rect rect, BoxStyle style);

    /// <summary>
    /// Draws text. The renderer is responsible for its own text layout and caching.
    /// </summary>
    void DrawText(Vector2 origin, string text, ButtonStyle style, Alignment alignment, Vector2 maxSize, Color color);

    /// <summary>
    /// Pushes a clipping rectangle onto the stack. All subsequent drawing will be clipped to this rectangle.
    /// </summary>
    void PushClipRect(Vortice.Mathematics.Rect rect, AntialiasMode antialiasMode = AntialiasMode.PerPrimitive);

    /// <summary>
    /// Pops the last clipping rectangle from the stack.
    /// </summary>
    void PopClipRect();

    /// <summary>
    /// Flushes any batched rendering commands, particularly for text.
    /// </summary>
    void Flush();
}
</file>

<file path="Core\Interface\ITextLayout.cs">
// DirectUI/Core/ITextLayout.cs
using System;
using System.Numerics;

namespace DirectUI.Core;

/// <summary>
/// Represents a block of text that has been fully processed for layout.
/// This is a backend-agnostic interface.
/// </summary>
public interface ITextLayout : IDisposable
{
    /// <summary>
    /// The final measured size of the laid-out text.
    /// </summary>
    Vector2 Size { get; }

    /// <summary>
    /// The original string content of this layout.
    /// </summary>
    string Text { get; }

    /// <summary>
    /// Retrieves the metrics for a glyph at a specific text position.
    /// </summary>
    /// <param name="textPosition">The zero-based index of the target character.</param>
    /// <param name="isTrailingHit">Indicates whether to measure the leading or trailing edge of the character.</param>
    /// <returns>Metrics describing the position and size of the specified character position.</returns>
    TextHitTestMetrics HitTestTextPosition(int textPosition, bool isTrailingHit);

    /// <summary>
    /// Performs a hit-test to determine which character position is at a given point.
    /// </summary>
    /// <param name="point">The point to test, relative to the layout's origin.</param>
    /// <returns>A result object containing the metrics and character position of the hit.</returns>
    TextHitTestResult HitTestPoint(Vector2 point);
}
</file>

<file path="Core\Interface\ITextService.cs">
// DirectUI/Core/ITextService.cs
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI.Core;

/// <summary>
/// Defines the abstract contract for text processing services like measurement and layout.
/// The UI library uses this to handle all font-related operations.
/// </summary>
public interface ITextService
{
    /// <summary>
    /// Measures the bounding box of a string given a specific style, without layout constraints.
    /// </summary>
    Vector2 MeasureText(string text, ButtonStyle style);

    /// <summary>
    /// Creates or retrieves a cached, fully formatted text layout object.
    /// </summary>
    ITextLayout GetTextLayout(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment);

    /// <summary>
    /// Cleans up any cached resources managed by the text service.
    /// </summary>
    void Cleanup();
}
</file>

<file path="Core\Interface\IWindowHost.cs">
// DirectUI/Core/IWindowHost.cs
using System;
using DirectUI.Input;
using Vortice.Mathematics;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI.Core;

/// <summary>
/// Defines the contract for a platform-specific window host that integrates with the DirectUI engine.
/// This interface abstracts window creation, main loop management, and exposes input and modal services.
/// </summary>
public interface IWindowHost : IDisposable
{
    /// <summary>
    /// Gets the native window handle, if applicable. Returns IntPtr.Zero otherwise.
    /// </summary>
    IntPtr Handle { get; }

    /// <summary>
    /// Provides access to the InputManager for the host to feed input events.
    /// </summary>
    InputManager Input { get; }

    /// <summary>
    /// Gets the current client size of the window.
    /// </summary>
    SizeI ClientSize { get; }

    /// <summary>
    /// Gets or sets whether the FPS counter should be displayed.
    /// </summary>
    bool ShowFpsCounter { get; set; }

    /// <summary>
    /// Provides access to a service for opening modal windows specific to this host's platform.
    /// </summary>
    IModalWindowService ModalWindowService { get; }

    /// <summary>
    /// Initializes the window host and the DirectUI engine.
    /// </summary>
    /// <param name="uiDrawCallback">The callback function that contains the application's UI drawing logic.</param>
    /// <param name="backgroundColor">The background color to clear the window with each frame.</param>
    /// <returns>True if initialization was successful, false otherwise.</returns>
    bool Initialize(Action<UIContext> uiDrawCallback, Color4 backgroundColor);

    /// <summary>
    /// Runs the platform-specific main message/event loop for the application.
    /// </summary>
    void RunLoop();

    /// <summary>
    /// Cleans up resources owned by the window host.
    /// </summary>
    void Cleanup();
}
</file>

<file path="InputBinding.cs">
namespace Cocoshell.Input;

public enum BindingType
{
    Keyboard,
    MouseButton
}

public class InputBinding
{
    // Property names match the YAML file keys (PascalCase)
    public BindingType Type { get; set; }
    public string KeyOrButton { get; set; } = string.Empty;
}
</file>

<file path="InputManager.cs">
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Cocoshell.Input;

public static class InputMapManager
{
    public static Dictionary<string, List<InputBinding>> Load(string filePath)
    {
        if (!File.Exists(filePath))
        {
            Console.WriteLine($"Warning: Input map file not found at '{filePath}'. Returning empty map.");
            return [];
        }

        try
        {
            var deserializer = new DeserializerBuilder()
                .WithNamingConvention(PascalCaseNamingConvention.Instance)
                .Build();

            string text = File.ReadAllText(filePath);
            var loadedMap = deserializer.Deserialize<Dictionary<string, List<InputBinding>>>(text);
            
            return loadedMap ?? [];
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error parsing input map file '{filePath}': {ex.Message}. Returning empty map.");
            return [];
        }
    }

    public static void Save(string filePath, Dictionary<string, List<InputBinding>> map)
    {
        try
        {
            var serializer = new SerializerBuilder()
                .WithNamingConvention(PascalCaseNamingConvention.Instance)
                .DisableAliases()
                .Build();
            
            string yaml = serializer.Serialize(map);
            
            File.WriteAllText(filePath, yaml);
            Console.WriteLine($"Successfully saved input map to '{filePath}'.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving input map file '{filePath}': {ex.Message}");
        }
    }
}
</file>

<file path="InputMapEditor.cs">
using System.Numerics;
using Cocoshell.Input;
using Vortice.Mathematics;
using DirectUI;
using DirectUI.Core;

namespace Cocoshell;

public class InputMapEditor
{
    private Dictionary<string, List<InputBinding>> _inputMap;
    private readonly string _inputMapPath;
    private bool _inputMapDirty = false;
    private int _newActionCounter = 1;
    private (string ActionName, int BindingIndex)? _listeningForBinding;
    private bool _ignoreInputForOneFrame;
    private readonly List<string> _actionNamesCache = new();
    private static readonly string[] s_bindingTypeNames = Enum.GetNames(typeof(BindingType));

    public InputMapEditor(string inputMapPath)
    {
        _inputMapPath = inputMapPath;
        _inputMap = LoadMap();
        UpdateActionNamesCache();
    }

    public bool IsDirty()
    {
        return _inputMapDirty;
    }

    public void RevertChanges()
    {
        _inputMap = LoadMap();
        UpdateActionNamesCache();
        _inputMapDirty = false;
    }

    public void SaveChanges()
    {
        InputMapManager.Save(_inputMapPath, _inputMap);
        _inputMapDirty = false;
    }

    public void Draw(UIContext context, Rect contentArea)
    {
        // --- Input Listening Logic ---
        HandleInputListening(context);

        var paddedContentRect = new Rect(
            contentArea.X + 10, contentArea.Y + 10,
            Math.Max(0, contentArea.Width - 20),
            Math.Max(0, contentArea.Height - 20)
        );

        string? actionToRemove = null;
        var scrollableSize = new Vector2(paddedContentRect.Width, paddedContentRect.Height - 40);

        // Outer VBox to hold the scroll region and the buttons below it
        UI.BeginVBoxContainer("input_map_vbox", paddedContentRect.TopLeft, 10);
        {
            // --- Scrollable list of actions and bindings ---
            UI.BeginScrollableRegion("input_map_scroll", scrollableSize, out _);
            UI.BeginVBoxContainer("input_map_scroll_content", UI.Context.Layout.GetCurrentPosition(), 8);
            {
                for (int i = 0; i < _actionNamesCache.Count; i++)
                {
                    string actionName = _actionNamesCache[i];
                    if (!_inputMap.TryGetValue(actionName, out var bindings)) continue;

                    string? removedAction = DrawInputMapAction(actionName, bindings);
                    if (removedAction != null)
                    {
                        actionToRemove = removedAction;
                    }
                }
            }
            UI.EndVBoxContainer();
            UI.EndScrollableRegion();

            if (actionToRemove != null)
            {
                _inputMap.Remove(actionToRemove);
                UpdateActionNamesCache();
                _inputMapDirty = true;
            }

            // --- Action Buttons (Add, Apply, Revert) ---
            DrawActionButtons();
        }
        UI.EndVBoxContainer();
    }

    private void HandleInputListening(UIContext context)
    {
        if (_ignoreInputForOneFrame)
        {
            _ignoreInputForOneFrame = false;
            return;
        }

        if (!_listeningForBinding.HasValue) return;

        var (actionName, bindingIndex) = _listeningForBinding.Value;
        var input = context.InputState;

        // Ensure the binding still exists before trying to modify it
        if (!_inputMap.TryGetValue(actionName, out var bindings) || bindingIndex >= bindings.Count)
        {
            _listeningForBinding = null;
            return;
        }

        InputBinding targetBinding = bindings[bindingIndex];
        bool inputWasBound = false;

        // Check for Keyboard Input
        if (input.PressedKeys.Count > 0)
        {
            targetBinding.Type = BindingType.Keyboard;
            targetBinding.KeyOrButton = input.PressedKeys[0].ToString();
            inputWasBound = true;
        }
        // Check for Mouse Input
        else if (input.PressedMouseButtons.Count > 0)
        {
            targetBinding.Type = BindingType.MouseButton;
            targetBinding.KeyOrButton = input.PressedMouseButtons[0].ToString();
            inputWasBound = true;
        }
        // Check if user clicked somewhere else to cancel
        else if (input.WasLeftMousePressedThisFrame || input.WasRightMousePressedThisFrame)
        {
            // This click didn't start a new binding listen, so it must be a cancel click.
            _listeningForBinding = null;
        }

        if (inputWasBound)
        {
            _inputMapDirty = true;
            _listeningForBinding = null; // Stop listening
        }
    }


    private string? DrawInputMapAction(string actionName, List<InputBinding> bindings)
    {
        string? actionToRemove = null;
        int bindingToRemove = -1;

        // --- Action Header (Name + Remove Button) ---
        UI.BeginHBoxContainer($"action_hbox_{actionName}", UI.Context.Layout.GetCurrentPosition(), 5);
        {
            UI.PushStyleColor(StyleColor.Button, Colors.Transparent);
            UI.PushStyleColor(StyleColor.TextDisabled, DefaultTheme.Text);
            UI.Button($"action_label_{actionName}", actionName, disabled: true, autoWidth: true);
            UI.PopStyleColor(2);

            UI.PushStyleVar(StyleVar.FrameRounding, 0.5f);
            UI.PushStyleColor(StyleColor.Button, new Color4(0.5f, 0.2f, 0.2f, 1f));
            if (UI.Button($"action_remove_{actionName}", "x", size: new Vector2(20, 20))) actionToRemove = actionName;
            UI.PopStyleColor();
            UI.PopStyleVar();
        }
        UI.EndHBoxContainer();

        // --- Indented VBox for bindings ---
        UI.BeginHBoxContainer($"bindings_outer_hbox_{actionName}", UI.Context.Layout.GetCurrentPosition(), 0);
        {
            UI.Button($"indent_spacer_{actionName}", "", size: new Vector2(20, 0), disabled: true); // Indent
            UI.BeginVBoxContainer($"bindings_vbox_{actionName}", UI.Context.Layout.GetCurrentPosition(), 5);
            {
                for (int j = 0; j < bindings.Count; j++)
                {
                    var binding = bindings[j];
                    UI.BeginHBoxContainer($"binding_hbox_{actionName}_{j}", UI.Context.Layout.GetCurrentPosition(), 5);
                    {
                        // Binding Type Combobox
                        int selectedIndex = (int)binding.Type;
                        if (UI.Combobox($"binding_type_{actionName}_{j}", ref selectedIndex, s_bindingTypeNames, new Vector2(100, 24)))
                        {
                            binding.Type = (BindingType)selectedIndex;
                            _inputMapDirty = true;
                        }

                        // Button to display binding and enter listening mode
                        string buttonText = binding.KeyOrButton;
                        bool isThisOneListening = _listeningForBinding.HasValue &&
                                                  _listeningForBinding.Value.ActionName == actionName &&
                                                  _listeningForBinding.Value.BindingIndex == j;

                        if (isThisOneListening)
                        {
                            buttonText = "Press a key...";
                        }

                        if (UI.Button($"binding_key_{actionName}_{j}", buttonText, new Vector2(150, 24)))
                        {
                            if (!isThisOneListening)
                            {
                                // Start listening for this binding
                                _listeningForBinding = (actionName, j);
                                _ignoreInputForOneFrame = true;
                            }
                            else
                            {
                                // If already listening, clicking again cancels
                                _listeningForBinding = null;
                            }
                        }

                        // Remove Binding Button
                        UI.PushStyleVar(StyleVar.FrameRounding, 0.5f);
                        UI.PushStyleColor(StyleColor.Button, new(0.5f, 0.2f, 0.2f, 1f));

                        if (UI.Button($"binding_remove_{actionName}_{j}", "x", size: new(24, 24)))
                        {
                            bindingToRemove = j;
                        }

                        UI.PopStyleColor();
                        UI.PopStyleVar();
                    }
                    UI.EndHBoxContainer();
                }

                if (bindingToRemove != -1)
                {
                    bindings.RemoveAt(bindingToRemove);
                    _inputMapDirty = true;
                }

                // "Add Binding" button for this action
                if (UI.Button($"add_binding_{actionName}", "Add Binding", size: new(100, 24)))
                {
                    bindings.Add(new()
                    {
                        Type = BindingType.Keyboard,
                        KeyOrButton = "None"
                    });

                    _inputMapDirty = true;
                }
            }
            UI.EndVBoxContainer();
        }
        UI.EndHBoxContainer();

        return actionToRemove;
    }

    private void DrawActionButtons()
    {
        UI.BeginHBoxContainer("input_map_actions", UI.Context.Layout.GetCurrentPosition(), 10);
        {
            UI.PushStyleVar(StyleVar.FrameRounding, 0.2f);
            UI.PushStyleColor(StyleColor.Button, DefaultTheme.NormalFill);
            UI.PushStyleColor(StyleColor.ButtonDisabled, DefaultTheme.DisabledFill);
            UI.PushStyleColor(StyleColor.TextDisabled, DefaultTheme.DisabledText);

            if (UI.Button("add_new_action", "Add New Action", autoWidth: true, textMargin: new Vector2(10, 5)))
            {
                string newActionName;

                do
                {
                    newActionName = $"NewAction_{_newActionCounter++}";
                }
                while (_inputMap.ContainsKey(newActionName));

                _inputMap[newActionName] = [];
                UpdateActionNamesCache();
                _inputMapDirty = true;
            }

            if (UI.Button("apply_changes", "Apply Changes", disabled: !_inputMapDirty, autoWidth: true, textMargin: new(10, 5)))
            {
                SaveChanges();
            }

            if (UI.Button("revert_changes", "Revert", autoWidth: true, textMargin: new(10, 5)))
            {
                RevertChanges();
            }

            UI.PopStyleColor(3);
            UI.PopStyleVar();
        }
        UI.EndHBoxContainer();
    }

    private Dictionary<string, List<InputBinding>> LoadMap()
    {
        try
        {
            return InputMapManager.Load(_inputMapPath);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load input map: {ex.Message}");
            return [];
        }
    }

    private void UpdateActionNamesCache()
    {
        _actionNamesCache.Clear();

        if (_inputMap is null)
        {
            return;
        }

        _actionNamesCache.AddRange(_inputMap.Keys);
    }
}
</file>

<file path="MyUILogic.cs">
// MyUILogic.cs
using System;
using System.Numerics;
using DirectUI.Backends;
using Vortice.Mathematics;
using DirectUI;
using DirectUI.Core;

namespace Cocoshell;

/// <summary>
/// This class encapsulates the actual UI logic and view management, decoupled from windowing.
/// It implements the IAppLogic interface.
/// </summary>
public class MyUILogic : IAppLogic
{
    // --- Constants ---
    private const float MenuBarHeight = 30f;
    private const float PanelPadding = 10f;
    private const float PanelGap = 10f;

    // --- State for layout ---
    private float _leftPanelWidth = 250f;
    private float _rightPanelWidth = 300f;
    private float _bottomPanelHeight = 150f;

    // --- Child Views ---
    private readonly MenuBarView _menuBarView;
    private readonly SceneTreeView _sceneTreeView;
    private readonly InspectorView _inspectorView;
    private readonly BottomPanelView _bottomPanelView;
    private readonly InputMapEditor _inputMapEditor; // Input map editor instance
    private readonly IModalWindowService _modalWindowService;

    // State for managing the modal "Project Settings" window
    private int _projectWindowActiveTab = 0;
    private static readonly string[] ProjectWindowTabLabels = { "General", "Input Map" };


    public Action OpenProjectWindowAction { get; } // Now just a wrapper for the modal service call

    public MyUILogic(IModalWindowService modalWindowService)
    {
        _modalWindowService = modalWindowService ?? throw new ArgumentNullException(nameof(modalWindowService));
        _menuBarView = new MenuBarView();
        _sceneTreeView = new SceneTreeView();
        _inspectorView = new InspectorView();
        _bottomPanelView = new BottomPanelView();
        _inputMapEditor = new InputMapEditor("input_map.yaml"); // Initialize here, if it's part of the app logic

        // Provide an action that calls the injected modal service.
        OpenProjectWindowAction = () => OpenProjectWindowInternal();
    }

    public void DrawUI(UIContext context)
    {
        if (context.Renderer is Direct2DRenderer d2dRenderer)
        {
            d2dRenderer.DrawCube();
            //Console.WriteLine("rendering cube");
        }

        _menuBarView.Draw(context, OpenProjectWindowAction);
        DrawMainLayoutPanels();

        // After drawing all panels, check if the bottom panel has signalled a scene change.
        if (_bottomPanelView.SelectedScenePath is not null)
        {
            _sceneTreeView.LoadScene(_bottomPanelView.SelectedScenePath);
        }
    }

    private void DrawMainLayoutPanels()
    {
        DrawLeftPanel();
        DrawRightPanel();
        DrawBottomPanel();
    }

    private void DrawLeftPanel()
    {
        var panelStyle = new BoxStyle { BorderLength = 1, Roundness = 0f };
        var padding = new Vector2(PanelPadding, PanelPadding);

        UI.BeginResizableVPanel("left_panel", ref _leftPanelWidth, HAlignment.Left, MenuBarHeight,
            minWidth: 150, maxWidth: 400, padding: padding, gap: PanelGap, panelStyle: panelStyle);

        _sceneTreeView.Draw();

        UI.EndResizableVPanel();
    }

    private void DrawRightPanel()
    {
        var panelStyle = new BoxStyle { BorderLength = 1, Roundness = 0f };
        var padding = new Vector2(PanelPadding, PanelPadding);

        // Calculate the available content height inside the panel for the inspector view.
        float panelContentHeight = UI.Context.Renderer.RenderTargetSize.Y - MenuBarHeight - (padding.Y * 2);

        UI.BeginResizableVPanel(
            "right_panel",
            ref _rightPanelWidth,
            HAlignment.Right,
            MenuBarHeight,
            minWidth: 150,
            maxWidth: 400,
            padding: padding,
            gap: 0,
            panelStyle: panelStyle);
        {
            _inspectorView.Draw(_sceneTreeView.SelectedNode, _rightPanelWidth, panelContentHeight);
        }
        UI.EndResizableVPanel();
    }

    private void DrawBottomPanel()
    {
        BoxStyle panelStyle = new() { BorderLength = 1, Roundness = 0f };
        Vector2 padding = new(PanelPadding, PanelPadding);

        UI.BeginResizableHPanel(
            "bottom_panel",
            ref _bottomPanelHeight,
            _leftPanelWidth,
            _rightPanelWidth,
            MenuBarHeight,
            minHeight: 50,
            maxHeight: 300,
            padding: padding,
            gap: PanelGap,
            panelStyle: panelStyle);
        {
            _bottomPanelView.Draw();
        }
        UI.EndResizableHPanel();
    }

    /// <summary>
    /// The drawing callback for the modal window.
    /// </summary>
    private void DrawProjectWindowUI(UIContext context)
    {
        var renderer = context.Renderer;
        float windowWidth = renderer.RenderTargetSize.X;
        float windowHeight = renderer.RenderTargetSize.Y;
        float tabBarHeight = 30f;
        var contentArea = new Rect(0, tabBarHeight, windowWidth, windowHeight - tabBarHeight);

        // --- Draw Tab Bar ---
        UI.TabBar("project_tabs", ProjectWindowTabLabels, ref _projectWindowActiveTab);

        // --- Draw Content Panel Background ---
        var panelStyle = new BoxStyle
        {
            FillColor = new(37 / 255f, 37 / 255f, 38 / 255f, 1.0f),
            BorderColor = DefaultTheme.HoverBorder,
            BorderLengthTop = 1f,
            Roundness = 0f
        };
        renderer.DrawBox(contentArea, panelStyle);

        // --- Draw Active Tab Content ---
        if (_projectWindowActiveTab == 0)
        {
            DrawGeneralSettingsTab(context, contentArea);
        }
        else if (_projectWindowActiveTab == 1)
        {
            _inputMapEditor.Draw(context, contentArea);
        }
    }

    private void DrawGeneralSettingsTab(UIContext context, Rect contentArea)
    {
        var contentPos = contentArea.TopLeft + new Vector2(10, 10);
        UI.BeginVBoxContainer("tab_general_vbox", contentPos, 10);
        if (UI.Button("modal_button_1", "A button in a modal")) { /* ... */ }
        if (UI.Button("modal_button_close", "Close Me"))
        {
            _modalWindowService.CloseModalWindow(0); // Signal the modal to close with success
        }
        UI.EndVBoxContainer();
    }

    /// <summary>
    /// Requests the host to open the project settings modal window.
    /// </summary>
    private void OpenProjectWindowInternal()
    {
        if (_modalWindowService.IsModalWindowOpen) return;

        _modalWindowService.OpenModalWindow(
            "Project Settings",
            600,
            400,
            DrawProjectWindowUI,
            (result) => {
                Console.WriteLine($"Project Settings Modal Closed with result: {result}");
                // If the modal was closed without explicitly saving (e.g., by X button), revert changes.
                if (result != 0 && _inputMapEditor.IsDirty())
                {
                    Console.WriteLine("Modal closed without saving. Reverting Input Map changes.");
                    _inputMapEditor.RevertChanges();
                }
            }
        );
    }
}
</file>

<file path="Program.cs">
using DirectUI;

namespace Cocoshell;

public class Program
{
    [STAThread]
    static void Main()
    {
        //var backend = GraphicsBackend.Raylib;
        var backend = GraphicsBackend.Direct2D;
        //var backend = GraphicsBackend.SDL3; // Set to SDL3 for testing

        ApplicationRunner.Run(backend, host => new MyUILogic(host.ModalWindowService));
    }
}
</file>

<file path="SceneNode.cs">
namespace Cocoshell;

public class SceneNode
{
    public string Name { get; set; } = "Unnamed";
    public string UserData { get; set; } = "";
    public bool IsExpanded { get; set; } = false;
    public List<SceneNode>? Children { get; set; }
}
</file>

<file path="SceneParser.cs">
using YamlDotNet.Serialization;
using DirectUI;

namespace Cocoshell;

public static class SceneParser
{
    public static TreeNode<string> Parse(string filePath)
    {
        var deserializer = new DeserializerBuilder().Build();
        var yamlData = deserializer.Deserialize<Dictionary<object, object>>(File.ReadAllText(filePath));

        return ConvertToTreeNode(ConvertDictionary(yamlData));
    }

    private static Dictionary<string, object> ConvertDictionary(Dictionary<object, object> dict)
    {
        Dictionary<string, object> newDict = [];

        foreach (KeyValuePair<object, object> kvp in dict)
        {
            if (kvp.Key is not string key)
            {
                continue;
            }

            newDict[key] = kvp.Value;
        }

        return newDict;
    }

    private static TreeNode<string> ConvertToTreeNode(Dictionary<string, object> nodeData)
    {
        if (!nodeData.TryGetValue("Node", out var nodeDescriptorObj) && !nodeData.TryGetValue("node", out nodeDescriptorObj))
        {
            throw new InvalidDataException("YAML node data is missing the 'Node' or 'node' key.");
        }

        string nodeDescriptor = nodeDescriptorObj.ToString();
        string[] parts = nodeDescriptor.Split(["::"], StringSplitOptions.None);
        string nodeName = parts.Length > 1 ? parts[1] : parts[0];
        string nodeType = parts[0];

        string userData = $"Type: {nodeType}";

        TreeNode<string> treeNode = new(nodeName, userData, false);

        if (!nodeData.TryGetValue("children", out var childrenObj) || childrenObj is not List<object> childrenList)
        {
            return treeNode;
        }

        if (childrenList.Count > 0)
        {
            treeNode.IsExpanded = true;
        }

        foreach (object childObj in childrenList)
        {
            if (childObj is not Dictionary<object, object> childDict)
            {
                continue;
            }

            Dictionary<string, object> stringKeyDict = ConvertDictionary(childDict);
            TreeNode<string> childTreeNode = ConvertToTreeNode(stringKeyDict);
            treeNode.Children.Add(childTreeNode);
        }

        return treeNode;
    }
}
</file>

<file path="Views\BottomPanelView.cs">
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Numerics;
using Vortice.Mathematics;
using DirectUI;

namespace Cocoshell;

public class BottomPanelView
{
    private readonly string _rootPath = @"D:\Parsa Stuff\Visual Studio\Cosmocrush\Cosmocrush\Res";
    private string _currentPath;
    private string? _pathToNavigateTo; // Used to defer navigation until after drawing

    private readonly List<string> _directories;
    private readonly List<string> _files;
    private string? _errorMessage;

    private readonly ButtonStylePack _folderIconStyle;
    private readonly ButtonStylePack _fileIconStyle;
    private readonly ButtonStyle _labelStyle;
    private readonly ButtonStyle _pathLabelStyle;

    public string? SelectedScenePath { get; private set; }

    public BottomPanelView()
    {
        _folderIconStyle = new ButtonStylePack { Roundness = 0.2f, BorderLength = 1f };
        _folderIconStyle.Normal.FillColor = new Color4(0.3f, 0.4f, 0.6f, 1f); // Blueish for folders
        _folderIconStyle.Hover.FillColor = new Color4(0.4f, 0.5f, 0.7f, 1f);
        _folderIconStyle.Pressed.FillColor = new Color4(0.5f, 0.6f, 0.8f, 1f);

        _fileIconStyle = new ButtonStylePack { Roundness = 0.2f, BorderLength = 1f };
        _fileIconStyle.Normal.FillColor = new Color4(0.4f, 0.4f, 0.4f, 1f); // Grey for files
        _fileIconStyle.Hover.FillColor = new Color4(0.5f, 0.5f, 0.5f, 1f);
        _fileIconStyle.Pressed.FillColor = new Color4(0.6f, 0.6f, 0.6f, 1f);

        _labelStyle = new ButtonStyle
        {
            FontColor = DefaultTheme.Text,
            FontSize = 12f // Corrected font size for labels to fit better
        };

        _pathLabelStyle = new ButtonStyle
        {
            FontColor = new Color4(0.7f, 0.7f, 0.7f, 1f),
            FontSize = 12f
        };

        _directories = new List<string>();
        _files = new List<string>();
        _currentPath = _rootPath;

        LoadDirectoryContents();
    }

    private void LoadDirectoryContents()
    {
        _directories.Clear();
        _files.Clear();
        _errorMessage = null;

        try
        {
            if (Directory.Exists(_currentPath))
            {
                // Add an "up" directory if we're not at the root
                if (Path.GetFullPath(_currentPath).TrimEnd('\\') != Path.GetFullPath(_rootPath).TrimEnd('\\'))
                {
                    _directories.Add("..");
                }

                _directories.AddRange(Directory.GetDirectories(_currentPath).Select(Path.GetFileName).Where(s => s is not null)!);
                _files.AddRange(Directory.GetFiles(_currentPath).Select(Path.GetFileName).Where(s => s is not null)!);

                // Keep ".." at the top, sort the rest
                var sortedDirs = _directories.Where(d => d != "..").OrderBy(d => d, StringComparer.OrdinalIgnoreCase).ToList();
                _directories.RemoveAll(d => d != "..");
                _directories.AddRange(sortedDirs);

                _files.Sort(StringComparer.OrdinalIgnoreCase);
            }
            else
            {
                _errorMessage = $"Path not found: {_currentPath}";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Error accessing path '{_currentPath}': {ex.Message}";
        }
    }

    private static string TruncatePathForDisplay(string path, int maxLength)
    {
        if (string.IsNullOrEmpty(path) || path.Length <= maxLength)
        {
            return path;
        }
        // A more robust truncation that handles short max lengths gracefully.
        if (maxLength <= 3)
        {
            return path.Substring(0, maxLength);
        }
        return "..." + path.Substring(path.Length - maxLength + 3);
    }

    public void Draw()
    {
        _pathToNavigateTo = null; // Reset deferred action at the start of the frame
        SelectedScenePath = null; // Reset selected scene path at start of frame

        var contentArea = UI.Context.Layout.GetCurrentClipRect();
        if (contentArea.Width <= 0 || contentArea.Height <= 0)
        {
            return;
        }

        UI.BeginVBoxContainer("bottom_panel_main_vbox", UI.Context.Layout.GetCurrentPosition(), 5);

        // Truncate the path label to a safe length before rendering.
        string displayPath = TruncatePathForDisplay(_currentPath, 60);
        UI.Text("current_path_label", displayPath, style: _pathLabelStyle);

        if (!string.IsNullOrEmpty(_errorMessage))
        {
            // Truncate the error message as well.
            string displayError = TruncatePathForDisplay(_errorMessage, 60);
            UI.Text("bottom_panel_error", displayError);
        }
        else
        {
            var scrollableSize = new Vector2(contentArea.Width, Math.Max(0, contentArea.Height - 30));
            UI.BeginScrollableRegion("bottom_panel_scroll", scrollableSize, out float innerWidth);
            {
                var gridStartPosition = UI.Context.Layout.GetCurrentPosition();
                var gridAvailableSize = new Vector2(innerWidth, 10000);
                var gridGap = new Vector2(16, 16);
                int numColumns = Math.Max(1, (int)(innerWidth / 90));

                UI.BeginGridContainer("bottom_panel_grid", gridStartPosition, gridAvailableSize, numColumns, gridGap);
                {
                    foreach (var dirName in _directories)
                    {
                        DrawFileSystemEntry(dirName, true);
                    }

                    foreach (var fileName in _files)
                    {
                        DrawFileSystemEntry(fileName, false);
                    }
                }
                UI.EndGridContainer();
            }
            UI.EndScrollableRegion();
        }

        // --- Deferred Action ---
        // After all drawing loops are complete, check if navigation was requested.
        // This prevents modifying the collection while it's being enumerated.
        if (_pathToNavigateTo != null)
        {
            _currentPath = _pathToNavigateTo;
            LoadDirectoryContents();
        }

        UI.EndVBoxContainer();
    }

    private void DrawFileSystemEntry(string name, bool isDirectory)
    {
        string id = (isDirectory ? "dir_" : "file_") + name;
        var iconSize = new Vector2(64, 64);
        var labelSize = new Vector2(iconSize.X + 10, 20); // Reduced height for smaller font

        UI.BeginVBoxContainer(id + "_vbox", UI.Context.Layout.GetCurrentPosition(), 4);
        {
            string iconText = isDirectory ? (name == ".." ? ".." : "D") : "F";
            var style = isDirectory ? _folderIconStyle : _fileIconStyle;

            if (UI.Button(id + "_icon", iconText, size: iconSize, theme: style))
            {
                if (isDirectory)
                {
                    if (name == "..")
                    {
                        var parentDir = Directory.GetParent(_currentPath);
                        if (parentDir != null)
                        {
                            _pathToNavigateTo = parentDir.FullName; // Defer navigation
                        }
                    }
                    else
                    {
                        _pathToNavigateTo = Path.Combine(_currentPath, name); // Defer navigation
                    }
                }
                else
                {
                    // If a file is clicked, check its extension.
                    if (Path.GetExtension(name).Equals(".yaml", StringComparison.OrdinalIgnoreCase))
                    {
                        SelectedScenePath = Path.Combine(_currentPath, name);
                    }
                }
            }

            // Truncate the display name before rendering to prevent buffer overflow.
            string displayName = TruncatePathForDisplay(name, 12);

            UI.Text(
                id + "_label",
                displayName, // Use the truncated name
                size: labelSize,
                style: _labelStyle,
                textAlignment: new Alignment(HAlignment.Center, VAlignment.Top)
            );
        }
        UI.EndVBoxContainer();
    }
}
</file>

<file path="Views\InspectorView.cs">
using System.Numerics;
using System.Reflection;
using System.Text;
using Cherris;
using Vortice.DirectWrite;
using DirectUI;
using ButtonStyle = DirectUI.ButtonStyle;
using HAlignment = DirectUI.HAlignment;
using VAlignment = DirectUI.VAlignment;

namespace Cocoshell;

public class InspectorView
{
    private const float PanelGap = 10f;
    private const float PanelPadding = 10f;
    private const float GridGap = 8f;

    private readonly ButtonStyle _titleStyle = new()
    {
        FontWeight = FontWeight.SemiBold,
        FontSize = 28f
    };

    private readonly ButtonStyle _propertyLabelStyle = new()
    {
        FontSize = 13f,
        FontWeight = FontWeight.Normal,
        FontColor = new(0.8f, 0.8f, 0.8f, 1.0f)
    };

    private class Vector2EditState
    {
        public string X { get; set; } = "0";
        public string Y { get; set; } = "0";
    }

    public void Draw(Node? selectedNode, float panelWidth, float panelHeight)
    {
        float availableContentWidth = panelWidth - (PanelPadding * 2);
        var startPos = UI.Context.Layout.GetCurrentPosition();

        UI.BeginVBoxContainer("inspector_outer_vbox", startPos, PanelGap);
        {
            DrawHeader(availableContentWidth);
            UI.Separator(availableContentWidth, thickness: 1f, verticalPadding: 4f);

            var currentPos = UI.Context.Layout.GetCurrentPosition();
            var heightUsed = currentPos.Y - startPos.Y;
            var scrollableHeight = panelHeight - heightUsed;


            if (scrollableHeight < 0)
            {
                scrollableHeight = 0;
            }

            Vector2 scrollableSize = new(availableContentWidth, scrollableHeight);

            UI.BeginScrollableRegion("inspector_scroll", scrollableSize, out float innerContentWidth);
            {
                if (selectedNode is null)
                {
                    UI.BeginVBoxContainer("inspector_content_vbox", UI.Context.Layout.GetCurrentPosition(), 8f);
                    UI.Button("no_selection_label", "No node selected.", disabled: true, autoWidth: true);
                    UI.EndVBoxContainer();
                }
                else
                {
                    UI.BeginVBoxContainer("inspector_properties_vbox", UI.Context.Layout.GetCurrentPosition(), 8f);
                    {
                        DrawAllProperties(selectedNode, innerContentWidth);
                    }
                    UI.EndVBoxContainer();
                }
            }
            UI.EndScrollableRegion();
        }
        UI.EndVBoxContainer();
    }

    private void DrawHeader(float availableWidth)
    {
        UI.Text(
            "inspector_title",
            "",
            size: new(availableWidth, 0),
            style: _titleStyle,
            textAlignment: new(HAlignment.Center, VAlignment.Center)
        );
    }

    private void DrawAllProperties(Node selectedNode, float availableWidth)
    {
        Type? currentType = selectedNode.GetType();
        bool isFirstGroup = true;

        var classHeaderStyle = new ButtonStyle
        {
            FontWeight = FontWeight.Bold,
            FontSize = 13f
        };

        while (currentType != null && typeof(Node).IsAssignableFrom(currentType))
        {
            var properties = currentType
                .GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)
                .Where(p => p.CanRead &&
                            p.GetIndexParameters().Length == 0 &&
                            !p.IsDefined(typeof(HideFromInspectorAttribute), false))
                .ToList();

            if (properties.Any())
            {
                if (!isFirstGroup)
                {
                    // Add separator BEFORE the group, but not for the first one.
                    UI.Separator(availableWidth, thickness: 1f, verticalPadding: 8f);
                }

                UI.Text(
                    $"header_{currentType.Name}",
                    currentType.Name,
                    style: classHeaderStyle,
                    size: new(availableWidth, 0),
                    textAlignment: new Alignment(HAlignment.Center, VAlignment.Center)
                );


                foreach (var prop in properties)
                {
                    DrawPropertyRow(selectedNode, prop, availableWidth);
                }

                isFirstGroup = false;
            }

            currentType = currentType.BaseType;
        }
    }

    private void DrawPropertyRow(Node node, PropertyInfo prop, float availableWidth)
    {
        float labelWidth = (availableWidth - GridGap) * 0.4f;
        float editorWidth = (availableWidth - GridGap) * 0.6f;
        string hboxId = $"hbox_prop_{node.Name}_{prop.Name}";
        object? value;

        try
        {
            value = prop.GetValue(node, null);
        }
        catch (Exception ex)
        {
            UI.Text($"prop_error_{prop.Name}", $"Error getting value: {ex.Message}");
            return;
        }

        UI.BeginHBoxContainer(hboxId, UI.Context.Layout.GetCurrentPosition(), GridGap);

        try
        {
            UI.Text(
                $"prop_label_{prop.Name}",
                SplitPascalCase(prop.Name),
                size: new(labelWidth, 24),
                style: _propertyLabelStyle,
                textAlignment: new(HAlignment.Left, VAlignment.Center)
            );

            DrawPropertyEditor(node, prop, value, editorWidth);
        }
        finally
        {
            UI.EndHBoxContainer();
        }
    }

    private static void DrawPropertyEditor(Node node, PropertyInfo prop, object? value, float editorWidth)
    {
        string propId = $"prop_value_{prop.Name}";
        var lineEditSize = new Vector2(editorWidth, 24); // Default size for editors

        if (prop.PropertyType.IsEnum && prop.CanWrite)
        {
            string[] enumNames = Enum.GetNames(prop.PropertyType);
            int selectedIndex = Array.IndexOf(enumNames, value?.ToString());
            if (selectedIndex == -1) selectedIndex = 0; // Default to first if not found

            if (UI.Combobox(propId, ref selectedIndex, enumNames, lineEditSize))
            {
                object? newValue = Enum.ToObject(prop.PropertyType, selectedIndex);
                prop.SetValue(node, newValue);
            }
        }
        else
        {
            switch (value)
            {
                case bool b when prop.CanWrite:
                    bool isChecked = b;
                    if (UI.Checkbox(propId, "", ref isChecked, size: new Vector2(0, 24)))
                    {
                        prop.SetValue(node, isChecked);
                    }
                    break;

                case Vector2 v:
                    if (prop.CanWrite)
                    {
                        DrawVector2Editor(node, prop, v, propId, editorWidth);
                    }
                    else
                    {
                        UI.Button($"{propId}_display", $"X:{v.X:F2}, Y:{v.Y:F2}", size: new(editorWidth, 24), disabled: true);
                    }
                    break;

                default:
                    string defaultString = value?.ToString() ?? "null";
                    UI.Button($"{propId}_display", defaultString, size: new(editorWidth, 24), disabled: true);
                    break;
            }
        }
    }

    private static void DrawVector2Editor(Node node, PropertyInfo prop, Vector2 value, string baseId, float editorWidth)
    {
        string xId = $"{baseId}_X";
        string yId = $"{baseId}_Y";
        int xIntId = xId.GetHashCode();
        int yIntId = yId.GetHashCode();

        int stateId = HashCode.Combine(node.GetHashCode(), prop.Name.GetHashCode());
        var editState = UI.State.GetOrCreateElement<Vector2EditState>(stateId);

        bool isXFocused = UI.State.FocusedElementId == xIntId;
        bool isYFocused = UI.State.FocusedElementId == yIntId;

        if (!isXFocused)
        {
            if (!float.TryParse(editState.X, out var parsedX) || float.Abs(parsedX - value.X) > 1e-4f)
            {
                editState.X = value.X.ToString("F3");
            }
        }
        if (!isYFocused)
        {
            if (!float.TryParse(editState.Y, out var parsedY) || float.Abs(parsedY - value.Y) > 1e-4f)
            {
                editState.Y = value.Y.ToString("F3");
            }
        }

        UI.BeginHBoxContainer(baseId + "_hbox", UI.Context.Layout.GetCurrentPosition(), 5);
        {
            float lineEditWidth = Math.Max(0, (editorWidth - 5) / 2);
            var lineEditSize = new Vector2(lineEditWidth, 24);

            string localX = editState.X;

            if (UI.InputText(xId, ref localX, lineEditSize))
            {
                editState.X = localX;
                if (float.TryParse(editState.X, out var newX))
                {
                    prop.SetValue(node, new Vector2(newX, value.Y));
                }
            }

            var currentValue = (Vector2)prop.GetValue(node)!;

            string localY = editState.Y;

            if (UI.InputText(yId, ref localY, lineEditSize))
            {
                editState.Y = localY;

                if (float.TryParse(editState.Y, out var newY))
                {
                    prop.SetValue(node, new Vector2(currentValue.X, newY));
                }
            }
        }

        UI.EndHBoxContainer();
    }

    private static string SplitPascalCase(string input)
    {
        if (string.IsNullOrEmpty(input))
        {
            return input;
        }

        StringBuilder result = new();

        result.Append(input[0]);

        for (int i = 1; i < input.Length; i++)
        {
            if (char.IsUpper(input[i]))
            {
                result.Append(' ');
            }

            result.Append(input[i]);
        }

        return result.ToString();
    }
}
</file>

<file path="Views\MainView.cs">
// Views/MainView.cs
using System;
using System.Numerics;
using Vortice.Mathematics;
using DirectUI;

namespace Cocoshell;

public class MainView
{
    // --- Constants ---
    private const float MenuBarHeight = 30f;
    private const float PanelPadding = 10f;
    private const float PanelGap = 10f;

    // --- State for layout ---
    private float _leftPanelWidth = 250f;
    private float _rightPanelWidth = 300f;
    private float _bottomPanelHeight = 150f;

    // --- Child Views ---
    private readonly MenuBarView _menuBarView;
    private readonly SceneTreeView _sceneTreeView;
    private readonly InspectorView _inspectorView;
    private readonly BottomPanelView _bottomPanelView;

    public MainView()
    {
        _menuBarView = new MenuBarView();
        _sceneTreeView = new SceneTreeView();
        _inspectorView = new InspectorView();
        _bottomPanelView = new BottomPanelView();
    }

    public void Draw(UIContext context, Action openProjectWindowAction)
    {
        _menuBarView.Draw(context, openProjectWindowAction);
        DrawMainLayoutPanels();

        // After drawing all panels, check if the bottom panel has signalled a scene change.
        if (_bottomPanelView.SelectedScenePath is not null)
        {
            _sceneTreeView.LoadScene(_bottomPanelView.SelectedScenePath);
        }
    }

    private void DrawMainLayoutPanels()
    {
        DrawLeftPanel();
        DrawRightPanel();
        DrawBottomPanel();
    }

    private void DrawLeftPanel()
    {
        var panelStyle = new BoxStyle { BorderLength = 1, Roundness = 0f };
        var padding = new Vector2(PanelPadding, PanelPadding);

        UI.BeginResizableVPanel("left_panel", ref _leftPanelWidth, HAlignment.Left, MenuBarHeight,
            minWidth: 150, maxWidth: 400, padding: padding, gap: PanelGap, panelStyle: panelStyle);

        _sceneTreeView.Draw();

        UI.EndResizableVPanel();
    }

    private void DrawRightPanel()
    {
        var panelStyle = new BoxStyle { BorderLength = 1, Roundness = 0f };
        var padding = new Vector2(PanelPadding, PanelPadding);

        // Calculate the available content height inside the panel for the inspector view.
        float panelContentHeight = UI.Context.Renderer.RenderTargetSize.Y - MenuBarHeight - (padding.Y * 2);

        UI.BeginResizableVPanel(
            "right_panel",
            ref _rightPanelWidth,
            HAlignment.Right,
            MenuBarHeight,
            minWidth: 150,
            maxWidth: 400,
            padding: padding,
            gap: 0,
            panelStyle: panelStyle);
        {
            _inspectorView.Draw(_sceneTreeView.SelectedNode, _rightPanelWidth, panelContentHeight);
        }
        UI.EndResizableVPanel();
    }

    private void DrawBottomPanel()
    {
        BoxStyle panelStyle = new() { BorderLength = 1, Roundness = 0f };
        Vector2 padding = new(PanelPadding, PanelPadding);

        UI.BeginResizableHPanel(
            "bottom_panel",
            ref _bottomPanelHeight,
            _leftPanelWidth,
            _rightPanelWidth,
            MenuBarHeight,
            minHeight: 50,
            maxHeight: 300,
            padding: padding,
            gap: PanelGap,
            panelStyle: panelStyle);
        {
            _bottomPanelView.Draw();
        }
        UI.EndResizableHPanel();
    }
}
</file>

<file path="Views\MenuBarView.cs">
using System;
using System.Numerics;
using Vortice.Mathematics;
using DirectUI;

namespace Cocoshell;

public class MenuBarView
{
    private const float MenuBarHeight = 30f;

    public void Draw(UIContext context, Action openProjectWindowAction)
    {
        var renderer = context.Renderer;

        // Use renderer's GetOrCreateBrush and DrawBox/DrawLine methods
        var menuBarBackgroundBrushColor = new Color4(37 / 255f, 37 / 255f, 38 / 255f, 1f);
        var menuBarBorderColor = DefaultTheme.NormalBorder;

        renderer.DrawBox(new Rect(0, 0, renderer.RenderTargetSize.X, MenuBarHeight), new BoxStyle { FillColor = menuBarBackgroundBrushColor, Roundness = 0f, BorderLength = 0f });
        renderer.DrawLine(new Vector2(0, MenuBarHeight - 1), new Vector2(renderer.RenderTargetSize.X, MenuBarHeight - 1), menuBarBorderColor, 1f);

        // Define a shared style for all menu buttons
        UI.PushStyleVar(StyleVar.FrameRounding, 0.0f);
        UI.PushStyleVar(StyleVar.FrameBorderSize, 0.0f);
        UI.PushStyleColor(StyleColor.Button, Colors.Transparent);
        UI.PushStyleColor(StyleColor.ButtonHovered, new Color4(63 / 255f, 63 / 255f, 70 / 255f, 1f));
        UI.PushStyleColor(StyleColor.ButtonPressed, DefaultTheme.Accent);
        UI.PushStyleColor(StyleColor.Text, new Color4(204 / 255f, 204 / 255f, 204 / 255f, 1f));

        UI.BeginHBoxContainer("menu_bar", new Vector2(5, 0), 0);
        {
            if (MenuBarButton("file_button", "File"))
            {

            }

            if (MenuBarButton("project_button", "Project"))
            {
                openProjectWindowAction?.Invoke();
            }

            if (MenuBarButton("edit_button", "Edit"))
            {

            }

            if (MenuBarButton("view_button", "View"))
            {

            }

            if (MenuBarButton("help_button", "Help"))
            {

            }
        }
        UI.EndHBoxContainer();

        UI.PopStyleColor(4);
        UI.PopStyleVar(2);
    }

    private static bool MenuBarButton(string id, string text)
    {
        return UI.Button(
            id,
            text,
            size: new(0, MenuBarHeight),
            autoWidth: true,
            textMargin: new(10, 0),
            textAlignment: new(HAlignment.Center, VAlignment.Center));
    }
}
</file>

<file path="Views\SceneTreeView.cs">
using Cherris;
using DirectUI;

namespace Cocoshell;

public class SceneTreeView
{
    private TreeNode<Node> _uiTreeRoot;
    private readonly TreeStyle _treeStyle = new();

    public Node? SelectedNode { get; private set; }

    public SceneTreeView()
    {
        string defaultScenePath = @"D:\Parsa Stuff\Visual Studio\Cosmocrush\Cosmocrush\Res\Scenes\Menu\Menu.yaml";
        LoadScene(defaultScenePath);
        // _uiTreeRoot is initialized by LoadScene
    }

    public void LoadScene(string scenePath)
    {
        try
        {
            if (File.Exists(scenePath))
            {
                // Use the Cherris engine's PackedScene loader
                var packedScene = new PackedScene(scenePath);
                Node sceneRoot = packedScene.Instantiate<Node>(); // Instantiate the actual scene graph
                _uiTreeRoot = ConvertToUITree(sceneRoot); // Create a UI representation
            }
            else
            {
                _uiTreeRoot = CreateDefaultTree("Scene file not found", scenePath);
            }
        }
        catch (Exception ex)
        {
            _uiTreeRoot = CreateDefaultTree($"Error parsing scene: {ex.Message}", scenePath);
        }

        SelectedNode = null; // Reset selection when loading a new scene
    }

    private TreeNode<Node> ConvertToUITree(Node root)
    {
        // The UI TreeNode stores the actual Cherris.Node in its UserData property.
        var uiRoot = new TreeNode<Node>(root.Name, root, root.Children.Any());
        foreach (var child in root.Children)
        {
            uiRoot.AddChild(ConvertToUITree(child));
        }
        return uiRoot;
    }

    public void Draw()
    {
        if (_uiTreeRoot is null) return;

        UI.BeginVBoxContainer("tree_vbox", UI.Context.Layout.GetCurrentPosition(), 0);
        UI.Tree("file_tree", _uiTreeRoot, out var clickedNode, _treeStyle);
        if (clickedNode is not null)
        {
            // When a node is clicked in the UI, we get the real Cherris.Node from its UserData.
            SelectedNode = clickedNode.UserData;
        }
        UI.EndVBoxContainer();
    }

    private static TreeNode<Node> CreateDefaultTree(string reason, string path)
    {
        var errorNode = new Node { Name = reason };
        var root = new TreeNode<Node>("Error", errorNode, true);

        var reasonNode = new Node { Name = reason };
        root.AddChild(reason, reasonNode);

        if (!string.IsNullOrEmpty(path))
        {
            var pathNode = new Node { Name = $"Path: {path}" };
            root.AddChild($"Path: {path}", pathNode);
        }

        return root;
    }
}
</file>

