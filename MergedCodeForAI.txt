<file path="Alignment.cs">
// Alignment.cs
namespace DirectUI;

public enum HAlignment { Left, Center, Right }
public enum VAlignment { Top, Center, Bottom }

public struct Alignment(HAlignment horizontal, VAlignment vertical)
{
    public HAlignment Horizontal { get; set; } = horizontal;
    public VAlignment Vertical { get; set; } = vertical;
}
</file>

<file path="AppHost.cs">
// AppHost.cs
using System;
using System.Numerics;
using DirectUI.Diagnostics;
using Vortice.Mathematics;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI;

/// <summary>
/// Manages the application's rendering lifecycle, graphics device, and input state aggregation.
/// This class acts as the "engine" that is hosted by a window.
/// </summary>
public class AppHost
{
    private readonly Action<UIContext> _drawCallback;
    private readonly Color4 _backgroundColor;
    private readonly FpsCounter _fpsCounter;

    private GraphicsDevice? _graphicsDevice;
    private IntPtr _hwnd;

    // Input state
    private Vector2 _currentMousePos = new(-1, -1);
    private bool _isLeftMouseButtonDown = false;
    private bool _wasLeftMouseClickedThisFrame = false;

    public AppHost(Action<UIContext> drawCallback, Color4 backgroundColor)
    {
        _drawCallback = drawCallback ?? throw new ArgumentNullException(nameof(drawCallback));
        _backgroundColor = backgroundColor;
        _fpsCounter = new FpsCounter();
    }

    public bool Initialize(IntPtr hwnd, SizeI clientSize)
    {
        _hwnd = hwnd;
        if (_graphicsDevice?.IsInitialized ?? false) return true;
        if (_hwnd == IntPtr.Zero) return false;

        _graphicsDevice ??= new GraphicsDevice();

        if (_graphicsDevice.Initialize(_hwnd, clientSize))
        {
            _fpsCounter.Initialize(_graphicsDevice.RenderTarget!, _graphicsDevice.DWriteFactory!);
            return true;
        }

        return false;
    }

    public void Cleanup()
    {
        _fpsCounter.Cleanup();
        UI.CleanupResources();
        _graphicsDevice?.Cleanup();
    }

    public void Resize(SizeI newSize)
    {
        if (_graphicsDevice?.IsInitialized ?? false)
        {
            _graphicsDevice.Resize(newSize);

            if (_graphicsDevice.IsInitialized)
            {
                _fpsCounter.HandleResize(_graphicsDevice.RenderTarget!);
            }
        }
        else if (_hwnd != IntPtr.Zero)
        {
            Initialize(_hwnd, GetClientRectSizeForHost());
        }
    }

    public void UpdateFpsState()
    {
        _fpsCounter.Update();
    }

    public void Render()
    {
        // Prevent re-entrant rendering calls, which can happen if a new window
        // is created and painted synchronously inside another window's render loop.
        if (UI.IsRendering) return;

        if (!(_graphicsDevice?.IsInitialized ?? false))
        {
            if (!Initialize(_hwnd, GetClientRectSizeForHost()))
            {
                _wasLeftMouseClickedThisFrame = false;
                return;
            }
        }

        _graphicsDevice!.BeginDraw();

        var rt = _graphicsDevice.RenderTarget!;
        var dwrite = _graphicsDevice.DWriteFactory!;

        try
        {
            rt.Clear(_backgroundColor);

            var inputState = new InputState(
                _currentMousePos,
                _wasLeftMouseClickedThisFrame,
                _isLeftMouseButtonDown
            );

            var uiContext = new UIContext(rt, dwrite, inputState);
            UI.BeginFrame(uiContext);

            _drawCallback(uiContext);

            UI.EndFrame();

            _fpsCounter.Draw(rt);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred during drawing: {ex}");
            _graphicsDevice.Cleanup();
        }
        finally
        {
            _graphicsDevice.EndDraw();
            _wasLeftMouseClickedThisFrame = false;
        }
    }

    private SizeI GetClientRectSizeForHost()
    {
        if (_hwnd != IntPtr.Zero && NativeMethods.GetClientRect(_hwnd, out NativeMethods.RECT r))
        {
            int width = Math.Max(1, r.right - r.left);
            int height = Math.Max(1, r.bottom - r.top);
            return new SizeI(width, height);
        }
        // Fallback for when the handle is not yet valid during initialization.
        // This size isn't critical as resize will be called immediately after.
        return new SizeI(1, 1);
    }

    public void SetMousePosition(int x, int y)
    {
        _currentMousePos = new Vector2(x, y);
    }

    public void SetMouseDown(MouseButton button)
    {
        if (button == MouseButton.Left)
        {
            _isLeftMouseButtonDown = true;
            _wasLeftMouseClickedThisFrame = true;
        }
    }

    public void SetMouseUp(MouseButton button)
    {
        if (button == MouseButton.Left)
        {
            _isLeftMouseButtonDown = false;
        }
    }
}
</file>

<file path="Application.cs">
using System;
using System.Collections.Generic;

namespace DirectUI;

/// <summary>
/// Manages the application's global message loop and window collection.
/// </summary>
public static class Application
{
    private static readonly List<Win32Window> s_windows = new();
    private static bool s_isRunning = false;

    /// <summary>
    /// Registers a window with the application manager. Called by Win32Window's constructor.
    /// </summary>
    public static void RegisterWindow(Win32Window window)
    {
        if (!s_windows.Contains(window))
        {
            s_windows.Add(window);
        }
    }

    /// <summary>
    /// Unregisters a window. Called when a window is destroyed.
    /// </summary>
    public static void UnregisterWindow(Win32Window window)
    {
        s_windows.Remove(window);
        // If the last window is closed, exit the application.
        if (s_windows.Count == 0)
        {
            Exit();
        }
    }

    /// <summary>
    /// Starts and runs the main application message loop.
    /// </summary>
    public static void Run()
    {
        if (s_windows.Count == 0)
        {
            Console.WriteLine("Application.Run() called with no windows registered.");
            return;
        }

        s_isRunning = true;
        while (s_isRunning)
        {
            ProcessMessages();

            if (!s_isRunning) break;

            // Create a copy for safe iteration, as windows can be closed (and removed) during the loop.
            var windowsToUpdate = new List<Win32Window>(s_windows);
            foreach (var window in windowsToUpdate)
            {
                if (window.Handle != IntPtr.Zero)
                {
                    window.FrameUpdate();
                }
            }
        }
    }

    /// <summary>
    /// Processes all pending window messages in the queue.
    /// </summary>
    private static void ProcessMessages()
    {
        while (NativeMethods.PeekMessage(out var msg, IntPtr.Zero, 0, 0, NativeMethods.PM_REMOVE))
        {
            if (msg.message == NativeMethods.WM_QUIT)
            {
                s_isRunning = false;
                break;
            }

            NativeMethods.TranslateMessage(ref msg);
            NativeMethods.DispatchMessage(ref msg);
        }
    }

    /// <summary>
    /// Signals the application to exit its message loop.
    /// </summary>
    public static void Exit()
    {
        if (s_isRunning)
        {
            s_isRunning = false;
            // Post a quit message to ensure the loop breaks out of GetMessage if it's blocking.
            NativeMethods.PostQuitMessage(0);
        }
    }
}
</file>

<file path="Direct2DAppWindow.cs">
// Direct2DAppWindow.cs
using System;
using System.Numerics;
using Vortice.Mathematics;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI;

public abstract class Direct2DAppWindow : Win32Window
{
    private AppHost? _appHost;

    protected Direct2DAppWindow(string title = "Vortice DirectUI Base Window", int width = 800, int height = 600)
        : base(title, width, height)
    {
    }

    /// <summary>
    /// Factory method for the derived class to create its specific AppHost.
    /// The AppHost contains the rendering logic and graphics resources.
    /// </summary>
    protected abstract AppHost CreateAppHost();

    protected override bool Initialize()
    {
        Console.WriteLine("Direct2DAppWindow initializing...");
        _appHost = CreateAppHost();
        return _appHost.Initialize(Handle, GetClientRectSize());
    }

    protected override void Cleanup()
    {
        Console.WriteLine("Direct2DAppWindow cleaning up its resources...");
        _appHost?.Cleanup();
        _appHost = null;
    }

    protected override void OnPaint()
    {
        _appHost?.Render();
    }

    public override void FrameUpdate()
    {
        _appHost?.UpdateFpsState();
        Invalidate(); // Always invalidate to trigger a paint message for a continuous render loop.
    }

    protected override void OnSize(int width, int height)
    {
        _appHost?.Resize(new SizeI(width, height));
    }

    protected override void OnMouseMove(int x, int y)
    {
        _appHost?.SetMousePosition(x, y);
        Invalidate();
    }

    protected override void OnMouseDown(MouseButton button, int x, int y)
    {
        _appHost?.SetMousePosition(x, y); // Update position on click
        _appHost?.SetMouseDown(button);
        Invalidate();
    }

    protected override void OnMouseUp(MouseButton button, int x, int y)
    {
        _appHost?.SetMousePosition(x, y); // Update position on release
        _appHost?.SetMouseUp(button);
        Invalidate();
    }

    protected override void OnKeyDown(int keyCode)
    {
        if (keyCode == NativeMethods.VK_ESCAPE)
        {
            Close();
        }
        Invalidate();
    }

    protected override bool OnClose() { return true; }

    protected SizeI GetClientRectSize()
    {
        if (Handle != nint.Zero && NativeMethods.GetClientRect(Handle, out NativeMethods.RECT r))
        {
            int width = Math.Max(1, r.right - r.left);
            int height = Math.Max(1, r.bottom - r.top);
            return new SizeI(width, height);
        }
        int baseWidth = Math.Max(1, Width);
        int baseHeight = Math.Max(1, Height);
        if (Handle != nint.Zero)
        {
            Console.WriteLine($"GetClientRect failed. Falling back to stored size: {baseWidth}x{baseHeight}");
        }
        return new SizeI(baseWidth, baseHeight);
    }
}
</file>

<file path="DrawingContext.cs">
using Vortice.Direct2D1;
using Vortice.DirectWrite;

namespace DirectUI;

public readonly struct DrawingContext
{
    public readonly ID2D1HwndRenderTarget RenderTarget;
    public readonly IDWriteFactory DWriteFactory;

    public DrawingContext(ID2D1HwndRenderTarget renderTarget, IDWriteFactory dwriteFactory)
    {
        RenderTarget = renderTarget;
        DWriteFactory = dwriteFactory;
    }
}
</file>

<file path="GraphicsDevice.cs">
// GraphicsDevice.cs
using System;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.DXGI;
using SharpGen.Runtime;
using Vortice.Mathematics;
using Vortice.DCommon;
using D2D = Vortice.Direct2D1;
using DW = Vortice.DirectWrite;
using D2DFactoryType = Vortice.Direct2D1.FactoryType;
using SizeI = Vortice.Mathematics.SizeI;

namespace DirectUI;

public class GraphicsDevice : IDisposable
{
    public ID2D1Factory1? D2DFactory { get; private set; }
    public IDWriteFactory? DWriteFactory { get; private set; }
    public ID2D1HwndRenderTarget? RenderTarget { get; private set; }
    public bool IsInitialized { get; private set; } = false;

    private bool _isDisposed = false;

    public bool Initialize(IntPtr hwnd, SizeI size)
    {
        if (IsInitialized) return true;
        if (hwnd == IntPtr.Zero) return false;

        Console.WriteLine($"Attempting Graphics Initialization for HWND {hwnd} with size {size}...");
        try
        {
            Cleanup(); // Clean up any previous (potentially invalid) resources

            Result factoryResult = D2D1.D2D1CreateFactory(D2DFactoryType.SingleThreaded, out ID2D1Factory1? d2dFactory);
            factoryResult.CheckError();
            D2DFactory = d2dFactory ?? throw new InvalidOperationException("D2D Factory creation failed silently.");

            Result dwriteResult = DWrite.DWriteCreateFactory(DW.FactoryType.Shared, out IDWriteFactory? dwriteFactory);
            dwriteResult.CheckError();
            DWriteFactory = dwriteFactory ?? throw new InvalidOperationException("DWrite Factory creation failed silently.");

            if (size.Width <= 0 || size.Height <= 0)
            {
                Console.WriteLine($"Invalid client rect size ({size}). Aborting graphics initialization.");
                Cleanup();
                return false;
            }

            var dxgiPixelFormat = new PixelFormat(Format.B8G8R8A8_UNorm, Vortice.DCommon.AlphaMode.Premultiplied);
            var renderTargetProperties = new RenderTargetProperties(dxgiPixelFormat);
            var hwndRenderTargetProperties = new HwndRenderTargetProperties
            {
                Hwnd = hwnd,
                PixelSize = size,
                PresentOptions = PresentOptions.Immediately
            };

            RenderTarget = D2DFactory.CreateHwndRenderTarget(renderTargetProperties, hwndRenderTargetProperties);
            if (RenderTarget is null) throw new InvalidOperationException("Render target creation returned null unexpectedly.");

            RenderTarget.TextAntialiasMode = D2D.TextAntialiasMode.Cleartype;

            Console.WriteLine($"Vortice Graphics initialized successfully for HWND {hwnd}.");
            IsInitialized = true;
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Graphics Initialization failed: {ex.Message}");
            Cleanup(); // Ensures we are in a clean state after failure
            return false;
        }
    }

    public void Resize(SizeI newSize)
    {
        if (!IsInitialized || RenderTarget == null) return;

        try
        {
            Console.WriteLine($"Resizing render target to {newSize}...");
            RenderTarget.Resize(newSize);
            Console.WriteLine("Successfully resized render target.");
        }
        catch (SharpGenException ex)
        {
            Console.WriteLine($"Failed to resize Render Target (SharpGenException): {ex.Message} HRESULT: {ex.ResultCode}");
            if (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
            {
                Console.WriteLine("Render target needs recreation (Detected in Resize Exception).");
                MarkAsLost();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to resize Render Target (General Exception): {ex}");
            MarkAsLost();
        }
    }

    public void BeginDraw()
    {
        if (!IsInitialized || RenderTarget == null)
        {
            return;
        }
        RenderTarget.BeginDraw();
    }

    public void EndDraw()
    {
        if (!IsInitialized || RenderTarget == null) return;

        try
        {
            Result endDrawResult = RenderTarget.EndDraw();
            if (endDrawResult.Failure)
            {
                Console.WriteLine($"EndDraw failed: {endDrawResult.Description}");
                if (endDrawResult.Code == D2D.ResultCode.RecreateTarget.Code)
                {
                    Console.WriteLine("Render target needs recreation (Detected in EndDraw).");
                    MarkAsLost();
                }
            }
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Render target needs recreation (Caught SharpGenException in EndDraw): {ex.Message}");
            MarkAsLost();
        }
    }

    private void MarkAsLost()
    {
        if (!IsInitialized) return;
        Console.WriteLine("Marking graphics device as lost. Resources will be recreated on next opportunity.");
        Cleanup();
    }

    public void Cleanup()
    {
        bool resourcesExisted = D2DFactory is not null || RenderTarget is not null || DWriteFactory is not null;
        if (resourcesExisted) Console.WriteLine("Cleaning up GraphicsDevice resources...");

        RenderTarget?.Dispose(); RenderTarget = null;
        DWriteFactory?.Dispose(); DWriteFactory = null;
        D2DFactory?.Dispose(); D2DFactory = null;

        IsInitialized = false;

        if (resourcesExisted) Console.WriteLine("Finished cleaning GraphicsDevice resources.");
    }

    public void Dispose()
    {
        if (_isDisposed) return;
        Cleanup();
        _isDisposed = true;
        GC.SuppressFinalize(this);
    }

    ~GraphicsDevice()
    {
        Dispose();
    }
}
</file>

<file path="InputState.cs">
// InputState.cs
using System.Numerics;

namespace DirectUI;

// Holds input state needed for UI processing in a single frame
public readonly struct InputState
{
    public readonly Vector2 MousePosition;
    public readonly bool WasLeftMousePressedThisFrame; // True if the left button went down this frame
    public readonly bool IsLeftMouseDown; // True if the left button is currently held down
    // Add fields for Right mouse button if ClickBehavior.Right/Both is used

    public InputState(Vector2 mousePosition, bool wasLeftMousePressedThisFrame, bool isLeftMouseDown)
    {
        MousePosition = mousePosition;
        WasLeftMousePressedThisFrame = wasLeftMousePressedThisFrame;
        IsLeftMouseDown = isLeftMouseDown;
    }
}
</file>

<file path="ModalWindow.cs">
using System;
using Vortice.Mathematics;

namespace DirectUI;

/// <summary>
/// A specialized window that operates modally over an owner window.
/// </summary>
public class ModalWindow : Direct2DAppWindow
{
    private readonly Win32Window _owner;
    private readonly Action<UIContext> _drawCallback;

    public ModalWindow(Win32Window owner, string title, int width, int height, Action<UIContext> drawCallback)
        : base(title, width, height)
    {
        _owner = owner ?? throw new ArgumentNullException(nameof(owner));
        _drawCallback = drawCallback ?? throw new ArgumentNullException(nameof(drawCallback));
    }

    /// <summary>
    /// Overrides AppHost creation to inject the specific drawing logic for this modal window.
    /// </summary>
    protected override AppHost CreateAppHost()
    {
        // A slightly different background for modals
        var backgroundColor = new Color4(37 / 255f, 37 / 255f, 38 / 255f, 1.0f);
        return new AppHost(_drawCallback, backgroundColor);
    }

    /// <summary>
    /// Creates the window with modal-specific styles and disables its owner.
    /// </summary>
    public bool CreateAsModal()
    {
        if (Handle != IntPtr.Zero) return true;

        uint style = NativeMethods.WS_POPUP | NativeMethods.WS_CAPTION | NativeMethods.WS_SYSMENU | NativeMethods.WS_VISIBLE | NativeMethods.WS_THICKFRAME;

        if (!base.Create(_owner.Handle, style))
        {
            return false;
        }

        if (_owner.Handle != IntPtr.Zero)
        {
            NativeMethods.EnableWindow(_owner.Handle, false);
        }
        return true;
    }

    /// <summary>
    /// Re-enables the owner window when this modal window is destroyed.
    /// </summary>
    protected override void OnDestroy()
    {
        if (_owner.Handle != IntPtr.Zero)
        {
            NativeMethods.EnableWindow(_owner.Handle, true);
        }
        base.OnDestroy();
    }
}
</file>

<file path="NativeMethods.cs">
using System;
using System.Runtime.InteropServices;

// No changes needed here if it was correct from the previous step.
// Ensure these constants are defined:
// WM_NCCREATE, WM_CREATE, WM_NCDESTROY, WM_PAINT, WM_DESTROY, WM_SIZE,
// WM_CLOSE, WM_KEYDOWN, WM_LBUTTONDOWN, WM_LBUTTONUP, WM_MOUSEMOVE, WM_QUIT
// GWLP_USERDATA, VK_ESCAPE, etc.
// And the structs: WNDCLASSEX, MSG, POINT, RECT, CREATESTRUCT
// And the functions: RegisterClassEx, CreateWindowEx, GetMessage, etc.
// And the delegates: WndProc

namespace DirectUI;

internal static class NativeMethods
{
    // --- Constants ---
    public const uint CS_HREDRAW = 0x0002;
    public const uint CS_VREDRAW = 0x0001;
    public const uint CS_OWNDC = 0x0020;

    public const uint WS_OVERLAPPED = 0x00000000;
    public const uint WS_CAPTION = 0x00C00000;
    public const uint WS_SYSMENU = 0x00080000;
    public const uint WS_THICKFRAME = 0x00040000;
    public const uint WS_MINIMIZEBOX = 0x00020000;
    public const uint WS_MAXIMIZEBOX = 0x00010000;
    public const uint WS_OVERLAPPEDWINDOW = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
    public const uint WS_VISIBLE = 0x10000000;
    public const uint WS_POPUP = 0x80000000;

    public const int WM_NCCREATE = 0x0081;
    public const int WM_CREATE = 0x0001;
    public const int WM_NCDESTROY = 0x0082;
    public const int WM_PAINT = 0x000F;
    public const int WM_DESTROY = 0x0002;
    public const int WM_SIZE = 0x0005;
    public const int WM_CLOSE = 0x0010;
    public const int WM_KEYDOWN = 0x0100;
    public const int WM_LBUTTONDOWN = 0x0201;
    public const int WM_LBUTTONUP = 0x0202; // Ensure this exists
    public const int WM_MOUSEMOVE = 0x0200; // Ensure this exists
    public const int WM_QUIT = 0x0012;

    public const int CW_USEDEFAULT = unchecked((int)0x80000000);
    public const int SW_SHOWNORMAL = 1;
    public const int VK_ESCAPE = 0x1B;
    public const int GWLP_USERDATA = -21;

    public const uint PM_REMOVE = 0x0001;

    // --- Structures ---
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
    public struct WNDCLASSEX
    { /* ... as before ... */
        public int cbSize;
        public uint style;
        public WndProc lpfnWndProc; // Use delegate type directly
        public int cbClsExtra;
        public int cbWndExtra;
        public IntPtr hInstance;
        public IntPtr hIcon;
        public IntPtr hCursor;
        public IntPtr hbrBackground;
        public string lpszMenuName;
        public string lpszClassName;
        public IntPtr hIconSm;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct MSG
    { /* ... as before ... */
        public IntPtr hwnd;
        public uint message;
        public IntPtr wParam;
        public IntPtr lParam;
        public uint time;
        public POINT pt;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct POINT
    { /* ... as before ... */
        public int X;
        public int Y;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct RECT
    { /* ... as before ... */
        public int left;
        public int top;
        public int right;
        public int bottom;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct CREATESTRUCT
    { /* ... as before ... */
        public IntPtr lpCreateParams;
        public IntPtr hInstance;
        public IntPtr hMenu;
        public IntPtr hwndParent;
        public int cy; // Height
        public int cx; // Width
        public int y;  // Top
        public int x;  // Left
        public int style;
        [MarshalAs(UnmanagedType.LPWStr)] // Assuming Unicode
        public string lpszName;
        [MarshalAs(UnmanagedType.LPWStr)] // Assuming Unicode
        public string lpszClass;
        public int dwExStyle;
    }

    // --- Delegates ---
    public delegate IntPtr WndProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam);

    // --- Functions ---
    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern ushort RegisterClassEx([In] ref WNDCLASSEX lpwcx);
    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern IntPtr CreateWindowEx(uint dwExStyle, string lpClassName, string lpWindowName, uint dwStyle, int x, int y, int nWidth, int nHeight, IntPtr hWndParent, IntPtr hMenu, IntPtr hInstance, IntPtr lpParam);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool UpdateWindow(IntPtr hWnd);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool DestroyWindow(IntPtr hWnd);
    [DllImport("user32.dll")]
    public static extern IntPtr DefWindowProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam);
    [DllImport("user32.dll")]
    public static extern void PostQuitMessage(int nExitCode);
    [DllImport("user32.dll")]
    public static extern bool GetMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax);
    [DllImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool PeekMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax, uint wRemoveMsg);
    [DllImport("user32.dll")]
    public static extern bool TranslateMessage([In] ref MSG lpMsg);
    [DllImport("user32.dll")]
    public static extern IntPtr DispatchMessage([In] ref MSG lpmsg);
    [DllImport("user32.dll")]
    public static extern bool GetClientRect(IntPtr hWnd, out RECT lpRect);
    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern IntPtr GetModuleHandle(string lpModuleName);
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool InvalidateRect(IntPtr hWnd, IntPtr lpRect, bool bErase);
    [DllImport("user32.dll")]
    public static extern IntPtr LoadCursor(IntPtr hInstance, int lpCursorName);
    [DllImport("user32.dll")]
    public static extern IntPtr LoadIcon(IntPtr hInstance, IntPtr lpIconName);
    [DllImport("user32.dll", EntryPoint = "SetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr SetWindowLongPtr64(IntPtr hWnd, int nIndex, IntPtr dwNewLong);
    [DllImport("user32.dll", EntryPoint = "SetWindowLongW", SetLastError = true)]
    private static extern IntPtr SetWindowLong32(IntPtr hWnd, int nIndex, IntPtr dwNewLong);
    [DllImport("user32.dll", EntryPoint = "GetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr GetWindowLongPtr64(IntPtr hWnd, int nIndex);
    [DllImport("user32.dll", EntryPoint = "GetWindowLongW", SetLastError = true)]
    private static extern IntPtr GetWindowLong32(IntPtr hWnd, int nIndex);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr SetCapture(IntPtr hWnd);
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool ReleaseCapture();
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool EnableWindow(IntPtr hWnd, bool bEnable);


    public static IntPtr SetWindowLongPtr(IntPtr hWnd, int nIndex, IntPtr dwNewLong)
    {
        if (IntPtr.Size == 8) return SetWindowLongPtr64(hWnd, nIndex, dwNewLong);
        else return SetWindowLong32(hWnd, nIndex, dwNewLong);
    }
    public static IntPtr GetWindowLongPtr(IntPtr hWnd, int nIndex)
    {
        if (IntPtr.Size == 8) return GetWindowLongPtr64(hWnd, nIndex);
        else return GetWindowLong32(hWnd, nIndex);
    }

    // --- Helpers ---
    public static short LoWord(IntPtr val) => unchecked((short)(long)val);
    public static short HiWord(IntPtr val) => unchecked((short)((long)val >> 16));
}
</file>

<file path="Win32Window.cs">
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Collections.Generic;

namespace DirectUI;

public abstract class Win32Window : IDisposable
{
    private readonly string _windowClassName;
    private readonly string _windowTitle;
    private readonly int _initialWidth;
    private readonly int _initialHeight;
    private IntPtr _hwnd = IntPtr.Zero;
    private IntPtr _hInstance = IntPtr.Zero;
    private NativeMethods.WndProc _wndProcDelegate;
    private bool _isDisposed = false;
    private static readonly HashSet<string> RegisteredClassNames = new HashSet<string>();
    private GCHandle _gcHandle;

    public IntPtr Handle => _hwnd;
    public int Width { get; protected set; }
    public int Height { get; protected set; }
    protected IntPtr OwnerHandle { get; private set; } = IntPtr.Zero;

    protected Win32Window(string title, int width, int height, string className = null)
    {
        _windowTitle = title ?? "Win32 Window";
        _initialWidth = width > 0 ? width : 800;
        _initialHeight = height > 0 ? height : 600;
        Width = _initialWidth;
        Height = _initialHeight;
        _windowClassName = className ?? ("Win32Window_" + Guid.NewGuid().ToString("N"));
        _wndProcDelegate = WindowProcedure;
    }

    public bool Create(IntPtr owner = default, uint? style = null)
    {
        OwnerHandle = owner;
        if (_hwnd != IntPtr.Zero) return true;

        if (!TryCreateWindow(owner, style))
        {
            Console.WriteLine("Window creation failed.");
            Dispose();
            return false;
        }

        if (!Initialize())
        {
            Console.WriteLine("Derived init failed.");
            Dispose();
            return false;
        }

        NativeMethods.ShowWindow(_hwnd, NativeMethods.SW_SHOWNORMAL);
        NativeMethods.UpdateWindow(_hwnd);
        return true;
    }

    private bool TryCreateWindow(IntPtr owner, uint? style)
    {
        _hInstance = NativeMethods.GetModuleHandle(null);
        if (_hInstance == IntPtr.Zero) _hInstance = Process.GetCurrentProcess().Handle;

        Application.RegisterWindow(this);

        lock (RegisteredClassNames)
        {
            if (!RegisteredClassNames.Contains(_windowClassName))
            {
                var wndClass = new NativeMethods.WNDCLASSEX
                {
                    cbSize = Marshal.SizeOf(typeof(NativeMethods.WNDCLASSEX)),
                    style = NativeMethods.CS_HREDRAW | NativeMethods.CS_VREDRAW,
                    lpfnWndProc = _wndProcDelegate,
                    hInstance = _hInstance,
                    lpszClassName = _windowClassName,
                    hIcon = NativeMethods.LoadIcon(IntPtr.Zero, (IntPtr)32512),
                    hCursor = NativeMethods.LoadCursor(IntPtr.Zero, 32512),
                };
                if (NativeMethods.RegisterClassEx(ref wndClass) == 0) { Console.WriteLine($"RegisterClassEx failed: {Marshal.GetLastWin32Error()}"); return false; }
                RegisteredClassNames.Add(_windowClassName); Console.WriteLine($"Class '{_windowClassName}' registered.");
            }
        }
        _gcHandle = GCHandle.Alloc(this);

        uint windowStyle = style ?? (NativeMethods.WS_OVERLAPPEDWINDOW | NativeMethods.WS_VISIBLE);

        _hwnd = NativeMethods.CreateWindowEx(0, _windowClassName, _windowTitle, windowStyle,
            NativeMethods.CW_USEDEFAULT, NativeMethods.CW_USEDEFAULT, _initialWidth, _initialHeight, owner, IntPtr.Zero, _hInstance, GCHandle.ToIntPtr(_gcHandle));

        if (_hwnd == IntPtr.Zero) { Console.WriteLine($"CreateWindowEx failed: {Marshal.GetLastWin32Error()}"); if (_gcHandle.IsAllocated) _gcHandle.Free(); return false; }
        Console.WriteLine($"Window created: {_hwnd}"); return true;
    }

    private static IntPtr WindowProcedure(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        Win32Window window = null;
        if (msg == NativeMethods.WM_NCCREATE)
        {
            var cs = Marshal.PtrToStructure<NativeMethods.CREATESTRUCT>(lParam);
            var handle = GCHandle.FromIntPtr(cs.lpCreateParams); window = handle.Target as Win32Window;
            NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, GCHandle.ToIntPtr(handle));
            Console.WriteLine($"WM_NCCREATE: Associated instance with HWND {hWnd}");
        }
        else
        {
            IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA);
            if (ptr != IntPtr.Zero) { var handle = GCHandle.FromIntPtr(ptr); window = handle.Target as Win32Window; }
        }
        if (window != null) { try { return window.HandleMessage(hWnd, msg, wParam, lParam); } catch (Exception ex) { Console.WriteLine($"Error handling msg {msg}: {ex}"); } }
        return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
    }

    protected virtual IntPtr HandleMessage(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        switch (msg)
        {
            case NativeMethods.WM_PAINT: OnPaint(); return IntPtr.Zero;
            case NativeMethods.WM_SIZE: Width = NativeMethods.LoWord(lParam); Height = NativeMethods.HiWord(lParam); OnSize(Width, Height); return IntPtr.Zero;
            case NativeMethods.WM_MOUSEMOVE: OnMouseMove(NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam)); return IntPtr.Zero;
            case NativeMethods.WM_LBUTTONDOWN:
                NativeMethods.SetCapture(hWnd);
                OnMouseDown(MouseButton.Left, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
                return IntPtr.Zero;
            case NativeMethods.WM_LBUTTONUP:
                NativeMethods.ReleaseCapture();
                OnMouseUp(MouseButton.Left, NativeMethods.LoWord(lParam), NativeMethods.HiWord(lParam));
                return IntPtr.Zero;
            case NativeMethods.WM_KEYDOWN: OnKeyDown((int)wParam); return IntPtr.Zero;
            case NativeMethods.WM_CLOSE: if (OnClose()) { NativeMethods.DestroyWindow(hWnd); } return IntPtr.Zero;
            case NativeMethods.WM_DESTROY:
                Console.WriteLine($"WM_DESTROY for {hWnd}.");
                Application.UnregisterWindow(this);
                OnDestroy();
                // If this is the main window, Application will exit.
                if (OwnerHandle == IntPtr.Zero)
                {
                    Application.Exit();
                }
                return IntPtr.Zero;
            case NativeMethods.WM_NCDESTROY:
                Console.WriteLine($"WM_NCDESTROY: Releasing GCHandle for {hWnd}.");
                IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA);
                if (ptr != IntPtr.Zero)
                {
                    var handle = GCHandle.FromIntPtr(ptr);
                    if (handle.IsAllocated) handle.Free();
                    NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, IntPtr.Zero);
                }
                if (_gcHandle.IsAllocated && GCHandle.ToIntPtr(_gcHandle) == ptr) { _gcHandle = default; }
                _hwnd = IntPtr.Zero;
                return IntPtr.Zero;
            default: return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
        }
    }

    public void Close() { if (_hwnd != IntPtr.Zero) NativeMethods.DestroyWindow(_hwnd); }
    public void Invalidate() { if (_hwnd != IntPtr.Zero) NativeMethods.InvalidateRect(_hwnd, IntPtr.Zero, false); }

    public virtual void FrameUpdate() { }

    protected virtual bool Initialize() { return true; }
    protected abstract void OnPaint();
    protected virtual void OnSize(int width, int height) { }
    protected virtual void OnMouseDown(MouseButton button, int x, int y) { }
    protected virtual void OnMouseUp(MouseButton button, int x, int y) { }
    protected virtual void OnMouseMove(int x, int y) { }
    protected virtual void OnKeyDown(int keyCode) { }
    protected virtual bool OnClose() { return true; }
    protected virtual void OnDestroy() { }
    protected virtual void Cleanup() { }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (_isDisposed) return;

        if (disposing)
        {
            Console.WriteLine("Disposing Win32Window (managed)...");
            Cleanup();
        }

        Console.WriteLine("Disposing Win32Window (unmanaged)...");

        if (_hwnd != IntPtr.Zero)
        {
            Console.WriteLine($"Destroying window {_hwnd} during Dispose...");
            NativeMethods.DestroyWindow(_hwnd);
            _hwnd = IntPtr.Zero;
        }
        else
        {
            if (_gcHandle.IsAllocated)
            {
                Console.WriteLine("Freeing dangling GCHandle...");
                _gcHandle.Free();
            }
        }

        _isDisposed = true;

        Console.WriteLine("Win32Window disposed.");
    }

    ~Win32Window()
    {
        Console.WriteLine("Win32Window Finalizer!");
        Dispose(false);
    }
}

public enum MouseButton
{
    Left,
    Right,
    Middle,
    XButton1,
    XButton2
}
</file>

<file path="Containers\GridContainerState.cs">
// NEW: GridContainerState.cs
// Summary: State object for managing grid layout.
using System.Collections.Generic;
using System.Numerics;

namespace DirectUI;

internal class GridContainerState
{
    internal string Id { get; }
    internal Vector2 StartPosition { get; } // Top-left corner of the grid area
    internal int NumColumns { get; }
    internal Vector2 Gap { get; } // Gap between cells (X and Y)
    internal Vector2 AvailableSize { get; } // Total area the grid can occupy

    // Calculated layout values
    internal float CellWidth { get; }
    internal List<float> RowHeights { get; } = new(); // Store height of each completed row
    internal float CurrentRowMaxHeight { get; set; } = 0f; // Track max height of elements in the current row being built
    internal int CurrentCellIndex { get; set; } = 0; // 0-based index of the next cell to place an element in
    internal Vector2 CurrentDrawPosition { get; set; } // Calculated top-left for the next element

    // Tracking overall bounds occupied by elements
    internal float AccumulatedWidth { get; set; } = 0f;
    internal float AccumulatedHeight { get; set; } = 0f;


    internal GridContainerState(string id, Vector2 startPosition, Vector2 availableSize, int numColumns, Vector2 gap)
    {
        Id = id;
        StartPosition = startPosition;
        AvailableSize = availableSize;
        NumColumns = Math.Max(1, numColumns); // Ensure at least one column
        Gap = gap;

        // Calculate fixed cell width based on available space and gaps
        float totalHorizontalGap = Math.Max(0, NumColumns - 1) * Gap.X;
        float widthForCells = AvailableSize.X - totalHorizontalGap;
        CellWidth = (NumColumns > 0) ? Math.Max(0, widthForCells / NumColumns) : 0;

        // Initial position is the start position
        CurrentDrawPosition = startPosition;
        RowHeights.Add(0); // Add initial height for the first row (will be updated)
    }

    internal void MoveToNextCell(Vector2 elementSize)
    {
        // Update max height for the current row
        CurrentRowMaxHeight = Math.Max(CurrentRowMaxHeight, elementSize.Y);

        // Update total occupied width (conservative estimate using cell width)
        int currentCol = CurrentCellIndex % NumColumns;
        float currentWidth = (currentCol + 1) * CellWidth + currentCol * Gap.X;
        AccumulatedWidth = Math.Max(AccumulatedWidth, currentWidth);


        CurrentCellIndex++;
        int nextCol = CurrentCellIndex % NumColumns;

        if (nextCol == 0) // Moved to the start of a new row
        {
            // Finalize the height of the completed row
            RowHeights[^1] = CurrentRowMaxHeight; // Update last row's height
            AccumulatedHeight += CurrentRowMaxHeight + (RowHeights.Count > 1 ? Gap.Y : 0); // Add height and gap (if not first row)

            // Reset for the new row
            CurrentRowMaxHeight = 0f;
            RowHeights.Add(0); // Add placeholder height for the new row

            // Calculate Y position for the new row
            float newY = StartPosition.Y;
            for (int i = 0; i < RowHeights.Count - 1; i++) // Sum heights and gaps of completed rows
            {
                newY += RowHeights[i] + Gap.Y;
            }

            // Set position for the first cell of the new row
            CurrentDrawPosition = new Vector2(StartPosition.X, newY);

        }
        else // Moving to the next column in the same row
        {
            // Calculate X position for the next cell
            float currentX = StartPosition.X + nextCol * (CellWidth + Gap.X);
            CurrentDrawPosition = new Vector2(currentX, CurrentDrawPosition.Y); // Y stays the same
        }
    }

    internal Vector2 GetTotalOccupiedSize()
    {
        // Calculate final height including the current row being built
        float finalHeight = AccumulatedHeight + CurrentRowMaxHeight;
        return new Vector2(AccumulatedWidth, finalHeight);
    }
}
</file>

<file path="Containers\HBoxContainerState.cs">
using System.Numerics;

namespace DirectUI;

internal class HBoxContainerState
{
    internal string Id { get; }
    internal Vector2 StartPosition { get; }
    internal Vector2 CurrentPosition { get; set; }
    internal float Gap { get; }
    internal float MaxElementHeight { get; set; } = 0f;
    internal float AccumulatedWidth { get; set; } = 0f;
    internal int ElementCount { get; set; } = 0;

    internal HBoxContainerState(string id, Vector2 startPosition, float gap)
    {
        Id = id;
        StartPosition = startPosition;
        CurrentPosition = startPosition;
        Gap = gap;
    }
}
</file>

<file path="Containers\ResizableHPanelState.cs">
namespace DirectUI;

internal class ResizableHPanelState
{
    internal string Id { get; }
    internal HBoxContainerState InnerHBox { get; }
    internal bool ClipRectWasPushed { get; }

    internal ResizableHPanelState(string id, HBoxContainerState innerHBox, bool clipPushed)
    {
        Id = id;
        InnerHBox = innerHBox;
        ClipRectWasPushed = clipPushed;
    }
}
</file>

<file path="Containers\ResizablePanelState.cs">
namespace DirectUI;

internal class ResizablePanelState
{
    internal string Id { get; }
    internal VBoxContainerState InnerVBox { get; }
    internal bool ClipRectWasPushed { get; }

    internal ResizablePanelState(string id, VBoxContainerState innerVBox, bool clipPushed)
    {
        Id = id;
        InnerVBox = innerVBox;
        ClipRectWasPushed = clipPushed;
    }
}
</file>

<file path="Containers\TreeViewState.cs">
namespace DirectUI;

internal class TreeViewState
{
    internal string Id { get; }
    internal TreeStyle Style { get; }
    internal Stack<bool> IndentLineState { get; } = new();

    internal TreeViewState(string id, TreeStyle style)
    {
        Id = id;
        Style = style;
    }
}
</file>

<file path="Containers\VBoxContainerState.cs">
using System.Numerics;

namespace DirectUI;

internal class VBoxContainerState
{
    internal string Id { get; }
    internal Vector2 StartPosition { get; }
    internal Vector2 CurrentPosition { get; set; } // Top-left for the next element
    internal float Gap { get; }
    internal float MaxElementWidth { get; set; } = 0f; // Track width for container bounds
    internal float AccumulatedHeight { get; set; } = 0f; // Track height for container bounds
    internal int ElementCount { get; set; } = 0;

    internal VBoxContainerState(string id, Vector2 startPosition, float gap)
    {
        Id = id;
        StartPosition = startPosition;
        CurrentPosition = startPosition;
        Gap = gap;
    }
}
</file>

<file path="Core\UI.Containers.cs">
using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

public static partial class UI
{
    public static void BeginHBoxContainer(string id, Vector2 position, float gap = 5.0f)
    {
        Context.containerStack.Push(new HBoxContainerState(id, position, gap));
    }

    public static void EndHBoxContainer()
    {
        if (Context.containerStack.Count == 0 || Context.containerStack.Peek() is not HBoxContainerState state)
        { Console.WriteLine("Error: EndHBoxContainer called without a matching BeginHBoxContainer."); return; }
        Context.containerStack.Pop();
        if (Context.IsInLayoutContainer())
        { Context.AdvanceLayoutCursor(new Vector2(state.AccumulatedWidth, state.MaxElementHeight)); }
    }

    public static void BeginVBoxContainer(string id, Vector2 position, float gap = 5.0f)
    {
        Context.containerStack.Push(new VBoxContainerState(id, position, gap));
    }

    public static void EndVBoxContainer()
    {
        if (Context.containerStack.Count == 0 || Context.containerStack.Peek() is not VBoxContainerState state)
        { Console.WriteLine("Error: EndVBoxContainer called without a matching BeginVBoxContainer."); return; }
        Context.containerStack.Pop();
        if (Context.IsInLayoutContainer())
        { Context.AdvanceLayoutCursor(new Vector2(state.MaxElementWidth, state.AccumulatedHeight)); }
    }

    public static void BeginGridContainer(string id, Vector2 position, Vector2 availableSize, int numColumns, Vector2 gap)
    {
        Context.containerStack.Push(new GridContainerState(id, position, availableSize, numColumns, gap));
    }

    public static void EndGridContainer()
    {
        if (Context.containerStack.Count == 0 || Context.containerStack.Peek() is not GridContainerState state)
        { Console.WriteLine("Error: EndGridContainer called without a matching BeginGridContainer."); return; }
        Context.containerStack.Pop();
        if (Context.IsInLayoutContainer())
        {
            Vector2 containerSize = state.GetTotalOccupiedSize();
            Context.AdvanceLayoutCursor(containerSize);
        }
    }

    public static void BeginResizableVPanel(string id, ref float currentWidth, ResizablePanelDefinition definition, HAlignment alignment = HAlignment.Left, float topOffset = 0f)
    {
        if (!IsContextValid() || definition == null) return;
        var intId = id.GetHashCode();

        var input = Context.InputState;
        var renderTarget = Context.RenderTarget;
        var windowWidth = renderTarget.Size.Width;
        var windowHeight = renderTarget.Size.Height;
        var availableHeight = windowHeight - topOffset;

        if (!definition.Disabled)
        {
            float handleWidth = Math.Min(definition.ResizeHandleWidth, currentWidth);
            float panelX = (alignment == HAlignment.Right) ? windowWidth - currentWidth : 0;
            float handleX = (alignment == HAlignment.Right) ? panelX : panelX + currentWidth - handleWidth;
            Rect handleRect = new Rect(handleX, topOffset, handleWidth, availableHeight);

            bool isHoveringHandle = handleRect.Contains(input.MousePosition.X, input.MousePosition.Y);
            if (isHoveringHandle) State.SetPotentialInputTarget(intId);
            if (input.WasLeftMousePressedThisFrame && isHoveringHandle && State.PotentialInputTargetId == intId && !State.DragInProgressFromPreviousFrame) State.SetPotentialCaptorForFrame(intId);
            if (State.ActivelyPressedElementId == intId && !input.IsLeftMouseDown) State.ClearActivePress(intId);
            if (State.ActivelyPressedElementId == intId && input.IsLeftMouseDown)
            {
                if (alignment == HAlignment.Left) currentWidth = Math.Clamp(input.MousePosition.X, definition.MinWidth, definition.MaxWidth);
                else currentWidth = Math.Clamp(windowWidth - input.MousePosition.X, definition.MinWidth, definition.MaxWidth);
            }
        }

        var panelStyle = definition.PanelStyle ?? new BoxStyle { FillColor = new(0.15f, 0.15f, 0.2f, 1.0f), BorderColor = DefaultTheme.NormalBorder, BorderLength = 1 };
        currentWidth = Math.Max(0, currentWidth);
        float finalPanelX = (alignment == HAlignment.Right) ? windowWidth - currentWidth : 0;
        Rect panelRect = new Rect(finalPanelX, topOffset, currentWidth, availableHeight);
        if (panelRect.Width > 0 && panelRect.Height > 0)
        {
            Resources.DrawBoxStyleHelper(renderTarget, new Vector2(panelRect.X, panelRect.Y), new Vector2(panelRect.Width, panelRect.Height), panelStyle);
        }

        Vector2 contentStartPosition = new Vector2(finalPanelX + definition.Padding.X, topOffset + definition.Padding.Y);
        Rect contentClipRect = new Rect(contentStartPosition.X, contentStartPosition.Y, Math.Max(0, currentWidth - (definition.Padding.X * 2)), Math.Max(0, availableHeight - (definition.Padding.Y * 2)));
        bool clipPushed = false;
        if (contentClipRect.Width > 0 && contentClipRect.Height > 0)
        {
            renderTarget.PushAxisAlignedClip(contentClipRect, D2D.AntialiasMode.Aliased);
            clipPushed = true;
        }
        var vboxState = new VBoxContainerState(id + "_vbox", contentStartPosition, definition.Gap);
        var panelState = new ResizablePanelState(id, vboxState, clipPushed);
        Context.containerStack.Push(panelState);
    }

    public static void EndResizableVPanel()
    {
        if (Context.containerStack.Count == 0 || Context.containerStack.Peek() is not ResizablePanelState state)
        { Console.WriteLine("Error: EndResizableVPanel called without a matching BeginResizableVPanel."); return; }
        if (state.ClipRectWasPushed && Context.RenderTarget is not null)
        {
            Context.RenderTarget.PopAxisAlignedClip();
        }
        Context.containerStack.Pop();
    }

    public static void BeginResizableHPanel(string id, ref float currentHeight, ResizableHPanelDefinition definition, float reservedLeftSpace, float reservedRightSpace, float topOffset = 0f)
    {
        if (!IsContextValid() || definition == null) return;
        var intId = id.GetHashCode();

        var input = Context.InputState;
        var renderTarget = Context.RenderTarget;
        var windowWidth = renderTarget.Size.Width;
        var windowHeight = renderTarget.Size.Height;
        var availableWidth = Math.Max(0, windowWidth - reservedLeftSpace - reservedRightSpace);
        var maxAllowedHeight = windowHeight - topOffset;
        var effectiveMaxHeight = Math.Min(definition.MaxHeight, maxAllowedHeight);

        if (!definition.Disabled)
        {
            currentHeight = Math.Clamp(currentHeight, definition.MinHeight, effectiveMaxHeight);
            float panelY = windowHeight - currentHeight;
            float handleHeight = Math.Min(definition.ResizeHandleWidth, currentHeight);
            Rect handleRect = new Rect(reservedLeftSpace, panelY, availableWidth, handleHeight);

            bool isHoveringHandle = handleRect.Contains(input.MousePosition.X, input.MousePosition.Y);
            if (isHoveringHandle) State.SetPotentialInputTarget(intId);
            if (input.WasLeftMousePressedThisFrame && isHoveringHandle && State.PotentialInputTargetId == intId && !State.DragInProgressFromPreviousFrame) State.SetPotentialCaptorForFrame(intId);
            if (State.ActivelyPressedElementId == intId && !input.IsLeftMouseDown) State.ClearActivePress(intId);
            if (State.ActivelyPressedElementId == intId && input.IsLeftMouseDown)
            {
                float clampedMouseY = Math.Max(input.MousePosition.Y, topOffset);
                currentHeight = Math.Clamp(windowHeight - clampedMouseY, definition.MinHeight, effectiveMaxHeight);
            }
        }

        var panelStyle = definition.PanelStyle ?? new BoxStyle { FillColor = new(0.15f, 0.15f, 0.2f, 1.0f), BorderColor = DefaultTheme.NormalBorder, BorderLength = 1 };
        currentHeight = Math.Clamp(currentHeight, definition.MinHeight, effectiveMaxHeight);
        float finalPanelY = windowHeight - currentHeight;
        Rect panelRect = new Rect(reservedLeftSpace, finalPanelY, availableWidth, currentHeight);
        if (panelRect.Width > 0 && panelRect.Height > 0)
        {
            Resources.DrawBoxStyleHelper(renderTarget, new Vector2(panelRect.X, panelRect.Y), new Vector2(panelRect.Width, panelRect.Height), panelStyle);
        }

        Vector2 contentStartPosition = new Vector2(reservedLeftSpace + definition.Padding.X, finalPanelY + definition.Padding.Y);
        Rect contentClipRect = new Rect(contentStartPosition.X, contentStartPosition.Y, Math.Max(0, availableWidth - (definition.Padding.X * 2)), Math.Max(0, currentHeight - (definition.Padding.Y * 2)));
        bool clipPushed = false;
        if (contentClipRect.Width > 0 && contentClipRect.Height > 0)
        {
            renderTarget.PushAxisAlignedClip(contentClipRect, D2D.AntialiasMode.Aliased);
            clipPushed = true;
        }
        var hboxState = new HBoxContainerState(id + "_hbox", contentStartPosition, definition.Gap);
        var panelState = new ResizableHPanelState(id, hboxState, clipPushed);
        Context.containerStack.Push(panelState);
    }

    public static void EndResizableHPanel()
    {
        if (Context.containerStack.Count == 0 || Context.containerStack.Peek() is not ResizableHPanelState state)
        { Console.WriteLine("Error: EndResizableHPanel called without a matching BeginResizableHPanel."); return; }
        if (state.ClipRectWasPushed && Context.RenderTarget is not null)
        {
            Context.RenderTarget.PopAxisAlignedClip();
        }
        Context.containerStack.Pop();
    }
}
</file>

<file path="Core\UI.cs">
using System;
using System.Numerics;

namespace DirectUI;

public static partial class UI
{
    // --- Core Components ---
    public static UIContext Context { get; private set; } = null!;
    public static UIPersistentState State { get; private set; } = null!;
    public static UIResources Resources { get; private set; } = null!;
    public static bool IsRendering { get; private set; } = false;

    // --- Frame Management ---
    public static void BeginFrame(UIContext context)
    {
        IsRendering = true;

        Context = context;
        State ??= new UIPersistentState();
        Resources ??= new UIResources();

        State.ResetFrameState(context.InputState);

        Context.containerStack.Clear();
        Context.treeStateStack.Clear();
    }

    public static void EndFrame()
    {
        if (Context.containerStack.Count > 0)
        {
            Console.WriteLine($"Warning: Mismatch in Begin/End container calls. {Context.containerStack.Count} containers left open at EndFrame.");
            Context.containerStack.Clear();
        }
        if (Context.treeStateStack.Count > 0)
        {
            Console.WriteLine($"Warning: Mismatch in Begin/End Tree calls. {Context.treeStateStack.Count} trees left open at EndFrame.");
            Context.treeStateStack.Clear();
        }

        // It's important that IsRendering is set to false AFTER the context is cleared.
        Context = null!;
        IsRendering = false;
    }

    public static void CleanupResources()
    {
        Resources?.CleanupResources();
    }

    // --- Helper Methods ---
    private static bool IsContextValid()
    {
        if (Context?.RenderTarget is null || Context?.DWriteFactory is null)
        {
            Console.WriteLine($"Error: UI method called outside BeginFrame/EndFrame or context is invalid.");
            return false;
        }
        return true;
    }

    private static void ApplyButtonDefinition(Button instance, ButtonDefinition definition)
    {
        instance.Size = definition.Size; instance.Text = definition.Text; instance.Themes = definition.Theme ?? instance.Themes ?? new ButtonStylePack();
        instance.Origin = definition.Origin ?? Vector2.Zero; instance.TextAlignment = definition.TextAlignment ?? new Alignment(HAlignment.Center, VAlignment.Center);
        instance.TextOffset = definition.TextOffset ?? Vector2.Zero; instance.AutoWidth = definition.AutoWidth; instance.TextMargin = definition.TextMargin ?? new Vector2(10, 5);
        instance.Behavior = definition.Behavior; instance.LeftClickActionMode = definition.LeftClickActionMode; instance.Disabled = definition.Disabled; instance.UserData = definition.UserData;
    }

    private static void ApplySliderDefinition(InternalSliderLogic instance, SliderDefinition definition)
    {
        instance.Size = definition.Size; instance.MinValue = definition.MinValue; instance.MaxValue = definition.MaxValue; instance.Step = definition.Step;
        instance.Theme = definition.Theme ?? instance.Theme ?? new SliderStyle(); instance.GrabberTheme = definition.GrabberTheme ?? instance.GrabberTheme ?? new ButtonStylePack();
        instance.GrabberSize = definition.GrabberSize ?? instance.GrabberSize; instance.Origin = definition.Origin ?? Vector2.Zero; instance.Disabled = definition.Disabled; instance.UserData = definition.UserData;
    }
}
</file>

<file path="Core\UI.StatelessWidgets.cs">
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace DirectUI;

public static partial class UI
{
    internal static bool StatelessButton(int id, Rect bounds, string text, ButtonStylePack stylePack, Alignment textAlignment, DirectUI.Button.ActionMode clickActionMode, bool autoWidth = false, Vector2? textMargin = null, Vector2 textOffset = default)
    {
        InputState input = Context.InputState;
        var renderTarget = Context.RenderTarget;
        var dwriteFactory = Context.DWriteFactory;

        Vector2 finalSize = new(bounds.Width, bounds.Height);
        if (autoWidth)
        {
            Vector2 measuredSize = Resources.MeasureText(dwriteFactory, text, stylePack.Normal);
            Vector2 margin = textMargin ?? new Vector2(10, 5);
            finalSize.X = measuredSize.X + margin.X * 2;
        }
        Rect finalBounds = new(bounds.X, bounds.Y, finalSize.X, finalSize.Y);

        bool isHovering = finalBounds.Contains(input.MousePosition.X, input.MousePosition.Y);
        bool isPressed = State.ActivelyPressedElementId == id;
        bool wasClickedThisFrame = false;

        if (isHovering) State.SetPotentialInputTarget(id);

        if (!input.IsLeftMouseDown && isPressed)
        {
            if (isHovering && clickActionMode == DirectUI.Button.ActionMode.Release) wasClickedThisFrame = true;
            State.ClearActivePress(id);
            isPressed = false;
        }

        if (input.WasLeftMousePressedThisFrame && isHovering && State.PotentialInputTargetId == id && !State.DragInProgressFromPreviousFrame)
        {
            State.SetButtonPotentialCaptorForFrame(id);
            isPressed = true;
        }

        if (!wasClickedThisFrame && clickActionMode == DirectUI.Button.ActionMode.Press && State.InputCaptorId == id) wasClickedThisFrame = true;

        stylePack.UpdateCurrentStyle(isHovering, isPressed, false);
        ButtonStyle currentStyle = stylePack.Current;
        Resources.DrawBoxStyleHelper(renderTarget, new(finalBounds.X, finalBounds.Y), new(finalBounds.Width, finalBounds.Height), currentStyle);

        var textBrush = Resources.GetOrCreateBrush(renderTarget, currentStyle.FontColor);
        var textFormat = Resources.GetOrCreateTextFormat(dwriteFactory, currentStyle);
        if (textBrush is not null && textFormat is not null && !string.IsNullOrEmpty(text))
        {
            var layoutKey = new UIResources.TextLayoutCacheKey(text, currentStyle, new(finalBounds.Width, finalBounds.Height), textAlignment);
            if (!Resources.textLayoutCache.TryGetValue(layoutKey, out var textLayout))
            {
                textLayout = dwriteFactory.CreateTextLayout(text, textFormat, finalBounds.Width, finalBounds.Height);
                textLayout.TextAlignment = textAlignment.Horizontal switch
                {
                    HAlignment.Left => Vortice.DirectWrite.TextAlignment.Leading,
                    HAlignment.Center => Vortice.DirectWrite.TextAlignment.Center,
                    HAlignment.Right => Vortice.DirectWrite.TextAlignment.Trailing,
                    _ => Vortice.DirectWrite.TextAlignment.Leading
                };
                textLayout.ParagraphAlignment = textAlignment.Vertical switch
                {
                    VAlignment.Top => ParagraphAlignment.Near,
                    VAlignment.Center => ParagraphAlignment.Center,
                    VAlignment.Bottom => ParagraphAlignment.Far,
                    _ => ParagraphAlignment.Near
                };
                Resources.textLayoutCache[layoutKey] = textLayout;
            }
            renderTarget.DrawTextLayout(new(finalBounds.X + textOffset.X, finalBounds.Y + textOffset.Y), textLayout, textBrush);
        }
        return wasClickedThisFrame;
    }
}
</file>

<file path="Core\UI.Widgets.cs">
using System;
using System.Collections.Generic;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

public static partial class UI
{
    public static bool Button(string id, ButtonDefinition definition)
    {
        if (!IsContextValid() || definition is null) return false;
        Button buttonInstance = State.GetOrCreateElement<Button>(id);
        buttonInstance.Position = Context.ApplyLayout(definition.Position);
        ApplyButtonDefinition(buttonInstance, definition);

        bool pushedClip = false;
        if (Context.IsInLayoutContainer() && Context.containerStack.Peek() is GridContainerState grid)
        {
            float clipStartY = grid.CurrentDrawPosition.Y; float gridBottomY = grid.StartPosition.Y + grid.AvailableSize.Y;
            float clipHeight = Math.Max(0f, gridBottomY - clipStartY);
            Rect cellClipRect = new Rect(grid.CurrentDrawPosition.X, clipStartY, Math.Max(0f, grid.CellWidth), clipHeight);
            if (Context.RenderTarget is not null && cellClipRect.Width > 0 && cellClipRect.Height > 0)
            { Context.RenderTarget.PushAxisAlignedClip(cellClipRect, D2D.AntialiasMode.Aliased); pushedClip = true; }
        }

        bool clicked = buttonInstance.Update(id);
        if (pushedClip && Context.RenderTarget is not null)
        { Context.RenderTarget.PopAxisAlignedClip(); }

        Context.AdvanceLayout(buttonInstance.Size);
        return clicked;
    }

    public static float HSlider(string id, float currentValue, SliderDefinition definition)
    {
        if (!IsContextValid() || definition is null) return currentValue;
        InternalHSliderLogic sliderInstance = State.GetOrCreateElement<InternalHSliderLogic>(id);
        sliderInstance.Position = Context.ApplyLayout(definition.Position);
        ApplySliderDefinition(sliderInstance, definition);
        sliderInstance.Direction = definition.HorizontalDirection;

        float newValue = sliderInstance.UpdateAndDraw(id, currentValue);
        Context.AdvanceLayout(sliderInstance.Size);
        return newValue;
    }

    public static float VSlider(string id, float currentValue, SliderDefinition definition)
    {
        if (!IsContextValid() || definition is null) return currentValue;
        InternalVSliderLogic sliderInstance = State.GetOrCreateElement<InternalVSliderLogic>(id);
        sliderInstance.Position = Context.ApplyLayout(definition.Position);
        ApplySliderDefinition(sliderInstance, definition);
        sliderInstance.Direction = definition.VerticalDirection;

        float newValue = sliderInstance.UpdateAndDraw(id, currentValue);
        Context.AdvanceLayout(sliderInstance.Size);
        return newValue;
    }

    public static void Tree<T>(string id, TreeNode<T> root, out TreeNode<T>? clickedNode, TreeStyle? style = null)
    {
        if (!IsContextValid() || root is null) { clickedNode = null; return; }

        clickedNode = null;
        var treeStyle = style ?? State.GetOrCreateElement<TreeStyle>(id + "_style");

        var treeState = new TreeViewState(id, treeStyle);
        Context.treeStateStack.Push(treeState);
        ProcessTreeNodeRecursive(id.GetHashCode(), 0, root, ref clickedNode);
        Context.treeStateStack.Pop();
    }

    private static void ProcessTreeNodeRecursive<T>(int parentIdHash, int index, TreeNode<T> node, ref TreeNode<T>? clickedNode)
    {
        if (Context.treeStateStack.Count == 0) return;
        var treeState = Context.treeStateStack.Peek();
        var style = treeState.Style;
        var renderTarget = Context.RenderTarget;

        var startLayoutPos = Context.GetCurrentLayoutPosition();
        var brush = Resources.GetOrCreateBrush(renderTarget, style.LineColor);
        if (brush is not null)
        {
            int i = 0;
            foreach (var shouldDrawLine in treeState.IndentLineState)
            {
                if (shouldDrawLine)
                {
                    float x = startLayoutPos.X + (i * style.Indent) + (style.Indent * 0.5f);
                    renderTarget.DrawLine(new Vector2(x, startLayoutPos.Y), new Vector2(x, startLayoutPos.Y + style.RowHeight), brush, 1.0f);
                }
                i++;
            }
            if (treeState.IndentLineState.Count > 0)
            {
                float hLineXStart = startLayoutPos.X + ((treeState.IndentLineState.Count - 1) * style.Indent) + (style.Indent * 0.5f);
                float hLineY = startLayoutPos.Y + style.RowHeight * 0.5f;
                renderTarget.DrawLine(new Vector2(hLineXStart, hLineY), new Vector2(hLineXStart + style.Indent * 0.5f, hLineY), brush, 1.0f);
            }
        }

        float indentSize = treeState.IndentLineState.Count * style.Indent;
        var nodeRowStartPos = startLayoutPos + new Vector2(indentSize, 0);
        float currentX = nodeRowStartPos.X;
        float gap = 5;

        int nodeHash = node.GetHashCode();
        int toggleId = HashCode.Combine(parentIdHash, index, nodeHash, 0);
        int labelId = HashCode.Combine(parentIdHash, index, nodeHash, 1);

        float toggleWidth = style.RowHeight - 4;
        if (node.Children.Count > 0)
        {
            var bounds = new Rect(currentX, nodeRowStartPos.Y, toggleWidth, style.RowHeight);
            if (StatelessButton(toggleId, bounds, node.IsExpanded ? "-" : "+", style.ToggleStyle, new Alignment(HAlignment.Center, VAlignment.Center), DirectUI.Button.ActionMode.Release))
            {
                node.IsExpanded = !node.IsExpanded;
            }
        }
        currentX += toggleWidth;

        currentX += gap;
        var labelStyle = style.NodeLabelStyle;
        var labelTextAlignment = new Alignment(HAlignment.Left, VAlignment.Center);
        float labelMargin = 4;
        var labelSize = Resources.MeasureText(Context.DWriteFactory, node.Text, labelStyle.Normal);
        float labelWidth = labelSize.X + labelMargin * 2;
        var labelOffset = new Vector2(labelMargin, 0);
        var labelBounds = new Rect(currentX, nodeRowStartPos.Y, labelWidth, style.RowHeight);
        if (StatelessButton(labelId, labelBounds, node.Text, labelStyle, labelTextAlignment, DirectUI.Button.ActionMode.Press, textOffset: labelOffset))
        {
            clickedNode = node;
        }
        currentX += labelWidth;

        Context.AdvanceLayout(new Vector2((currentX - nodeRowStartPos.X), style.RowHeight));

        if (node.IsExpanded && node.Children.Count > 0)
        {
            for (int childIdx = 0; childIdx < node.Children.Count; childIdx++)
            {
                bool isLastChild = childIdx == node.Children.Count - 1;
                treeState.IndentLineState.Push(!isLastChild);
                ProcessTreeNodeRecursive(toggleId, childIdx, node.Children[childIdx], ref clickedNode);
                treeState.IndentLineState.Pop();
            }
        }
    }
}
</file>

<file path="Core\UIContext.cs">
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.DirectWrite;

namespace DirectUI;

public class UIContext
{
    // Per-frame resources
    public ID2D1HwndRenderTarget RenderTarget { get; }
    public IDWriteFactory DWriteFactory { get; }
    public InputState InputState { get; }

    // Per-frame layout state
    internal readonly Stack<object> containerStack = new();
    internal readonly Stack<TreeViewState> treeStateStack = new();

    public UIContext(ID2D1HwndRenderTarget renderTarget, IDWriteFactory dwriteFactory, InputState inputState)
    {
        RenderTarget = renderTarget;
        DWriteFactory = dwriteFactory;
        InputState = inputState;
    }

    // --- Layout Helpers ---
    internal Vector2 ApplyLayout(Vector2 defaultPosition)
    {
        return IsInLayoutContainer() ? GetCurrentLayoutPositionInternal() : defaultPosition;
    }

    internal void AdvanceLayout(Vector2 elementSize)
    {
        if (IsInLayoutContainer())
        {
            AdvanceLayoutCursor(new Vector2(Math.Max(0, elementSize.X), Math.Max(0, elementSize.Y)));
        }
    }

    public bool IsInLayoutContainer() => containerStack.Count > 0;

    public Vector2 GetCurrentLayoutPosition()
    {
        return IsInLayoutContainer() ? GetCurrentLayoutPositionInternal() : Vector2.Zero;
    }

    private Vector2 GetCurrentLayoutPositionInternal()
    {
        if (containerStack.Count == 0)
        {
            return Vector2.Zero;
        }

        return containerStack.Peek() switch
        {
            HBoxContainerState hbox => hbox.CurrentPosition,
            VBoxContainerState vbox => vbox.CurrentPosition,
            GridContainerState grid => grid.CurrentDrawPosition,
            ResizablePanelState panel => panel.InnerVBox.CurrentPosition,
            ResizableHPanelState hpanel => hpanel.InnerHBox.CurrentPosition,
            _ => Vector2.Zero,
        };
    }

    internal void AdvanceLayoutCursor(Vector2 elementSize)
    {
        if (containerStack.Count == 0) return;
        object currentContainerState = containerStack.Peek();
        switch (currentContainerState)
        {
            case HBoxContainerState hbox:
                {
                    if (elementSize.Y > hbox.MaxElementHeight) hbox.MaxElementHeight = elementSize.Y;
                    hbox.AccumulatedWidth += elementSize.X;
                    if (hbox.ElementCount > 0)
                    {
                        hbox.AccumulatedWidth += hbox.Gap;
                    }
                    float advanceX = elementSize.X + hbox.Gap;
                    hbox.CurrentPosition = new Vector2(hbox.CurrentPosition.X + advanceX, hbox.CurrentPosition.Y);
                    hbox.ElementCount++;
                    break;
                }
            case VBoxContainerState vbox:
                {
                    if (elementSize.X > vbox.MaxElementWidth) vbox.MaxElementWidth = elementSize.X;
                    vbox.AccumulatedHeight += elementSize.Y;
                    if (vbox.ElementCount > 0)
                    {
                        vbox.AccumulatedHeight += vbox.Gap;
                    }
                    float advanceY = elementSize.Y + vbox.Gap;
                    vbox.CurrentPosition = new Vector2(vbox.CurrentPosition.X, vbox.CurrentPosition.Y + advanceY);
                    vbox.ElementCount++;
                    break;
                }
            case GridContainerState grid:
                {
                    grid.MoveToNextCell(elementSize);
                    break;
                }
            case ResizablePanelState panel:
                {
                    var innerVBox = panel.InnerVBox;
                    if (elementSize.X > innerVBox.MaxElementWidth) innerVBox.MaxElementWidth = elementSize.X;
                    innerVBox.AccumulatedHeight += elementSize.Y;
                    if (innerVBox.ElementCount > 0)
                    {
                        innerVBox.AccumulatedHeight += innerVBox.Gap;
                    }
                    float advanceY = elementSize.Y + innerVBox.Gap;
                    innerVBox.CurrentPosition = new Vector2(innerVBox.CurrentPosition.X, innerVBox.CurrentPosition.Y + advanceY);
                    innerVBox.ElementCount++;
                    break;
                }
            case ResizableHPanelState hpanel:
                {
                    var innerHBox = hpanel.InnerHBox;
                    if (elementSize.Y > innerHBox.MaxElementHeight) innerHBox.MaxElementHeight = elementSize.Y;
                    innerHBox.AccumulatedWidth += elementSize.X;
                    if (innerHBox.ElementCount > 0)
                    {
                        innerHBox.AccumulatedWidth += innerHBox.Gap;
                    }
                    float advanceX = elementSize.X + innerHBox.Gap;
                    innerHBox.CurrentPosition = new Vector2(innerHBox.CurrentPosition.X + advanceX, innerHBox.CurrentPosition.Y);
                    innerHBox.ElementCount++;
                    break;
                }
            default:
                {
                    Console.WriteLine("Error: AdvanceLayoutCursor called with unexpected container type.");
                    break;
                }
        }
    }
}
</file>

<file path="Core\UIPersistentState.cs">
using System;
using System.Collections.Generic;

namespace DirectUI;

/// <summary>
/// Manages state that persists across frames, such as UI element instances
/// and input capture state (e.g., which element is currently being pressed).
/// </summary>
public class UIPersistentState
{
    // --- Persistent Element State ---
    private readonly Dictionary<string, object> uiElements = new();

    public T GetOrCreateElement<T>(string id) where T : new()
    {
        if (uiElements.TryGetValue(id, out object? element) && element is T existingElement)
        {
            return existingElement;
        }

        T newElement = new();
        uiElements[id] = newElement;
        return newElement;
    }


    // --- Input State (persists across frames until interaction ends) ---
    public int ActivelyPressedElementId { get; private set; } = 0;
    public bool DragInProgressFromPreviousFrame { get; private set; } = false;

    // --- Input State (reset each frame) ---
    public int PotentialInputTargetId { get; private set; } = 0;
    public int InputCaptorId { get; private set; } = 0;
    private bool captureAttemptedThisFrame = false;
    public bool NonSliderElementClaimedPress { get; private set; } = false;


    /// <summary>
    /// Resets the per-frame state variables. Called once at the beginning of each frame.
    /// </summary>
    public void ResetFrameState(InputState input)
    {
        DragInProgressFromPreviousFrame = input.IsLeftMouseDown && ActivelyPressedElementId != 0;
        PotentialInputTargetId = 0;
        InputCaptorId = 0;
        captureAttemptedThisFrame = false;
        NonSliderElementClaimedPress = false;
    }

    // --- Input Capture & Targeting ---
    public bool IsElementActive()
    {
        return ActivelyPressedElementId != 0;
    }

    public void SetPotentialInputTarget(int id)
    {
        PotentialInputTargetId = id;
    }

    public void SetPotentialCaptorForFrame(int id)
    {
        captureAttemptedThisFrame = true;
        InputCaptorId = id;
        ActivelyPressedElementId = id;
    }

    public void SetButtonPotentialCaptorForFrame(int id)
    {
        captureAttemptedThisFrame = true;
        InputCaptorId = id;
        ActivelyPressedElementId = id;
        NonSliderElementClaimedPress = true;
    }

    public void ClearActivePress(int id)
    {
        if (ActivelyPressedElementId == id)
        {
            ActivelyPressedElementId = 0;
        }
    }
}
</file>

<file path="Core\UIResources.cs">
using SharpGen.Runtime;
using System;
using System.Collections.Generic;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace DirectUI;

/// <summary>
/// Manages the creation, caching, and cleanup of shareable graphics resources
/// like brushes and text formats to avoid recreating them every frame.
/// </summary>
public class UIResources
{
    // --- Font Caching Key ---
    internal readonly struct FontKey : IEquatable<FontKey>
    {
        public readonly string FontName;
        public readonly float FontSize;
        public readonly FontWeight FontWeight;
        public readonly FontStyle FontStyle;
        public readonly FontStretch FontStretch;

        public FontKey(ButtonStyle style)
        {
            FontName = style.FontName;
            FontSize = style.FontSize;
            FontWeight = style.FontWeight;
            FontStyle = style.FontStyle;
            FontStretch = style.FontStretch;
        }

        public bool Equals(FontKey other) => FontName == other.FontName && FontSize.Equals(other.FontSize) && FontWeight == other.FontWeight && FontStyle == other.FontStyle && FontStretch == other.FontStretch;
        public override bool Equals(object? obj) => obj is FontKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(FontName, FontSize, FontWeight, FontStyle, FontStretch);
    }

    // --- Text Layout Caching Key ---
    internal readonly struct TextLayoutCacheKey : IEquatable<TextLayoutCacheKey>
    {
        public readonly string Text;
        public readonly FontKey FontKey;
        public readonly Vector2 MaxSize;
        public readonly HAlignment HAlign;
        public readonly VAlignment VAlign;

        public TextLayoutCacheKey(string text, ButtonStyle style, Vector2 maxSize, Alignment alignment)
        {
            Text = text;
            FontKey = new FontKey(style);
            MaxSize = maxSize;
            HAlign = alignment.Horizontal;
            VAlign = alignment.Vertical;
        }

        public bool Equals(TextLayoutCacheKey other) => Text == other.Text && MaxSize.Equals(other.MaxSize) && HAlign == other.HAlign && VAlign == other.VAlign && FontKey.Equals(other.FontKey);
        public override bool Equals(object? obj) => obj is TextLayoutCacheKey other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(Text, FontKey, MaxSize, HAlign, VAlign);
    }

    // --- Caches ---
    private readonly Dictionary<Color4, ID2D1SolidColorBrush> brushCache = new();
    private readonly Dictionary<FontKey, IDWriteTextFormat> textFormatCache = new();
    private readonly Dictionary<(string, FontKey), Vector2> textSizeCache = new();
    internal readonly Dictionary<TextLayoutCacheKey, IDWriteTextLayout> textLayoutCache = new();

    // --- Brush and Font Cache ---
    public ID2D1SolidColorBrush GetOrCreateBrush(ID2D1RenderTarget renderTarget, Color4 color)
    {
        if (renderTarget is null) { Console.WriteLine("Error: GetOrCreateBrush called with no active render target."); return null!; }
        if (brushCache.TryGetValue(color, out ID2D1SolidColorBrush? brush) && brush is not null) { return brush; }
        else if (brush is null && brushCache.ContainsKey(color)) { brushCache.Remove(color); }
        try
        {
            brush = renderTarget.CreateSolidColorBrush(color);
            if (brush is not null) { brushCache[color] = brush; return brush; }
            else { Console.WriteLine($"Warning: CreateSolidColorBrush returned null for color {color}"); return null!; }
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == ResultCode.RecreateTarget.Code) { Console.WriteLine($"Brush creation failed due to RecreateTarget error (Color: {color}). External cleanup needed."); return null!; }
        catch (Exception ex) { Console.WriteLine($"Error creating brush for color {color}: {ex.Message}"); return null!; }
    }

    public IDWriteTextFormat? GetOrCreateTextFormat(IDWriteFactory dwriteFactory, ButtonStyle style)
    {
        if (dwriteFactory is null) return null;

        var key = new FontKey(style);
        if (textFormatCache.TryGetValue(key, out var format))
        {
            return format;
        }

        try
        {
            var newFormat = dwriteFactory.CreateTextFormat(style.FontName, null, style.FontWeight, style.FontStyle, style.FontStretch, style.FontSize, "en-us");
            if (newFormat is not null) { textFormatCache[key] = newFormat; }
            return newFormat;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error creating text format for font '{style.FontName}': {ex.Message}");
            return null;
        }
    }

    public Vector2 MeasureText(IDWriteFactory dwriteFactory, string text, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(text) || style is null) return Vector2.Zero;

        var fontKey = new FontKey(style);
        var cacheKey = (text, fontKey);
        if (textSizeCache.TryGetValue(cacheKey, out var cachedSize)) return cachedSize;

        IDWriteTextFormat? textFormat = GetOrCreateTextFormat(dwriteFactory, style);
        if (textFormat is null) { Console.WriteLine("Warning: Failed to create/get TextFormat for measurement."); return Vector2.Zero; }

        using var textLayout = dwriteFactory.CreateTextLayout(text, textFormat, float.MaxValue, float.MaxValue);
        TextMetrics textMetrics = textLayout.Metrics;
        var measuredSize = new Vector2(textMetrics.WidthIncludingTrailingWhitespace, textMetrics.Height);
        textSizeCache[cacheKey] = measuredSize;
        return measuredSize;
    }

    public void DrawBoxStyleHelper(ID2D1RenderTarget renderTarget, Vector2 pos, Vector2 size, BoxStyle style)
    {
        if (renderTarget is null || style is null || size.X <= 0 || size.Y <= 0) return;

        ID2D1SolidColorBrush fillBrush = GetOrCreateBrush(renderTarget, style.FillColor);
        ID2D1SolidColorBrush borderBrush = GetOrCreateBrush(renderTarget, style.BorderColor);

        float borderTop = Math.Max(0f, style.BorderLengthTop);
        float borderRight = Math.Max(0f, style.BorderLengthRight);
        float borderBottom = Math.Max(0f, style.BorderLengthBottom);
        float borderLeft = Math.Max(0f, style.BorderLengthLeft);

        bool hasVisibleFill = style.FillColor.A > 0 && fillBrush is not null;
        bool hasVisibleBorder = style.BorderColor.A > 0 && borderBrush is not null && (borderTop > 0 || borderRight > 0 || borderBottom > 0 || borderLeft > 0);

        if (!hasVisibleFill && !hasVisibleBorder) return;

        if (style.Roundness > 0.0f)
        {
            Rect outerBounds = new Rect(pos.X, pos.Y, size.X, size.Y);
            float maxRadius = Math.Min(outerBounds.Width * 0.5f, outerBounds.Height * 0.5f);
            float radius = Math.Max(0f, maxRadius * Math.Clamp(style.Roundness, 0.0f, 1.0f));

            if (float.IsFinite(radius) && radius >= 0)
            {
                if (hasVisibleBorder)
                {
                    System.Drawing.RectangleF outerRectF = new(outerBounds.X, outerBounds.Y, outerBounds.Width, outerBounds.Height);
                    renderTarget.FillRoundedRectangle(new RoundedRectangle(outerRectF, radius, radius), borderBrush);
                }
                if (hasVisibleFill)
                {
                    float fillX = pos.X + borderLeft;
                    float fillY = pos.Y + borderTop;
                    float fillWidth = Math.Max(0f, size.X - borderLeft - borderRight);
                    float fillHeight = Math.Max(0f, size.Y - borderTop - borderBottom);
                    if (fillWidth > 0 && fillHeight > 0)
                    {
                        float avgBorderX = (borderLeft + borderRight) * 0.5f;
                        float avgBorderY = (borderTop + borderBottom) * 0.5f;
                        float innerRadiusX = Math.Max(0f, radius - avgBorderX);
                        float innerRadiusY = Math.Max(0f, radius - avgBorderY);
                        System.Drawing.RectangleF fillRectF = new(fillX, fillY, fillWidth, fillHeight);
                        renderTarget.FillRoundedRectangle(new RoundedRectangle(fillRectF, innerRadiusX, innerRadiusY), fillBrush);
                    }
                    else if (!hasVisibleBorder && fillBrush is not null)
                    {
                        System.Drawing.RectangleF outerRectF = new(outerBounds.X, outerBounds.Y, outerBounds.Width, outerBounds.Height);
                        renderTarget.FillRoundedRectangle(new RoundedRectangle(outerRectF, radius, radius), fillBrush);
                    }
                }
                return;
            }
        }
        if (hasVisibleBorder && borderBrush is not null)
        {
            renderTarget.FillRectangle(new Rect(pos.X, pos.Y, size.X, size.Y), borderBrush);
        }
        if (hasVisibleFill)
        {
            float fillX = pos.X + borderLeft;
            float fillY = pos.Y + borderTop;
            float fillWidth = Math.Max(0f, size.X - borderLeft - borderRight);
            float fillHeight = Math.Max(0f, size.Y - borderTop - borderBottom);
            if (fillWidth > 0 && fillHeight > 0)
            {
                renderTarget.FillRectangle(new Rect(fillX, fillY, fillWidth, fillHeight), fillBrush);
            }
            else if (!hasVisibleBorder && fillBrush is not null)
            {
                renderTarget.FillRectangle(new Rect(pos.X, pos.Y, size.X, size.Y), fillBrush);
            }
        }
    }

    public void CleanupResources()
    {
        Console.WriteLine("UI Resource Cleanup: Disposing cached resources...");
        int brushCount = brushCache.Count;
        foreach (var pair in brushCache) { pair.Value?.Dispose(); }
        brushCache.Clear();

        int formatCount = textFormatCache.Count;
        foreach (var pair in textFormatCache) { pair.Value?.Dispose(); }
        textFormatCache.Clear();

        int layoutCount = textLayoutCache.Count;
        foreach (var pair in textLayoutCache) { pair.Value?.Dispose(); }
        textLayoutCache.Clear();

        int sizeCacheCount = textSizeCache.Count;
        textSizeCache.Clear();

        Console.WriteLine($"UI Resource Cleanup finished. Disposed {brushCount} brushes, {formatCount} text formats, and {layoutCount} text layouts. Cleared {sizeCacheCount} size cache entries.");
    }
}
</file>

<file path="Diagnostics\FpsCounter.cs">
using System;
using System.Diagnostics;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;
using DW = Vortice.DirectWrite;

namespace DirectUI.Diagnostics;

public class FpsCounter
{
    // Configuration
    private readonly Color4 _textColor = DefaultTheme.Text;
    private readonly string _fontName = "Consolas";
    private readonly float _fontSize = 14.0f;
    private const long FpsUpdateIntervalTicks = TimeSpan.TicksPerSecond / 2; // Update twice a second

    // State
    private readonly Stopwatch _timer = new();
    private long _lastUpdateTimeTicks = 0;
    private int _frameCountSinceUpdate = 0;
    private float _currentFps = 0.0f;

    // Direct2D Resources
    private ID2D1SolidColorBrush? _textBrush;
    private IDWriteTextFormat? _textFormat;

    public void Initialize(ID2D1RenderTarget renderTarget, IDWriteFactory dwriteFactory)
    {
        ArgumentNullException.ThrowIfNull(renderTarget);
        ArgumentNullException.ThrowIfNull(dwriteFactory);

        Cleanup(); // Ensure any old resources are released

        try
        {
            _textFormat = dwriteFactory.CreateTextFormat(_fontName, null, FontWeight.Normal, FontStyle.Normal, FontStretch.Normal, _fontSize, "en-us");
            _textFormat.TextAlignment = DW.TextAlignment.Leading;
            _textFormat.ParagraphAlignment = ParagraphAlignment.Near;

            _textBrush = renderTarget.CreateSolidColorBrush(_textColor);

            Console.WriteLine("Created FPS drawing resources.");

            _frameCountSinceUpdate = 0;
            _currentFps = 0;
            _lastUpdateTimeTicks = 0;
            _timer.Restart();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Warning: Failed to create FPS counter drawing resources: {ex.Message}");
            Cleanup(); // Clean up partial resources on failure
        }
    }

    public void Cleanup()
    {
        _timer.Stop();
        _textBrush?.Dispose();
        _textBrush = null;
        _textFormat?.Dispose();
        _textFormat = null;
    }

    public void HandleResize(ID2D1RenderTarget renderTarget)
    {
        // The text format is device-independent, but the brush is not.
        _textBrush?.Dispose();
        _textBrush = null;
        try
        {
            if (renderTarget is not null)
            {
                _textBrush = renderTarget.CreateSolidColorBrush(_textColor);
                Console.WriteLine("Recreated FPS brush after resize.");
            }
        }
        catch (Exception brushEx)
        {
            Console.WriteLine($"Warning: Failed to recreate FPS brush after resize: {brushEx.Message}");
        }
    }

    public bool Update()
    {
        if (!_timer.IsRunning)
        {
            _timer.Start();
            _lastUpdateTimeTicks = _timer.ElapsedTicks;
            _frameCountSinceUpdate = 0;
        }

        _frameCountSinceUpdate++;
        long elapsedTicks = _timer.ElapsedTicks;
        long timeSinceLastUpdate = elapsedTicks - _lastUpdateTimeTicks;

        if (timeSinceLastUpdate >= FpsUpdateIntervalTicks)
        {
            float secondsElapsed = (float)timeSinceLastUpdate / TimeSpan.TicksPerSecond;
            _currentFps = (secondsElapsed > 0.001f) ? (_frameCountSinceUpdate / secondsElapsed) : 0.0f;
            _frameCountSinceUpdate = 0;
            _lastUpdateTimeTicks = elapsedTicks;
            return true; // Indicates the text has changed, so a redraw is needed.
        }

        return false;
    }

    public void Draw(ID2D1RenderTarget renderTarget)
    {
        if (_textBrush is null || _textFormat is null)
        {
            return;
        }

        string fpsText = $"FPS: {_currentFps:F1}";
        var layoutRect = new Rect(5f, 5f, 150f, 30f);
        renderTarget.DrawText(fpsText, _textFormat, layoutRect, _textBrush);
    }
}
</file>

<file path="Styles\BoxStyle.cs">
// MODIFIED: Styles/BoxStyle.cs
// Summary: Replaced BorderThickness with BorderLengthTop, BorderLengthRight, BorderLengthBottom, BorderLengthLeft. Added convenience setter BorderLength.
using Vortice.Mathematics;

namespace DirectUI;

public class BoxStyle
{
    public float Roundness { get; set; } = 0.2f;
    public Color4 FillColor { get; set; } = DefaultTheme.NormalFill;
    public Color4 BorderColor { get; set; } = DefaultTheme.NormalBorder;

    public float BorderLengthTop { get; set; } = 1.0f;
    public float BorderLengthRight { get; set; } = 1.0f;
    public float BorderLengthBottom { get; set; } = 1.0f;
    public float BorderLengthLeft { get; set; } = 1.0f;

    public float BorderLength
    {
        set
        {
            BorderLengthTop = value;
            BorderLengthRight = value;
            BorderLengthBottom = value;
            BorderLengthLeft = value;
        }
    }
}
</file>

<file path="Styles\ButtonStyle.cs">
// ButtonStyle.cs
using Vortice.Mathematics;
using Vortice.DirectWrite; // For Font related enums eventually

namespace DirectUI;

public class ButtonStyle : BoxStyle
{
    // DirectWrite Font properties will be managed elsewhere (e.g., IDWriteTextFormat)
    // public float FontSpacing { get; set; } = 0; // Handled by TextFormat
    // public float FontSize { get; set; } = 16; // Handled by TextFormat
    // public Font? Font { get; set; } = null; // Represented by TextFormat
    public Color4 FontColor { get; set; } = DefaultTheme.Text;

    // Properties needed for creating IDWriteTextFormat
    public string FontName { get; set; } = "Segoe UI";
    public float FontSize { get; set; } = 16.0f;
    public FontWeight FontWeight { get; set; } = FontWeight.Normal;
    public FontStyle FontStyle { get; set; } = FontStyle.Normal;
    public FontStretch FontStretch { get; set; } = FontStretch.Normal;
}
</file>

<file path="Styles\ButtonStylePack.cs">
// MODIFIED: Styles/ButtonStylePack.cs
// Summary: Updated BorderThickness convenience setter to use the new BorderLength setter in BoxStyle. Added Obsolete attribute to BorderThickness.
using System.Collections.Generic;
using System;
using Vortice.Mathematics;
using Vortice.DirectWrite;

namespace DirectUI;

public sealed class ButtonStylePack
{
    public ButtonStyle Current { get; private set; }
    public ButtonStyle Normal { get; set; } = new();
    public ButtonStyle Hover { get; set; } = new();
    public ButtonStyle Pressed { get; set; } = new();
    public ButtonStyle Disabled { get; set; } = new();
    // public ButtonStyle Focused { get; set; } = new(); // Focus state not implemented yet

    public ButtonStylePack()
    {
        Hover.FillColor = DefaultTheme.HoverFill;
        Hover.BorderColor = DefaultTheme.HoverBorder;

        Pressed.FillColor = DefaultTheme.Accent;
        Pressed.BorderColor = DefaultTheme.AccentBorder;

        Disabled.FillColor = DefaultTheme.DisabledFill;
        Disabled.BorderColor = DefaultTheme.DisabledBorder;
        Disabled.FontColor = DefaultTheme.DisabledText;

        Current = Normal;
    }

    public void UpdateCurrentStyle(bool isHovering, bool isPressed, bool isDisabled /*, bool isFocused */)
    {
        if (isDisabled)
        {
            Current = Disabled;
        }
        else if (isPressed)
        {
            Current = Pressed;
        }
        else if (isHovering)
        {
            Current = Hover;
        }
        //else if (isFocused) // Future focus state
        //{
        //    Current = Focused;
        //}
        else
        {
            Current = Normal;
        }
    }

    private IEnumerable<ButtonStyle> AllStyles => [Normal, Hover, Pressed, Disabled /*, Focused*/];

    public string FontName
    {
        set => SetAll(s => s.FontName = value);
    }

    public float FontSize
    {
        set => SetAll(s => s.FontSize = value);
    }

    public FontWeight FontWeight
    {
        set => SetAll(s => s.FontWeight = value);
    }

    public FontStyle FontStyle
    {
        set => SetAll(s => s.FontStyle = value);
    }

    public FontStretch FontStretch
    {
        set => SetAll(s => s.FontStretch = value);
    }

    public Color4 FontColor
    {
        set => SetAll(s => s.FontColor = value);
    }

    public float Roundness
    {
        set => SetAll(s => s.Roundness = value);
    }

    // Updated setter
    public float BorderLength
    {
        set => SetAll(s => s.BorderLength = value);
    }

    // Obsolete - kept for backward compatibility or remove if breaking change is ok
    [Obsolete("Use BorderLength instead.")]
    public float BorderThickness
    {
        set => SetAll(s => s.BorderLength = value);
    }

    public Color4 FillColor
    {
        set => SetAll(s => s.FillColor = value);
    }

    public Color4 BorderColor
    {
        set => SetAll(s => s.BorderColor = value);
    }

    private void SetAll(Action<ButtonStyle> setter)
    {
        foreach (ButtonStyle style in AllStyles)
        {
            setter(style);
        }
        // Update Current directly after modifying the source styles
        // No need to call setter(Current) separately if UpdateCurrentStyle is called later.
        // If UpdateCurrentStyle might not be called, uncommenting setter(Current) ensures immediate consistency.
        // setter(Current);
    }
}
</file>

<file path="Styles\DefaultTheme.cs">
// DefaultTheme.cs
using Vortice.Mathematics;

namespace DirectUI;

// Defines default colors for the UI theme
public static class DefaultTheme
{
    // --- Theme Color Definitions ---

    private static class Ue5ThemeColors
    {
        // Palette based on Unreal Engine 5 Editor
        public static readonly Color4 Fill = new Color4(42 / 255f, 42 / 255f, 42 / 255f, 1.0f);        // #2A2A2A
        public static readonly Color4 FillLighter = new Color4(58 / 255f, 58 / 255f, 58 / 255f, 1.0f);  // #3A3A3A
        public static readonly Color4 Border = new Color4(21 / 255f, 21 / 255f, 21 / 255f, 1.0f);      // #151515 (Matches window background)

        // --- CHANGE HERE ---
        // Changed from blue to a light gray for a more authentic UE5 feel.
        public static readonly Color4 Hover = new Color4(160 / 255f, 160 / 255f, 160 / 255f, 1.0f);   // #A0A0A0
        // --- END CHANGE ---

        public static readonly Color4 Accent = new Color4(255 / 255f, 171 / 255f, 0 / 255f, 1.0f);     // Orange #FFAB00
        public static readonly Color4 AccentBorder = new Color4(255 / 255f, 187 / 255f, 51 / 255f, 1.0f); // Lighter Orange

        public static readonly Color4 DisabledFill = new Color4(32 / 255f, 32 / 255f, 32 / 255f, 0.8f);
        public static readonly Color4 DisabledBorder = new Color4(48 / 255f, 48 / 255f, 48 / 255f, 0.8f);
        public static readonly Color4 DisabledText = new Color4(128 / 255f, 128 / 255f, 128 / 255f, 1.0f);

        public static readonly Color4 Text = new Color4(240 / 255f, 240 / 255f, 240 / 255f, 1.0f);     // #F0F0F0
    }

    private static class OriginalColors
    {
        public static readonly Color4 NormalFill = new Color4(0.25f, 0.25f, 0.3f, 1.0f);
        public static readonly Color4 NormalBorder = new Color4(0.4f, 0.4f, 0.45f, 1.0f);
        public static readonly Color4 HoverFill = new Color4(0.35f, 0.35f, 0.4f, 1.0f);
        public static readonly Color4 HoverBorder = new Color4(0.5f, 0.5f, 0.55f, 1.0f);
        public static readonly Color4 Accent = new Color4(0.2f, 0.4f, 0.8f, 1.0f);
        public static readonly Color4 AccentBorder = new Color4(0.3f, 0.5f, 0.9f, 1.0f);
        public static readonly Color4 DisabledFill = new Color4(0.2f, 0.2f, 0.2f, 0.8f);
        public static readonly Color4 DisabledBorder = new Color4(0.3f, 0.3f, 0.3f, 0.8f);
        public static readonly Color4 DisabledText = new Color4(0.5f, 0.5f, 0.5f, 1.0f);
        public static readonly Color4 Text = Colors.WhiteSmoke;
    }


    // --- Current Active Theme ---
    // Change the assignments here to swap themes.

    // Basic Palette
    public static readonly Color4 White = Colors.White;
    public static readonly Color4 Black = Colors.Black;
    public static readonly Color4 Transparent = Colors.Transparent;

    // --- ACTIVE THEME: UE5 ---
    public static readonly Color4 NormalFill = Ue5ThemeColors.Fill;
    public static readonly Color4 NormalBorder = Ue5ThemeColors.Border;
    public static readonly Color4 HoverFill = Ue5ThemeColors.FillLighter;    // Subtle gray change for hover fill
    public static readonly Color4 HoverBorder = Ue5ThemeColors.Hover;        // Light gray border on hover
    public static readonly Color4 Accent = Ue5ThemeColors.Accent;            // Orange accent for pressed
    public static readonly Color4 AccentBorder = Ue5ThemeColors.AccentBorder;
    public static readonly Color4 DisabledFill = Ue5ThemeColors.DisabledFill;
    public static readonly Color4 DisabledBorder = Ue5ThemeColors.DisabledBorder;
    public static readonly Color4 DisabledText = Ue5ThemeColors.DisabledText;
    public static readonly Color4 FocusBorder = Ue5ThemeColors.Hover;        // Use gray for focus
    public static readonly Color4 Text = Ue5ThemeColors.Text;

    /*
    // --- BACKUP THEME: Original ---
    // To restore the original theme, comment out the "UE5" block above
    // and uncomment this block below.
    public static readonly Color4 NormalFill = OriginalColors.NormalFill;
    public static readonly Color4 NormalBorder = OriginalColors.NormalBorder;
    public static readonly Color4 HoverFill = OriginalColors.HoverFill;
    public static readonly Color4 HoverBorder = OriginalColors.HoverBorder;
    public static readonly Color4 Accent = OriginalColors.Accent;
    public static readonly Color4 AccentBorder = OriginalColors.AccentBorder;
    public static readonly Color4 DisabledFill = OriginalColors.DisabledFill;
    public static readonly Color4 DisabledBorder = OriginalColors.DisabledBorder;
    public static readonly Color4 DisabledText = OriginalColors.DisabledText;
    public static readonly Color4 FocusBorder = Colors.LightSkyBlue;
    public static readonly Color4 Text = OriginalColors.Text;
    */
}
</file>

<file path="Styles\SliderStyle.cs">
// MODIFIED: Styles/SliderStyle.cs
// Summary: Updated default BoxStyle initializations to use BorderLength instead of BorderThickness.
using Vortice.Mathematics;

namespace DirectUI;

public class SliderStyle
{
    public BoxStyle Background { get; set; } = new()
    {
        FillColor = DefaultTheme.DisabledFill,
        BorderColor = DefaultTheme.NormalBorder,
        Roundness = 0.5f,
        BorderLength = 1.0f // Use new property
    };

    public BoxStyle Foreground { get; set; } = new()
    {
        FillColor = DefaultTheme.Accent,
        BorderColor = Colors.Transparent,
        Roundness = 0.5f,
        BorderLength = 0.0f // Use new property
    };
}
</file>

<file path="Styles\TreeStyle.cs">
using DirectUI;
using Vortice.Mathematics;

namespace DirectUI;

public class TreeStyle
{
    public float Indent { get; set; } = 19f;
    public float RowHeight { get; set; } = 22f;
    public Color4 LineColor { get; set; } = DefaultTheme.HoverBorder;
    public ButtonStylePack ToggleStyle { get; set; }
    public ButtonStylePack NodeLabelStyle { get; set; }

    public TreeStyle()
    {
        ToggleStyle = new ButtonStylePack
        {
            Roundness = 0.2f,
            BorderLength = 1f,
            FontName = "Consolas",
            FontSize = 14
        };
        ToggleStyle.Normal.FillColor = DefaultTheme.NormalFill;
        ToggleStyle.Normal.BorderColor = DefaultTheme.NormalBorder;
        ToggleStyle.Hover.FillColor = DefaultTheme.HoverFill;
        ToggleStyle.Hover.BorderColor = DefaultTheme.HoverBorder;
        ToggleStyle.Pressed.FillColor = DefaultTheme.Accent;
        ToggleStyle.Pressed.BorderColor = DefaultTheme.AccentBorder;

        NodeLabelStyle = new ButtonStylePack
        {
            Roundness = 0f,
            BorderLength = 0f,
            FontName = "Segoe UI",
            FontSize = 14
        };
        NodeLabelStyle.Normal.FillColor = Colors.Transparent;
        NodeLabelStyle.Normal.FontColor = DefaultTheme.Text;
        NodeLabelStyle.Hover.FillColor = new Color4(0.25f, 0.25f, 0.25f, 0.5f); // Semi-transparent gray
        NodeLabelStyle.Hover.FontColor = DefaultTheme.Text;
        NodeLabelStyle.Pressed.FillColor = DefaultTheme.Accent;
        NodeLabelStyle.Pressed.FontColor = Colors.White;
        NodeLabelStyle.Pressed.BorderColor = DefaultTheme.AccentBorder;
    }
}
</file>

<file path="Widgets\Button.cs">
namespace DirectUI;

using System;
using System.Numerics;
using Vortice.DirectWrite;
using Vortice.Mathematics;
using Vortice.Direct2D1;
using SharpGen.Runtime;

public class Button
{
    public enum ActionMode { Release, Press }
    public enum ClickBehavior { Left, Right, Both }

    // --- Properties ---
    public Vector2 Position { get; set; } = Vector2.Zero;
    public Vector2 Size { get; set; } = new(84, 28);
    public Vector2 Origin { get; set; } = Vector2.Zero;
    public string Text { get; set; } = "";
    public Vector2 TextOffset { get; set; } = Vector2.Zero;
    public Alignment TextAlignment { get; set; } = new(HAlignment.Center, VAlignment.Center);
    public ButtonStylePack Themes { get; set; } = new();
    public ActionMode LeftClickActionMode { get; set; } = ActionMode.Release;
    public bool AutoWidth { get; set; } = false;
    public Vector2 TextMargin { get; set; } = new(10, 5);
    public ClickBehavior Behavior { get; set; } = Button.ClickBehavior.Left;
    public bool Disabled { get; set; } = false;
    public object? UserData { get; set; } = null;

    public bool IsHovering { get; internal set; } = false;

    public Rect GlobalBounds
    {
        get
        {
            float x = Position.X - Origin.X;
            float y = Position.Y - Origin.Y;
            float width = Math.Max(0, Size.X);
            float height = Math.Max(0, Size.Y);
            Rect calculatedBounds = new(x, y, width, height);

            return calculatedBounds;
        }
    }

    private bool isPressed = false;


    internal bool Update(string id)
    {
        var context = UI.Context;
        var state = UI.State;
        var resources = UI.Resources;

        var renderTarget = context.RenderTarget;
        var dwriteFactory = context.DWriteFactory;
        var input = context.InputState;
        var intId = id.GetHashCode();

        if (renderTarget is null || dwriteFactory is null)
        {
            return false;
        }

        PerformAutoWidth(dwriteFactory);

        bool wasClickedThisFrame = false;
        isPressed = false;

        if (Disabled)
        {
            IsHovering = false;
            if (state.ActivelyPressedElementId == intId)
            {
                state.ClearActivePress(intId);
            }
        }
        else
        {
            Rect bounds = GlobalBounds;
            IsHovering = bounds.Width > 0 && bounds.Height > 0 && bounds.Contains(input.MousePosition.X, input.MousePosition.Y);

            if (IsHovering)
            {
                state.SetPotentialInputTarget(intId);
            }

            bool primaryActionHeld = (Behavior is ClickBehavior.Left or ClickBehavior.Both) && input.IsLeftMouseDown;
            bool primaryActionPressedThisFrame = (Behavior is ClickBehavior.Left or ClickBehavior.Both) && input.WasLeftMousePressedThisFrame;

            if (!primaryActionHeld && state.ActivelyPressedElementId == intId)
            {
                if (IsHovering && LeftClickActionMode is ActionMode.Release)
                {
                    wasClickedThisFrame = true;
                }
                state.ClearActivePress(intId);
            }

            if (primaryActionPressedThisFrame)
            {
                if (IsHovering && state.PotentialInputTargetId == intId && !state.DragInProgressFromPreviousFrame)
                {
                    state.SetButtonPotentialCaptorForFrame(intId);
                }
            }
            isPressed = (state.ActivelyPressedElementId == intId);
        }

        UpdateStyle();

        try
        {
            Rect currentBounds = GlobalBounds;
            if (currentBounds.Width > 0 && currentBounds.Height > 0)
            {
                DrawBackground(renderTarget);
                DrawText(renderTarget, dwriteFactory);
            }
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Render target needs recreation during Button draw: {ex.Message}");
            resources.CleanupResources();
            return false;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error drawing button {id}: {ex}");
            return false;
        }

        if (!wasClickedThisFrame && LeftClickActionMode is ActionMode.Press && state.InputCaptorId == intId)
        {
            wasClickedThisFrame = true;
        }

        return wasClickedThisFrame;
    }

    internal void UpdateStyle()
    {
        Themes?.UpdateCurrentStyle(IsHovering, isPressed, Disabled);
    }

    internal void PerformAutoWidth(IDWriteFactory dwriteFactory)
    {
        if (!AutoWidth || dwriteFactory is null || Themes is null)
        {
            return;
        }

        Vector2 textSize = UI.Resources.MeasureText(dwriteFactory, Text, Themes.Normal);
        float desiredWidth = textSize.X + TextMargin.X * 2;

        if (desiredWidth > 0 && Math.Abs(Size.X - desiredWidth) > 0.1f)
        {
            Size = new Vector2(desiredWidth, Size.Y);
        }
    }

    private void DrawBackground(ID2D1RenderTarget renderTarget)
    {
        Rect bounds = GlobalBounds;
        ButtonStyle? style = Themes?.Current;
        if (style is null || bounds.Width <= 0 || bounds.Height <= 0) return;

        UI.Resources.DrawBoxStyleHelper(renderTarget, new Vector2(bounds.X, bounds.Y), new Vector2(bounds.Width, bounds.Height), style);
    }

    private void DrawText(ID2D1RenderTarget renderTarget, IDWriteFactory dwriteFactory)
    {
        if (string.IsNullOrEmpty(Text)) return;
        ButtonStyle? style = Themes?.Current;
        if (style is null) return;

        ID2D1SolidColorBrush textBrush = UI.Resources.GetOrCreateBrush(renderTarget, style.FontColor);
        if (textBrush is null) return;

        IDWriteTextFormat? textFormat = UI.Resources.GetOrCreateTextFormat(dwriteFactory, style);
        if (textFormat is null) return;

        IDWriteTextLayout? textLayout = null;
        try
        {
            Rect bounds = GlobalBounds;
            if (bounds.Width <= 0 || bounds.Height <= 0) return;

            textLayout = dwriteFactory.CreateTextLayout(Text, textFormat, bounds.Width, bounds.Height);
            textLayout.TextAlignment = TextAlignment.Horizontal switch
            {
                HAlignment.Left => Vortice.DirectWrite.TextAlignment.Leading,
                HAlignment.Center => Vortice.DirectWrite.TextAlignment.Center,
                HAlignment.Right => Vortice.DirectWrite.TextAlignment.Trailing,
                _ => Vortice.DirectWrite.TextAlignment.Leading
            };
            textLayout.ParagraphAlignment = TextAlignment.Vertical switch
            {
                VAlignment.Top => ParagraphAlignment.Near,
                VAlignment.Center => ParagraphAlignment.Center,
                VAlignment.Bottom => ParagraphAlignment.Far,
                _ => ParagraphAlignment.Near
            };

            var textOrigin = new Vector2(bounds.X + TextOffset.X, bounds.Y + TextOffset.Y);
            renderTarget.DrawTextLayout(textOrigin, textLayout, textBrush, DrawTextOptions.None);
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Button Text Draw failed (RecreateTarget): {ex.Message}.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error drawing button text: {ex.Message}");
        }
        finally
        {
            textLayout?.Dispose();
        }
    }
}
</file>

<file path="Widgets\ButtonDefinition.cs">
// ButtonDefinition.cs
using System.Numerics;
using Vortice.Mathematics; // For Color4 if needed directly, though ButtonStylePack handles colors

namespace DirectUI;

public class ButtonDefinition
{
    public Vector2 Position { get; set; } = Vector2.Zero;
    public Vector2 Size { get; set; } = new(84, 28); // Default size
    public string Text { get; set; } = "";
    public ButtonStylePack? Theme { get; set; } = null; // Optional theme override
    public Vector2? Origin { get; set; } = null; // Use null to indicate default (Vector2.Zero)
    public Alignment? TextAlignment { get; set; } = null; // Use null for default (Center, Center)
    public Vector2? TextOffset { get; set; } = null; // Use null for default (Vector2.Zero)
    public bool AutoWidth { get; set; } = false;
    public Vector2? TextMargin { get; set; } = null; // Use null for default (10, 5)
    public Button.ClickBehavior Behavior { get; set; } = Button.ClickBehavior.Left;
    public Button.ActionMode LeftClickActionMode { get; set; } = Button.ActionMode.Release;
    public bool Disabled { get; set; } = false;
    public object? UserData { get; set; } = null;
}
</file>

<file path="Widgets\InternalHSliderLogic.cs">
using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

internal class InternalHSliderLogic : InternalSliderLogic
{
    public HSliderDirection Direction { get; set; } = HSliderDirection.LeftToRight;

    protected override void CalculateTrackBounds()
    {
        trackMinBound = trackPosition.X;
        trackMaxBound = trackPosition.X + Size.X;
    }

    protected override float HandleInput(InputState input, float currentValue)
    {
        float newValue = currentValue;
        Vector2 mousePos = input.MousePosition;
        var state = UI.State;

        Vector2 currentGrabberPos = CalculateGrabberPosition(currentValue);
        Rect currentGrabberBounds = new Rect(currentGrabberPos.X, currentGrabberPos.Y, GrabberSize.X, GrabberSize.Y);
        isGrabberHovered = currentGrabberBounds.Contains(mousePos.X, mousePos.Y);

        Rect trackBoundsRect = new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y);
        isTrackHovered = trackBoundsRect.Contains(mousePos.X, mousePos.Y);

        bool isSliderHovered = isGrabberHovered || isTrackHovered;

        if (isSliderHovered)
        {
            state.SetPotentialInputTarget(GlobalIntId);
        }

        if (state.ActivelyPressedElementId == GlobalIntId && !input.IsLeftMouseDown)
        {
            state.ClearActivePress(GlobalIntId);
        }

        if (input.WasLeftMousePressedThisFrame)
        {
            if (isSliderHovered && state.PotentialInputTargetId == GlobalIntId && !state.DragInProgressFromPreviousFrame)
            {
                state.SetButtonPotentialCaptorForFrame(GlobalIntId);

                if (isTrackHovered && !isGrabberHovered)
                {
                    pendingTrackClickValueJump = true;
                    trackClickPosition = Math.Clamp(mousePos.X, trackMinBound, trackMaxBound);
                }
            }
        }

        if (state.ActivelyPressedElementId == GlobalIntId && input.IsLeftMouseDown)
        {
            if (!pendingTrackClickValueJump)
            {
                float clampedX = Math.Clamp(mousePos.X, trackMinBound, trackMaxBound);
                newValue = ConvertPositionToValue(clampedX);
                newValue = ApplyStep(newValue);
                newValue = Math.Clamp(newValue, MinValue, MaxValue);
            }
        }

        return newValue;
    }

    protected override float ConvertPositionToValue(float position)
    {
        if (trackMaxBound <= trackMinBound) return MinValue;
        float normalized = (position - trackMinBound) / (trackMaxBound - trackMinBound);
        normalized = Math.Clamp(normalized, 0.0f, 1.0f);
        if (Direction == HSliderDirection.RightToLeft) { normalized = 1.0f - normalized; }
        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return rawValue;
    }
    protected override Vector2 CalculateGrabberPosition(float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0;
        if (Direction == HSliderDirection.RightToLeft) { normalizedValue = 1.0f - normalizedValue; }
        float trackWidth = Size.X;
        float centerX = trackMinBound + normalizedValue * trackWidth;
        float xPos = centerX - (GrabberSize.X / 2.0f);
        float yPos = trackPosition.Y + (Size.Y / 2.0f) - (GrabberSize.Y / 2.0f);
        float minX = trackPosition.X;
        float maxX = trackPosition.X + Size.X - GrabberSize.X;
        if (maxX < minX) maxX = minX;
        xPos = Math.Clamp(xPos, minX, maxX);
        return new Vector2(xPos, yPos);
    }
    protected override void DrawForeground(ID2D1RenderTarget renderTarget, float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        if (valueRange <= 0 || renderTarget is null) return;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0.0f;
        float foregroundWidth = Size.X * normalizedValue;
        if (foregroundWidth <= 0.001f) return;
        Rect clipRect;
        if (Direction == HSliderDirection.RightToLeft) { clipRect = new Rect(trackPosition.X + Size.X - foregroundWidth, trackPosition.Y, foregroundWidth, Size.Y); }
        else { clipRect = new Rect(trackPosition.X, trackPosition.Y, foregroundWidth, Size.Y); }
        renderTarget.PushAxisAlignedClip(clipRect, D2D.AntialiasMode.Aliased);
        UI.Resources.DrawBoxStyleHelper(renderTarget, trackPosition, Size, Theme.Foreground);
        renderTarget.PopAxisAlignedClip();
    }
}
</file>

<file path="Widgets\InternalSliderLogic.cs">
using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.Mathematics;

namespace DirectUI;

internal abstract class InternalSliderLogic
{
    // --- Configuration ---
    public Vector2 Position { get; set; }
    public Vector2 Size { get; set; }
    public Vector2 Origin { get; set; }
    public float MinValue { get; set; }
    public float MaxValue { get; set; }
    public float Step { get; set; }
    public SliderStyle Theme { get; set; } = new();
    public ButtonStylePack GrabberTheme { get; set; } = new();
    public Vector2 GrabberSize { get; set; } = new(16, 16);
    public bool Disabled { get; set; }
    public object? UserData { get; set; }

    // --- Internal State ---
    protected bool isGrabberPressed = false;
    protected bool isGrabberHovered = false;
    protected bool isTrackHovered = false;
    protected Vector2 trackPosition;
    protected float trackMinBound;
    protected float trackMaxBound;
    protected bool pendingTrackClickValueJump = false;
    protected float trackClickPosition = 0f;
    protected string GlobalId { get; private set; } = string.Empty;
    protected int GlobalIntId { get; private set; } = 0;


    // --- Calculated Properties ---
    public Rect GlobalBounds => new(Position.X - Origin.X, Position.Y - Origin.Y, Size.X, Size.Y);

    // --- Abstract Methods ---
    protected abstract void CalculateTrackBounds();
    protected abstract float HandleInput(InputState input, float currentValue);
    protected abstract float ConvertPositionToValue(float position);
    protected abstract Vector2 CalculateGrabberPosition(float currentValue);
    protected abstract void DrawForeground(ID2D1RenderTarget renderTarget, float currentValue);


    // --- Common Logic ---
    internal float UpdateAndDraw(string id, float currentValue)
    {
        var context = UI.Context;
        var state = UI.State;

        GlobalId = id;
        GlobalIntId = id.GetHashCode();
        trackPosition = Position - Origin;
        CalculateTrackBounds();

        pendingTrackClickValueJump = false;
        float newValue = currentValue;

        if (Disabled)
        {
            isGrabberHovered = false;
            isGrabberPressed = false;
            isTrackHovered = false;
            if (state.ActivelyPressedElementId == GlobalIntId) state.ClearActivePress(GlobalIntId);
        }
        else
        {
            newValue = HandleInput(context.InputState, currentValue);
        }

        if (pendingTrackClickValueJump && state.InputCaptorId == GlobalIntId && !state.NonSliderElementClaimedPress)
        {
            newValue = ConvertPositionToValue(trackClickPosition);
            newValue = ApplyStep(newValue);
            newValue = Math.Clamp(newValue, MinValue, MaxValue);
        }
        pendingTrackClickValueJump = false;

        UpdateGrabberThemeStyle();

        if (context.RenderTarget is null)
        {
            Console.WriteLine("Error: RenderTarget is null during Slider UpdateAndDraw.");
            return newValue;
        }

        try
        {
            DrawBackground(context.RenderTarget);
            DrawForeground(context.RenderTarget, newValue);
            DrawGrabber(context.RenderTarget, newValue);
        }
        catch (SharpGen.Runtime.SharpGenException ex) when (ex.ResultCode.Code == Vortice.Direct2D1.ResultCode.RecreateTarget.Code)
        {
            Console.WriteLine($"Slider Draw failed (RecreateTarget): {ex.Message}. External cleanup needed.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error drawing slider: {ex.Message}");
        }

        return newValue;
    }

    // --- Helper Methods ---
    protected float ApplyStep(float value)
    {
        float clampedValue = Math.Clamp(value, MinValue, MaxValue);
        if (Step <= 0 || MaxValue <= MinValue)
        {
            return clampedValue;
        }

        float range = MaxValue - MinValue;
        if (range < Step && Step > 0)
        {
            return (value - MinValue < range / 2.0f) ? MinValue : MaxValue;
        }

        float stepsFromMin = (float)Math.Round((clampedValue - MinValue) / Step);
        float steppedValue = MinValue + stepsFromMin * Step;

        return Math.Clamp(steppedValue, MinValue, MaxValue);
    }


    protected void UpdateGrabberThemeStyle()
    {
        isGrabberPressed = UI.State.ActivelyPressedElementId == GlobalIntId;
        GrabberTheme.UpdateCurrentStyle(isGrabberHovered, isGrabberPressed, Disabled);
    }


    // --- Drawing Methods ---
    protected void DrawBackground(ID2D1RenderTarget renderTarget)
    {
        UI.Resources.DrawBoxStyleHelper(renderTarget, trackPosition, Size, Theme.Background);
    }

    protected void DrawGrabber(ID2D1RenderTarget renderTarget, float currentValue)
    {
        Vector2 grabberPos = CalculateGrabberPosition(currentValue);
        UI.Resources.DrawBoxStyleHelper(renderTarget, grabberPos, GrabberSize, GrabberTheme.Current);
    }
}
</file>

<file path="Widgets\InternalVSlider.cs">
using System;
using System.Numerics;
using Vortice.Direct2D1;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;

namespace DirectUI;

internal class InternalVSliderLogic : InternalSliderLogic
{
    public VSliderDirection Direction { get; set; } = VSliderDirection.TopToBottom;

    protected override void CalculateTrackBounds()
    {
        trackMinBound = trackPosition.Y;
        trackMaxBound = trackPosition.Y + Size.Y;
    }

    protected override float HandleInput(InputState input, float currentValue)
    {
        float newValue = currentValue;
        Vector2 mousePos = input.MousePosition;
        var state = UI.State;

        Vector2 currentGrabberPos = CalculateGrabberPosition(currentValue);
        Rect currentGrabberBounds = new Rect(currentGrabberPos.X, currentGrabberPos.Y, GrabberSize.X, GrabberSize.Y);
        isGrabberHovered = currentGrabberBounds.Contains(mousePos.X, mousePos.Y);

        Rect trackBoundsRect = new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y);
        isTrackHovered = trackBoundsRect.Contains(mousePos.X, mousePos.Y);

        bool isSliderHovered = isGrabberHovered || isTrackHovered;

        if (isSliderHovered)
        {
            state.SetPotentialInputTarget(GlobalIntId);
        }

        if (state.ActivelyPressedElementId == GlobalIntId && !input.IsLeftMouseDown)
        {
            state.ClearActivePress(GlobalIntId);
        }

        if (input.WasLeftMousePressedThisFrame)
        {
            if (isSliderHovered && state.PotentialInputTargetId == GlobalIntId && !state.DragInProgressFromPreviousFrame)
            {
                state.SetButtonPotentialCaptorForFrame(GlobalIntId);

                if (isTrackHovered && !isGrabberHovered)
                {
                    pendingTrackClickValueJump = true;
                    trackClickPosition = Math.Clamp(mousePos.Y, trackMinBound, trackMaxBound);
                }
            }
        }

        if (state.ActivelyPressedElementId == GlobalIntId && input.IsLeftMouseDown)
        {
            if (!pendingTrackClickValueJump)
            {
                float clampedY = Math.Clamp(mousePos.Y, trackMinBound, trackMaxBound);
                newValue = ConvertPositionToValue(clampedY);
                newValue = ApplyStep(newValue);
                newValue = Math.Clamp(newValue, MinValue, MaxValue);
            }
        }

        return newValue;
    }

    protected override float ConvertPositionToValue(float position)
    {
        if (trackMaxBound <= trackMinBound) return MinValue;
        float normalized = (position - trackMinBound) / (trackMaxBound - trackMinBound);
        normalized = Math.Clamp(normalized, 0.0f, 1.0f);
        if (Direction == VSliderDirection.BottomToTop) { normalized = 1.0f - normalized; }
        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return rawValue;
    }
    protected override Vector2 CalculateGrabberPosition(float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0;
        if (Direction == VSliderDirection.BottomToTop) { normalizedValue = 1.0f - normalizedValue; }
        float trackHeight = Size.Y;
        float centerY = trackMinBound + normalizedValue * trackHeight;
        float yPos = centerY - (GrabberSize.Y / 2.0f);
        float xPos = trackPosition.X + (Size.X / 2.0f) - (GrabberSize.X / 2.0f);
        float minY = trackPosition.Y;
        float maxY = trackPosition.Y + Size.Y - GrabberSize.Y;
        if (maxY < minY) maxY = minY;
        yPos = Math.Clamp(yPos, minY, maxY);
        return new Vector2(xPos, yPos);
    }
    protected override void DrawForeground(ID2D1RenderTarget renderTarget, float currentValue)
    {
        float valueRange = MaxValue - MinValue;
        if (valueRange <= 0 || renderTarget is null) return;
        float clampedValue = Math.Clamp(currentValue, MinValue, MaxValue);
        float normalizedValue = (valueRange > 0) ? (clampedValue - MinValue) / valueRange : 0.0f;
        float foregroundHeight = Size.Y * normalizedValue;
        if (foregroundHeight <= 0.001f) return;
        Rect clipRect;
        if (Direction == VSliderDirection.BottomToTop) { clipRect = new Rect(trackPosition.X, trackPosition.Y + Size.Y - foregroundHeight, Size.X, foregroundHeight); }
        else { clipRect = new Rect(trackPosition.X, trackPosition.Y, Size.X, foregroundHeight); }
        renderTarget.PushAxisAlignedClip(clipRect, D2D.AntialiasMode.Aliased);
        UI.Resources.DrawBoxStyleHelper(renderTarget, trackPosition, Size, Theme.Foreground);
        renderTarget.PopAxisAlignedClip();
    }
}
</file>

<file path="Widgets\ResizableHPanelDefinition.cs">
using System.Numerics;

namespace DirectUI;

public class ResizableHPanelDefinition
{
    public float MinHeight { get; set; } = 50f;
    public float MaxHeight { get; set; } = 300f;
    public float ResizeHandleWidth { get; set; } = 5f; // This is actually handle *height* here
    public BoxStyle? PanelStyle { get; set; } = null;
    public Vector2 Padding { get; set; } = new Vector2(5, 5);
    public float Gap { get; set; } = 5f;
    public bool Disabled { get; set; } = false;
}
</file>

<file path="Widgets\ResizablePanelDefinition.cs">
using System.Numerics;

namespace DirectUI;

public class ResizablePanelDefinition
{
    public float MinWidth { get; set; } = 50f;
    public float MaxWidth { get; set; } = 500f;
    public float ResizeHandleWidth { get; set; } = 5f;
    public BoxStyle? PanelStyle { get; set; } = null;
    public Vector2 Padding { get; set; } = new Vector2(5, 5);
    public float Gap { get; set; } = 5f;
    public bool Disabled { get; set; } = false;
}
</file>

<file path="Widgets\SliderDefinition.cs">
// NEW: SliderDefinition.cs
// Summary: Configuration object for creating immediate-mode sliders (HSlider/VSlider).
using System.Numerics;

namespace DirectUI;

// Enums for direction (can reuse or redefine if needed, assume reuse for now)
// public enum HSliderDirection { LeftToRight, RightToLeft } // Already exists if Cherris files were added
// public enum VSliderDirection { TopToBottom, BottomToTop } // Already exists if Cherris files were added


public class SliderDefinition
{
    public Vector2 Position { get; set; } = Vector2.Zero; // Used if not in a container
    public Vector2 Size { get; set; } = new(200, 16); // Default size (adjust as needed)
    public float MinValue { get; set; } = 0.0f;
    public float MaxValue { get; set; } = 1.0f;
    public float Step { get; set; } = 0.01f;

    public SliderStyle? Theme { get; set; } = null; // Optional override for track style
    public ButtonStylePack? GrabberTheme { get; set; } = null; // Optional override for grabber style
    public Vector2? GrabberSize { get; set; } = null; // Optional override for grabber size (e.g., new(16, 16))

    // Direction specific to slider type, ignored by the other type
    public HSliderDirection HorizontalDirection { get; set; } = HSliderDirection.LeftToRight;
    public VSliderDirection VerticalDirection { get; set; } = VSliderDirection.TopToBottom;

    public bool Disabled { get; set; } = false;
    public object? UserData { get; set; } = null;
    public Vector2? Origin { get; set; } = null; // Use null for default (Vector2.Zero)
}
</file>

<file path="Widgets\SliderDirection.cs">
namespace DirectUI;

public enum HSliderDirection { LeftToRight, RightToLeft }
public enum VSliderDirection { TopToBottom, BottomToTop }
</file>

<file path="Widgets\TreeNode.cs">
using System.Collections.Generic;

namespace DirectUI;

/// <summary>
/// Represents a node in a generic tree structure.
/// </summary>
/// <typeparam name="T">The type of the user data associated with the node.</typeparam>
public class TreeNode<T>
{
    public string Text { get; set; }
    public T UserData { get; set; }
    public bool IsExpanded { get; set; }
    public List<TreeNode<T>> Children { get; } = new();

    public TreeNode(string text, T userData, bool expanded = false)
    {
        Text = text;
        UserData = userData;
        IsExpanded = expanded;
    }

    /// <summary>
    /// Adds a new child node to this node.
    /// </summary>
    /// <param name="text">The display text of the child node.</param>
    /// <param name="userData">The user data associated with the child node.</param>
    /// <param name="expanded">Whether the child node is expanded by default.</param>
    /// <returns>The newly created child node.</returns>
    public TreeNode<T> AddChild(string text, T userData, bool expanded = false)
    {
        var child = new TreeNode<T>(text, userData, expanded);
        Children.Add(child);
        return child;
    }
}
</file>

<file path="MyDirectUIApp.cs">
using System;
using System.IO;
using System.Numerics;
using Vortice.Mathematics;

namespace DirectUI;

public class MyDirectUIApp : Direct2DAppWindow
{
    // Application state remains here, where it belongs.
    private float sliderValue = 0.5f;
    private float leftPanelWidth = 250f;
    private float rightPanelWidth = 250f;
    private float bottomPanelHeight = 150f;

    // Window management state
    private ModalWindow? _projectWindow;
    private bool _isProjectWindowOpen = false;
    private bool _openProjectWindowRequested = false;

    private readonly TreeNode<string> _fileRoot;
    private readonly TreeStyle _treeStyle = new();

    public MyDirectUIApp(string title, int width, int height)
        : base(title, width, height)
    {
        // Data initialization remains here.
        try
        {
            string scenePath = @"D:\Parsa Stuff\Visual Studio\Cosmocrush\Cosmocrush\Res\Scenes\Player.yaml";
            if (File.Exists(scenePath))
            {
                _fileRoot = SceneParser.Parse(scenePath);
            }
            else
            {
                Console.WriteLine($"Warning: Scene file not found at '{scenePath}'. Loading default tree.");
                _fileRoot = CreateDefaultTree();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error parsing scene file. Loading default tree. Error: {ex.Message}");
            _fileRoot = CreateDefaultTree();
        }
    }

    // Override FrameUpdate to handle window management outside of rendering
    public override void FrameUpdate()
    {
        // Handle window creation/destruction logic here, which is safer than in the render loop.
        ManageWindows();

        // Call base implementation to handle FPS updates and invalidation for this window.
        base.FrameUpdate();
    }

    private void ManageWindows()
    {
        // Check if a modal needs to be opened
        if (_openProjectWindowRequested && !_isProjectWindowOpen)
        {
            _openProjectWindowRequested = false; // Consume the request
            _projectWindow = new ModalWindow(this, "Project Settings", 400, 300, DrawProjectWindowUI);
            if (_projectWindow.CreateAsModal())
            {
                _isProjectWindowOpen = true;
            }
            else
            {
                Console.WriteLine("Failed to create modal window.");
                _projectWindow?.Dispose();
                _projectWindow = null;
                _isProjectWindowOpen = false;
            }
        }

        // Check if the modal window was closed by the user (e.g., via ESC or close button)
        if (_isProjectWindowOpen && (_projectWindow == null || _projectWindow.Handle == IntPtr.Zero))
        {
            _projectWindow?.Dispose(); // Ensure cleanup
            _projectWindow = null;
            _isProjectWindowOpen = false;
        }

        // Check if we need to close the window programmatically
        // (e.g., from a "Close" button inside the modal's UI, which sets _isProjectWindowOpen to false)
        if (!_isProjectWindowOpen && _projectWindow != null && _projectWindow.Handle != IntPtr.Zero)
        {
            _projectWindow.Close();
            // The check above will handle cleanup in the next frame after the window is destroyed.
        }
    }


    // The factory method implementation creates the AppHost, passing the drawing logic.
    protected override AppHost CreateAppHost()
    {
        var backgroundColor = new Color4(21 / 255f, 21 / 255f, 21 / 255f, 1.0f); // #151515
        return new AppHost(DrawUI, backgroundColor);
    }

    private TreeNode<string> CreateDefaultTree()
    {
        var root = new TreeNode<string>("Error", "Could not load scene", true);
        root.AddChild("Please check file path and format.", "");
        root.AddChild(@"Path: D:\Parsa Stuff\Visual Studio\Cosmocrush\Cosmocrush\Res\Scenes\Player.yaml", "");
        return root;
    }

    // The actual drawing logic for the main window.
    private void DrawUI(UIContext context)
    {
        // Note: UI.BeginFrame and UI.EndFrame are now called by the AppHost.
        // We just need to define the UI content for the frame.

        float menuBarHeight = 30f;

        // --- Menu Bar ---
        {
            var rt = context.RenderTarget;
            var menuBarBackgroundBrush = UI.Resources.GetOrCreateBrush(rt, new Color4(37 / 255f, 37 / 255f, 38 / 255f, 1f));
            var menuBarBorderBrush = UI.Resources.GetOrCreateBrush(rt, DefaultTheme.NormalBorder);

            if (menuBarBackgroundBrush != null)
            {
                rt.FillRectangle(new Rect(0, 0, rt.Size.Width, menuBarHeight), menuBarBackgroundBrush);
            }
            if (menuBarBorderBrush != null)
            {
                rt.DrawLine(new Vector2(0, menuBarHeight - 1), new Vector2(rt.Size.Width, menuBarHeight - 1), menuBarBorderBrush, 1f);
            }

            var menuButtonTheme = new ButtonStylePack
            {
                Roundness = 0f,
                BorderLength = 0,
                FontName = "Segoe UI",
                FontSize = 14
            };
            menuButtonTheme.Normal.FillColor = Colors.Transparent;
            menuButtonTheme.Normal.FontColor = new Color4(204 / 255f, 204 / 255f, 204 / 255f, 1f);
            menuButtonTheme.Hover.FillColor = new Color4(63 / 255f, 63 / 255f, 70 / 255f, 1f);
            menuButtonTheme.Pressed.FillColor = DefaultTheme.Accent;

            var menuButtonDef = new ButtonDefinition
            {
                Theme = menuButtonTheme,
                AutoWidth = true,
                TextMargin = new Vector2(10, 0),
                Size = new Vector2(0, menuBarHeight),
                TextAlignment = new Alignment(HAlignment.Center, VAlignment.Center)
            };

            UI.BeginHBoxContainer("menu_bar", new Vector2(5, 0), 0);
            menuButtonDef.Text = "File";
            if (UI.Button("file_button", menuButtonDef)) { Console.WriteLine("File clicked"); }

            menuButtonDef.Text = "Project";
            if (UI.Button("project_button", menuButtonDef))
            {
                if (!_isProjectWindowOpen)
                {
                    _openProjectWindowRequested = true;
                }
            }

            menuButtonDef.Text = "Edit";
            if (UI.Button("edit_button", menuButtonDef)) { Console.WriteLine("Edit clicked"); }
            menuButtonDef.Text = "View";
            if (UI.Button("view_button", menuButtonDef)) { Console.WriteLine("View clicked"); }
            menuButtonDef.Text = "Help";
            if (UI.Button("help_button", menuButtonDef)) { Console.WriteLine("Help clicked"); }
            UI.EndHBoxContainer();
        }

        // --- Define shared styles ---
        var buttonTheme = new ButtonStylePack
        {
            Roundness = 0.2f,
            BorderLength = 1, // Thinner border
            FontName = "Segoe UI",
            FontSize = 16,
        };

        var panelStyle = new BoxStyle
        {
            BorderLength = 1,
            Roundness = 0f
        };

        var vPanelDef = new ResizablePanelDefinition
        {
            MinWidth = 150,
            MaxWidth = 400,
            Padding = new Vector2(10, 10),
            Gap = 10,
            PanelStyle = panelStyle
        };

        var hPanelDef = new ResizableHPanelDefinition
        {
            MinHeight = 50,
            MaxHeight = 300,
            Padding = new Vector2(10, 10),
            Gap = 10,
            PanelStyle = panelStyle
        };


        // --- Left Panel ---
        {
            UI.BeginResizableVPanel("left_panel", ref leftPanelWidth, vPanelDef, HAlignment.Left, menuBarHeight);

            // Wrap tree in a VBox with 0 gap to ensure lines connect correctly
            UI.BeginVBoxContainer("tree_vbox", UI.Context.GetCurrentLayoutPosition(), 0);
            UI.Tree("file_tree", _fileRoot, out var clickedNode, _treeStyle);
            if (clickedNode is not null)
            {
                Console.WriteLine($"Tree Node Clicked: '{clickedNode.Text}', Path: {clickedNode.UserData}");
            }
            UI.EndVBoxContainer();

            UI.EndResizableVPanel();
        }

        // --- Right Panel ---
        {
            UI.BeginResizableVPanel("right_panel", ref rightPanelWidth, vPanelDef, HAlignment.Right, menuBarHeight);

            if (UI.Button("right_button_1", new ButtonDefinition { Text = "Right Panel", Theme = buttonTheme }))
            {
                Console.WriteLine("Right panel button 1 clicked!");
            }
            if (UI.Button("right_button_2", new ButtonDefinition { Text = "Another Button", Theme = buttonTheme }))
            {
                Console.WriteLine("Right panel button 2 clicked!");
            }
            sliderValue = UI.HSlider("my_slider", sliderValue, new SliderDefinition { Size = new Vector2(200, 20) });

            UI.EndResizableVPanel();
        }

        // --- Bottom Panel ---
        {
            UI.BeginResizableHPanel("bottom_panel", ref bottomPanelHeight, hPanelDef, leftPanelWidth, rightPanelWidth, menuBarHeight);

            if (UI.Button("bottom_button", new ButtonDefinition { Text = "Bottom Panel Button", Theme = buttonTheme }))
            {
                Console.WriteLine("Bottom button clicked!");
            }

            UI.EndResizableHPanel();
        }
    }

    // Drawing logic for the modal window.
    private void DrawProjectWindowUI(UIContext context)
    {
        UI.BeginVBoxContainer("modal_vbox", new Vector2(10, 10), 10);

        if (UI.Button("modal_button_1", new ButtonDefinition { Text = "A button in a modal" }))
        {
            Console.WriteLine("Modal button clicked!");
        }

        if (UI.Button("modal_button_close", new ButtonDefinition { Text = "Close Me" }))
        {
            _isProjectWindowOpen = false; // Signal to close the window
        }

        UI.EndVBoxContainer();
    }
}
</file>

<file path="Program.cs">
using DirectUI;

namespace Cocoshell;

public class Program
{
    [STAThread] // Important for COM (Direct2D) and Win32 APIs
    static void Main(string[] args)
    {
        Console.WriteLine("Starting Refactored Direct2D Application...");

        // Use 'using' to ensure Dispose is called automatically
        using (var appWindow = new MyDirectUIApp("My Refactored D2D App", 1024, 768))
        {
            try
            {
                // Create the main window, which registers itself with the Application manager.
                if (appWindow.Create())
                {
                    // Run the central message loop that processes all windows.
                    Application.Run();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Unhandled exception in Run: {ex}");
                // Log exception, show message box, etc.
            }
        } // appWindow.Dispose() is called here, which triggers its window closure

        Console.WriteLine("Application finished.");
        // Console.ReadKey(); // Optional: Keep console open after exit
    }
}
</file>

<file path="SceneNode.cs">
namespace DirectUI;

public class SceneNode
{
    public string Name { get; set; } = "Unnamed";
    public string UserData { get; set; } = "";
    public bool IsExpanded { get; set; } = false;
    public List<SceneNode>? Children { get; set; }
}
</file>

<file path="SceneParser.cs">
using YamlDotNet.Serialization;

namespace DirectUI;

public static class SceneParser
{
    public static TreeNode<string> Parse(string filePath)
    {
        var deserializer = new DeserializerBuilder().Build();
        var yamlData = deserializer.Deserialize<Dictionary<object, object>>(File.ReadAllText(filePath));

        return ConvertToTreeNode(ConvertDictionary(yamlData));
    }

    private static Dictionary<string, object> ConvertDictionary(Dictionary<object, object> dict)
    {
        Dictionary<string, object> newDict = [];

        foreach (KeyValuePair<object, object> kvp in dict)
        {
            if (kvp.Key is not string key)
            {
                continue;
            }

            newDict[key] = kvp.Value;
        }

        return newDict;
    }

    private static TreeNode<string> ConvertToTreeNode(Dictionary<string, object> nodeData)
    {
        if (!nodeData.TryGetValue("Node", out var nodeDescriptorObj) && !nodeData.TryGetValue("node", out nodeDescriptorObj))
        {
            throw new InvalidDataException("YAML node data is missing the 'Node' or 'node' key.");
        }

        string nodeDescriptor = nodeDescriptorObj.ToString();
        string[] parts = nodeDescriptor.Split(["::"], StringSplitOptions.None);
        string nodeName = parts.Length > 1 ? parts[1] : parts[0];
        string nodeType = parts[0];

        string userData = $"Type: {nodeType}";

        TreeNode<string> treeNode = new(nodeName, userData, false);

        if (!nodeData.TryGetValue("children", out var childrenObj) || childrenObj is not List<object> childrenList)
        {
            return treeNode;
        }

        if (childrenList.Count > 0)
        {
            treeNode.IsExpanded = true;
        }

        foreach (object childObj in childrenList)
        {
            if (childObj is not Dictionary<object, object> childDict)
            {
                continue;
            }

            Dictionary<string, object> stringKeyDict = ConvertDictionary(childDict);
            TreeNode<string> childTreeNode = ConvertToTreeNode(stringKeyDict);
            treeNode.Children.Add(childTreeNode);
        }

        return treeNode;
    }
}
</file>

